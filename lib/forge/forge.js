
/**
 * Namespace for ForgeJS
 * @namespace FORGE
 * @type {Object}
 */
var FORGE = FORGE || {};

/**
 * Version number of ForgeJS.
 * @name FORGE.VERSION
 * @type {string}
 * @const
 */
FORGE.VERSION = '0.9.5';

/**
 * Array of {@link FORGE.Viewer} uids.
 * @name FORGE.VIEWERS
 * @type {Array<string>}
 */
FORGE.VIEWERS = [];

/**
 * Global debug switch.
 * @name FORGE.DEBUG
 * @type {boolean}
 * @const
 */
FORGE.DEBUG = false;

/**
 * Global warning switch.
 * @name  FORGE.WARNING
 * @type {boolean}
 * @const
 */
FORGE.WARNING = true;


/**
 * Most of the ForgeJS objects extends FORGE.BaseObject.<br>
 * Its main purpose is to name objects with a class name (a type) and to have a destroy method that handles an "alive" flag.
 *
 * @constructor FORGE.BaseObject
 * @param {string} className - The class name of the object.
 *
 * @todo  See if we can trace inheritance.
 */
FORGE.BaseObject = function(className)
{
    /**
     * The unique identifier of this object.
     * @name  FORGE.BaseObject#_uid
     * @type {string}
     * @private
     */
    this._uid = "";

    /**
     * Array of tags that can be used to identify / classify this object.
     * @name  FORGE.BaseObject#_tags
     * @type {?Array<string>}
     * @private
     */
    this._tags = null;

    /**
     * Custom data associated to this object.
     * @name  FORGE.BaseObject#_data
     * @type {?*}
     * @private
     */
    this._data = null;

    /**
     * Internal refernce to the onDestroy {@link FORGE.EventDispatcher}.
     * @name FORGE.BaseObject#_onDestroy
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onDestroy = null;

    /**
     * Internal reference to the alive flag.
     * @name FORGE.BaseObject#_alive
     * @type {boolean}
     * @private
     */
    this._alive = true;

    /**
     * Internal reference to the debug flag.
     * @name FORGE.BaseObject#_debug
     * @type {boolean}
     * @private
     */
    this._debug = false;

    /**
     * Internal reference to the warning flag.
     * @name  FORGE.BaseObject#_warning
     * @type {boolean}
     * @private
     */
    this._warning = false;

    /**
     * Array to store log if debug is enabled.
     * @name FORGE.BaseObject#_logs
     * @type {?Array}
     * @private
     */
    this._logs = null;

    /**
     * Internal reference to the class name of the object that extends this base object.
     * @name FORGE.BaseObject#_className
     * @type {string}
     * @private
     */
    this._className = className || "BaseObject";

    /**
     * Inheritance chain.
     * @name FORGE.BaseObject#_inheritance
     * @type {Array<String>}
     * @private
     * @todo  Code this mechanism of type chain inheritance
     */
    this._inheritance = ["BaseObject"];
};

FORGE.BaseObject.prototype.constructor = FORGE.BaseObject;


/**
 * Registers the object in the uid index and bind to tag manager if tags set.
 * If no uid set, use a generated one.
 * @method FORGE.BaseObject#_register
 * @private
 */
FORGE.BaseObject.prototype._register = function()
{
    this.log("register");

    //Generate a uid if undefined
    if(typeof this._uid !== "string" || this._uid === "")
    {
        this._uid = FORGE.UID.generate();
    }
    //Register in UID table
    var registered = FORGE.UID.register(this);

    //If this object have tags associated to it.
    if(this._tags !== null)
    {
        //Maybe there is a single string typed tag, convert it to an array.
        if(typeof this._tags === "string")
        {
            this._tags = [this._tags];
        }

        //Register tags if it is an Array
        if(Array.isArray(this._tags) === true)
        {
            FORGE.Tags.register(this);
        }
    }

    return registered;
};

/**
 * Unregisters the object in the uid index.
 * @method FORGE.BaseObject#_unregister
 * @private
 */
FORGE.BaseObject.prototype._unregister = function()
{
    this.log("unregister");

    if(this._uid !== "" && FORGE.UID.exists(this._uid) === true)
    {
        FORGE.UID.unregister(this);
    }
};

/**
 * That method describe how to output the log, can be overwritted by a debug plugin for example.
 * @method FORGE.BaseObject#_stdout
 * @private
 * @param {*} value - The value you want to stdout.
 * @param {string} mode - The console method to use (default is log)
 */
FORGE.BaseObject.prototype._stdout = function(value, mode)
{
    var m = mode || "log";
    var consoleLog = [];
    if (FORGE.Device.chrome === true || FORGE.Device.firefox === true)
    {
        consoleLog = [ "%c[ForgeJS]%c "
            + "FORGE." + this._className + ": " + value + " %c(@"
            + window.performance.now().toFixed(2) + "ms)",
            "background: #e2edff; color: #4286f4; font-weight: 700;",
            "font-weight: 400;",
            "color: #AAA;"
            ];
    }
    else
    {
        consoleLog = [ "[ForgeJS] FORGE." + this._className + ": " + value + " (@"
            + window.performance.now().toFixed(2) + "ms)"
            ];
    }
    console[m].apply(console, consoleLog);

    if(typeof value === "object" && value !== null)
    {
        console[m](value);
    }
};

/**
 * Basic log method, log a string in the console if debug is enabled.
 * @method FORGE.BaseObject#log
 * @param {*} value - The value you want to log in the console.
 */
FORGE.BaseObject.prototype.log = function(value)
{
    if(window["FORGE"]["DEBUG"] === true || window["FORGE"][this._className]["DEBUG"] === true || this._debug === true)
    {
        this._stdout(value, "log");

        if(this._logs === null)
        {
            this._logs = [];
        }

        this._logs.push(value);
    }
};

/**
 * Basic warn method, log a warn string in the console if warning is enabled.
 * @method FORGE.BaseObject#warn
 * @param {?(string|Object)} value - The value you want to warn in the console.
 */
FORGE.BaseObject.prototype.warn = function(value)
{
    if(window["FORGE"]["WARNING"] === true || window["FORGE"][this._className]["WARNING"] === true || this._warning === true)
    {
        this._stdout(value, "warn");
    }
};

/**
 * Basic destroy method, prevent double destroy, change the alive flag.
 * @method FORGE.BaseObject#destroy
 */
FORGE.BaseObject.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    this.log("destroy");

    this._unregister();

    if(this._onDestroy !== null)
    {
        this._onDestroy.dispatch();
        this._onDestroy.destroy();
        this._onDestroy = null;
    }

    this._data = null;

    this._alive = false;
};

/**
 * Get the class name of the object.
 * @name FORGE.BaseObject#className
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.BaseObject.prototype, "className",
{
    /** @this {FORGE.BaseObject} */
    get: function()
    {
        return this._className;
    }

});

/**
 * Get the uid of the object.
 * @name FORGE.BaseObject#uid
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.BaseObject.prototype, "uid",
{
    /** @this {FORGE.BaseObject} */
    get: function()
    {
        return this._uid;
    }
});

/**
 * Get the tags associated to this object.
 * @name FORGE.BaseObject#tags
 * @readonly
 * @type {Array}
 */
Object.defineProperty(FORGE.BaseObject.prototype, "tags",
{
    /** @this {FORGE.BaseObject} */
    get: function()
    {
        return this._tags;
    }
});

/**
 * Get the alive flag value of the object.
 * @name FORGE.BaseObject#alive
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.BaseObject.prototype, "alive",
{
    /** @this {FORGE.BaseObject} */
    get: function()
    {
        return this._alive;
    }
});

/**
* Get and set any custom data you want to associate to this object.
* @name FORGE.BaseObject#data
* @type {*}
*/
Object.defineProperty(FORGE.BaseObject.prototype, "data",
{
    /** @this {FORGE.BaseObject} */
    get: function()
    {
        return this._data;
    },

    /** @this {FORGE.BaseObject} */
    set: function(value)
    {
        this._data = value;
    }
});

/**
 * Get and set the debug flag.
 * @name FORGE.BaseObject#debug
 * @type {boolean}
 */
Object.defineProperty(FORGE.BaseObject.prototype, "debug",
{
    /** @this {FORGE.BaseObject} */
    get: function()
    {
        return this._debug;
    },

    /** @this {FORGE.BaseObject} */
    set: function(value)
    {
        this._debug = Boolean(value);

        if(this._debug === true)
        {
            console.log("Enabling debug for a FORGE."+this._className+" instance :");
            console.log(this);
        }
    }
});

/**
 * Get and set the warning flag.
 * @name FORGE.BaseObject#warning
 * @type {boolean}
 */
Object.defineProperty(FORGE.BaseObject.prototype, "warning",
{
    /** @this {FORGE.BaseObject} */
    get: function()
    {
        return this._warning;
    },

    /** @this {FORGE.BaseObject} */
    set: function(value)
    {
        this._warning = Boolean(value);

        if(this._warning === true)
        {
            console.log("Enabling warning for a FORGE."+this._className+" instance :");
            console.log(this);
        }
    }
});

/**
 * Get the onDestroy {@link FORGE.EventDispatcher}, this event is emitted at the end of the destroy sequence.
 * @name FORGE.BaseObject#onDestroy
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.BaseObject.prototype, "onDestroy",
{
    /** @this {FORGE.BaseObject} */
    get: function()
    {
        if(this._onDestroy === null)
        {
            this._onDestroy = new FORGE.EventDispatcher(this);
        }

        return this._onDestroy;
    }
});

/**
 * The main viewer class.
 *
 * @constructor FORGE.Viewer
 * @param {HTMLElement|string} parent - The parent element.
 * @param {(MainConfig|string)} config - Object that represents the project configuration, it can be an object or a json configuration url.
 * @param {?ViewerCallbacks} callbacks - On boot callbacks
 * @extends {FORGE.BaseObject}
 *
 * @todo Create a FORGE.Config Object to define default values, that can be overrided by the config param.
 */
FORGE.Viewer = function(parent, config, callbacks)
{
    FORGE.BaseObject.call(this, "Viewer");

    /**
     * Either the parent id or the parent DOM Element of the viewer.
     * @name FORGE.Viewer#_parent
     * @type {Element|HTMLElement|string}
     * @private
     */
    this._parent = parent;

    /**
     * The main config of the FORGE project
     * @name  FORGE.Viewer#_mainConfig
     * @type {(MainConfig|string)}
     * @private
     */
    this._mainConfig = config;

    /**
     * The viewer configuration or its URL.
     * After the config loading it will be a MainConfig in all cases.
     * @name FORGE.Viewer#_config
     * @type {?ViewerConfig}
     * @private
     */
    this._config = null;

    /**
     * Reference to the DisplayList manager
     * @name FORGE.DispalyList
     * @type {FORGE.DisplayList}
     * @private
     */
    this._display = null;

    /**
     * This is a relative div between the parent and the viewer container.
     * @name  FORGE.Viewer#_relative
     * @type {?Element}
     * @private
     */
    this._relative = null;

    /**
     * The viewer container reference.
     * @name FORGE.Viewer#_container
     * @type {FORGE.DisplayObjectContainer}
     * @private
     */
    this._container = null;

    /**
     * The canvas container reference.
     * @name FORGE.Viewer#_canvasContainer
     * @type {FORGE.DisplayObjectContainer}
     * @private
     */
    this._canvasContainer = null;

    /**
     * The DOM hotspot container reference.
     * @name FORGE.Viewer#_domHotspotContainer
     * @type {FORGE.DisplayObjectContainer}
     * @private
     */
    this._domHotspotContainer = null;

    /**
     * The DOM hotspot style container reference.
     * @name FORGE.Viewer#_domHotspotStyle
     * @type {Element|HTMLStyleElement}
     * @private
     */
    this._domHotspotStyle = null;

    /**
     * The plugins container reference.
     * @name FORGE.Viewer#_pluginContainer
     * @type {FORGE.DisplayObjectContainer}
     * @private
     */
    this._pluginContainer = null;

    /**
     * The canvas reference.
     * @name FORGE.Viewer#_canvas
     * @type {FORGE.Canvas}
     * @private
     */
    this._canvas = null;

     /**
     * System module reference.
     * @name FORGE.Viewer#_system
     * @type {FORGE.System}
     * @private
     */
    this._system = null;

    /**
     * Audio / mixer interface reference.
     * @name FORGE.Viewer#_audio
     * @type {FORGE.SoundManager}
     * @private
     */
    this._audio = null;

    /**
     * Playlists interface reference.
     * @name FORGE.Viewer#_playlists
     * @type {FORGE.PlaylistManager}
     * @private
     */
    this._playlists = null;

    /**
     * Hotspots interface reference.
     * @name  FORGE.Viewer#_hotspots
     * @type {FORGE.HotspotManager}
     * @private
     */
    this._hotspots = null;

    /**
     * Action manager reference.
     * @name FORGE.Viewer#_actions
     * @type {FORGE.ActionManager}
     * @private
     */
    this._actions = null;

    /**
     * Director's cut track manager
     * @name  FORGE.Viewer#_director
     * @type {FORGE.Director}
     * @private
     */
    this._director = null;

    /**
     * Controller manager.
     * @name FORGE.Viewer#_controllers
     * @type {FORGE.ControllerManager}
     * @private
     */
    this._controllers = null;

    /**
     * Post processing.
     * @name  FORGE.Viewer#_postProcessing
     * @type {FORGE.PostProcessing}
     * @private
     */
    this._postProcessing = null;

    /**
     * Story reference.
     * @name FORGE.Viewer#_story
     * @type {FORGE.Story}
     * @private
     */
    this._story = null;

    /**
     * History manager reference.
     * @name FORGE.Viewer#_history
     * @type {FORGE.History}
     * @private
     */
    this._history = null;

    /**
     * Loader reference.
     * @name FORGE.Viewer#_load
     * @type {FORGE.Loader}
     * @private
     */
    this._load = null;

    /**
     * Cache reference.
     * @name FORGE.Viewer#_cache
     * @type {FORGE.Cache}
     * @private
     */
    this._cache = null;

    /**
     * Keyboard interface.
     * @name FORGE.Viewer#_keyboard
     * @type {FORGE.Keyboard}
     * @private
     */
    this._keyboard = null;

    /**
     * Gyroscope interface.
     * @name FORGE.Viewer#_gyroscope
     * @type {FORGE.Gyroscope}
     * @private
     */
    this._gyroscope = null;

    /**
     * Gamepads manager.
     * @name FORGE.Viewer#_gamepad
     * @type {FORGE.GamepadsManager}
     * @private
     */
    this._gamepad = null;

    /**
     * Plugins interface reference.
     * @name FORGE.Viewer#_plugins
     * @type {FORGE.PluginManager}
     * @private
     */
    this._plugins = null;

    /**
     * Main loop reference.
     * @name FORGE.Viewer#_raf
     * @type {FORGE.RequestAnimationFrame}
     * @private
     */
    this._raf = null;

    /**
     * Handle viewer clock reference.
     * @name FORGE.Viewer#_clock
     * @type {FORGE.Clock}
     * @private
     */
    this._clock = null;

    /**
     * Tween Manager reference.
     * @name FORGE.Viewer#_tween
     * @type {FORGE.TweenManager}
     * @private
     */
    this._tween = null;

    /**
     * i18n and locales interface reference.
     * @name FORGE.Viewer#_i18n
     * @type {FORGE.LocaleManager}
     * @private
     */
    this._i18n = null;

    /**
     * Renderer reference.
     * @name FORGE.Viewer#_renderManager
     * @type {FORGE.RenderManager}
     * @private
     */
    this._renderManager = null;

    /**
     * Paused state of the main loop.
     * @name FORGE.Viewer#_paused
     * @type {boolean}
     * @private
     */
    this._paused = false;

    /**
     * Flag to know if the viewer is ready
     * @name  FORGE.Viewer#_ready
     * @type {boolean}
     * @private
     */
    this._ready = false;

    /**
     * Event dispatcher for the viewer on ready event. Dispatched after the boot sequence.
     * @name  FORGE.Viewer#_onReady
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onReady = null;

    /**
     * Event dispatcher for the on pause event.
     * @name  FORGE.Viewer#_onPause
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * Event dispatcher for the on resume event.
     * @name  FORGE.Viewer#_onResume
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onResume = null;

    /**
     * Event dispatcher for the on config load complete event.
     * @name  FORGE.Viewer#_onConfigLoadComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onConfigLoadComplete = null;

    /**
     * Event dispatcher for the on main config load complete event.
     * @name  FORGE.Viewer#_onMainConfigLoadComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onMainConfigLoadComplete = null;

    /**
     * Callback function for the viewer.
     * @name FORGE.Viewer#_callbacks
     * @type {?ViewerCallbacks}
     * @private
     */
    this._callbacks = callbacks || null;

    var bootBind = this._boot.bind(this);
    window.setTimeout(bootBind, 0);
};

FORGE.Viewer.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Viewer.prototype.constructor = FORGE.Viewer;

/**
 * Viewer default configuration
 * @name  FORGE.Viewer.DEFAULT_CONFIG
 * @type {ViewerConfig}
 * @const
 */
FORGE.Viewer.DEFAULT_CONFIG =
{
    background: "#000",
    autoResume: true,
    autoPause: true,

    webgl:
    {
        antialias: true,
        alpha: true,
        premultipliedAlpha: false,
        stencil: false
    }
};

/**
 * Boot sequence.
 * @method FORGE.Viewer#_boot
 * @param {Function} callback - Callback function.
 * @private
 */
FORGE.Viewer.prototype._boot = function(callback)
{
    /**
     * WARNING THE ORDER OF THE BOOT SEQUENCE MATTERS A LOT!
     * DO NOT CHANGE ANYTHING UNLESS YOU ARE SURE OF WHAT YOURE DOING
     */

    if(this._alive === false)
    {
        return;
    }

    this._uid = "FORGE-instance-" + String(FORGE.VIEWERS.length);
    FORGE.VIEWERS.push(this._uid);
    this._register();

    this.log("FORGE.Viewer.boot();");

    this._display = new FORGE.DisplayList(this);

    this._createContainers();
    this._createCanvas();

    this._system = new FORGE.System(this);
    this._clock = new FORGE.Clock(this);
    this._audio = new FORGE.SoundManager(this);
    this._raf = new FORGE.RequestAnimationFrame(this);
    this._i18n = new FORGE.LocaleManager(this);
    this._story = new FORGE.Story(this);
    this._history = new FORGE.History(this);
    this._renderManager = new FORGE.RenderManager(this);
    this._controllers = new FORGE.ControllerManager(this);
    this._playlists = new FORGE.PlaylistManager(this);
    this._plugins = new FORGE.PluginManager(this);
    this._hotspots = new FORGE.HotspotManager(this);
    this._actions = new FORGE.ActionManager(this);
    this._director = new FORGE.Director(this);
    this._postProcessing = new FORGE.PostProcessing(this);

    this._keyboard = new FORGE.Keyboard(this);
    this._gyroscope = new FORGE.Gyroscope(this);
    this._gamepad = new FORGE.GamepadsManager(this);
    this._cache = new FORGE.Cache(this);
    this._load = new FORGE.Loader(this);
    this._tween = new FORGE.TweenManager(this);

    this._system.boot();
    this._audio.boot();
    this._raf.boot();
    this._story.boot();
    this._playlists.boot();
    this._plugins.boot();
    this._hotspots.boot();

    this.log("ForgeJS " + FORGE.VERSION);

    //Call the boot method argument callback
    if (typeof callback === "function")
    {
        callback.call();
    }

    //Call the viewer constructor callback
    if (this._callbacks !== null && typeof this._callbacks.boot === "function")
    {
        this._callbacks.boot.call();
    }

    this._ready = true;

    if (this._onReady !== null)
    {
        this._onReady.dispatch();
    }

    this._loadConfig(this._mainConfig);
};

/**
 * Load the main configuration of the viewer.
 * @method FORGE.Viewer#_loadConfig
 * @param  {?(MainConfig|string)} config - The config object or its URL
 * @private
 */
FORGE.Viewer.prototype._loadConfig = function(config)
{
    if (typeof config === "string")
    {
        this._load.json(this._uid + "-configuration", config, this._mainConfigLoadComplete, this);
    }
    else if (config !== null && typeof config === "object")
    {
        this._parseMainConfig(config);
    }
};

/**
 * Event handler for the configuration JSON load complete.
 * @method FORGE.Story#_mainConfigLoadComplete
 * @param  {FORGE.File} file - The {@link FORGE.File} that describes the loaded JSON file.
 * @private
 */
FORGE.Viewer.prototype._mainConfigLoadComplete = function(file)
{
    this.log("FORGE.Viewer._mainConfigLoadComplete();");

    var json = this._cache.get(FORGE.Cache.types.JSON, file.key);
    var config = /** @type {MainConfig} */ (json.data);

    this._parseMainConfig(config);
};

/**
 * Parse the Global Main Configuration
 * @param  {MainConfig} config - Main configuration to parse.
 * @private
 */
FORGE.Viewer.prototype._parseMainConfig = function(config)
{
    // Final assignement of the config
    this._mainConfig = config;

    this._parseConfig(config.viewer);

    if (typeof config.i18n !== "undefined")
    {
        this._i18n.addConfig(config.i18n); //force the parse of the main config
    }

    this._history.addConfig(config.history);

    if (typeof config.audio !== "undefined")
    {
        this._audio.addConfig(config.audio);
    }

    if (typeof config.playlists !== "undefined")
    {
        this._playlists.addConfig(config.playlists);
    }

    if (typeof config.actions !== "undefined")
    {
        this._actions.addConfig(config.actions);
    }

    if (typeof config.director !== "undefined")
    {
        this._director.load(config.director);
    }

    if (typeof config.hotspots !== "undefined")
    {
        this._hotspots.addTracks(config.hotspots);
    }

    if (typeof config.postProcessing !== "undefined")
    {
        this._postProcessing.addConfig(config.postProcessing);
    }

    if (typeof config.plugins !== "undefined")
    {
        this._plugins.addConfig(config.plugins);
    }

    this._controllers.addConfig(config.controllers);

    if (typeof config.story !== "undefined")
    {
        this._story.load(config.story);
    }

    this._raf.start();

    if (this._onMainConfigLoadComplete !== null)
    {
        this._onMainConfigLoadComplete.dispatch();
    }
};

/**
 * Parse the Viewer config.
 * @method FORGE.Viewer#_parseConfig
 * @param {ViewerConfig} config - The viewer configuration to parse
 * @private
 */
FORGE.Viewer.prototype._parseConfig = function(config)
{
    this._config = /** @type {ViewerConfig} */ (FORGE.Utils.extendSimpleObject(FORGE.Viewer.DEFAULT_CONFIG, config));

    if (this._onConfigLoadComplete !== null)
    {
        this._onConfigLoadComplete.dispatch();
    }
};

/**
 * Create all containers into the DOM.
 * @method FORGE.Viewer#_createContainers
 * @private
 */
FORGE.Viewer.prototype._createContainers = function()
{
    if (typeof this._parent === "string" && this._parent !== "")
    {
        this._parent = document.getElementById(this._parent);
    }

    if (typeof this._parent === "undefined" || this._parent === null || FORGE.Dom.isHtmlElement(this._parent) === false)
    {
        throw "FORGE.Viewer.boot : Viewer parent is invalid";
    }

    this._relative = document.createElement("div");
    this._relative.style.width = "100%";
    this._relative.style.height = "100%";
    this._relative.style.position = "relative";
    this._parent.appendChild(this._relative);

    this._container = new FORGE.DisplayObjectContainer(this, null, null, /** @type {Element} */ (this._relative));
    this._container.id = "FORGE-main-container-" + this._uid;

    this._canvasContainer = new FORGE.DisplayObjectContainer(this);
    this._canvasContainer.id = "FORGE-canvas-container-" + this._uid;
    this._container.index = 0;
    this._canvasContainer.maximize(true);
    this._container.addChild(this._canvasContainer);

    this._domHotspotContainer = new FORGE.DisplayObjectContainer(this);
    this._domHotspotContainer.id = "FORGE-dom-hotspot-container-" + this._uid;
    this._container.index = 0;
    this._domHotspotContainer.maximize(true);
    this._container.addChild(this._domHotspotContainer);

    this._domHotspotStyle = document.createElement("style");
    this._domHotspotStyle.type = "text/css";
    document.head.appendChild(this._domHotspotStyle);

    this._pluginContainer = new FORGE.DisplayObjectContainer(this);
    this._pluginContainer.id = "FORGE-plugin-container-" + this._uid;
    this._container.index = 0;
    this._pluginContainer.maximize(true);
    this._container.addChild(this._pluginContainer);
};

/**
 * Create the canvas into the DOM.
 * @method FORGE.Viewer#_createCanvas
 * @private
 */
FORGE.Viewer.prototype._createCanvas = function()
{
    this._canvas = new FORGE.Canvas(this);
    this._canvas.maximize(true);
    this._canvasContainer.addChild(this._canvas);
};

/**
 * Update class informations on main loop.
 * @method FORGE.Viewer#_updateLogic
 * @private
 */
FORGE.Viewer.prototype._updateLogic = function()
{
    this._display.update();
    this._keyboard.update();
    this._gamepad.update();
    this._audio.update();
    this._plugins.update();
    this._tween.update();
    this._hotspots.update();
    this._controllers.update();
    this._renderManager.update();

    if (this._callbacks !== null && typeof this._callbacks.update === "function")
    {
        this._callbacks.update.call();
    }
};

/**
 * Update scene rendering on main loop.
 * @method FORGE.Viewer#_updateRendering
 * @private
 */
FORGE.Viewer.prototype._updateRendering = function()
{
    if (this._callbacks !== null && typeof this._callbacks.beforeRender === "function")
    {
        this._callbacks.beforeRender.call();
    }

    if (this._renderManager !== null)
    {
        this._renderManager.render();
    }

    if (this._callbacks !== null && typeof this._callbacks.afterRender === "function")
    {
        this._callbacks.afterRender.call();
    }
};

/**
 * Update method called by the viewer main loop.
 * @method FORGE.Viewer#update
 * @param  {number} time - Time in ms
 */
FORGE.Viewer.prototype.update = function(time)
{
    if (this._paused === true)
    {
        return;
    }

    //Update the global clock
    this._clock.update(time);

    this._updateLogic();
    this._updateRendering();
};

/**
 * Pause the refresh on the main loop.
 * @method FORGE.Viewer#pause
 * @param {boolean} internal - Internal lib usage
 */
FORGE.Viewer.prototype.pause = function(internal)
{
    if(this._paused === true)
    {
        return;
    }

    this._paused = true;

    // Pause all media if autoPause is true
    if (internal !== true || (this._config !== null && this._config.autoPause === true))
    {
        this._audio.pauseAll();
    }

    if (this._onPause !== null)
    {
        this._onPause.dispatch({
            "internal": internal
        });
    }
};

/**
 * Resume the refresh on the main loop.
 * @method FORGE.Viewer#resume
 * @param {boolean} internal - Internal lib usage
 */
FORGE.Viewer.prototype.resume = function(internal)
{
    if(this._paused === false)
    {
        return;
    }

    this._paused = false;

    // Resume all media if autoResume is true
    if (internal !== true || (this._config !== null && this._config.autoResume === true))
    {
        this._audio.resumeAll();
    }

    if (this._onResume !== null)
    {
        this._onResume.dispatch({
            "internal": internal
        });
    }
};

/**
 * Destroy method.
 * @method FORGE.Viewer#destroy
 */
FORGE.Viewer.prototype.destroy = function()
{

    /**
     * WARNING THE ORDER OF THE DESTROY SEQUENCE MATTERS A LOT!
     * DO NOT CHANGE ANYTHING UNLESS YOU ARE SURE OF WHAT YOURE DOING
     */

    if(this._raf !== null)
    {
        this._raf.destroy();
        this._raf = null;
    }

    if(this._system !== null)
    {
        this._system.destroy();
        this._system = null;
    }

    if(this._plugins !== null)
    {
        this._plugins.destroy();
        this._plugins = null;
    }

    if(this._load !== null)
    {
        this._load.destroy();
        this._load = null;
    }

    if(this._history !== null)
    {
        this._history.destroy();
        this._history = null;
    }

    if(this._clock !== null)
    {
        this._clock.destroy();
        this._clock = null;
    }

    if (this._controllers !== null)
    {
        this._controllers.destroy();
        this._controllers = null;
    }

    if(this._keyboard !== null)
    {
        this._keyboard.destroy();
        this._keyboard = null;
    }

    if(this._gyroscope !== null)
    {
        this._gyroscope.destroy();
        this._gyroscope = null;
    }

    if(this._gamepad !== null)
    {
        this._gamepad.destroy();
        this._gamepad = null;
    }

    if(this._hotspots !== null)
    {
        this._hotspots.destroy();
        this._hotspots = null;
    }

    if(this._director !== null)
    {
        this._director.destroy();
        this._director = null;
    }

    if(this._renderManager !== null)
    {
        this._renderManager.destroy();
        this._renderManager = null;
    }

    if(this._canvas !== null)
    {
        this._canvas.destroy();
        this._canvas = null;
    }

    if(this._canvasContainer !== null)
    {
        this._canvasContainer.destroy();
        this._canvasContainer = null;
    }

    if(this._domHotspotContainer !== null)
    {
        this._domHotspotContainer.destroy();
        this._domHotspotContainer = null;
    }

    if(this._pluginContainer !== null)
    {
        this._pluginContainer.destroy();
        this._pluginContainer = null;
    }

    if(this._container !== null)
    {
        this._container.destroy();
        this._container = null;
    }

    if(this._postProcessing !== null)
    {
        this._postProcessing.destroy();
        this._postProcessing = null;
    }

    if(this._actions !== null)
    {
        this._actions.destroy();
        this._actions = null;
    }

    if(this._display !== null)
    {
        this._display.destroy();
        this._display = null;
    }

    if(this._playlists !== null)
    {
        this._playlists.destroy();
        this._playlists = null;
    }

    if(this._audio !== null)
    {
        this._audio.destroy();
        this._audio = null;
    }

    if(this._story !== null)
    {
        this._story.destroy();
        this._story = null;
    }

    if(this._tween !== null)
    {
        this._tween.destroy();
        this._tween = null;
    }

    if(this._cache !== null)
    {
        this._cache.destroy();
        this._cache = null;
    }

    if(this._i18n !== null)
    {
        this._i18n.destroy();
        this._i18n = null;
    }

    this._parent = null;
    this._callbacks = null;

    if (this._onReady !== null)
    {
        this._onReady.destroy();
        this._onReady = null;
    }

    if (this._onPause !== null)
    {
        this._onPause.destroy();
        this._onPause = null;
    }

    if (this._onResume !== null)
    {
        this._onResume.destroy();
        this._onResume = null;
    }

    if (this._onConfigLoadComplete !== null)
    {
        this._onConfigLoadComplete.destroy();
        this._onConfigLoadComplete = null;
    }

    if (this._onMainConfigLoadComplete !== null)
    {
        this._onMainConfigLoadComplete.destroy();
        this._onMainConfigLoadComplete = null;
    }

    FORGE.VIEWERS.splice(this._uid, 1);

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the viewer ready status.
 * @name FORGE.Viewer#ready
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "ready",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._ready;
    }
});

/**
 * Get the main configuration.
 * @name FORGE.Viewer#mainConfig
 * @type {MainConfig}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "mainConfig",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._mainConfig;
    }
});

/**
 * Get the viewer configuration.
 * @name FORGE.Viewer#config
 * @type {ViewerConfig}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "config",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._config;
    }
});

/**
 * Get the viewer parent element.
 * @name FORGE.Viewer#parent
 * @type {HTMLElement|String}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "parent",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._parent;
    }
});

/**
 * Get the viewer display list manager.
 * @name FORGE.Viewer#display
 * @type {FORGE.DisplayList}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "display",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._display;
    }
});

/**
 * Get and set the fullscreen property of the viewer main container.
 * @name FORGE.Viewer#fullscreen
 * @type {boolean}
 */
Object.defineProperty(FORGE.Viewer.prototype, "fullscreen",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._container.isFullscreen();
    },

    /** @this {FORGE.Viewer} */
    set: function(value)
    {
        if (typeof value !== "boolean" || this._container.isFullscreen() === value)
        {
            return;
        }

        this._container.fullscreen = value;
    }
});

/**
 * Get the viewer container.
 * @name FORGE.Viewer#container
 * @type {FORGE.DisplayObjectContainer}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "container",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._container;
    }
});

/**
 * Get the viewer canvas container.
 * @name FORGE.Viewer#canvasContainer
 * @type {FORGE.DisplayObjectContainer}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "canvasContainer",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._canvasContainer;
    }
});

/**
 * Get the viewer canvas.
 * @name FORGE.Viewer#canvas
 * @type {FORGE.Canvas}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "canvas",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._canvas;
    }
});

/**
 * Get the viewer DOM hotspot container.
 * @name FORGE.Viewer#domHotspotContainer
 * @type {FORGE.DisplayObjectContainer}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "domHotspotContainer",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._domHotspotContainer;
    }
});

/**
 * Get the viewer DOM hotspot style container.
 * @name FORGE.Viewer#domHotspotStyle
 * @type {HTMLStyleElement}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "domHotspotStyle",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._domHotspotStyle;
    }
});

/**
 * Get the viewer plugin container.
 * @name FORGE.Viewer#pluginContainer
 * @type {FORGE.DisplayObjectContainer}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "pluginContainer",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._pluginContainer;
    }
});

/**
 * Get the viewer request animation frame interface.
 * @name FORGE.Viewer#raf
 * @type {FORGE.RequestAnimationFrame}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "raf",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._raf;
    }
});

/**
 * Get the viewer audio/sound interface.
 * @name FORGE.Viewer#audio
 * @type {FORGE.SoundManager}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "audio",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._audio;
    }
});

/**
 * Get the viewer playlists for sounds.
 * @name FORGE.Viewer#playlists
 * @type {FORGE.PlaylistManager}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "playlists",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._playlists;
    }
});

/**
 * Get the viewer hotspots module.
 * @name FORGE.Viewer#hotspots
 * @type {FORGE.HotspotManager}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "hotspots",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._hotspots;
    }
});

/**
 * Get the viewer action manager.
 * @name FORGE.Viewer#actions
 * @type {FORGE.ActionManager}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "actions",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._actions;
    }
});

/**
 * Get the director's cut track manager.
 * @name FORGE.Viewer#director
 * @type {FORGE.Director}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "director",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._director;
    }
});

/**
 * Get the story module.
 * @name FORGE.Viewer#story
 * @type {FORGE.Story}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "story",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._story;
    }
});

/**
 * Get the history module.
 * @name FORGE.Viewer#history
 * @type {FORGE.History}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "history",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._history;
    }
});

/**
 * Get the viewer loader.
 * @name FORGE.Viewer#load
 * @type {FORGE.Loader}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "load",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._load;
    }
});

/**
 * Get the viewer cache.
 * @name FORGE.Viewer#cache
 * @type {FORGE.Cache}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "cache",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._cache;
    }
});

/**
 * Get the viewer plugins interface.
 * @name FORGE.Viewer#plugins
 * @type {FORGE.PluginManager}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "plugins",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._plugins;
    }
});

/**
 * Get the viewer clock interface.
 * @name FORGE.Viewer#clock
 * @type {FORGE.Clock}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "clock",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._clock;
    }
});

/**
 * Get the viewer tween interface.
 * @name FORGE.Viewer#tween
 * @type {FORGE.TweenManager}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "tween",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._tween;
    }
});

/**
 * Get the viewer i18n and locales interface.
 * @name FORGE.Viewer#i18n
 * @type {FORGE.LocaleManager}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "i18n",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._i18n;
    }
});

/**
 * Get the viewer render manager.
 * @name FORGE.Viewer#renderer
 * @type {FORGE.RenderManager}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "renderer",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._renderManager;
    }
});

/**
 * Get the view.
 * @name FORGE.Viewer#view
 * @type {FORGE.ViewManager}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "view",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._renderManager.view;
    }
});

/**
 * Get the camera.
 * @name FORGE.Viewer#camera
 * @type {FORGE.Camera}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "camera",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._renderManager.camera;
    }
});

/**
 * Get controller manager.
 * @name FORGE.Viewer#controllers
 * @readonly
 * @type {FORGE.ControllerManager}
 */
Object.defineProperty(FORGE.Viewer.prototype, "controllers",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._controllers;
    }
});

/**
 * Get the postProcessing object.
 * @name FORGE.Viewer#postProcessing
 * @type {FORGE.PostProcessing}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "postProcessing",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._postProcessing;
    }
});

/**
 * Get the viewer keyboard interface.
 * @name FORGE.Viewer#keyboard
 * @type {FORGE.Keyboard}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "keyboard",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._keyboard;
    }
});

/**
 * Get the viewer gyroscope interface.
 * @name FORGE.Viewer#gyroscope
 * @type {FORGE.Gyroscope}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "gyroscope",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._gyroscope;
    }
});

/**
 * Get the viewer gamepad interface.
 * @name FORGE.Viewer#gamepad
 * @type {FORGE.GamepadsManager}
 * @readonly
 */
Object.defineProperty(FORGE.Viewer.prototype, "gamepad",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._gamepad;
    }
});

/**
 * Get and set the viewer width.
 * @name FORGE.Viewer#width
 * @type {number}
 */
Object.defineProperty(FORGE.Viewer.prototype, "width",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._container.width;
    },

    /** @this {FORGE.Viewer} */
    set: function(value)
    {
        this._container.width = value;
    }
});

/**
 * Get and set the viewer height.
 * @name FORGE.Viewer#height
 * @type {number}
 */
Object.defineProperty(FORGE.Viewer.prototype, "height",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        return this._container.height;
    },

    /** @this {FORGE.Viewer} */
    set: function(value)
    {
        this._container.height = value;
    }
});


/**
 * Get the "onReady" {@link FORGE.EventDispatcher} of the viewer.
 * @name FORGE.Viewer#onReady
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Viewer.prototype, "onReady",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        if (this._onReady === null)
        {
            this._onReady = new FORGE.EventDispatcher(this);
        }

        return this._onReady;
    }
});

/**
 * Get the "onPause" {@link FORGE.EventDispatcher} of the viewer.
 * @name FORGE.Viewer#onPause
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Viewer.prototype, "onPause",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        if (this._onPause === null)
        {
            this._onPause = new FORGE.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
 * Get the "onResume" {@link FORGE.EventDispatcher} of the viewer.
 * @name FORGE.Viewer#onResume
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Viewer.prototype, "onResume",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        if (this._onResume === null)
        {
            this._onResume = new FORGE.EventDispatcher(this);
        }

        return this._onResume;
    }
});

/**
 * Get the "onConfigLoadComplete" {@link FORGE.EventDispatcher} of the viewer.
 * @name FORGE.Viewer#onConfigLoadComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Viewer.prototype, "onConfigLoadComplete",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        if (this._onConfigLoadComplete === null)
        {
            this._onConfigLoadComplete = new FORGE.EventDispatcher(this);
        }

        return this._onConfigLoadComplete;
    }
});

/**
 * Get the "onMainConfigLoadComplete" {@link FORGE.EventDispatcher} of the viewer.
 * @name FORGE.Viewer#onMainConfigLoadComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Viewer.prototype, "onMainConfigLoadComplete",
{
    /** @this {FORGE.Viewer} */
    get: function()
    {
        if (this._onMainConfigLoadComplete === null)
        {
            this._onMainConfigLoadComplete = new FORGE.EventDispatcher(this);
        }

        return this._onMainConfigLoadComplete;
    }
});


/**
 * Manage Tags inside FORGE.
 * Tags is singleton, so if you have multiple instances in the same page you MUST avoid Tags conflict.
 * @constructor
 * @extends {FORGE.BaseObject}
 */
FORGE.Tags = (function(c)
{
    var Tmp = c();
    Tmp.prototype = Object.create(FORGE.BaseObject.prototype);
    Tmp.prototype.constructor = Tmp;

    /**
     * Register a tagged object.
     * @method FORGE.Tags.register
     * @param  {Object} object - The object you want to register into the tag index.
     */
    Tmp.prototype.register = function(object)
    {
        if(typeof object === "object" && typeof object.uid === "string" && Array.isArray(object.tags))
        {
            var uid = object.uid;
            var tags = object.tags;
            var tag;

            if(FORGE.UID.exists(uid) === true)
            {
                //this._objects[uid] = object;
                for(var i = 0, ii = tags.length; i < ii; i++)
                {
                    tag = tags[i];

                    //Skip if a tag is not a string, this is an error!
                    if(typeof tag !== "string")
                    {
                        this.warn("Tags: An object has a tag that isn't a string!");
                        continue;
                    }

                    //If the tag is unknow, add an entry to the tags array
                    if(typeof this._allTags[tag] === "undefined")
                    {
                        this._allTags[tag] = [];

                        if(this._onRegister !== null)
                        {
                            this._onRegister.dispatch({"tag": tag});
                        }
                    }

                    if(this._allTags[tag].indexOf(uid) === -1)
                    {
                        this._allTags[tag].push(uid);
                    }
                }
            }
            else
            {
                this.warn("Tags: The object you want to register in tags is not known by UID!");
                this.warn(object);
            }
        }
        else
        {
            this.warn("Tags: No uid or no tags on the object you try to register!");
            this.warn(object);
        }
    };

    /**
     * Get uids associated to a tag or to an array of tags.<br>
     * You can filter the className of objets to get.
     * @method FORGE.Tags.getUids
     * @param  {string|Array} value - The uid or array of uids of object(s) you want to get.
     * @param  {string} className  - Filter you result by className of objects.
     * @return {Array<string>}  Returns an array of uids that matches the request.
     */
    Tmp.prototype.getUids = function(value, className)
    {
        var uids = [];

        if(typeof value === "string")
        {
            uids = this._allTags[value];
        }
        else if(Array.isArray(value))
        {
            var tag;
            for(var i = 0, ii = value.length; i < ii; i++)
            {
                tag = value[i];
                if(this.exists(tag) === true)
                {
                    uids.concat(this.get[tag]);
                }
            }
        }

        if(typeof className === "string")
        {
            uids = FORGE.UID.filterType(uids, className);
        }

        return uids;
    };

    /**
     * Get objects associated to a tag or to an array of tags.<br>
     * You can filter the className of objets to get.
     * @method FORGE.Tags.get
     * @param  {(string|Array)} value - The uid or array of uids of object(s) you want to get.
     * @param {string} className - Filter you result by className of objects.
     * @return {(Object|Array|undefined)} Returns an object or an array of objects that matches the request.
     */
    Tmp.prototype.get = function(value, className)
    {
        if(typeof value === "string")
        {
            return FORGE.UID.get(this._allTags[value], className);
        }
        else if(Array.isArray(value))
        {
            var uids = [];
            var tag;
            for(var i = 0, ii = value.length; i < ii; i++)
            {
                tag = value[i];
                if(this.exists(tag) === true)
                {
                    uids.concat(this.get[tag]);
                }
            }

            return FORGE.UID.get(uids, className);
        }

        return undefined;
    };

    /**
     * Tell if this tag have at least an object of a specific className.
     * @method  FORGE.Tags.hasTypeOf
     * @param  {string}  tag - The tag you want to check if it reference an onbject of specified className.
     * @param {string} className - The className you want to check.
     * @return {boolean} Returns true if the tag have at least an object of the asked className.
     */
    Tmp.prototype.hasTypeOf = function(tag, className)
    {
        if(this.exists(tag) === true)
        {
            var uids = this._allTags[tag];

            for (var i = 0, ii = this._allTags.length; i < ii; i++)
            {
                if(FORGE.UID.isTypeOf(uids[i], className) === true)
                {
                    return true;
                }
            }
        }

        return false;
    };

    /**
     * Does a tag exists ?
     * @method FORGE.Tags.exists
     * @param  {string} tag - The tag you want to check.
     * @return {boolean} Returns true if uid is already registered, false if not.
     */
    Tmp.prototype.exists = function(tag)
    {
        return (typeof this._allTags[tag] !== "undefined" && this._allTags[tag] !== null);
    };

    /**
     * Get the list of all existing tags.
     * @name  FORGE.Tags#list
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "list",
    {
        get: function()
        {
            return Object.keys(this._allTags);
        }
    });

    /**
     * Get the on add event dispatcher.
     * @name  FORGE.Tags#onRegister
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "onRegister",
    {
        get: function()
        {
            if(this._onRegister === null)
            {
                this._onRegister = new FORGE.EventDispatcher(this);
            }

            return this._onRegister;
        }
    });

    return new Tmp();
})(function()
{
    return function()
    {
        /**
         * The object that reference all tags objects couples.
         * @name FORGE.Tags#_allTags
         * @type {Object}
         * @private
         */
        this._allTags = {};

        /**
         * Event dispatcher for add tag event.
         * @name  FORGE.Tags#_onRegister
         * @type {FORGE.EventDispatcher}
         * @private
         */
        this._onRegister = null;

        FORGE.BaseObject.call(this, "Tags");
    };
});
/**
 * Manage UIDs inside FORGE.<br>
 * UID is singleton, so if you have multiple instances in the same page you MUST avoid UID conflict.
 * @constructor
 * @extends {FORGE.BaseObject}
 */
FORGE.UID = (function(c)
{
    var Tmp = c();
    Tmp.prototype = Object.create(FORGE.BaseObject.prototype);
    Tmp.prototype.constructor = Tmp;

    /**
     * Generate a uid.
     * @method FORGE.UID.generate
     * @return {string} Return a UID string.
     */
    Tmp.prototype.generate = function()
    {
        // see http://stackoverflow.com/a/2117523/1233787
        var uid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c)
        {
            var h = Math.random() * 16 | 0;
            h = c == "x" ? h : (h & 0x3 | 0x8);
            return h.toString(16);
        });

        if (FORGE.UID.exists(uid) === false)
        {
            return uid;
        }
        else
        {
            return FORGE.UID.generate();
        }
    };

    /**
     * Validate recursively a uid.
     * @method FORGE.UID.validate
     * @param  {Object} object - The object you want to validate into the index.
     * @return {boolean} Returns the validate status.
     */
    Tmp.prototype.validate = function(object)
    {
        var uids = [];

        var validateRecursive = function(object)
        {
            var uid;

            for (var i in object)
            {
                if (i === "uid")
                {
                    uid = object[i];

                    if (typeof uid === "string")
                    {
                        if (FORGE.UID.exists(uid) || uids.indexOf(uid) !== -1)
                        {
                            this.warn("UID configuration not valid, uid " + uid + " already exists!");
                            return false;
                        }
                        else
                        {
                            uids.push(object[i]);
                        }
                    }
                    else
                    {
                        this.warn("Found a uid in configuration that is not a string!");
                        return false;
                    }
                }
                else if (typeof(object[i]) === "object")
                {
                    return validateRecursive.apply(this, [object[i]]);
                }
            }

            return true;
        };

        return validateRecursive.apply(this, [object]);
    };


    /**
     * Register an object into the uid index.
     * @method FORGE.UID.register
     * @param  {Object} object - The object you want to register into the index.
     * @return {boolean} Return true if the object is added to UID, false if not.
     */
    Tmp.prototype.register = function(object)
    {
        if (typeof object === "object" && typeof object.uid === "string")
        {
            var uid = object.uid;

            if (FORGE.UID.exists(uid) === false)
            {
                this._objects[uid] = object;
                return true;
            }
            else
            {
                this.warn("The uid you want to register already exists!");
                this.warn(object);
            }
        }
        else
        {
            this.warn("No uid on the object you try to register!");
            this.warn(object);
        }

        return false;
    };

    /**
     * Unregister an object from the uid index.
     * @method FORGE.UID.unregister
     * @param  {Object} object - The object you want to unregister from the index.
     */
    Tmp.prototype.unregister = function(object)
    {
        if (typeof object === "object" && typeof object.uid === "string")
        {
            var uid = object.uid;
            this._objects[uid] = null;
            delete this._objects[uid];
            return;
        }

        this.warn("No uid on the object you try to unregister!");
    };

    /**
     * Get all uids or uids of a specific className.
     * @method  FORGE.UID.getuids
     * @param  {string} className - Type of uids you want to get, if undefined this will return all the uids.
     * @return {Array<string>} Returns an array of uids.
     */
    Tmp.prototype.getUids = function(className)
    {
        if (typeof className === "undefined" || className === null)
        {
            return Object.keys(this._objects);
        }
        else
        {
            return FORGE.UID.filterType(Object.keys(this._objects), className);
        }
    };

    /**
     * Filter an array of uids and return only uids of a specific className.
     * @method FORGE.UID.filterType
     * @param  {Array<string>} uids - Array of uids to filter by className.
     * @param  {string} className - Class name of object to filter.
     * @return {Array<string>} Returns an array of uids filtered by className.
     */
    Tmp.prototype.filterType = function(uids, className)
    {
        var filter = function(uid)
        {
            if (FORGE.UID.isTypeOf(uid, className))
            {
                return true;
            }

            return false;
        };

        return uids.filter(filter);
    };

    /**
     * Get a registered object from its uid.
     * @method FORGE.UID.get
     * @param  {string|Array} value - The uid or array of uids of object(s) you want to get.
     * @param  {string=} className - The className of the object you want
     * @return {*} Returns the object(s) related to the filters.
     */
    Tmp.prototype.get = function(value, className)
    {
        //If no value is passed, the whole uids array is used as values
        if (typeof value === "undefined" || value === null)
        {
            //If no value and no className, return all the objects.
            if (typeof className !== "string")
            {
                return this._objects;
            }

            value = Object.keys(this._objects);
        }

        if (typeof value === "string")
        {
            return this._objects[value];
        }
        else if (Array.isArray(value))
        {
            if (typeof className === "string")
            {
                value = FORGE.UID.filterType(value, className);
            }

            var result = [];
            var uid;
            for (var i = 0, ii = value.length; i < ii; i++)
            {
                uid = value[i];
                if (FORGE.UID.exists(uid) === true)
                {
                    result.push(this._objects[uid]);
                }
            }

            return result;
        }

        return undefined;
    };

    /**
     * Tell if this uid matches an object of a specific className.
     * @method  FORGE.UID.isTypeOf
     * @param {string}  uid - uid of the object you want to check the className of.
     * @param {string} className - The className you want to check.
     * @return {boolean} Returns true if the object is of the asked className.
     */
    Tmp.prototype.isTypeOf = function(uid, className)
    {
        var object = FORGE.UID.get(uid);
        return FORGE.Utils.isTypeOf(object, className);
    };

    /**
     * Does a uid exists?
     * @method FORGE.UID.exists
     * @param  {string} uid - The uid you want to check.
     * @return {boolean} Return true if uid is already registered, false if not.
     */
    Tmp.prototype.exists = function(uid)
    {
        return (typeof this._objects[uid] !== "undefined" && this._objects[uid] !== null);
    };

    return new Tmp();

})(function()
{
    return function()
    {
        /**
         * The object that reference all uids objects couples.
         * @name FORGE.UID#_objects
         * @type {Object}
         * @private
         */
        this._objects = {};

        FORGE.BaseObject.call(this, "UID");
    };
});


/**
 * FORGE.EventDispatcher can dispatch and reference listeners.
 *
 * @constructor FORGE.EventDispatcher
 * @param {Object} emitter - The object that wiil be considered as the emitter of the event.
 * @param {boolean=} memorize - Does the dispatcher should memorize the previous dispatcher ?
 * @extends {FORGE.BaseObject}
 */
FORGE.EventDispatcher = function(emitter, memorize)
{
    /**
     * The emitter reference.
     * @name  FORGE.EventDispatcher#_emitter
     * @type {Object}
     * @private
     */
    this._emitter = emitter;

    /**
     * Does the dispatcher should memorize the previous dispatch?<br>
     * If true, will redispatch with the previous data when you add a listener to it.
     * @name  FORGE.EventDispatcher#_memorize
     * @type {boolean}
     * @private
     */
    this._memorize = memorize || false;

    /**
     * A backup of previous dispatched data for memorized dispatcher.
     * @name FORGE.EventDispatcher#_previousData
     * @type {*}
     * @private
     */
    this._previousData = null;

    /**
     * Array of {@link FORGE.Listener}.
     * @name FORGE.EventDispatcher#_listeners
     * @type {?Array<FORGE.Listener>}
     * @private
     */
    this._listeners = null;

    /**
     * Is this event dipatcher is active?<br>
     * If not, it will ignore all dispatch calls.
     * @name FORGE.EventDispatcher#_active
     * @type {boolean}
     * @private
     */
    this._active = true;

    /**
     * Dispatched flag, set to true at the first dispatch
     * @name  FORGE.EventDispatcher#_dispatched
     * @type {boolean}
     * @private
     */
    this._dispatched = false;

    FORGE.BaseObject.call(this, "EventDispatcher");
};

FORGE.EventDispatcher.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.EventDispatcher.prototype.constructor = FORGE.EventDispatcher;

/**
 * Create the listeners array an push a new listener into it.
 *
 * @method FORGE.EventDispatcher#_addListener
 * @private
 * @param {Function} listener - The listener to add.
 * @param {boolean} isOnce - Is the dispatcher should trigger this listener only one time?
 * @param {Object} context - The context in which the listener will be executed.
 * @param {number=} priority - The priority of the event.
 */
FORGE.EventDispatcher.prototype._addListener = function(listener, isOnce, context, priority)
{
    if(typeof listener !== "function")
    {
        this.warn("You're trying to add an undefined listener");
        return;
    }

    if(this.has(listener, context) === true)
    {
        this.warn("You're trying to add a duplicate listener for this context");
        return;
    }

    var lis = new FORGE.Listener(this, listener, isOnce, context, priority);

    //register the listener with priority
    this._registerListener(lis);

    if(this._memorize === true && this._active === true && this._dispatched === true)
    {
        lis.execute(this._previousData);
    }

    return listener;
};

/**
 * Internal method to insert the listener into the array according to its priority.
 *
 * @method FORGE.EventDispatcher#_registerListener
 * @private
 * @param  {FORGE.Listener} listener - The object which handle the listener and it's context.
 */
FORGE.EventDispatcher.prototype._registerListener = function(listener)
{
    if(this._listeners === null)
    {
        this._listeners = [];
    }

    if (this._listeners.length === 0)
    {
        this._listeners.push(listener);
        return;
    }

    var n = this._listeners.length;
    do
    {
        n--;
    }
    while(this._listeners[n] && listener._priority <= this._listeners[n]._priority);

    this._listeners.splice(n + 1, 0, listener);
};

/**
 * Internal method to get the index of a couple listener + context.
 *
 * @method FORGE.EventDispatcher#_indexOfListener
 * @private
 * @param  {Function} listener - The listener function you need to find its index.
 * @param {Object} context - The context associated to the listener function.
 * @return {number} - The index of the couple listener + context if found, -1 if not.
 */
FORGE.EventDispatcher.prototype._indexOfListener = function(listener, context)
{
    if(this._listeners === null)
    {
        return -1;
    }

    if ( typeof context === "undefined" )
    {
        context = null;
    }

    var _listener;

    for ( var i = 0, ii = this._listeners.length; i < ii; i++ )
    {
        _listener = this._listeners[i];

        if(_listener.listener === listener && _listener.context === context)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Add an event listener function.
 *
 * @method FORGE.EventDispatcher#add
 * @param {Function} listener - Event handler callback function.
 * @param {Object} context - The context for the listener call.
 * @param {number=} priority - Priority level for the event to be execute.
 */
FORGE.EventDispatcher.prototype.add = function(listener, context, priority)
{
    this._addListener(listener, false, context, priority);
};

/**
 * Add an event listener function that will be triggered only once.
 *
 * @method FORGE.EventDispatcher#addOnce
 * @param {Function} listener - Event handler callback function.
 * @param {Object} context - The context for the listener call.
 * @param {number=} priority - Priority level for the event to be execute.
 */
FORGE.EventDispatcher.prototype.addOnce = function(listener, context, priority)
{
    this._addListener(listener, true, context, priority);
};

/**
 * Remove a {@link FORGE.Listener} from this event dispatcher.
 *
 * @method FORGE.EventDispatcher#remove
 * @param  {Function} listener - The listener handler to be removed.
 * @param  {Object} context - The context of the handler to be removed.
 */
FORGE.EventDispatcher.prototype.remove = function(listener, context)
{
    var i = this._indexOfListener(listener, context);

    if(i !== -1)
    {
        this._listeners[i].destroy();
        this._listeners.splice(i, 1);
    }
};

/**
 * Check if this event dispatcher has a specific listener.
 *
 * @method FORGE.EventDispatcher#has
 * @param  {Function} listener - listener function to check.
 * @param  {Object} context - listener context to check.
 * @return {boolean} Returns true if the dispatcher has the listener, false if not.
 */
FORGE.EventDispatcher.prototype.has = function(listener, context)
{
    return this._indexOfListener(listener, context) !== -1;
};

/**
 * Dispatch the event, will trigger all the listeners methods.
 *
 * @method FORGE.EventDispatcher#dispatch
 * @param {*=} data - Any object or data you want to associate with the dispatched event.
 * @param {boolean=} async - Does the dispatch need to be async ?
 */
FORGE.EventDispatcher.prototype.dispatch = function(data, async)
{
    this._dispatched = true;

    if(this._memorize === true)
    {
        this._previousData = data === undefined ? null : data;
    }

    if(this._active === false || this._listeners === null)
    {
        return;
    }

    var n = this._listeners.length;

    while(n--)
    {
        this._listeners[n].execute(data, async);
    }

};

/**
 * Destroy method.
 * @method FORGE.EventDispatcher#destroy
 */
FORGE.EventDispatcher.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    if(this._listeners !== null)
    {
        var n = this._listeners.length;
        while(n--)
        {
            this._listeners[n].destroy();
        }

        this._listeners = null;
    }

    this._emitter = null;
    this._previousData = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
* Get the emitter object associated to this event dispatcher.
* @name FORGE.EventDispatcher#emitter
* @readonly
* @type {Object}
*/
Object.defineProperty(FORGE.EventDispatcher.prototype, "emitter",
{
    /** @this {FORGE.EventDispatcher} */
    get: function()
    {
        return this._emitter;
    }
});

/**
* Get and set the memorize flag associated to this event dispatcher.
* @name FORGE.EventDispatcher#memorized
* @type {boolean}
*/
Object.defineProperty(FORGE.EventDispatcher.prototype, "memorize",
{
    /** @this {FORGE.EventDispatcher} */
    get: function()
    {
        return this._memorize;
    },

    /** @this {FORGE.EventDispatcher} */
    set: function(value)
    {
        this._memorize = Boolean(value);
    }
});

/**
* Get and set the active flag associated to this event dispatcher.<br>
* If active is false, this dispatcher will not dispatch any event.
* @name FORGE.EventDispatcher#active
* @type {boolean}
*/
Object.defineProperty(FORGE.EventDispatcher.prototype, "active",
{
    /** @this {FORGE.EventDispatcher} */
    get: function()
    {
        return this._active;
    },

    /** @this {FORGE.EventDispatcher} */
    set: function(value)
    {
        this._active = Boolean(value);
    }
});

/**
 * FORGE.Event reference an emitter and eventually some data.
 *
 * @constructor FORGE.Event
 * @param {Object} emitter - The object that will be considered as the emitter of the event.
 * @param {Object} data - Any data associated to this event.
 */
FORGE.Event = function(emitter, data)
{
    /**
     * The object that will be considered as the emitter of the event.
     * @name FORGE.Event#_emitter
     * @type {Object}
     * @private
     */
    this._emitter = emitter;

    /**
     * Any data associated to this event.
     * @name FORGE.Event#_data
     * @type {?Object}
     * @private
     */
    this._data = data || null;
};


FORGE.Event.prototype.constructor = FORGE.Event;

/**
 * Get the event emitter.
 * @name  FORGE.Event#emitter
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.Event.prototype, "emitter",
{
    /** @this {FORGE.Event} */
    get: function ()
    {
        return this._emitter;
    }
});

/**
 * Get the data associated to the event.
 * @name  FORGE.Event#data
 * @readonly
 * @type {?Object}
 */
Object.defineProperty(FORGE.Event.prototype, "data",
{
    /** @this {FORGE.Event} */
    get: function ()
    {
        return this._data;
    }
});


/**
 * Object that handle listener function and its context.
 *
 * @constructor FORGE.Listener
 * @param {Function} listener - The handler function
 * @param {boolean} isOnce - If this listener will trigger only once, then delete itself from its dispatcher.
 * @param {Object} context - The context for listener execution.
 * @param {number=} priority - The priority of the listener.
 */
FORGE.Listener = function(dispatcher, listener, isOnce, context, priority)
{
    /**
     * Reference to the {@link FORGE.EvenDispatcher} this listener is attached to.
     * @name FORGE.Listener#_dispatcher
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._dispatcher = dispatcher;

    /**
     * The callback function that will be triggered when event occurs.
     * @name FORGE.Listener#_listener
     * @type {Function}
     * @private
     */
    this._listener = listener;

    /**
     * The context for listener execution.
     * @name FORGE.Listener#_context
     * @type {?Object}
     * @private
     */
    this._context = context || null;

    /**
     * If this listener will trigger only once, then delete itself from its dispatcher.
     * @name FORGE.Listener#_isOnce
     * @type {boolean}
     * @default false
     * @private
     */
    this._isOnce = isOnce || false;

    /**
     * The priority level of the event listener.<br>
     * Listeners with higher priority will be executed before listeners with lower priority.<br>
     * Listeners with same priority level will be executed at the same order as they were added. (default = 0).
     * @name FORGE.Listener#_priority
     * @type {number}
     * @private
     */
    this._priority = priority || 0;

    /**
     * The number of times the listener has been called.
     * @name  FORGE.Listener#_callCount
     * @type {number}
     * @private
     */
    this._callCount = 0;

    /**
     * The active state of the listener. Will be executed only if active.
     * @name  FORGE.Listener#_active
     * @type {boolean}
     * @private
     */
    this._active = true;

    /**
     * Is the async process is busy?
     * @name  FORGE.Listener#_asyncBusy
     * @type {boolean}
     * @private
     */
    this._asyncBusy = false;
};

FORGE.Listener.prototype.constructor = FORGE.Listener;

FORGE.Listener.prototype._execute = function(data)
{
    var event = new FORGE.Event(this._dispatcher.emitter, data);
    this._listener.call(this._context, event);

    this._callCount++;

    if(this._isOnce === true)
    {
        this.detach();
    }

    this._asyncBusy = false; //reset the async busy flag to false in all cases
};

/**
* Call listener passing a data object.<br>
* If listener was added using EventDispatcher.addOnce() it will be automatically removed.
*
* @method FORGE.Listener#execute
* @param {*=} data - Data that should be passed to the listener.
* @param {boolean=} async - Execute the listener in async mode (with a setTimeout at 0).
*/
FORGE.Listener.prototype.execute = function(data, async)
{
    if(this._active === true && this._listener !== null)
    {
        if(async === true && this._asyncBusy === false)
        {
            this._asyncBusy = true;
            var executeBind = this._execute.bind(this, data);
            window.setTimeout(executeBind, 0);
        }
        else if(async !== true)
        {
            this._execute(data);
        }
    }
};

/**
 * Detach the listener from its event dispatcher.
 * @method FORGE.Listener#detach
 */
FORGE.Listener.prototype.detach = function()
{
    return this._dispatcher.remove(this._listener, this._context);
};

/**
 * Destroy method.
 * @method FORGE.Listener#destroy
 */
FORGE.Listener.prototype.destroy = function()
{
    this._dispatcher = null;
    this._listener = null;
    this._context = null;
};

/**
 * Get the listener function.
 * @name FORGE.Listener#listener
 * @readonly
 * @type {Function}
 */
Object.defineProperty(FORGE.Listener.prototype, "listener", {

    /** @this {FORGE.Listener} */
    get: function ()
    {
        return this._listener;
    }
});

/**
 * Get the context object.
 * @name FORGE.Listener#context
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.Listener.prototype, "context", {

    /** @this {FORGE.Listener} */
    get: function ()
    {
        return this._context;
    }
});

/**
 * Get the priority number.
 * @name FORGE.Listener#priority
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.Listener.prototype, "priority", {

    /** @this {FORGE.Listener} */
    get: function ()
    {
        return this._priority;
    }
});

/**
 * Get the call count property value.
 * @name FORGE.Listener#callCount
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.Listener.prototype, "callCount", {

    /** @this {FORGE.Listener} */
    get: function ()
    {
        return this._callCount;
    }
});

/**
 * The FORGE.Story manages groups and scenes of the project's story.
 *
 * @constructor FORGE.Story
 * @param {FORGE.Viewer} viewer {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.Story = function(viewer)
{
    /**
    * The viewer reference.
    * @name FORGE.Story#_viewer
    * @type {FORGE.Viewer}
    * @private
    */
    this._viewer = viewer;

    /**
     * The config object.
     * @name FORGE.Story#_config
     * @type {?StoryConfig}
     * @private
     */
    this._config = null;

    /**
     * The internationalizable name of the story.
     * @name FORGE.Story#_name
     * @type {?FORGE.LocaleString}
     * @private
     */
    this._name = null;

    /**
     * The internationalizable slug name of the story.
     * @name FORGE.Story#_slug
     * @type {?FORGE.LocaleString}
     * @private
     */
    this._slug = null;

    /**
     * The internationalizable description of the story.
     * @name FORGE.Story#_description
     * @type {?FORGE.LocaleString}
     * @private
     */
    this._description = null;

    /**
     * The default uid to load, this can be a scene or a group uid.
     * @name FORGE.Story#_default
     * @type {string}
     * @private
     */
    this._default = "";

    /**
     * Array of {@link FORGE.Scene} uid of the story.
     * @name FORGE.Story#_scenes
     * @type {?Array<string>}
     * @private
     */
    this._scenes = null;

    /**
     * Uid of the current scene.
     * @name FORGE.Story#_sceneUid
     * @type {string}
     * @private
     */
    this._sceneUid = "";

    /**
     * Array of {@link FORGE.Group} uid of the story.
     * @name FORGE.Story#_groups
     * @type {?Array<string>}
     * @private
     */
    this._groups = null;

    /**
     * Uid of the current group.
     * @name FORGE.Story#_groupUid
     * @type {?string}
     * @private
     */
    this._groupUid = "";

    /**
     * Story events from the json configuration
     * @name FORGE.Story#_events
     * @type {Object<FORGE.ActionEventDispatcher>}
     * @private
     */
    this._events = {};

    /**
     * On ready event dispatcher
     * @name FORGE.Story#_onReady
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onReady = null;

    /**
     * On scene load requset event dispatcher.
     * @name  FORGE.Story#_onSceneLoadRequest
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onSceneLoadRequest = null;

    /**
     * On scene load start event dispatcher.
     * @name  FORGE.Story#_onSceneLoadStart
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onSceneLoadStart = null;

    /**
     * On scene load progress event dispatcher.
     * @name FORGE.Story#_onSceneLoadProgress
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onSceneLoadProgress = null;

    /**
     * On scene load complete event dispatcher.
     * @name FORGE.Story#_onSceneLoadComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onSceneLoadComplete = null;

    /**
     * On scene load error event dispatcher.
     * @name FORGE.Story#_onSceneLoadError
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onSceneLoadError = null;

    /**
     * On scene preview event dispatcher.
     * @name FORGE.Story#_onScenePreview
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onScenePreview = null;

    /**
     * On group change event dispatcher.
     * @name FORGE.Story#_onGroupChange
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onGroupChange = null;

    FORGE.BaseObject.call(this, "Story");

};

FORGE.Story.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Story.prototype.constructor = FORGE.Story;

/**
 * Event handler for the configuration JSON load complete.
 * @method FORGE.Story#_configLoadComplete
 * @private
 * @param  {FORGE.File} file - The {@link FORGE.File} that describes the loaded JSON file.
 */
FORGE.Story.prototype._configLoadComplete = function(file)
{
    this.log("FORGE.Story.loadComplete();");

    var json = this._viewer.cache.get(FORGE.Cache.types.JSON, file.key);
    var config = /** @type {StoryConfig} */ (json.data);

    this._parseConfig(config);
};

/**
 * Parse the story configuration.
 * @method FORGE.Story#_parseConfig
 * @private
 * @param  {StoryConfig} config - The story configuration to parse.
 */
FORGE.Story.prototype._parseConfig = function(config)
{
    if(FORGE.UID.validate(config) !== true)
    {
        throw "Story configuration is not valid, you have duplicate uids";
    }

    this._config = config;

    this._uid = this._config.uid;
    this._register();

    this._default = this._config.default;

    // Set the keys for the locale strings
    this._name.key = this._config.name;
    this._slug.key = this._config.slug;
    this._description.key = this._config.description;

    if(typeof this._config.scenes !== "undefined" && this._config.scenes.length > 0)
    {
        this._createScenes(this._config.scenes);
    }

    if(typeof this._config.groups !== "undefined" && this._config.groups.length > 0)
    {
        this._createGroups(this._config.groups);
    }

    if(typeof this._config.events === "object" && this._config.events !== null)
    {
        this._createEvents(this._config.events);
    }

    this._checkStoryScenes();
};

/**
 * Create events dispatchers.
 * @method FORGE.Story#_createEvents
 * @private
 * @param {StoryEventsConfig} events - The events config of the story.
 */
FORGE.Story.prototype._createEvents = function(events)
{
    var event;
    for(var e in events)
    {
        event = new FORGE.ActionEventDispatcher(this._viewer, e);
        event.addActions(events[e]);
        this._events[e] = event;
    }
};

/**
 * Clear all events.
 * @method FORGE.Story#_clearEvents
 * @private
 */
FORGE.Story.prototype._clearEvents = function()
{
    for(var e in this._events)
    {
        this._events[e].destroy();
        this._events[e] = null;
    }
};

/**
 * Check if all scenes have been loaded.
 * @method FORGE.Story#_checkStoryScenes
 * @private
 */
FORGE.Story.prototype._checkStoryScenes = function()
{
    if(typeof this._config.scenes === "undefined" || this._scenes.length === this._config.scenes.length)
    {
        this._setStoryReady();
    }
};

/**
 * Activate the story and load the first scene.
 * @method FORGE.Story#_setStoryReady
 * @private
 */
FORGE.Story.prototype._setStoryReady = function()
{
    if(this._onReady !== null)
    {
        this._onReady.dispatch();
    }

    if(FORGE.Utils.isTypeOf(this._events.onReady, "ActionEventDispatcher") === true)
    {
        this._events.onReady.dispatch();
    }

    // If slug name in URL load the associated object
    // NB: I couldn't find another way to correctly access the property without minification
    var hashParameters = FORGE.URL.parse()["hashParameters"];

    if(hashParameters !== null && typeof hashParameters.uid === "string" && FORGE.UID.exists(hashParameters.uid))
    {
        this._loadUid(hashParameters.uid);

        // this._viewer.i18n.onLocaleChangeComplete.addOnce(this._localeChangeCompleteHandler, this);
    }
    //Else if default uid
    else if(this._default !== "" && this._default !== null && FORGE.UID.exists(this._default))
    {
        this._loadUid(this._default);
    }
    //Else load scene index 0
    else
    {
        this.loadScene(0);
    }
};

/**
 * Load an object by its uid. It can be a scene uid or a group uid.
 * @method FORGE.Story._loadUid
 * @private
 * @param  {string} uid - Uid of the object you want to load.
 */
FORGE.Story.prototype._loadUid = function(uid)
{
    if(FORGE.UID.isTypeOf(uid, "Scene") === true || FORGE.UID.isTypeOf(uid, "Group") === true)
    {
        FORGE.UID.get(uid).load();
    }
};

/**
 * Create {@link FORGE.Scene}s from scenes configuration object.
 * @method FORGE.Story#_createScenes
 * @private
 * @param  {Array<SceneConfig>} config - The object that describes the scenes, issued from the main configuration.
 */
FORGE.Story.prototype._createScenes = function(config)
{
    var scene;
    for(var i = 0, ii = config.length; i < ii; i++)
    {
        scene = new FORGE.Scene(this._viewer);
        scene.addConfig(config[i]);

        //Scene is not booted at creation if the scene config is in an external file
        if(scene.booted === true)
        {
            this._addScene(scene);
        }
    }
};

/**
 * Add a scene into the scenes array.
 * @param {FORGE.Scene} scene - The scene to add.
 * @private
 */
FORGE.Story.prototype._addScene = function(scene)
{
    scene.onLoadRequest.add(this._sceneLoadRequestHandler, this);
    scene.onLoadStart.add(this._sceneLoadStartHandler, this);
    scene.onLoadComplete.add(this._sceneLoadCompleteHandler, this);

    this._scenes.push(scene.uid);
};

/**
 * Handler for the onBackgroundReady event of the FORGE.Scene that is being loaded.
 * @method FORGE.Story#_backgroundReadyHandler
 * @private
 */
FORGE.Story.prototype._backgroundReadyHandler = function()
{
    this._viewer.renderer.pickingManager.start();
};

/**
 * Internal envent handler for scene load request.
 * @method FORGE.Story#_sceneLoadRequestHandler
 * @param  {FORGE.Event} event - The {@link FORGE.Event} emitted by the scene that its load method is requested.
 * @private
 */
FORGE.Story.prototype._sceneLoadRequestHandler = function(event)
{
    var previousScene = this.scene;
    var nextScene = event.emitter;
    var time = NaN;

    //Unload the previous scene
    if(previousScene !== null)
    {
        // If the next scene have to be sync with the previous one
        if(nextScene.sync.indexOf(previousScene.uid) !== -1 && previousScene.media.type === FORGE.MediaType.VIDEO)
        {
            time = previousScene.media.displayObject.currentTime;
        }

        previousScene.unload();
    }

    this._sceneUid = nextScene.uid;

    nextScene.loadStart(time);

    this.log("scene load request");

    //The scene has no group so nullify the _groupUid
    if(nextScene.hasGroups() === false)
    {
        this._groupUid = null;

        if(this._onGroupChange !== null)
        {
            this._onGroupChange.dispatch(/** @type {StoryEvent} */({ groupUid: this._groupUid }));
        }

        if(FORGE.Utils.isTypeOf(this._events.onGroupChange, "ActionEventDispatcher") === true)
        {
            this._events.onGroupChange.dispatch();
        }
    }
    else if (nextScene.hasGroups() === true && nextScene.hasGroup(this._groupUid) === false)
    {
        this._setGroupUid(nextScene.groups[0].uid);
    }

    if(this._onSceneLoadRequest !== null)
    {
        this._onSceneLoadRequest.dispatch(/** @type {StoryEvent} */({ sceneUid: this._sceneUid }));
    }

    if(FORGE.Utils.isTypeOf(this._events.onSceneLoadRequest, "ActionEventDispatcher") === true)
    {
        this._events.onSceneLoadRequest.dispatch();
    }
};

/**
 * Internal envent handler for scene load start, updates the group index, re-dispatch scene load start at the story level.
 * @method FORGE.Story#_sceneLoadStartHandler
 * @private
 */
FORGE.Story.prototype._sceneLoadStartHandler = function()
{
    this.log("scene load start");

    if(this._onSceneLoadStart !== null)
    {
        this._onSceneLoadStart.dispatch(/** @type {StoryEvent} */({ sceneUid: this._sceneUid }));
    }

    if(FORGE.Utils.isTypeOf(this._events.onSceneLoadStart, "ActionEventDispatcher") === true)
    {
        this._events.onSceneLoadStart.dispatch();
    }
};

/**
 * Internal event handler for scene load complete, re-dispatch the load complete event at the story level.
 * @method FORGE.Story#_sceneLoadCompleteHandler
 * @private
 */
FORGE.Story.prototype._sceneLoadCompleteHandler = function()
{
    this.log("scene load complete");

    if(this._onSceneLoadComplete !== null)
    {
        this._onSceneLoadComplete.dispatch(/** @type {StoryEvent} */({ sceneUid: this._sceneUid }));
    }

    if(FORGE.Utils.isTypeOf(this._events.onSceneLoadComplete, "ActionEventDispatcher") === true)
    {
        this._events.onSceneLoadComplete.dispatch();
    }
};

/**
 * Create {@link FORGE.Group}s from groups configuration object.
 * @method FORGE.Story#_createGroups
 * @private
 * @param  {Object} config - The object that describes the groups, issued from the main configuration.
 */
FORGE.Story.prototype._createGroups = function(config)
{
    var group;
    for(var i = 0, ii = config.length; i < ii; i++)
    {
        group = new FORGE.Group(this._viewer, config[i]);
        this._groups.push(group.uid);
    }
};

/**
 * Internal method to set the current {@link FORGE.Group} uid. Dispatch "onGroupChange" if its a valid operation.
 * @method FORGE.Story#_setGroupUid
 * @private
 * @param {string} uid - Uid of the group to set
 */
FORGE.Story.prototype._setGroupUid = function(uid)
{
    if(FORGE.UID.isTypeOf(uid, "Group") === true && uid !== this._groupUid)
    {
        this._groupUid = uid;

        if(this._onGroupChange !== null)
        {
            this._onGroupChange.dispatch(/** @type {StoryEvent} */({ groupUid: this._groupUid }));
        }

        if(FORGE.Utils.isTypeOf(this._events.onGroupChange, "ActionEventDispatcher") === true)
        {
            this._events.onGroupChange.dispatch();
        }
    }
};

/**
 * Boot sequence.
 * @method FORGE.Story#boot
 */
FORGE.Story.prototype.boot = function()
{
    this.log("FORGE.Story.boot();");

    this._scenes = [];
    this._groups = [];

    this._name = new FORGE.LocaleString(this._viewer);
    this._slug = new FORGE.LocaleString(this._viewer);
    this._description = new FORGE.LocaleString(this._viewer);
};

/**
 * Load a JSON story configuration.
 * @method FORGE.Story#load
 * @param  {(string|StoryConfig)} config - The URL of the configuration JSON file to load or a story configuration object.
 */
FORGE.Story.prototype.load = function(config)
{
    this.log("load");

    if(typeof config === "string")
    {
        this._viewer.load.json("forge.story.config", config, this._configLoadComplete, this);
    }
    else if (typeof config === "object")
    {
        this._parseConfig(config);
    }
};

/**
 * Know if the story have any {@link FORGE.Scene}.
 * @method FORGE.Story#hasScenes
 * @return {boolean} Returns true if the story have at least a {@link FORGE.Scene}, false if not.
 */
FORGE.Story.prototype.hasScenes = function()
{
    return this._scenes.length !== 0;
};

/**
 * Know if the story have any {@link FORGE.Group}.
 * @method FORGE.Story#hasGroups
 * @return {boolean} Returns true if the story have at least a {@link FORGE.Group}, false if not.
 */
FORGE.Story.prototype.hasGroups = function()
{
    return this._groups.length !== 0;
};

/**
 * Load the next scene of the story.
 * @method FORGE.Story#nextScene
 */
FORGE.Story.prototype.nextScene = function()
{
    var index = this._scenes.indexOf(this._sceneUid);
    var uid;

    if(index + 1 < this._scenes.length)
    {
        uid = this._scenes[index + 1];
    }
    else
    {
        uid = this._scenes[0];
    }

    this.loadScene(uid);
};

/**
 * Load the previous scene of the story.
 * @method FORGE.Story#previousScene
 */
FORGE.Story.prototype.previousScene = function()
{
    var index = this._scenes.indexOf(this._sceneUid);
    var uid;

    if(index - 1 >= 0)
    {
        uid = this._scenes[index - 1];
    }
    else
    {
        uid = this._scenes[this._scenes.length - 1];
    }

    this.loadScene(uid);
};

/**
 * Load a {@link FORGE.Scene}.
 * @method FORGE.Story#loadScene
 * @param  {(FORGE.Scene|number|string)} value - Either the {@link FORGE.Scene} itself its index in the main _scenes Array or its uid.
 */
FORGE.Story.prototype.loadScene = function(value)
{
    var uid;

    // use the index of the group array
    if (typeof value === "number")
    {
        if(value >= 0 && value < this._scenes.length)
        {
            uid = this._scenes[value];
        }
        else
        {
            this.warn("Load scene error: index "+value+" is out of bounds");
        }
    }
    // use the uid
    else if (typeof value === "string" && FORGE.UID.isTypeOf(value, "Scene"))
    {
        uid = value;
    }
    // use a Group object directly
    else if (typeof value === "object" && FORGE.Utils.isTypeOf(value, "Scene"))
    {
        uid = value.uid;
    }

    //If uid is defined and if it's not the current scene
    if(typeof uid !== "undefined" && uid !== this._sceneUid)
    {
        // Disable picking while the scene is loading
        this._viewer.renderer.pickingManager.stop();

        // Read it when the background is ready again
        this._viewer.renderer.onBackgroundReady.addOnce(this._backgroundReadyHandler, this);

        this._loadUid(uid);
    }
};

/**
 * Internal method to load a {@link FORGE.Group}.
 * @method FORGE.Story#loadGroup
 * @param  {(FORGE.Group|number|string)} value - Either the {@link FORGE.Group} itself its index in the main _groups Array or its uid.
 */
FORGE.Story.prototype.loadGroup = function(value)
{
    var uid;

    // use the index of the group array
    if (typeof value === "number")
    {
        if(value >= 0 && value < this._groups.length)
        {
            uid = this._groups[value];
        }
        else
        {
            this.warn("Load group, index "+value+" is out of bounds");
        }
    }
    // use the uid
    else if (typeof value === "string" && FORGE.UID.isTypeOf(value, "Group"))
    {
        uid = value;
    }
    // use a Group object directly
    else if (typeof value === "object" && FORGE.Utils.isTypeOf(value, "Group"))
    {
        uid = value.uid;
    }

    //If uid is defined and if it's not the current scene
    if(typeof uid !== "undefined" && uid !== this._groupUid)
    {
        this._setGroupUid(uid);
        this._loadUid(uid);
    }
};

/**
 * Event handler for scene loaded from an external json file into config.
 * @method  FORGE.Story#_sceneConfigComplete
 * @param  {FORGE.Scene} scene - The scene that has finish to load its configuration.
 * @private
 */
FORGE.Story.prototype.notifySceneConfigLoadComplete = function(scene)
{
    this._addScene(scene);

    //check if all scenes are loaded
    this._checkStoryScenes();
};

/**
 * Destroy method.
 * @method FORGE.Story#destroy
 */
FORGE.Story.prototype.destroy = function()
{
    this._viewer = null;
    this._config = null;

    this._name.destroy();
    this._name = null;

    this._slug.destroy();
    this._slug = null;

    this._description.destroy();
    this._description = null;

    for(var i = 0, ii = this._scenes.length; i < ii; i++)
    {
        FORGE.UID.get(this._scenes[i]).destroy();
    }
    this._scenes = null;

    for(var j = 0, jj = this._groups.length; j < jj; j++)
    {
        FORGE.UID.get(this._groups[j]).destroy();
    }
    this._groups = null;

    // Events
    if(this._onReady !== null)
    {
        this._onReady.destroy();
        this._onReady = null;
    }

    if(this._onSceneLoadStart !== null)
    {
        this._onSceneLoadStart.destroy();
        this._onSceneLoadStart = null;
    }

    if(this._onSceneLoadProgress !== null)
    {
        this._onSceneLoadProgress.destroy();
        this._onSceneLoadProgress = null;
    }

    if(this._onSceneLoadComplete !== null)
    {
        this._onSceneLoadComplete.destroy();
        this._onSceneLoadComplete = null;
    }

    if(this._onSceneLoadError !==null)
    {
        this._onSceneLoadError.destroy();
        this._onSceneLoadError = null;
    }

    if(this._onScenePreview !== null)
    {
        this._onScenePreview.destroy();
        this._onScenePreview = null;
    }

    if(this._onGroupChange !== null)
    {
        this._onGroupChange.destroy();
        this._onGroupChange = null;
    }

    this._clearEvents();
    this._events = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
* Get the story config object.
* @name FORGE.Story#config
* @readonly
* @type {Object}
*/
Object.defineProperty(FORGE.Story.prototype, "config",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        return this._config;
    }
});

/**
* Get the name of the story.
* @name FORGE.Story#name
* @readonly
* @type {string}
*/
Object.defineProperty(FORGE.Story.prototype, "name",
{
    /** @this {FORGE.Story} */
    get: function ()
    {
        return this._name.value;
    }
});

/**
* Get the slug name of the story.
* @name FORGE.Story#slug
* @readonly
* @type {string}
*/
Object.defineProperty(FORGE.Story.prototype, "slug",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        return this._slug.value;
    }
});

/**
* Get the description of the story.
* @name FORGE.Story#description
* @readonly
* @type {string}
*/
Object.defineProperty(FORGE.Story.prototype, "description",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        return this._description.value;
    }
});


/**
* Get the Array of {@link FORGE.Scene} that compose the story.
* @name FORGE.Story#scenes
* @readonly
* @type {?Array<FORGE.Scene>}
*/
Object.defineProperty(FORGE.Story.prototype, "scenes",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        return FORGE.UID.get(this._scenes);
    }
});

/**
 * Get the current {@link FORGE.Scene} object, or set the current scene passing the {@link FORGE.Scene} object itself, its index or uid.
 * @name FORGE.Story#scene
 * @type  {FORGE.Scene}
 */
Object.defineProperty(FORGE.Story.prototype, "scene",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        if(this._sceneUid === null || this._sceneUid === "")
        {
            return null;
        }

        return FORGE.UID.get(this._sceneUid);
    },

    /** @this {FORGE.Story} */
    set: function(value)
    {
        this.loadScene(value);
    }
});

/**
* Get all the sceneUids.
* @name FORGE.Story#sceneUids
* @readonly
* @type {Array<string>}
*/
Object.defineProperty(FORGE.Story.prototype, "sceneUids",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        return this._scenes;
    }
});

/**
* Get the current sceneUid.
* @name FORGE.Story#sceneUid
* @type {string}
*/
Object.defineProperty(FORGE.Story.prototype, "sceneUid",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        return this._sceneUid;
    },

    /** @this {FORGE.Story} */
    set: function(value)
    {
        this.loadScene(value);
    }
});

/**
* Get the Array of {@link FORGE.Group} that compose the story.
* @name FORGE.Story#groups
* @readonly
* @type {?Array<FORGE.Group>}
*/
Object.defineProperty(FORGE.Story.prototype, "groups",
{
    /** @this {FORGE.Story} */
    get: function ()
    {
        return FORGE.UID.get(this._groups);
    }
});

/**
 * Get the current {@link FORGE.Group} object, or set the current scene passing the {@link FORGE.Group} object itself, its index or uid.
 * @name FORGE.Story#group
 * @type  {(FORGE.Group)}
 */
Object.defineProperty(FORGE.Story.prototype, "group",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        if(this._groupUid === null || this._groupUid === "")
        {
            return null;
        }

        return FORGE.UID.get(this._groupUid);
    },

    /** @this {FORGE.Story} */
    set: function(value)
    {
        this.loadGroup(value);
    }
});

/**
* Get all the group Uids.
* @name FORGE.Story#groupUids
* @readonly
* @type {Array<string>}
*/
Object.defineProperty(FORGE.Story.prototype, "groupUids",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        return this._groups;
    }
});

/**
* Get the current groupUid.
* @name FORGE.Story#groupUid
* @type {string}
*/
Object.defineProperty(FORGE.Story.prototype, "groupUid",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        return this._groupUid;
    },

    /** @this {FORGE.Story} */
    set: function(value)
    {
        this.loadGroup(value);
    }
});

/**
 * Get the onReady {@link FORGE.EventDispatcher}.
 * @name  FORGE.Story#onReady
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Story.prototype, "onReady",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        if(this._onReady === null)
        {
            this._onReady = new FORGE.EventDispatcher(this);
        }

        return this._onReady;
    }
});

/**
 * Get the onSceneLoadRequest {@link FORGE.EventDispatcher}.
 * @name  FORGE.Story#onSceneLoadRequest
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Story.prototype, "onSceneLoadRequest",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        if(this._onSceneLoadRequest === null)
        {
            this._onSceneLoadRequest = new FORGE.EventDispatcher(this);
        }

        return this._onSceneLoadRequest;
    }
});

/**
 * Get the onSceneLoadStart {@link FORGE.EventDispatcher}.
 * @name  FORGE.Story#onSceneLoadStart
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Story.prototype, "onSceneLoadStart",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        if(this._onSceneLoadStart === null)
        {
            this._onSceneLoadStart = new FORGE.EventDispatcher(this);
        }

        return this._onSceneLoadStart;
    }
});

/**
 * Get the onSceneLoadProgress {@link FORGE.EventDispatcher}.
 * @name  FORGE.Story#onSceneLoadProgress
 * @readonly
 * @type {FORGE.EventDispatcher}
 * @todo  This event is currently not dispatched
 */
Object.defineProperty(FORGE.Story.prototype, "onSceneLoadProgress",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        if(this._onSceneLoadProgress === null)
        {
            this._onSceneLoadProgress = new FORGE.EventDispatcher(this);
        }

        return this._onSceneLoadProgress;
    }
});

/**
 * Get the onSceneLoadComplete {@link FORGE.EventDispatcher}.
 * @name  FORGE.Story#onSceneLoadComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Story.prototype, "onSceneLoadComplete",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        if(this._onSceneLoadComplete === null)
        {
            this._onSceneLoadComplete = new FORGE.EventDispatcher(this);
        }

        return this._onSceneLoadComplete;
    }
});

/**
 * Get the onSceneLoadError {@link FORGE.EventDispatcher}.
 * @name  FORGE.Story#onSceneLoadError
 * @readonly
 * @type {FORGE.EventDispatcher}
 * @todo  This event is currently not dispatched
 */
Object.defineProperty(FORGE.Story.prototype, "onSceneLoadError",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        if(this._onSceneLoadError === null)
        {
            this._onSceneLoadError = new FORGE.EventDispatcher(this);
        }

        return this._onSceneLoadError;
    }
});

/**
 * Get the onScenePreview {@link FORGE.EventDispatcher}.
 * @name  FORGE.Story#onScenePreview
 * @readonly
 * @type {FORGE.EventDispatcher}
 * @todo  This event is currently not dispatched
 */
Object.defineProperty(FORGE.Story.prototype, "onScenePreview",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        if(this._onScenePreview === null)
        {
            this._onScenePreview = new FORGE.EventDispatcher(this);
        }

        return this._onScenePreview;
    }
});

/**
 * Get the onGroupChange {@link FORGE.EventDispatcher}.
 * @name  FORGE.Story#onGroupChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Story.prototype, "onGroupChange",
{
    /** @this {FORGE.Story} */
    get: function()
    {
        if(this._onGroupChange === null)
        {
            this._onGroupChange = new FORGE.EventDispatcher(this);
        }

        return this._onGroupChange;
    }
});

/**
 * A FORGE.Group is an object that represents a group of {@link FORGE.Scene} objects.
 *
 * @constructor FORGE.Group
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {GroupConfig} config - The group config object.
 * @extends {FORGE.BaseObject}
 */
FORGE.Group = function(viewer, config)
{
    /**
     * The viewer reference.
     * @name FORGE.Group#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The config object.
     * @name FORGE.Group#_config
     * @type {GroupConfig}
     * @private
     */
    this._config = config;

    /**
     * The internationalizable name of the group.
     * @name FORGE.Group#_name
     * @type {?FORGE.LocaleString}
     * @private
     */
    this._name = null;

    /**
     * The color associated to this group (hexa code like #ffffff).<br>
     * Default value is the white code #ffffff.
     * @name  FORGE.Group#_color
     * @type {string}
     * @private
     */
    this._color = "#ffffff";

    /**
     * The color alpha associated to this group is a number between 0 and 1.<br>
     * Default value is 1.
     * @name  FORGE.Group#_alpha
     * @type {number}
     * @private
     */
    this._alpha = 1;

    /**
     * The internationalizable slug name of the group.
     * @name FORGE.Group#_slug
     * @type {?FORGE.LocaleString}
     * @private
     */
    this._slug = null;

    /**
     * The internationalizable description of the group.
     * @name FORGE.Group#_description
     * @type {?FORGE.LocaleString}
     * @private
     */
    this._description = null;

    /**
     * Array of children that can be {@link FORGE.Scene} or {@link FORGE.Group}.
     * @name FORGE.Group#children
     * @type {Array<string>}
     * @private
     */
    this._children = null;

    /**
     * The default child uid to load.
     * @name  FORGE.group#_default
     * @type {string}
     * @private
     */
    this._default = "";

    /**
     * Parents of this group, these are {@link FORGE.Group}.
     * @name  FORGE.Group#parents
     * @type {Array<FORGE.Group>}
     * @private
     */
    this._parents = null;

    FORGE.BaseObject.call(this, "Group");

    this._boot();
};

FORGE.Group.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Group.prototype.constructor = FORGE.Group;

/**
 * Boot sequence.
 * @method FORGE.Group#_boot
 * @private
 */
FORGE.Group.prototype._boot = function()
{
    this.log("FORGE.Group._boot();");

    this._uid = this._config.uid;
    this._tags = this._config.tags;
    this._register();

    this._parents = [];
    this._children = [];

    this._name = new FORGE.LocaleString(this._viewer, this._config.name);
    this._slug = new FORGE.LocaleString(this._viewer, this._config.slug);
    this._description = new FORGE.LocaleString(this._viewer, this._config.description);

    if (typeof this._config.color === "string")
    {
        this._color = this._config.color;
    }

    if (typeof this._config.alpha === "number")
    {
        this._alpha = this._config.alpha;
    }

    this._parseChildren(this._config);
};

/**
 * Parse scenes in config.
 * @method FORGE.Group#_parseChildren
 * @private
 * @param  {GroupConfig} config - The object that describes the scenes config.
 */
FORGE.Group.prototype._parseChildren = function(config)
{

    if (typeof config.children !== "undefined" && FORGE.Utils.isArrayOf(config.children, "string") === true)
    {
        this._children = config.children;
    }
    else
    {
        this.warn("A group has no children in its configuration, or configuration is not valid!");
    }

    //Parse the default child of the group
    if (typeof config.default === "string")
    {
        if (this._children.indexOf(config.default) !== -1)
        {
            this._default = config.default;
        }
        else
        {
            this.warn("A group has a default child that is not in its children array!");
        }
    }
};

/**
 * Load the group with a specific scene, by default the scene is scene index 0.
 * @method FORGE.Group#load
 * @param {number|string|FORGE.Scene|FORGE.Group=} value - The numeric index of the child or the uid of the child you want to load.<br>
 * If no value passed in arguments, the group will load its default child if it is set.<br>
 * If no default child set, it will load its first child no matter the type of this child
 */
FORGE.Group.prototype.load = function(value)
{
    this.log("FORGE.Group.load();");

    if (this._children === null || this._children.length === 0)
    {
        throw "Group.load() : can't load a group that have no children";
    }

    var uid = "";

    // If no value passed in arguments, the group will load its default child if it is set.
    if (typeof value === "undefined" || value === null)
    {
        if (typeof this._default === "string" && this._default !== "")
        {
            uid = this._default;
        }
        else
        {
            uid = this._children[0];
        }
    }
    else if (typeof value === "number" && value >= 0 && value < this._children.length)
    {
        uid = this._children[value];
    }
    else if (typeof value === "string")
    {
        uid = value;
    }
    else if (typeof value === "object" && this.hasChild(value) === true)
    {
        uid = value.uid;
    }

    if (this._children.indexOf(uid) === -1)
    {
        throw "Group.load() : uid \"" + uid + "\" is not in children of the group!";
    }

    if (FORGE.UID.isTypeOf(uid, "Scene") === true || FORGE.UID.isTypeOf(uid, "Group") === true)
    {
        var child = FORGE.UID.get(uid);
        child.load();
    }
    else
    {
        throw "Impossible to load group child with uid " + uid + ", it seems to be neither a scene or a group!";
    }
};

/**
 * Know if a {@link FORGE.Scene}, a {@link FORGE.Group} or a uid is part of this group?
 * @method FORGE.Group#hasScene
 * @param {(FORGE.Scene|FORGE.Group|string)} value - Either the {@link FORGE.Scene} or a {@link FORGE.Group} or a uid string.
 * @return {boolean} Returns true if the child is part of this group, false if not.
 */
FORGE.Group.prototype.hasChild = function(value)
{
    if (typeof value === "string")
    {
        return this._children.indexOf(value) !== -1;
    }
    else if (FORGE.Utils.isTypeOf(value, "Scene") === true || FORGE.Utils.isTypeOf(value, "Group") === true)
    {
        return this.hasChild(value.uid);
    }

    return false;
};


/**
 * Know if a {@link FORGE.Scene} is part of this group?
 * @method FORGE.Group#hasScene
 * @param {(FORGE.Scene|string)} value - Either the {@link FORGE.Scene} or a uid string.
 * @return {boolean} Returns true if the scene is part of this group, false if not.
 */
FORGE.Group.prototype.hasScene = function(value)
{
    if (typeof value === "string" && FORGE.UID.isTypeOf(value, "Scene"))
    {
        return this._children.indexOf(value) !== -1;
    }
    else if (FORGE.Utils.isTypeOf(value, "Scene") === true)
    {
        return this.hasScene(value.uid);
    }

    return false;
};

/**
 * Know if a {@link FORGE.Group} is part of this group?
 * @method FORGE.Group#hasGroup
 * @param {(FORGE.Group|string)} value - Either the {@link FORGE.Group} or a uid string.
 * @return {boolean} Returns true if the group is part of this group, false if not.
 */
FORGE.Group.prototype.hasGroup = function(value)
{
    if (typeof value === "string" && FORGE.UID.isTypeOf(value, "Group"))
    {
        return this._children.indexOf(value) !== -1;
    }
    else if (FORGE.Utils.isTypeOf(value, "Group") === true)
    {
        return this.hasGroup(value.uid);
    }

    return false;
};

/**
 * Know if this group have any children.
 * @method FORGE.Group#hasChildren
 * @return {boolean} Returns true if this group have at least a children, false if not.
 */
FORGE.Group.prototype.hasChildren = function()
{
    return this._children.length !== 0;
};

/**
 * Know if this group have any object of a specified className.
 * @method FORGE.Group#hasTypeOfChild
 * @param {string} className - the className of the object you want to know if this group has in its children array.
 * @return {boolean} Returns true if this group have at least an object of the requested className in its children, false if not.
 */
FORGE.Group.prototype.hasTypeOfChild = function(className)
{
    var uid;
    for (var i = 0, ii = this._children.length; i < ii; i++)
    {
        uid = this._children[i];
        if (FORGE.UID.isTypeOf(uid, className))
        {
            return true;
        }
    }

    return false;
};

/**
 * Know if this group have any {@link FORGE.Scene}.
 * @method FORGE.Group#hasScenes
 * @return {boolean} Returns true if this group have at least a {@link FORGE.Scene}, false if not.
 */
FORGE.Group.prototype.hasScenes = function()
{
    return this.hasTypeOfChild("Scene");
};

/**
 * Know if this group have any {@link FORGE.Group}.
 * @method FORGE.Group#hasGroups
 * @return {boolean} Returns true if this group have at least a {@link FORGE.Group}, false if not.
 */
FORGE.Group.prototype.hasGroups = function()
{
    return this.hasTypeOfChild("Group");
};

/**
 * Get children uids of a specified className (or not).
 * @method FORGE.Group#getChildrenUids
 * @param {string=} className - the className of the object uids you want to get.
 * @return {Array} Returns array of children uids of the specified className.
 */
FORGE.Group.prototype.getChildrenUids = function(className)
{
    //If no className specified, return the complete array of children uids.
    if (typeof className !== "string")
    {
        return this._children;
    }

    var children = [];

    for (var i = 0, ii = this._children.length; i < ii; i++)
    {
        if (FORGE.UID.isTypeOf(this._children[i], className))
        {
            children.push(this._children[i]);
        }
    }

    return children;
};

/**
 * Get children objects of a specified className.<br>
 * If you do not specify className this method will return all the children objects.
 * @method FORGE.Group#getChildren
 * @param {string=} className - the className of the object you want to get.
 * @return {Array} Returns array of children objects of the specified className.
 */
FORGE.Group.prototype.getChildren = function(className)
{
    var uids = this.getChildrenUids(className);
    return FORGE.UID.get(uids);
};

/**
 * Load the next scene of this group.<br>
 * If this group has no scene, you can't use this method.<br>
 * If the current scene of the story is not one of this group, the group will load either the default child or its first found scene.<br>
 * If the current scene is part of this group, nextScene will loop forward through its scenes.
 * @method FORGE.Group#nextScene
 */
FORGE.Group.prototype.nextScene = function()
{
    if (this.hasScenes() === false)
    {
        this.warn("Can't do Group.nextScene() on this group that have no scenes!");
        return;
    }

    var scenesUids = this.scenesUids;
    var index = scenesUids.indexOf(this._viewer.story.sceneUid);
    var uid; //Default uid to load is the first scene.

    if (index === -1)
    {
        if (FORGE.UID.isTypeOf(this._default, "Scene"))
        {
            uid = this._default;
        }
        else
        {
            uid = scenesUids[0];
        }
    }

    if (index + 1 < scenesUids.length)
    {
        uid = scenesUids[index + 1];
    }
    else if (index !== -1)
    {
        uid = scenesUids[0];
    }

    this.load(uid);
};

/**
 * Load the previous scene of this group.<br>
 * If this group has no scene, you can't use this method.<br>
 * If the current scene of the story is not one of this group, the group will load either the default child or its first found scene.<br>
 * If the current scene is part of this group, previousScene will loop backward through its scenes.
 * @method FORGE.Group#previousScene
 */
FORGE.Group.prototype.previousScene = function()
{
    if (this.hasScenes() === false)
    {
        this.warn("Can't do Group.previousScene() on this group that have no scenes!");
        return;
    }

    var scenesUids = this.scenesUids;
    var index = scenesUids.indexOf(this._viewer.story.sceneUid);
    var uid; //Default uid to load is the first scene.

    if (index === -1)
    {
        if (FORGE.UID.isTypeOf(this._default, "Scene"))
        {
            uid = this._default;
        }
        else
        {
            uid = scenesUids[0];
        }
    }

    if (index - 1 >= 0)
    {
        uid = scenesUids[index - 1];
    }
    else if (index !== -1)
    {
        uid = scenesUids[scenesUids.length - 1];
    }

    this.load(uid);
};

/**
 * Destroy method.
 * @method FORGE.Group#destroy
 */
FORGE.Group.prototype.destroy = function()
{
    this._viewer = null;

    this._children = null;

    this._name.destroy();
    this._name = null;

    this._slug.destroy();
    this._slug = null;

    this._description.destroy();
    this._description = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the group config object.
 * @name FORGE.Group#config
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.Group.prototype, "config",
{
    /** @this {FORGE.Group} */
    get: function()
    {
        return this._config;
    }
});

/**
 * Get the count of how many times this group has been viewed.
 * @name FORGE.Group#viewCount
 * @readonly
 * @type {number}
 */
// Object.defineProperty(FORGE.Group.prototype, "viewCount",
// {
//     /** @this {FORGE.Group} */
//     get: function()
//     {
//         var count = 0;

//         for(var i = 0, ii = this._scenes.length; i < ii; i++)
//         {
//             count += this._scenes[i].viewCount;
//         }
//         return count;
//     }
// });

/**
 * Know if this group has been viewed at least one time.
 * @name FORGE.Group#viewed
 * @readonly
 * @type {boolean}
 */
// Object.defineProperty(FORGE.Group.prototype, "viewed",
// {
//     /** @this {FORGE.Group} */
//     get: function()
//     {
//         return this.viewCount !== 0;
//     }
// });


/**
 * Get the name of this group.
 * @name FORGE.Group#name
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Group.prototype, "name",
{
    /** @this {FORGE.Group} */
    get: function()
    {
        return this._name.value;
    }
});

/**
 * Get the color associated to this group.
 * @name FORGE.Group#color
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Group.prototype, "color",
{
    /** @this {FORGE.Group} */
    get: function()
    {
        return this._color;
    }
});

/**
 * Get the alpha associated to this group.
 * @name FORGE.Group#alpha
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.Group.prototype, "alpha",
{
    /** @this {FORGE.Group} */
    get: function()
    {
        return this._alpha;
    }
});

/**
 * Get the slug name of this group.
 * @name FORGE.Group#slug
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Group.prototype, "slug",
{
    /** @this {FORGE.Group} */
    get: function()
    {
        return this._slug.value;
    }
});

/**
 * Get the description of this group.
 * @name FORGE.Group#description
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Group.prototype, "description",
{
    /** @this {FORGE.Group} */
    get: function()
    {
        return this._description.value;
    }
});

/**
 * Get the Array of children uids that compose this group.
 * @name FORGE.Group#childrenUids
 * @readonly
 * @type {?Array<string>}
 */
Object.defineProperty(FORGE.Group.prototype, "childrenUids",
{
    /** @this {FORGE.Group} */
    get: function()
    {
        return this.getChildrenUids();
    }
});

/**
 * Get the Array of children objects that compose this group.
 * @name FORGE.Group#children
 * @readonly
 * @type {?Array<Object>}
 */
Object.defineProperty(FORGE.Group.prototype, "children",
{
    /** @this {FORGE.Group} */
    get: function()
    {
        return this.getChildren();
    }
});

/**
 * Get the Array of {@link FORGE.Scene} uids that compose this group.
 * @name FORGE.Group#scenesUids
 * @readonly
 * @type {?Array<string>}
 */
Object.defineProperty(FORGE.Group.prototype, "scenesUids",
{
    /** @this {FORGE.Group} */
    get: function()
    {
        return this.getChildrenUids("Scene");
    }
});

/**
 * Get the Array of {@link FORGE.Scene} objects that compose this group.
 * @name FORGE.Group#scenes
 * @readonly
 * @type {?Array<FORGE.Scene>}
 */
Object.defineProperty(FORGE.Group.prototype, "scenes",
{
    /** @this {FORGE.Group} */
    get: function()
    {
        return this.getChildren("Scene");
    }
});

/**
 * Get the Array of {@link FORGE.Group} uids that compose this group.
 * @name FORGE.Group#groupsUids
 * @readonly
 * @type {?Array<string>}
 */
Object.defineProperty(FORGE.Group.prototype, "groupsUids",
{
    /** @this {FORGE.Group} */
    get: function()
    {
        return this.getChildrenUids("Group");
    }
});

/**
 * Get the Array of {@link FORGE.Group} uids that compose this group.
 * @name FORGE.Group#groups
 * @readonly
 * @type {?Array<FORGE.Group>}
 */
Object.defineProperty(FORGE.Group.prototype, "groups",
{
    /** @this {FORGE.Group} */
    get: function()
    {
        return this.getChildren("Group");
    }
});
/**
 * A FORGE.Scene is an object that represents a scene of a {@link FORGE.Story}.
 *
 * @constructor FORGE.Scene
 * @param {FORGE.Viewer} viewer {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.Scene = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.Scene#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The scene config object.
     * @name FORGE.Scene#_sceneConfig
     * @type {?SceneConfig}
     * @private
     */
    this._config = null;

    /**
     * The internationalizable name of the scene.
     * @name FORGE.Scene#_name
     * @type {?FORGE.LocaleString}
     * @private
     */
    this._name = null;

    /**
     * The internationalizable slug name of the scene.
     * @name FORGE.Scene#_slug
     * @type {?FORGE.LocaleString}
     * @private
     */
    this._slug = null;

    /**
     * The internationalizable description of the scene.
     * @name FORGE.Scene#_description
     * @type {?FORGE.LocaleString}
     * @private
     */
    this._description = null;

    /**
     * The array of scene uids to be sync with
     * @name FORGE.Scene#_sync
     * @type {Array<string>}
     * @private
     */
    this._sync = [];

    /**
     * The number of times this has been viewed.
     * @name  FORGE.Scene#_viewCount
     * @type {number}
     * @private
     */
    this._viewCount = 0;

    /**
     * Array of group uids this scene belongs to. aka "parents".
     * @name FORGE.Scene#_groups
     * @type {?Array<string>}
     * @private
     */
    this._groups = null;

    /**
     * Is booted flag.
     * @name FORGE.Scene#_booted
     * @type {boolean}
     * @private
     */
    this._booted = false;

    /**
     * Use external config file flag.
     * @name FORGE.Scene#_useExternalConfig
     * @type {boolean}
     * @private
     */
    this._useExternalConfig = false;

    /**
     * Scene events from the json configuration
     * @name FORGE.Story#_events
     * @type {Object<FORGE.ActionEventDispatcher>}
     * @private
     */
    this._events = {};

    /**
     * The media of the scene
     * @name FORGE.Scene#_media
     * @type {FORGE.Media}
     * @private
     */
    this._media = null;

    /**
     * Load request event dispatcher.
     * @name  FORGE.Scene#_onLoadRequest
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLoadRequest = null;

    /**
     * Load start event dispatcher.
     * @name  FORGE.Scene#_onLoadStart
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLoadStart = null;

    /**
     * Load complete event dispatcher.
     * @name  FORGE.Scene#_onLoadComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;

    /**
     * Unload start event dispatcher.
     * @name  FORGE.Scene#_onUnloadStart
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onUnloadStart = null;

    /**
     * Unload complete event dispatcher.
     * @name  FORGE.Scene#_onUnloadComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onUnloadComplete = null;

    /**
     * Load complete event dispatcher for scene configuration file.
     * @name  FORGE.Scene#_onConfigLoadComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onConfigLoadComplete = null;

    /**
     * media create event dispatcher.
     * @name  FORGE.Scene#_onMediaCreate
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onMediaCreate = null;

    FORGE.BaseObject.call(this, "Scene");
};

FORGE.Scene.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Scene.prototype.constructor = FORGE.Scene;

/**
 * Parse scene configuration.
 * @method FORGE.Scene#_parseConfig
 * @private
 * @param {SceneConfig} config - The configuration object to parse.
 */
FORGE.Scene.prototype._parseConfig = function(config)
{
    this._config = config;

    this._uid = config.uid;
    this._tags = config.tags;
    this._register();

    this._name = new FORGE.LocaleString(this._viewer, this._config.name);
    this._slug = new FORGE.LocaleString(this._viewer, this._config.slug);
    this._description = new FORGE.LocaleString(this._viewer, this._config.description);
    this._sync = (FORGE.Utils.isArrayOf(this._config.sync, "string") === true) ? this._config.sync : [];

    if(typeof config.events === "object" && config.events !== null)
    {
        this._createEvents(config.events);
    }

    if (this._booted === false && typeof config.url === "string" && config.url !== "")
    {
        //use an external config json file
        this._useExternalConfig = true;
        this._viewer.load.json(this._uid, config.url, this._configLoadComplete, this);
    }
    else
    {
        this._booted = true;
    }
};

/**
 * Event handler for the load of the scene config json file.
 * @method FORGE.Scene#_configLoadComplete
 * @param {FORGE.File} file - The file data.
 * @private
 *
 * @todo the "story.config" cache file is not updated in this case, a cache entry is added for each scene UID.
 */
FORGE.Scene.prototype._configLoadComplete = function(file)
{
    this.log("config load complete");

    this._booted = true;

    //extend the config
    if (typeof file.data === "string")
    {
        file.data = /** @type {Object} */ (JSON.parse(file.data));
    }

    // extend init config
    this._config = /** @type {SceneConfig} */ (FORGE.Utils.extendSimpleObject(this._config, file.data));

    this._viewer.story.notifySceneConfigLoadComplete(this);

    if (this._onConfigLoadComplete !== null)
    {
        this._onConfigLoadComplete.dispatch();
    }
};

/**
 * Create events dispatchers.
 * @method FORGE.Scene#_createEvents
 * @private
 * @param {SceneEventsConfig} events - The events config of the scene.
 */
FORGE.Scene.prototype._createEvents = function(events)
{
    this.log("create events");

    var event;
    for(var e in events)
    {
        event = new FORGE.ActionEventDispatcher(this._viewer, e);
        event.addActions(events[e]);
        this._events[e] = event;
    }
};

/**
 * Clear all events.
 * @method FORGE.Scene#_clearEvents
 * @private
 */
FORGE.Scene.prototype._clearEvents = function()
{
    this.log("clear events");

    for(var e in this._events)
    {
        this._events[e].destroy();
        this._events[e] = null;
    }
};

/**
 * Create the scene media
 * @param  {SceneMediaConfig} media - media configuration
 * @private
 */
FORGE.Scene.prototype._createMedia = function(media)
{
    this.log("create media");

    if(this._media === null)
    {
        this._media = new FORGE.Media(this._viewer, media);

        if(this._onMediaCreate !== null)
        {
            this._onMediaCreate.dispatch({ media: this._media });
        }
    }
};

/**
 * Add a scene configuration object.
 * @method  FORGE.Scene#addConfig
 * @param {SceneConfig} config - The scene configuration object to add.
 */
FORGE.Scene.prototype.addConfig = function(config)
{
    this._parseConfig(config);
};

/**
 * Load just emmit a load request. The story will trigger the loadStart.
 * @method FORGE.Scene#load
 */
FORGE.Scene.prototype.load = function()
{
    this.log("load");

    if (this._viewer.story.scene === this)
    {
        return;
    }

    if (this._onLoadRequest !== null)
    {
        this._onLoadRequest.dispatch();
    }

    if(FORGE.Utils.isTypeOf(this._events.onLoadRequest, "ActionEventDispatcher") === true)
    {
        this._events.onLoadRequest.dispatch();
    }
};

/**
 * Create the media and start to load.
 * @method FORGE.Scene#loadStart
 * @param {number} time - The time of the media (if video)
 */
FORGE.Scene.prototype.loadStart = function(time)
{
    if(typeof time === "number" && isNaN(time) === false && typeof this._config.media !== "undefined")
    {
        if(typeof this._config.media.options === "undefined")
        {
            this._config.media.options = {};
        }

        this._config.media.options.startTime = time;
    }

    this._createMedia(this._config.media);

    if (this._onLoadStart !== null)
    {
        this._onLoadStart.dispatch();
    }

    if(FORGE.Utils.isTypeOf(this._events.onLoadStart, "ActionEventDispatcher") === true)
    {
        this._events.onLoadStart.dispatch();
    }

    this._viewCount++;

    if (this._onLoadComplete !== null)
    {
        this._onLoadComplete.dispatch();
    }

    if(FORGE.Utils.isTypeOf(this._events.onLoadComplete, "ActionEventDispatcher") === true)
    {
        this._events.onLoadComplete.dispatch();
    }
};

/**
 * Unload the scene.
 * @method FORGE.Scene#unload
 * @todo cleanup if useless
 */
FORGE.Scene.prototype.unload = function()
{
    this.log("unload");

    if (this._onUnloadStart !== null)
    {
        this._onUnloadStart.dispatch();
    }

    if(FORGE.Utils.isTypeOf(this._events.onUnloadStart, "ActionEventDispatcher") === true)
    {
        this._events.onUnloadStart.dispatch();
    }

    this._media.destroy();
    this._media = null;

    if (this._onUnloadComplete !== null)
    {
        this._onUnloadComplete.dispatch();
    }

    if(FORGE.Utils.isTypeOf(this._events.onUnloadComplete, "ActionEventDispatcher") === true)
    {
        this._events.onUnloadComplete.dispatch();
    }
};

/**
 * Know if a {@link FORGE.Group} is related to this scene?
 * @method FORGE.Scene#hasGroup
 * @param {(FORGE.Group|string)} value - Either the {@link FORGE.Group} itself or its index or its uid.
 * @return {boolean} Returns true if the {@link FORGE.Group} is related to this scene, false if not.
 */
FORGE.Scene.prototype.hasGroup = function(value)
{
    if (typeof value === "string" && FORGE.UID.isTypeOf(value, "Group") === true)
    {
        return FORGE.UID.get( /** @type {string} */ (value)).hasScene(this);
    }
    else if (FORGE.Utils.isTypeOf(value, "Group") === true)
    {
        return value.hasScene(this);
    }

    return false;
};

/**
 * Know if this scene is related to any {@link FORGE.Group}.
 * @method FORGE.Scene#hasGroups
 * @return {boolean} Returns true if this scene is related to at least a {@link FORGE.Group}, false if not.
 */
FORGE.Scene.prototype.hasGroups = function()
{
    var groups = this._viewer.story.groups;
    var group;
    for (var i = 0, ii = groups.length; i < ii; i++)
    {
        group = groups[i];
        if (group.hasScene(this) === true)
        {
            return true;
        }
    }

    return false;
};

/**
 * Know if the scene has sound source?
 * @method FORGE.Scene#hasSoundSource
 * @return {boolean} Returns true if the scene has a sound source, false if not.
 */
FORGE.Scene.prototype.hasSoundSource = function()
{
    if (typeof this._config.sound !== "undefined" && typeof this._config.sound.source !== "undefined" && ((typeof this._config.sound.source.url !== "undefined" && this._config.sound.source.url !== "") || (typeof this._config.sound.source.target !== "undefined" && this._config.sound.source.target !== "")))
    {
        return true;
    }
    return false;
};

/**
 * Know if the scene has sound target as source?
 * @method FORGE.Scene#hasSoundTarget
 * @param {string} uid - The target source UID to verify.
 * @return {boolean} Returns true if the scene has a sound source target, false if not.
 */
FORGE.Scene.prototype.hasSoundTarget = function(uid)
{
    if (typeof this._config.sound !== "undefined" && typeof this._config.sound.source !== "undefined" && typeof this._config.sound.source.target !== "undefined" && this._config.sound.source.target !== "" && this._config.sound.source.target === uid)
    {
        return true;
    }

    return false;
};

/**
 * Know if an ambisonic sound is attached to the scene?
 * @method FORGE.Scene#isAmbisonic
 * @return {boolean} Returns true if the scene has an ambisonic sound source, false if not.
 */
FORGE.Scene.prototype.isAmbisonic = function()
{
    //@todo real check of the UID target object rather then the isAmbisonic method of the FORGE.Scene
    if (this.hasSoundSource() === true && this._config.sound.type === FORGE.SoundType.AMBISONIC)
    {
        return true;
    }

    return false;
};

/**
 * Destroy method
 * @method FORGE.Scene#destroy
 */
FORGE.Scene.prototype.destroy = function()
{
    this._viewer = null;

    this._name.destroy();
    this._name = null;

    this._slug.destroy();
    this._slug = null;

    this._description.destroy();
    this._description = null;

    if (this._media !== null)
    {
        this._media.destroy();
        this._media = null;
    }

    if (this._onLoadStart !== null)
    {
        this._onLoadStart.destroy();
        this._onLoadStart = null;
    }

    if (this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    if (this._onUnloadStart !== null)
    {
        this._onUnloadStart.destroy();
        this._onUnloadStart = null;
    }

    if (this._onUnloadComplete !== null)
    {
        this._onUnloadComplete.destroy();
        this._onUnloadComplete = null;
    }

    this._clearEvents();
    this._events = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
* Get the booted status of the scene.
* @name FORGE.Scene#booted
* @type {boolean}
* @readonly
*/
Object.defineProperty(FORGE.Scene.prototype, "booted",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        return this._booted;
    }
});

/**
* Get the group config object.
* @name FORGE.Scene#config
* @readonly
* @type {SceneConfig}
*/
Object.defineProperty(FORGE.Scene.prototype, "config",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        return this._config;
    }
});

/**
 * Get the count of how many times this group has been viewed.
 * @name FORGE.Scene#viewCount
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.Scene.prototype, "viewCount",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        return this._viewCount;
    }
});

/**
 * Know if this scene has been viewed at least one time.
 * @name FORGE.Scene#viewed
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Scene.prototype, "viewed",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        return this._viewCount !== 0;
    }
});

/**
 * Get the name of this scene.
 * @name FORGE.Scene#name
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Scene.prototype, "name",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        return this._name.value;
    }
});

/**
 * Get the slug name of this scene.
 * @name FORGE.Scene#slug
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Scene.prototype, "slug",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        return this._slug.value;
    }
});

/**
 * Get the description of this scene.
 * @name FORGE.Scene#description
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Scene.prototype, "description",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        return this._description.value;
    }
});

/**
 * Get the sync array.
 * @name FORGE.Scene#sync
 * @readonly
 * @type {Array<string>}
 */
Object.defineProperty(FORGE.Scene.prototype, "sync",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        return this._sync;
    }
});

/**
 * Get the Array of groups uids to which this scene belongs to.
 * @name FORGE.Scene#groupsUid
 * @readonly
 * @type {?Array<FORGE.Group>}
 */
Object.defineProperty(FORGE.Scene.prototype, "groupsUid",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        var groups = this._viewer.story.groups;
        var group;
        var result = [];

        for (var i = 0, ii = groups.length; i < ii; i++)
        {
            group = groups[i];

            if (group.hasScene(this) === true)
            {
                result.push(group.uid);
            }
        }

        return result;
    }
});

/**
 * Get the Array of {@link FORGE.Group} to which this scene belongs to.
 * @name FORGE.Scene#groups
 * @readonly
 * @type {?Array<FORGE.Group>}
 */
Object.defineProperty(FORGE.Scene.prototype, "groups",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        return FORGE.UID.get(this.groupsUid);
    }
});

/**
 * Get the thumbnails Array.
 * @name  FORGE.Scene#thumbnails
 * @readonly
 * @type {Array}
 *
 * @todo  Define what is a thumbnail array, maybe with a thumbnail object descriptor
 */
Object.defineProperty(FORGE.Scene.prototype, "thumbnails",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        return this._config.thumbnails;
    }
});

/**
 * Get the scene media.
 * @name  FORGE.Scene#media
 * @readonly
 * @type {FORGE.Media}
 */
Object.defineProperty(FORGE.Scene.prototype, "media",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        return this._media;
    }
});

/**
 * Get the background of the scene.
 * @name  FORGE.Scene#background
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Scene.prototype, "background",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        return (typeof this._config.background !== "undefined") ? this._config.background : this._viewer.config.background;
    }
});

/**
 * Get the onLoadRequest {@link FORGE.EventDispatcher}.
 * @name  FORGE.Scene#onLoadRequest
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Scene.prototype, "onLoadRequest",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        if (this._onLoadRequest === null)
        {
            this._onLoadRequest = new FORGE.EventDispatcher(this);
        }

        return this._onLoadRequest;
    }
});

/**
 * Get the onLoadStart {@link FORGE.EventDispatcher}.
 * @name  FORGE.Scene#onLoadStart
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Scene.prototype, "onLoadStart",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        if (this._onLoadStart === null)
        {
            this._onLoadStart = new FORGE.EventDispatcher(this);
        }

        return this._onLoadStart;
    }
});

/**
 * Get the onLoadComplete {@link FORGE.EventDispatcher}.
 * @name  FORGE.Scene#onLoadComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Scene.prototype, "onLoadComplete",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        if (this._onLoadComplete === null)
        {
            this._onLoadComplete = new FORGE.EventDispatcher(this);
        }

        return this._onLoadComplete;
    }
});

/**
 * Get the onUnloadStart {@link FORGE.EventDispatcher}.
 * @name  FORGE.Scene#onUnloadStart
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Scene.prototype, "onUnloadStart",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        if (this._onUnloadStart === null)
        {
            this._onUnloadStart = new FORGE.EventDispatcher(this);
        }

        return this._onUnloadStart;
    }
});

/**
 * Get the onUnloadComplete {@link FORGE.EventDispatcher}.
 * @name  FORGE.Scene#onUnloadComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Scene.prototype, "onUnloadComplete",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        if (this._onUnloadComplete === null)
        {
            this._onUnloadComplete = new FORGE.EventDispatcher(this);
        }

        return this._onUnloadComplete;
    }
});

/**
 * Get the onConfigLoadComplete {@link FORGE.EventDispatcher}.
 * @name  FORGE.Scene#onConfigLoadComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Scene.prototype, "onConfigLoadComplete",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        if (this._onConfigLoadComplete === null)
        {
            this._onConfigLoadComplete = new FORGE.EventDispatcher(this);
        }

        return this._onConfigLoadComplete;
    }
});

/**
 * Get the onMediaCreate {@link FORGE.EventDispatcher}.
 * @name  FORGE.Scene#onMediaCreate
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Scene.prototype, "onMediaCreate",
{
    /** @this {FORGE.Scene} */
    get: function()
    {
        if (this._onMediaCreate === null)
        {
            this._onMediaCreate = new FORGE.EventDispatcher(this);
        }

        return this._onMediaCreate;
    }
});

/**
 * Math helper
 * @namespace FORGE.Math
 * @type {Object}
 */
FORGE.Math = {};

/**
 * @name FORGE.Math.DEGREES
 * @type {string}
 * @const
 */
FORGE.Math.DEGREES = "degrees";

/**
 * @name FORGE.Math.RADIANS
 * @type {string}
 * @const
 */
FORGE.Math.RADIANS = "radians";

/**
 * FORGE.Math.DEG2RAD
 * @type {number}
 * @const
 */
FORGE.Math.DEG2RAD = Math.PI / 180.0;

/**
 * FORGE.Math.RAD2DEG
 * @type {number}
 * @const
 */
FORGE.Math.RAD2DEG = 180.0 / Math.PI;

/**
 * FORGE.Math.TWOPI
 * @type {number}
 * @const
 */
FORGE.Math.TWOPI = Math.PI * 2;


/**
 * Converts angle unit degrees to radians
 *
 * @method FORGE.Math.degToRad
 * @param  {number} deg - angle in degrees
 * @return {number} Return the angle in radians
 */
FORGE.Math.degToRad = function(deg)
{
    return deg * FORGE.Math.DEG2RAD;
};

/**
 * Converts angle unit radians to degrees
 *
 * @method FORGE.Math.radToDeg
 * @param  {number} rad - angle in radians
 * @return {number} Return the angle in degrees
 */
FORGE.Math.radToDeg = function(rad)
{
    return rad * FORGE.Math.RAD2DEG;
};

/**
 * Returns the value of a number rounded to the nearest decimal value
 *
 * @method FORGE.Math.round10
 * @param  {number} value - Value to round
 * @return {number} Return the rounded value
 */
FORGE.Math.round10 = function(value)
{
    return Math.round(value * 10) / 10;
};

/**
 * Clamp a value between a min and a max value
 *
 * @method FORGE.Math.clamp
 * @param  {number} value - Value to clamp
 * @param  {?number=} min - The min value
 * @param  {?number=} max - The max value
 * @return {number} Return the clamped value
 */
FORGE.Math.clamp = function(value, min, max)
{
    min = (typeof min === "number" && isNaN(min) === false) ? min : -Infinity;
    max = (typeof max === "number" && isNaN(max) === false) ? max : Infinity;

    return Math.min(Math.max(value, min), max);
};

/**
 * Wrap a value between a min and a max value
 *
 * @method FORGE.Math.wrap
 * @param  {number} value - Value to wrap
 * @param  {number} min - The min value
 * @param  {number} max - The max value
 * @return {number} Return the wrapped value
 */
FORGE.Math.wrap = function(value, min, max)
{
    if (value === max)
    {
        return max;
    }

    var range = max - min;

    if (range === 0)
    {
        return min;
    }

    return ((value - min) % range + range) % range + min;
};

/**
 * Linear mix function
 *
 * @method FORGE.Math.mix
 * @param  {number} a - first value
 * @param  {number} b - second value
 * @param  {number} mix - factor
 * @return {number} linear mix of a and b
 */
FORGE.Math.mix = function(a, b, mix)
{
    return a * mix + b * (1 - mix);
};

/**
 * Smoothstep function
 *
 * @method FORGE.Math.smoothStep
 * @param  {number} value - Value to smooth
 * @param  {number} edge0 - low edge
 * @param  {number} edge1 - high edge
 * @return {number} smooth step result
 */
FORGE.Math.smoothStep = function(value, edge0, edge1)
{
    value = FORGE.Math.clamp((value - edge0) / (edge1 - edge0), 0.0, 1.0);
    return value * value * (3 - 2 * value);
};

/**
 * Check if a value is a power of two
 * @method FORGE.Math.isPowerOfTwo
 * @param  {number} value - value to check
 */
FORGE.Math.isPowerOfTwo = function(value)
{
    return ((value != 0) && !(value & (value - 1)));
};

/**
 * Get euler angles from rotation matrix
 *
 * @method FORGE.Math.rotationMatrixToEuler
 * @param  {THREE.Matrix4} mat - rotation matrix
 * @return {TEuler} object with keys {yaw, pitch, roll} and euler angles as values [radians]
 */
FORGE.Math.rotationMatrixToEuler = function(mat)
{
    return {
        yaw: Math.atan2(-mat.elements[2 + 0 * 4], mat.elements[2 + 2 * 4]),
        pitch: Math.asin(-mat.elements[2 + 1 * 4]),
        roll: Math.atan2(-mat.elements[0 + 1 * 4], mat.elements[1 + 1 * 4])
    };
};

/**
 * Get rotation matrix from euler angles
 *
 * @method FORGE.Math.eulerToRotationMatrix
 * @param  {number} yaw - yaw angle [rad]
 * @param  {number} pitch - pitch angle [rad]
 * @param  {number} roll - roll angle [rad]
 * @param  {boolean=} orderYPR
 * @return {THREE.Matrix4} rotation matrix
 */
FORGE.Math.eulerToRotationMatrix = function(yaw, pitch, roll, orderYPR)
{
    var cy = Math.cos(yaw);
    var sy = Math.sin(yaw);
    var cp = Math.cos(-pitch);
    var sp = Math.sin(-pitch);
    var cr = Math.cos(roll);
    var sr = Math.sin(roll);

    if (typeof orderYPR === "undefined")
    {
        orderYPR = false;
    }

    //jscs:disable
    if (orderYPR)
    {
        // M(yaw) * M(pitch) * M(roll)
        return new THREE.Matrix4().set(
             cy * cr + sy * sp * sr, -cy * sr + sy * sp * cr, sy * cp, 0,
                            cp * sr,                 cp * cr,     -sp, 0,
            -sy * cr + cy * sp * sr,  sy * sr + cy * sp * cr, cy * cp, 0,
                                  0,                       0,       0, 1
        );
    }

    // M(roll) * M(pitch) *  M(yaw)
    return new THREE.Matrix4().set(
        cr * cy - sr * sp * sy, -sr * cp, cr * sy + sr * sp * cy, 0,
        sr * cy + cr * sp * sy,  cr * cp, sr * sy - cr * sp * cy, 0,
                      -sy * cp,       sp,                cp * cy, 0,
                             0,        0,                      0, 1
     );
    //jscs:enable
};

/**
 * Converts spherical coordinates to cartesian, respecting the FORGE
 * coordinates system.
 *
 * @method FORGE.Math.sphericalToCartesian
 * @param {number} radius - radius
 * @param {number} theta - theta angle
 * @param {number} phi - phi angle
 * @param {string} [unit=radian] - The unit used for theta and phi arguments
 * @return {CartesianCoordinates} the resulting cartesian coordinates
 */
FORGE.Math.sphericalToCartesian = function(radius, theta, phi, unit)
{
    var res = {};

    if (unit === FORGE.Math.DEGREES)
    {
        theta = FORGE.Math.degToRad(theta);
        phi = FORGE.Math.degToRad(phi);
    }

    // wrap phi in [-π/2; π/2]
    phi = FORGE.Math.wrap(phi, -Math.PI / 2, Math.PI / 2);
    // invert theta if radius is negative
    theta += radius < 0 ? Math.PI : 0;
    // wrap theta in [0; 2π)
    theta = FORGE.Math.wrap(theta, 0, 2 * Math.PI);
    // abs so the radius is positive
    radius = Math.abs(radius);

    res.x = radius * Math.cos(phi) * Math.sin(theta);
    res.y = radius * Math.sin(phi);
    res.z = -radius * Math.cos(phi) * Math.cos(theta);

    return res;
};

/**
 * Converts cartesian coordinates to spherical, respecting the FORGE
 * coordinates system.
 *
 * @method FORGE.Math.cartesianToSpherical
 * @param {number} x - x
 * @param {number} y - y
 * @param {number} z - z
 * @param {string} [unit=radian] - The unit used to return spherical
 * @return {SphericalCoordinates}
 */
FORGE.Math.cartesianToSpherical = function(x, y, z, unit)
{
    var res = {};

    res.radius = Math.sqrt(x*x + y*y + z*z);

    if (res.radius === 0)
    {
        return { radius: 0, theta: 0, phi: 0 };
    }

    res.phi = Math.asin(y / res.radius);
    res.theta = Math.atan2(x, -z || 0); // we want to avoid -z = -0

    if(unit === FORGE.Math.DEGREES)
    {
        res.phi = FORGE.Math.radToDeg(res.phi);
        res.theta = FORGE.Math.radToDeg(res.theta);
    }

    return res;
};

/**
 * Quaternion helper.
 * @namespace {Object} FORGE.Quaternion
 */
FORGE.Quaternion = {};

/**
 * Get euler angles from a quaternion.
 *
 * @method FORGE.Quaternion.toEuler
 * @param {THREE.Quaternion} quat - rotation quaternion
 * @return {TEuler} euler angle object
 */
FORGE.Quaternion.toEuler = function(quat)
{
    var euler = new THREE.Euler().setFromQuaternion (quat, "XYZ");

    var result =
    {
        yaw: euler.x,
        pitch: -euler.y,
        roll: euler.z
    };

    return result;
};

/**
 * Get a quaternion from euler angles.
 *
 * @method FORGE.Quaternion.fromEuler
 * @param {TEuler|number} yaw - yaw euler angle (y axis) [radians]
 * @param {number=} pitch - pitch euler angle (x axis) [radians]
 * @param {number=} roll - roll euler angle (z axis) [radians]
 * @return {THREE.Quaternion} resulting rotation quaternion
 */
FORGE.Quaternion.fromEuler = function(yaw, pitch, roll)
{
    if(typeof yaw === "object")
    {
        pitch = yaw.pitch;
        roll = yaw.roll;
        yaw = yaw.yaw;
    }

    return new THREE.Quaternion().setFromEuler(new THREE.Euler(yaw, -pitch, roll, "ZXY"));
};

/**
 * Get a rotation matrix from a quaternion.
 *
 * @method FORGE.Quaternion.toRotationMatrix
 * @param {THREE.Quaternion} quat - quaternion
 * @return {THREE.Matrix4} rotation matrix
 */
FORGE.Quaternion.toRotationMatrix = function(quat)
{
    var euler = FORGE.Quaternion.toEuler(quat);
    return FORGE.Math.eulerToRotationMatrix(euler.yaw, euler.pitch, euler.roll);
};

/**
 * Get a quaternion from a rotation matrix.
 *
 * @method FORGE.Quaternion.fromRotationMatrix
 * @param {THREE.Matrix4} mat - rotation matrix
 * @return {THREE.Quaternion} quat quaternion
 */
FORGE.Quaternion.fromRotationMatrix = function(mat)
{
    var euler = FORGE.Math.rotationMatrixToEuler(mat);
    return FORGE.Quaternion.fromEuler(euler);
};

/**
 * Cancel roll and return new quaternion.
 *
 * @method FORGE.Quaternion.cancelRoll
 * @param  {THREE.Quaternion} quat - input quaternion
 * @return {THREE.Quaternion} quaternion without roll
 */
FORGE.Quaternion.cancelRoll = function(quat)
{
    var euler = FORGE.Quaternion.toEuler(quat);
    return FORGE.Quaternion.fromEuler(euler.yaw, euler.pitch, 0);
};

/**
 * Get difference quaternion between two rotation quaternions.
 *
 * @method FORGE.Quaternion.diffBetweenQuaternions
 * @param {THREE.Quaternion} q0 - start quaternion
 * @param {THREE.Quaternion} q1 - end quaternion
 * @return {THREE.Quaternion}
 */
FORGE.Quaternion.diffBetweenQuaternions = function(q0, q1)
{
    return new THREE.Quaternion().copy(q0).inverse().multiply(q1);
};

/**
 * Get rotation angle between two quaternions.
 *
 * @method FORGE.Quaternion.angularDistance
 * @param {THREE.Quaternion} q0 - interval start quaternion
 * @param {THREE.Quaternion} q1 - interval end quaternion
 * @return {number} angle in radians
 */
FORGE.Quaternion.angularDistance = function(q0, q1)
{
    var d = Math.abs(q0.dot(q1));

    if (d >= 1.0)
    {
        return 0;
    }

    return 2 * Math.acos(d);
};

/**
 * Multiply a quaternion with a scalar.
 *
 * @method FORGE.Quaternion.multiplyScalar
 * @param {number} scalar scalar - multiplyScalar
 * @param {THREE.Quaternion} quat - quaternion
 * @return {THREE.Quaternion} result quaternion
 */
FORGE.Quaternion.multiplyScalar = function (scalar, quat)
{
    return new THREE.Quaternion(scalar * quat.x, scalar * quat.y, scalar * quat.z, scalar * quat.w);
};

/**
 * Add quaternions.
 *
 * @method FORGE.Quaternion.add
 * @param {THREE.Quaternion} q0 - first quaternion
 * @param {THREE.Quaternion} q1 - second quaternion
 * @return {THREE.Quaternion} result quaternion
 */
FORGE.Quaternion.add = function (q0, q1)
{
    return new THREE.Quaternion(q0.x + q1.x, q0.y + q1.y, q0.z + q1.z, q0.w + q1.w);
};

/**
 * Quaternion log function.
 *
 * @method FORGE.Quaternion.log
 * @param {THREE.Quaternion} quat - quaternion
 * @return {THREE.Quaternion} result quaternion
 */
FORGE.Quaternion.log = function(quat)
{
    var qres = new THREE.Quaternion(0, 0, 0, 0);

    if (Math.abs(quat.w) < 1)
    {
        var angle = Math.acos(quat.w);
        var sin = Math.sin(angle);

        if (sin > 0)
        {
            qres.x = angle * quat.x / sin;
            qres.y = angle * quat.y / sin;
            qres.z = angle * quat.z / sin;
        }

        return qres;
    }

    qres.x = quat.x;
    qres.y = quat.y;
    qres.z = quat.z;

    return qres;
};

/**
 * Quaternion exp function.
 *
 * @method FORGE.Quaternion.exp
 * @param {THREE.Quaternion} quat - quaternion
 * @return {THREE.Quaternion} result quaternion
 */
FORGE.Quaternion.exp = function (quat)
{
    var angle = Math.sqrt(quat.x * quat.x + quat.y * quat.y + quat.z * quat.z);
    var sin = Math.sin(angle);

    var qres = new THREE.Quaternion().copy(quat);
    qres.w = Math.cos(angle);

    if (Math.abs(sin) > Number.EPSILON)
    {
        qres.x = sin * quat.x / angle;
        qres.y = sin * quat.y / angle;
        qres.z = sin * quat.z / angle;
    }

    return qres;
};

/**
 * Quaternion slerp computation.
 *
 * @method FORGE.Quaternion.slerp
 * @param {THREE.Quaternion} q0 - interval start quaternion
 * @param {THREE.Quaternion} q1 - interval end quaternion
 * @param {number} t - interpolation time
 * @return {THREE.Quaternion} result quaternion
 */
FORGE.Quaternion.slerp = function(q0, q1, t)
{
    var qres = new THREE.Quaternion();
    THREE.Quaternion.slerp(q0, q1, qres, t);
    return qres;
};

/**
 * Compute squad interpolation.
 *
 * @method FORGE.Quaternion.squad
 * @param {THREE.Quaternion} q0 - interval start quaternion
 * @param {THREE.Quaternion} a0 - left quandrangle
 * @param {THREE.Quaternion} a1 - right quandrangle
 * @param {THREE.Quaternion} q1 - interval end quaternion
 * @param {THREE.Quaternion} qres - result quaternion
 * @param {number} t - interpolation time
 * @return {THREE.Quaternion} result quaternion
 */
FORGE.Quaternion.squad = function(q0, a0, a1, q1, qres, t)
{
    var slerp1 = FORGE.Quaternion.slerp(q0, q1, t);
    var slerp2 = FORGE.Quaternion.slerp(a0, a1, t);
    return FORGE.Quaternion.slerp(slerp1, slerp2, 2*t*(1-t));
};

/**
 * Compute NLERP interpolation without inversion
 *
 * @method FORGE.Quaternion.nlerpNoInvert
 * @param {THREE.Quaternion} q0 interval start quaternion
 * @param {THREE.Quaternion} q1 interval end quaternion
 * @param {number} t interpolation time
 * @return {THREE.Quaternion} result quaternion
 */
FORGE.Quaternion.nlerpNoInvert = function(q0, q1, t)
{
    return FORGE.Quaternion.add(
        FORGE.Quaternion.multiplyScalar(1 - t, q0),
        FORGE.Quaternion.multiplyScalar(t, q1)
    ).normalize();
};

/**
 * Compute SLERP interpolation without inversion
 *
 * @method FORGE.Quaternion.slerpNoInvert
 * @param {THREE.Quaternion} q0 interval start quaternion
 * @param {THREE.Quaternion} q1 interval end quaternion
 * @param {number} t interpolation time
 * @return {THREE.Quaternion} result quaternion
 */
FORGE.Quaternion.slerpNoInvert = function(q0, q1, t)
{
    var dot = q0.dot(q1);

    if (Math.abs(dot) >= 0.95)
    {
        return FORGE.Quaternion.nlerpNoInvert(q0, q1, t);
    }

    var angle = Math.acos(dot);
    return FORGE.Quaternion.multiplyScalar(1.0 / Math.sin(angle),
        FORGE.Quaternion.add(
            FORGE.Quaternion.multiplyScalar(Math.sin(angle * (1-t)), q0),
            FORGE.Quaternion.multiplyScalar(Math.sin(angle * t), q1)
        )
    );
};

/**
 * Compute SQUAD interpolation without inversion
 *
 * @method FORGE.Quaternion.squadNoInvert
 * @param {THREE.Quaternion} q0 interval start quaternion
 * @param {THREE.Quaternion} a0 left quandrangle
 * @param {THREE.Quaternion} a1 right quandrangle
 * @param {THREE.Quaternion} q1 interval end quaternion
 * @param {number} t interpolation time
 * @return {THREE.Quaternion} result quaternion
 */
FORGE.Quaternion.squadNoInvert = function(q0, a0, a1, q1, t)
{
    var qq = FORGE.Quaternion.slerpNoInvert(q0, q1, t);
    var qa = FORGE.Quaternion.slerpNoInvert(a0, a1, t);
    return FORGE.Quaternion.slerpNoInvert(qq, qa, 2 * t * (1-t));
};

/**
 * Make a spline from three quaternions.
 *
 * @method FORGE.Quaternion.spline
 * @param {THREE.Quaternion} q0 previous quaternion
 * @param {THREE.Quaternion} q1 current quaternion
 * @param {THREE.Quaternion} q2 next quaternion
 * @return {THREE.Quaternion}
 */
FORGE.Quaternion.spline = function (q0, q1, q2)
{
    var q1Inv = new THREE.Quaternion().copy(q1).conjugate();

    var p0 = new THREE.Quaternion().copy(q1Inv).multiply(q0);
    var p2 = new THREE.Quaternion().copy(q1Inv).multiply(q2);

    var qLog0 = FORGE.Quaternion.log(p0);
    var qLog2 = FORGE.Quaternion.log(p2);

    var qLogSum = FORGE.Quaternion.add(qLog0, qLog2);
    var qLogSumQuater = FORGE.Quaternion.multiplyScalar(-0.25, qLogSum);
    var qExp = FORGE.Quaternion.exp(qLogSumQuater);

    return new THREE.Quaternion().copy(q1).multiply(qExp).normalize();
};

/**
 * Rectangle object.
 *
 * @constructor FORGE.Rectangle
 * @param {number} x - horizontal coordinate of origin
 * @param {number} y - vertical coordinate of origin
 * @param {number} width - width of the rectangle
 * @param {number} height - height of the rectangle
 */
FORGE.Rectangle = function(x, y, width, height)
{
    /**
     * Horizontal coordinate of origin
     * @name FORGE.Rectangle#_x
     * @type {number}
     * @private
     */
    this._x = typeof x === "number" ? x : 0;

    /**
     * Vertical coordinate of origin
     * @name FORGE.Rectangle#_y
     * @type {number}
     * @private
     */
    this._y = typeof y === "number" ? y : 0;

    /**
     * Width
     * @name FORGE.Rectangle#_width
     * @type {number}
     * @private
     */
    this._width = typeof width === "number" ? width : 0;

    /**
     * Height
     * @name FORGE.Rectangle#_height
     * @type {number}
     * @private
     */
    this._height = typeof height === "number" ? height : 0;

};

FORGE.Rectangle.prototype.constructor = FORGE.Rectangle;


/**
 * Get and set x origin coordinate.
 * @name FORGE.Rectangle#x
 * @type {number}
 */
Object.defineProperty(FORGE.Rectangle.prototype, "x",
{
    /** @this {FORGE.Rectangle} */
    get: function()
    {
        return this._x;
    },

    /** @this {FORGE.Rectangle} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._x = value;
        }
    }
});

/**
 * Get and set y origin coordinate.
 * @name FORGE.Rectangle#y
 * @type {number}
 */
Object.defineProperty(FORGE.Rectangle.prototype, "y",
{
    /** @this {FORGE.Rectangle} */
    get: function()
    {
        return this._y;
    },

    /** @this {FORGE.Rectangle} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._y = value;
        }
    }
});

/**
 * Get and set width of the rectangle.
 * @name FORGE.Rectangle#width
 * @type {number}
 */
Object.defineProperty(FORGE.Rectangle.prototype, "width",
{
    /** @this {FORGE.Rectangle} */
    get: function()
    {
        return this._width;
    },

    /** @this {FORGE.Rectangle} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._width = value;
        }
    }
});

/**
 * Get and set width of the rectangle (w is a short for width).
 * @name FORGE.Rectangle#w
 * @type {number}
 */
Object.defineProperty(FORGE.Rectangle.prototype, "w",
{
    /** @this {FORGE.Rectangle} */
    get: function()
    {
        return this.width;
    },

    /** @this {FORGE.Rectangle} */
    set: function(value)
    {
        this.width = value;
    }
});

/**
 * Get and set height of the rectangle.
 * @name FORGE.Rectangle#height
 * @type {number}
 */
Object.defineProperty(FORGE.Rectangle.prototype, "height",
{
    /** @this {FORGE.Rectangle} */
    get: function()
    {
        return this._height;
    },

    /** @this {FORGE.Rectangle} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._height = value;
        }
    }
});

/**
 * Get and set height of the rectangle (h is a short for height).
 * @name FORGE.Rectangle#h
 * @type {number}
 */
Object.defineProperty(FORGE.Rectangle.prototype, "h",
{
    /** @this {FORGE.Rectangle} */
    get: function()
    {
        return this.height;
    },

    /** @this {FORGE.Rectangle} */
    set: function(value)
    {
        this.height = value;
    }
});

/**
 * Get center point.
 * @name FORGE.Rectangle#center
 * @type {THREE.Vector2}
 * @readonly
 */
Object.defineProperty(FORGE.Rectangle.prototype, "center",
{
    /** @this {FORGE.Rectangle} */
    get: function()
    {
        return new THREE.Vector2(this._x + 0.5 * this._width, this._y + 0.5 * this._height);
    }
});

/**
 * Get origin.
 * @name FORGE.Rectangle#origin
 * @type {THREE.Vector2}
 * @readonly
 */
Object.defineProperty(FORGE.Rectangle.prototype, "origin",
{
    /** @this {FORGE.Rectangle} */
    get: function()
    {
        return new THREE.Vector2(this._x, this._y);
    }
});

/**
 * Get size.
 * @name FORGE.Rectangle#size
 * @type {FORGE.Size}
 * @readonly
 */
Object.defineProperty(FORGE.Rectangle.prototype, "size",
{
    /** @this {FORGE.Rectangle} */
    get: function()
    {
        return new FORGE.Size(this._width, this._height);
    }
});



/**
 * Size object.
 *
 * @constructor FORGE.Size
 * @param {number} width width property
 * @param {number} height height property
 */
FORGE.Size = function(width, height)
{
    /**
     * Width.
     * @name FORGE.Size#_width
     * @type {number}
     * @private
     */
    this._width = width || 0;

    /**
     * Height.
     * @name FORGE.Size#_height
     * @type {number}
     * @private
     */
    this._height = height || 0;
};

FORGE.Size.prototype.constructor = FORGE.Size;


/**
 * Get width.
 * @name FORGE.Size#width
 * @type {number}
 */
Object.defineProperty(FORGE.Size.prototype, "width",
{
    /** @this {FORGE.Size} */
    get: function()
    {
        return this._width;
    }
});

/**
 * Get height.
 * @name FORGE.Size#height
 * @type {number}
 */
Object.defineProperty(FORGE.Size.prototype, "height",
{
    /** @this {FORGE.Size} */
    get: function()
    {
        return this._height;
    }
});

/**
 * Get ratio.
 * @name FORGE.Size#ratio
 * @type {number}
 */
Object.defineProperty(FORGE.Size.prototype, "ratio",
{
    /** @this {FORGE.Size} */
    get: function()
    {
        return this._width / this._height;
    }
});


/**
 * @namespace {Object} FORGE.MediaType
 */
FORGE.MediaType = {};

/**
 * @name FORGE.MediaType.UNDEFINED
 * @type {string}
 * @const
 */
FORGE.MediaType.UNDEFINED = "undefined";

/**
 * @name FORGE.MediaType.IMAGE
 * @type {string}
 * @const
 */
FORGE.MediaType.IMAGE = "image";

/**
 * @name FORGE.MediaType.VIDEO
 * @type {string}
 * @const
 */
FORGE.MediaType.VIDEO = "video";

/**
 * @name FORGE.MediaType.GRID
 * @type {string}
 * @const
 */
FORGE.MediaType.GRID = "grid";


/**
 * @namespace {Object} FORGE.MediaFormat
 */
FORGE.MediaFormat = {};

/**
 * @name FORGE.MediaFormat.EQUIRECTANGULAR
 * @type {string}
 * @const
 */
FORGE.MediaFormat.EQUIRECTANGULAR = "equi";

/**
 * @name FORGE.MediaFormat.CUBE
 * @type {string}
 * @const
 */
FORGE.MediaFormat.CUBE = "cube";

/**
 * @name FORGE.MediaFormat.FLAT
 * @type {string}
 * @const
 */
FORGE.MediaFormat.FLAT = "flat";

/**
 * @name FORGE.MediaFormat.HOTSPOT
 * @type {string}
 * @const
 */
FORGE.MediaFormat.HOTSPOT = "hotspot";

/**
 * This object stores a number of tiles used for multi resolution cases with
 * tiles. It acts as a LRU map, as we can't store infinite amount of tiles.
 * The number of tiles to store is Σ(6 * 4^n), with n being the number of levels.
 *
 * There is an exception though: the level 0 of a multi resolution is always
 * kept in the cache.
 *
 * @constructor FORGE.MediaStore
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference
 * @param {SceneMediaSourceConfig} config - the config given by a media to know
 *                                          how to load each tile
 * @param {(FORGE.Image|SceneMediaPreviewConfig)} preview - the pattern of the preview
 * @extends {FORGE.BaseObject}
 */
FORGE.MediaStore = function(viewer, config, preview)
{
    /**
     * The viewer reference.
     * @name FORGE.MediaStore#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Media source configuration
     * @name FORGE.MediaStore#_config
     * @type {SceneMediaSourceConfig}
     * @private
     */
    this._config = config;

    /**
     * Pattern of the preview
     * @name FORGE.MediaStore#_preview
     * @type {(FORGE.Image|SceneMediaSourceConfig)}
     * @private
     */
    this._preview = preview;

    /**
     * A map containing all {@link FORGE.MediaTexture}, with the key being constitued
     * from the level, face, x and y properties defining the texture
     * @name FORGE.MediaStore#_textures
     * @type {?FORGE.Map}
     * @private
     */
    this._textures = null;

    /**
     * The list of currently being loaded textures
     * @name FORGE.MediaStore#_loadingTextures
     * @type {?Array<string>}
     * @private
     */
    this._loadingTextures = null;

    /**
     * Map of texture promises
     * @type {FORGE.Map}
     * @private
     */
    this._texturePromises = null;

    /**
     * LIFO stack holding texture requests
     * @type {Array}
     * @private
     */
    this._textureStack = null;

    /**
     * LIFO stack timer interval
     * @type {?number}
     * @private
     */
    this._textureStackInterval = null;

    /**
     * The current size of all loaded textures.
     * @name FORGE.MediaStore#_size
     * @type {number}
     * @private
     */
    this._size = 0;

    /**
     * The max size of the cache.
     * @name FORGE.MediaStore#_maxSize
     * @type {number}
     * @private
     */
    this._maxSize = 0;

    /**
     * The global pattern of texture file urls
     * @name FORGE.MediaStore#_pattern
     * @type {string}
     * @private
     */
    this._pattern = "";

    /**
     * Object containing patterns of texture file urls per pyramid level
     * @name FORGE.MediaStore#_patterns
     * @type {?Object}
     * @private
     */
    this._patterns = null;

    /**
     * Faces configuration
     * @type {?Object}
     * @private
     */
    this._cubeFaceConfig = null;

    FORGE.BaseObject.call(this, "MediaStore");

    this._boot();
};

FORGE.MediaStore.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.MediaStore.prototype.constructor = FORGE.MediaStore;

/**
 * Texture stack interval in milliseconds
 * @type {number}
 */
FORGE.MediaStore.TEXTURE_STACK_INTERVAL_MS = 250;

/**
 * Table describing previous cube face
 * @type {CubeFaceObject}
 */
FORGE.MediaStore.CUBE_FACE_CONFIG = {
    "front": "front",
    "right": "right",
    "back": "back",
    "left": "left",
    "down": "down",
    "up": "up"
};

/**
 * Boot routine.
 *
 * @method FORGE.MediaStore#_boot
 * @private
 */
FORGE.MediaStore.prototype._boot = function()
{
    this._register();

    this._textures = new FORGE.Map();
    this._loadingTextures = [];
    this._textureStack = [];
    this._texturePromises = new FORGE.Map();
    this._patterns = {};

    this._parseConfig(this._config);

    if (FORGE.Device.desktop === true)
    {
        this._maxSize = 150000000;
    }
    else if (FORGE.Device.iOS === true)
    {
        this._maxSize = 40000000;
    }
    else
    {
        this._maxSize = 50000000;
    }
};

/**
 * Parse config routine.
 *
 * @method FORGE.MediaStore#_parseConfig
 * @param {SceneMediaSourceConfig} config - the config of the media source
 * @private
 */
FORGE.MediaStore.prototype._parseConfig = function(config)
{
    // a pattern should contains at least {f}, {l}, {x} or {y}
    var re = /\{[lfxy].*\}/;

    // Check if there is a global pattern
    if (typeof config.pattern === "string")
    {
        if (config.pattern.match(re) === null)
        {
            throw "the pattern of the multi resolution media is wrong";
        }

        this._pattern = config.pattern;
    }

    if (this._preview !== null)
    {
        if (typeof this._preview.url !== "string" || this._preview.url.match(re) === null)
        {
            this.warn("no preview for this panorama");
        }
        else
        {
            this._patterns[FORGE.Tile.PREVIEW] = this._preview.url;
        }
    }

    // Then check if each resolution level has its own pattern
    for (var l = 0, ll = config.levels.length; l < ll; l++)
    {
        if (typeof config.levels[l].pattern === "string")
        {
            if (config.pattern.match(re) === null)
            {
                throw "the pattern of the multi resolution media is wrong";
            }

            this._patterns[l] = config.levels[l].pattern;
        }
    }

    this._cubeFaceConfig = FORGE.MediaStore.CUBE_FACE_CONFIG;
    if (typeof config.faces !== "undefined")
    {
        this._cubeFaceConfig = config.faces;
    }
};

/**
 * Create the key of an image.
 *
 * @method FORGE.MediaStore#_createKey
 * @param {FORGE.Tile} tile - tile
 * @return {string} returns the key for this image
 * @private
 */
FORGE.MediaStore.prototype._createKey = function(tile)
{
    var key = "";
    key += typeof tile.face !== "undefined" ? this._cubeFaceConfig[tile.face] + "-" : "";
    key += typeof tile.level !== "undefined" ? tile.level + "-" : "";
    key += typeof tile.x !== "undefined" ? tile.x + "-" : "";
    key += typeof tile.y !== "undefined" ? tile.y : "";

    return key;
};

/**
 * Loads an Image from parameters, but doesn't add it to the map yet.
 *
 * @method FORGE.MediaStore#_load
 * @param {FORGE.Tile} tile - tile
 * @private
 */
FORGE.MediaStore.prototype._load = function(tile)
{
    var key = this._createKey(tile);
    if (this._loadingTextures.indexOf(key) !== -1)
    {
        return;
    }

    var entry = this._texturePromises.get(key);
    if (entry.cancelled)
    {
        this.log("Load promise cancelled for tile " + tile.name);
        entry.load.reject("Tile cancelled");
        this._texturePromises.delete(key);
        return;
    }

    this.log("Push loading texture for tile " + tile.name);
    this._loadingTextures.push(key);

    var url = this._pattern;

    if (typeof this._patterns[tile.level] !== "undefined")
    {
        url = this._patterns[tile.level];
    }

    url = url.replace(/\{face\}/, this._cubeFaceConfig[tile.face]);
    url = url.replace(/\{level\}/, tile.level.toString());
    url = url.replace(/\{x\}/, tile.x.toString());
    url = url.replace(/\{y\}/, tile.y.toString());

    var config = {
        url: url
    };

    var image = new FORGE.Image(this._viewer, config);

    image.data = {
        tile: tile
    };

    image.onLoadComplete.add(this._onLoadComplete.bind(this), this);
};

/**
 * Add the loaded image to the map.
 *
 * @method FORGE.MediaStore#_onLoadComplete
 * @param {FORGE.Image} image - the loaded image
 * @private
 */
FORGE.MediaStore.prototype._onLoadComplete = function(image)
{
    if (this._textures === null)
    {
        image.emitter.destroy();
        // stop it all, it means this mediastore has been destroyed and this is
        // a late-coming tile
        return;
    }

    image = image.emitter;
    var tile = image.data.tile;
    var key = this._createKey(tile);

    this.log("Texture load complete for tile " + tile.name);

    var texture = new THREE.Texture();
    texture.image = image.element;

    var size = image.element.height * image.element.width;
    this._size += size;

    var mediaTexture = new FORGE.MediaTexture(texture, (tile.level === FORGE.Tile.PREVIEW), size);
    this._textures.set(key, mediaTexture);

    // destroy the image, it is no longer needed
    this._loadingTextures.splice(this._loadingTextures.indexOf(image.data.key), 1);

    var entry = this._texturePromises.get(key);
    entry.load.resolve(mediaTexture.texture);
    this._texturePromises.delete(key);

    image.destroy();

    this._checkSize();
};

/**
 * Discard texture.
 *
 * @method FORGE.MediaStore#_discardTexture
 * @param {string} key - texture key
 * @private
 */
FORGE.MediaStore.prototype._discardTexture = function(key)
{
    if (this._textures.has(key) === false)
    {
        return;
    }

    var texture = this._textures.get(key);

    this._size -= texture.size;
    texture.destroy();

    this._textures.delete(key);
};

/**
 * Check the current size of the store, and flush some texture if necessary.
 *
 * @method FORGE.MediaStore#_checkSize
 * @private
 */
FORGE.MediaStore.prototype._checkSize = function()
{
    if (this._size < this._maxSize)
    {
        return;
    }

    var entries = this._textures.entries(),
        time = window.performance.now(),
        force = false,
        texture;

    entries = FORGE.Utils.sortArrayByProperty(entries, "1.lastTime");

    while (this._size > this._maxSize)
    {
        // oldest are first
        texture = entries.shift();

        // if no more entries (aka all texture are level 0) remove it anyway
        if (typeof texture === "undefined")
        {
            entries = this._textures.entries();
            entries = FORGE.Utils.sortArrayByProperty(entries, "1.lastTime");
            force = true;
        }
        else
        // but don't delete if it is locked
        if (force === true || texture[1].locked !== true)
        {
            this._discardTexture(texture[0]);
        }
    }
};

/**
 * Push item from texture stack.
 *
 * @method FORGE.MediaStore#_textureStackPush
 * @param {FORGE.Tile} tile - tile requesting texture
 */
FORGE.MediaStore.prototype._textureStackPush = function(tile)
{
    // First clear interval if any and push
    if (this._textureStackInterval !== null)
    {
        window.clearTimeout(this._textureStackInterval);
        this._textureStackInterval = null;
    }

    if (tile.level === FORGE.Tile.PREVIEW)
    {
        this._load(tile);
    }
    else
    {
        this._textureStack.push(tile);

        this._textureStackInterval = window.setTimeout(this._textureStackPop.bind(this), FORGE.MediaStore.TEXTURE_STACK_INTERVAL_MS);
    }
};

/**
 * Pop item from texture stack.
 *
 * @method FORGE.MediaStore#_textureStackPop
 */
FORGE.MediaStore.prototype._textureStackPop = function()
{
    this._textureStackInterval = null;

    while (this._textureStack.length > 0)
    {
        var tile = this._textureStack.pop();
        //this.log("Texture stack length (---): " + this._textureStack.length + " (" + tile.name + ")");

        this.log("Pop texture request from stack for tile " + tile.name);
        this._load(tile);
    }
};

/**
 * Get an image from this store, given four parameters: the face associated to
 * this image, the level of quality and the x and y positions. It returns
 * either a {@link THREE.Texture} or null.
 *
 * The inner working is as follow: either the image is already loaded and
 * returned, or either the image is being loaded and nothing is returned yet.
 * If the latter, the image is added to the map once it is completely loaded
 * (the onLoadComplete event).
 *
 * @method FORGE.MediaStore#get
 * @param {FORGE.Tile} tile - tile
 * @return {Promise} returns a promise on the image
 */
FORGE.MediaStore.prototype.get = function(tile)
{
    var key = this._createKey(tile);

    // If texture is available, return a resolved promise
    if (this._textures.has(key))
    {
        this.log("Texture available, return resolved promise");
        var promise = FORGE.Utils.makePromise();
        var mediaTexture = this._textures.get(key);
        promise.resolve(mediaTexture.texture);
        return promise;
    }

    // First check if texture is already loading (pending promise)
    // Return null, and client should do nothing but wait
    var promise = this._texturePromises.get(key);
    if (promise !== undefined)
    {
        return null;
    }

    this.log("Create load promise for tile " + tile.name);

    var loadingPromise = FORGE.Utils.makePromise();

    // Texture already available
    // Return resolved promise
    if (this._textures.has(key))
    {
        this.log("and resolve it immediately");
        loadingPromise.resolve(this._textures.get(key));
        return loadingPromise;
    }

    // Create new entry in map of promises
    var entry = /** @type {!TexturePromiseObject} */ (
    {
        load: loadingPromise,
        cancelled: false
    });

    this._texturePromises.set(key, entry);

    this._textureStackPush(tile);

    return loadingPromise;
};

/**
 * Ask store if it has a texture already available
 * @method FORGE.MediaStore#has
 * @param {string} key - texture key
 */
FORGE.MediaStore.prototype.has = function(key)
{
    return this._textures.has(key);
};

/**
 * Discard texture for a given tile
 * @method FORGE.MediaStore#discardTileTexture
 * @param {FORGE.Tile} tile - tile
 */
FORGE.MediaStore.prototype.discardTileTexture = function(tile)
{
    this._discardTexture(this._createKey(tile));
};

/**
 * Destroy routine.
 *
 * @method FORGE.MediaStore#destroy
 */
FORGE.MediaStore.prototype.destroy = function()
{
    this._unregister();

    this._patterns = null;

    this._viewer = null;
    this._loadingTextures = null;

    if (this._textureStack !== null)
    {
        this._textureStack.length = 0;
        this._textureStack = null;
    }

    this._texturePromises = null;

    this._textures.clear();
    this._textures = null;
};

/**
 * This object stores a THREE.Texture used for multi resolutions scene. It is
 * simplier (in terms of memory to store this object as it is tinier than a
 * FORGE.Image. It also remove the fact that we need to create a THREE.Texture
 * in the renderer.
 *
 * @constructor FORGE.MediaTexture
 * @param {THREE.Texture} texture - the THREE.Texture to store
 * @param {boolean} locked - is the texture locked (i.e. it isn't deletable)
 * @param {number} size - the size of the texture
 */
FORGE.MediaTexture = function(texture, locked, size)
{
    /**
     * The texture
     * @name FORGE.MediaTexture#_texture
     * @type {THREE.Texture}
     * @private
     */
    this._texture = texture;

    /**
     * Can the texture be deleted ? Otherwise it is locked, e.g. it is a level 0
     * @name FORGE.MediaTexture#_locked
     * @type {boolean}
     * @private
     */
    this._locked = locked;

    /**
     * The size of the texture
     * @name FORGE.MediaTexture#_size
     * @type {number}
     * @private
     */
    this._size = size;

    /**
     * The time the texture was last used
     * @name FORGE.MediaTexture#_lastTime
     * @type {number}
     * @private
     */
    this._lastTime = window.performance.now();

    /**
     * The number of times the texture was used
     * @name FORGE.MediaTexture#_count
     * @type {number}
     * @private
     */
    this._count = 0;
};

FORGE.MediaTexture.prototype.constructor = FORGE.MediaTexture;

/**
 * Destroy routine
 * @method FORGE.MediaTexture#destroy
 */
FORGE.MediaTexture.prototype.destroy = function()
{
    if (this._texture !== null)
    {
        this._texture.dispose();
    }

    this._texture = null;
};

/**
 * Get the texture.
 * @name  FORGE.MediaTexture#texture
 * @type {THREE.Texture}
 * @readonly
 */
Object.defineProperty(FORGE.MediaTexture.prototype, "texture",
{
    /** @this {FORGE.MediaTexture} */
    get: function()
    {
        this._count++;
        this._lastTime = window.performance.now();

        return this._texture;
    }
});

/**
 * Is the texture locked ?
 * @name  FORGE.MediaTexture#locked
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.MediaTexture.prototype, "locked",
{
    /** @this {FORGE.MediaTexture} */
    get: function()
    {
        return this._locked;
    }
});

/**
 * Get the size of the texture
 * @name  FORGE.MediaTexture#size
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.MediaTexture.prototype, "size",
{
    /** @this {FORGE.MediaTexture} */
    get: function()
    {
        return this._size;
    }
});

/**
 * Get the last time when it was called.
 * @name  FORGE.MediaTexture#lastTime
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.MediaTexture.prototype, "lastTime",
{
    /** @this {FORGE.MediaTexture} */
    get: function()
    {
        return this._lastTime;
    }
});

/**
 * Get the number of times it was called.
 * @name  FORGE.MediaTexture#count
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.MediaTexture.prototype, "count",
{
    /** @this {FORGE.MediaTexture} */
    get: function()
    {
        return this._count;
    }
});

/**
 * Media class.
 *
 * @constructor FORGE.Media
 * @param {FORGE.Viewer} viewer {@link FORGE.Viewer} reference.
 * @param {SceneMediaConfig} config input media configuration from json
 * @extends {FORGE.BaseObject}
 *
 */
FORGE.Media = function(viewer, config)
{
    /**
     * The viewer reference.
     * @name FORGE.Media#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Input scene and media config
     * @name FORGE.Media#_config
     * @type {SceneMediaConfig}
     * @private
     */
    this._config = config;

    /**
     * Type of the media
     * @name FORGE.Media#_type
     * @type {string}
     * @private
     */
    this._type = "";

    /**
     * Media options
     * @name  FORGE.Media#_options
     * @type {Object}
     * @private
     */
    this._options = null;

    /**
     * Image reference.
     * @name FORGE.Media#_displayObject
     * @type {FORGE.DisplayObject}
     * @private
     */
    this._displayObject = null;

    /**
     * Media store reference, if it is a multi resolution image.
     * @name FORGE.Media#_store
     * @type {FORGE.MediaStore}
     * @private
     */
    this._store = null;

    /**
     * A preview of the media: it is always an image, never a video (so, a
     * preview for a video would be an image).
     * @name FORGE.Media#_preview
     * @type {(FORGE.Image|SceneMediaPreviewConfig)}
     * @private
     */
    this._preview = null;

    /**
     * Loaded flag
     * @name FORGE.Media#_loaded
     * @type {boolean}
     * @private
     */
    this._loaded = false;

    /**
     * Events object that will keep references of the ActionEventDispatcher
     * @name FORGE.Media#_events
     * @type {Object<FORGE.ActionEventDispatcher>}
     * @private
     */
    this._events = null;

    /**
     * On load complete event dispatcher.
     * @name  FORGE.Media#_onLoadComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;

    FORGE.BaseObject.call(this, "Media");

    this._boot();
};

FORGE.Media.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Media.prototype.constructor = FORGE.Media;

/**
 * Init routine
 * @method FORGE.Media#_boot
 * @private
 */
FORGE.Media.prototype._boot = function()
{
    this._events = {};

    // This event can no be a lazzy one (memorize is true)
    this._onLoadComplete = new FORGE.EventDispatcher(this, true);

    this._parseConfig(this._config);
};

/**
 * Configuration parsing.
 * @method FORGE.Media#_parseConfig
 * @param {SceneMediaConfig} config input media configuration
 * @private
 */
FORGE.Media.prototype._parseConfig = function(config)
{
    if (typeof config === "undefined" || config === null)
    {
        this._type = FORGE.MediaType.UNDEFINED;
        this._notifyLoadComplete();

        return;
    }

    // Warning : UID is not registered and applied to the FORGE.Image|FORGE.VideoHTML5|FORGE.VideoDash objects for registration
    this._uid = config.uid;

    this._options = (typeof config.options !== "undefined") ? config.options : null;

    this._type = config.type;

    var source = config.source;

    if (typeof config.source !== "undefined" && typeof config.source.format === "undefined")
    {
        config.source.format = FORGE.MediaFormat.FLAT;
    }

    if (typeof config.events === "object" && config.events !== null)
    {
        this._createEvents(config.events);
    }

    if (this._type === FORGE.MediaType.GRID)
    {
        this._notifyLoadComplete();
        return;
    }

    if (typeof config.source === "undefined" || config.source === null)
    {
        return;
    }

    var preview = config.preview;

    if (this._type === FORGE.MediaType.IMAGE)
    {
        // Load the preview
        if (typeof preview !== "undefined")
        {
            if (typeof preview === "string")
            {
                preview = { url: preview };
            }

            var re = /\{[lfxy].*\}/;
            if (preview.url.match(re) !== null)
            {
                this._preview = /** @type {SceneMediaPreviewConfig} */ (preview);
            }
            else if (source.format === FORGE.MediaFormat.EQUIRECTANGULAR ||
                source.format === FORGE.MediaFormat.CUBE ||
                source.format === FORGE.MediaFormat.FLAT)
            {
                var previewConfig = {
                    key: this._uid + "-preview",
                    url: preview.url
                };

                this._preview = new FORGE.Image(this._viewer, previewConfig);
                this._preview.onLoadComplete.addOnce(this._onImageLoadComplete, this);
            }
        }

        var imageConfig;

        // If there isn't an URL set, it means that this is a multi resolution image.
        if (!source.url)
        {
            this._store = new FORGE.MediaStore(this._viewer, source, this._preview);
            this._notifyLoadComplete();
        }
        else if (source.format === FORGE.MediaFormat.EQUIRECTANGULAR ||
            source.format === FORGE.MediaFormat.CUBE ||
            source.format === FORGE.MediaFormat.FLAT)
        {
            imageConfig = {
                key: this._uid,
                url: source.url
            };

            this._displayObject = new FORGE.Image(this._viewer, imageConfig);
            this._displayObject.onLoadComplete.addOnce(this._onImageLoadComplete, this);
        }
        else
        {
            throw "Media format not supported";
        }

        return;
    }

    if (this._type === FORGE.MediaType.VIDEO)
    {
        // If the levels property is present, we get all urls from it and put it
        // inside source.url: it means that there is multi-quality. It is way
        // easier to handle for video than for image, as it can never be video
        // tiles to display.
        if (Array.isArray(source.levels))
        {
            source.url = [];
            for (var i = 0, ii = source.levels.length; i < ii; i++)
            {
                if(FORGE.Device.check(source.levels[i].device) === false)
                {
                    continue;
                }

                source.url.push(source.levels[i].url);
            }
        }

        if (typeof source.url !== "string" && source.url.length === 0)
        {
            return;
        }

        if (typeof source.streaming !== "undefined" && source.streaming.toLowerCase() === FORGE.VideoFormat.DASH)
        {
            this._displayObject = new FORGE.VideoDash(this._viewer, this._uid);
        }
        else
        {
            var scene = this._viewer.story.scene;

            // check of the ambisonic state of the video sound prior to the video instanciation
            this._displayObject = new FORGE.VideoHTML5(this._viewer, this._uid, null, null, (scene.hasSoundTarget(this._uid) === true && scene.isAmbisonic() === true ? true : false));
        }

        // At this point, source.url is either a streaming address, a simple
        // url, or an array of url
        this._displayObject.load(source.url);

        this._displayObject.onLoadedMetaData.addOnce(this._onLoadedMetaDataHandler, this);
        this._displayObject.onPlay.add(this._onPlayHandler, this);
        this._displayObject.onPause.add(this._onPauseHandler, this);
        this._displayObject.onSeeked.add(this._onSeekedHandler, this);
        this._displayObject.onEnded.add(this._onEndedHandler, this);


        return;
    }
};

/**
 * Create action events dispatchers.
 * @method FORGE.Media#_createEvents
 * @private
 * @param {SceneMediaEventsConfig} events - The events config of the media.
 */
FORGE.Media.prototype._createEvents = function(events)
{
    var event;
    for(var e in events)
    {
        event = new FORGE.ActionEventDispatcher(this._viewer, e);
        event.addActions(events[e]);
        this._events[e] = event;
    }
};

/**
 * Clear all object events.
 * @method Media.Object3D#_clearEvents
 * @private
 */
FORGE.Media.prototype._clearEvents = function()
{
    for(var e in this._events)
    {
        this._events[e].destroy();
        this._events[e] = null;
    }
};

/**
 * Internal handler on image ready.
 * @method FORGE.Media#_onImageLoadComplete
 * @private
 */
FORGE.Media.prototype._onImageLoadComplete = function()
{
    this._notifyLoadComplete();
};

/**
 * Internal handler on video metadata loaded.
 * @method FORGE.Media#_onLoadedMetaDataHandler
 * @private
 */
FORGE.Media.prototype._onLoadedMetaDataHandler = function()
{
    if (this._options !== null)
    {
        this._displayObject.volume = (typeof this._options.volume === "number") ? this._options.volume : 1;
        this._displayObject.loop = (typeof this._options.loop === "boolean") ? this._options.loop : true;
        this._displayObject.currentTime = (typeof this._options.startTime === "number") ? this._options.startTime : 0;

        if (this._options.autoPlay === true && document[FORGE.Device.visibilityState] === "visible")
        {
            this._displayObject.play();
        }

        this._displayObject.autoPause = this._options.autoPause;
        this._displayObject.autoResume = this._options.autoResume;
    }

    this._notifyLoadComplete();
};

/**
 * Method to dispatch the load complete event and set the media ready.
 * @method FORGE.Media#_onLoadedMetaDataHandler
 */
FORGE.Media.prototype._notifyLoadComplete = function()
{
    if (this._type === FORGE.MediaType.IMAGE)
    {
        if (this._store !== null)
        {
            this._loaded = true;
            this._onLoadComplete.dispatch();
        }
        else
        {
            this._loaded = this._displayObject !== null && this._displayObject.loaded && this._preview !== null && this._preview.loaded;

            if (this._preview === null || (this._displayObject !== null && this._displayObject.loaded === false) || this._preview.loaded === false)
            {
                this._onLoadComplete.dispatch();
            }
            else if (this._viewer.renderer.backgroundRenderer !== null)
            {
                this._viewer.renderer.backgroundRenderer.displayObject = this._displayObject;
            }

        }
    }
    else
    {
        this._loaded = true;
        this._onLoadComplete.dispatch();
    }
};

/**
 * Internal handler on video play.
 * @method FORGE.Media#_onPlayHandler
 * @private
 */
FORGE.Media.prototype._onPlayHandler = function()
{
    // Actions defined from the json
    if(FORGE.Utils.isTypeOf(this._events.onPlay, "ActionEventDispatcher") === true)
    {
        this._events.onPlay.dispatch();
    }
};

/**
 * Internal handler on video pause.
 * @method FORGE.Media#_onPauseHandler
 * @private
 */
FORGE.Media.prototype._onPauseHandler = function()
{
    // Actions defined from the json
    if(FORGE.Utils.isTypeOf(this._events.onPause, "ActionEventDispatcher") === true)
    {
        this._events.onPause.dispatch();
    }
};

/**
 * Internal handler on video seeked.
 * @method FORGE.Media#_onSeekedHandler
 * @private
 */
FORGE.Media.prototype._onSeekedHandler = function()
{
    // Actions defined from the json
    if(FORGE.Utils.isTypeOf(this._events.onSeeked, "ActionEventDispatcher") === true)
    {
        this._events.onSeeked.dispatch();
    }
};

/**
 * Internal handler on video ended.
 * @method FORGE.Media#_onEndedHandler
 * @private
 */
FORGE.Media.prototype._onEndedHandler = function()
{
    // Actions defined from the json
    if(FORGE.Utils.isTypeOf(this._events.onEnded, "ActionEventDispatcher") === true)
    {
        this._events.onEnded.dispatch();
    }
};

/**
 * Media destroy sequence
 *
 * @method FORGE.Media#destroy
 */
FORGE.Media.prototype.destroy = function()
{
    if (this._displayObject !== null)
    {
        this._displayObject.destroy();
        this._displayObject = null;
    }

    if (this._store !== null)
    {
        this._store.destroy();
        this._store = null;
    }

    if (this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    this._clearEvents();
    this._events = null;

    this._viewer = null;
};

/**
 * Get the media config.
 * @name  FORGE.Media#config
 * @type {SceneMediaConfig}
 * @readonly
 */
Object.defineProperty(FORGE.Media.prototype, "config",
{
    /** @this {FORGE.Media} */
    get: function()
    {
        return this._config;
    }
});

/**
 * Get the media type.
 * @name  FORGE.Media#type
 * @type {string}
 * @readonly
 */
Object.defineProperty(FORGE.Media.prototype, "type",
{
    /** @this {FORGE.Media} */
    get: function()
    {
        return this._type;
    }
});

/**
 * Get the displayObject.
 * @name  FORGE.Media#displayObject
 * @type {FORGE.DisplayObject}
 * @readonly
 */
Object.defineProperty(FORGE.Media.prototype, "displayObject",
{
    /** @this {FORGE.Media} */
    get: function()
    {
        if (this._type === FORGE.MediaType.IMAGE && this._store === null)
        {
            if (this._displayObject !== null && this._displayObject.loaded === true)
            {
                return this._displayObject;
            }

            return this._preview;
        }

        return this._displayObject;
    }
});

/**
 * Get the media store, if this is a multi resolution media.
 * @name FORGE.Media#store
 * @type {FORGE.MediaStore}
 * @readonly
 */
Object.defineProperty(FORGE.Media.prototype, "store",
{
    /** @this {FORGE.Media} */
    get: function()
    {
        return this._store;
    }
});

/**
 * Get the loaded flag
 * @name FORGE.Media#loaded
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.Media.prototype, "loaded",
{
    /** @this {FORGE.Media} */
    get: function()
    {
        return this._loaded;
    }
});

/**
 * Get the onLoadComplete {@link FORGE.EventDispatcher}.
 * @name FORGE.Media#onLoadComplete
 * @type {FORGE.EventDispatcher}
 * @readonly
 */
Object.defineProperty(FORGE.Media.prototype, "onLoadComplete",
{
    /** @this {FORGE.Media} */
    get: function()
    {
        return this._onLoadComplete;
    }
});

/**
 * RenderManager class.
 *
 * @constructor FORGE.RenderManager
 * @param {FORGE.Viewer} viewer - viewer reference
 * @extends {FORGE.BaseObject}
 *
 * @todo think about how to render multiple scene at the same time, with blending / overlap / viewport layouting...
 * maybe add a layer object encapsulating background / foreground renderings to ease the process
 */
FORGE.RenderManager = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.RenderManager#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * WebGL Renderer
     * @name FORGE.RenderManager#_webGLRenderer
     * @type {?THREE.WebGLRenderer}
     * @private
     */
    this._webGLRenderer = null;

    /**
     * Render pipeline managing composers
     * @name FORGE.RenderManager#_renderPipeline
     * @type {FORGE.RenderPipeline}
     * @private
     */
    this._renderPipeline = null;

    /**
     * Object managing screen/VR display
     * @name FORGE.RenderManager#_renderDisplay
     * @type {FORGE.RenderDisplay}
     * @private
     */
    this._renderDisplay = null;

    /**
     * View manager reference
     * @name FORGE.RenderManager#_viewManager
     * @type {FORGE.ViewManager}
     * @private
     */
    this._viewManager = null;

    /**
     * The sound reference linked to the media.
     * @name FORGE.RenderManager#_mediaSound
     * @type {?(FORGE.Sound|Object)}
     * @private
     */
    this._mediaSound = null;

    /**
     * Picking manager
     * @name FORGE.RenderManager#_pickingManager
     * @type {FORGE.PickingManager}
     * @private
     */
    this._pickingManager = null;

    /**
     * Background renderer.
     * @name FORGE.RenderManager#_backgroundRenderer
     * @type {?(FORGE.BackgroundMeshRenderer|FORGE.BackgroundShaderRenderer|FORGE.BackgroundPyramidRenderer)}
     * @private
     */
    this._backgroundRenderer = null;

    /**
     * Type of the background renderer.
     * @name FORGE.RenderManager#_backgroundRendererType
     * @type {string}
     * @private
     */
    this._backgroundRendererType = FORGE.BackgroundType.UNDEFINED;

    /**
     * Camera reference.
     * @name FORGE.RenderManager#_camera
     * @type {?FORGE.Camera}
     * @private
     */
    this._camera = null;

    /**
     * Canvas resolution (px)
     * @name FORGE.RenderManager#_canvasResolution
     * @type {?FORGE.Size}
     * @private
     */
    this._canvasResolution = null;

    /**
     * Display resolution (px)
     * @name FORGE.RenderManager#_displayResolution
     * @type {?FORGE.Size}
     * @private
     */
    this._displayResolution = null;

    /**
     * objects renderer
     * @name  FORGE.RenderManager#_objectRenderer
     * @type {?FORGE.ObjectRenderer}
     * @private
     */
    this._objectRenderer = null;

    /**
     * Background renderer ready flag
     * @name FORGE.RenderManager#_backgroundReady
     * @type {boolean}
     * @private
     */
    this._backgroundReady = false;

    /**
     * Render pipeline renderer ready flag
     * @name FORGE.RenderManager#_renderPipelineReady
     * @type {boolean}
     * @private
     */
    this._renderPipelineReady = false;

    /**
     * Event dispatcher for background renderer ready.
     * @name FORGE.RenderManager#_onBackgroundReady
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onBackgroundReady = null;

    /**
     * Event dispatcher for on before render.
     * @name FORGE.RenderManager#_onBeforeRender
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onBeforeRender = null;

    /**
     * Event dispatcher for on after render.
     * @name FORGE.RenderManager#_onAfterRender
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onAfterRender = null;

    FORGE.BaseObject.call(this, "RenderManager");

    this._boot();
};

FORGE.RenderManager.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.RenderManager.prototype.constructor = FORGE.RenderManager;

/**
 * Render manager constant near depth
 * @type {number}
 */
FORGE.RenderManager.DEPTH_NEAR = 0.01;

/**
 * Render manager constant far depth
 * @type {number}
 */
FORGE.RenderManager.DEPTH_FAR = 10000;

/**
 * Boot sequence.
 * @method FORGE.RenderManager#_boot
 * @private
 */
FORGE.RenderManager.prototype._boot = function()
{
    this._clock = new THREE.Clock();

    this._viewer.onConfigLoadComplete.add(this._onViewerConfigLoadComplete, this, 1000);
};

/**
 * Viewer ready handler
 * @method FORGE.RenderManager#_onViewerConfigLoadComplete
 * @private
 */
FORGE.RenderManager.prototype._onViewerConfigLoadComplete = function()
{
    var canvas = this._viewer.canvas.dom;

    var options = this._viewer.config.webgl;
    options.canvas = canvas;

    // WebGLRenderer will draw any component supported by WebGL
    try
    {
        this._webGLRenderer = new THREE.WebGLRenderer(options);
    }
    catch (error)
    {
        this.destroy();
        return;
    }

    this._webGLRenderer.autoClear = false;
    this._webGLRenderer.autoClearDepth = true;
    this._webGLRenderer.autoClearColor = true;

    this._viewManager = new FORGE.ViewManager(this._viewer);
    this._viewManager.onChange.add(this._onViewChangeHandler, this);

    this._pickingManager = new FORGE.PickingManager(this._viewer);
    this._renderDisplay = new FORGE.RenderDisplay(this._viewer);
    this._objectRenderer = new FORGE.ObjectRenderer(this._viewer);
    this._renderPipeline = new FORGE.RenderPipeline(this._viewer);

    this._renderDisplay.onDisplayChange.add(this._renderDisplayChangeHandler, this);
    this._setRendererSize(this._renderDisplay.rendererSize);

    this._camera = new FORGE.Camera(this._viewer);

    this._viewer.canvas.onResize.add(this._canvasResizeHandler, this);
    this._viewer.story.onSceneLoadStart.add(this._onSceneLoadStartHandler, this);
};

/**
 * Scene has started to load.
 * Init the view, the camera and the media
 * @todo create media / background renderer
 *
 * @method FORGE.RenderManager#_onSceneLoadStartHandler
 * @private
 */
FORGE.RenderManager.prototype._onSceneLoadStartHandler = function()
{
    // Listen to scene unload
    this._viewer.story.scene.onUnloadStart.addOnce(this._onSceneUnloadStartHandler, this);

    var sceneConfig = this._viewer.story.scene.config;

    // Apply background to renderer
    this._viewer.container.background = this._viewer.story.scene.background;

    // Create render scenes before initing the view to ensure pipeline is ready when
    // enabling the picking manager
    this._objectRenderer.createRenderScenes();
    this._renderPipeline.addRenderScenes(this._objectRenderer.renderScenes);

    this._viewManager.load(sceneConfig.view);

    this._initCamera(sceneConfig);

    this._initSound(sceneConfig);

    this._setupMedia();
};

/**
 * Bind event handlers on media.
 * @method FORGE.RenderManager#_setupMedia
 * @private
 */
FORGE.RenderManager.prototype._setupMedia = function()
{
    var media = this._viewer.story.scene.media;

    media.onLoadComplete.addOnce(this._mediaLoadCompleteHandler, this);

    // If media is a video, listen to the quality change event
    if (FORGE.Utils.isTypeOf(media.displayObject, ["VideoHTML5", "VideoDash"]))
    {
        media.displayObject.onQualityChange.add(this._mediaQualityChangeHandler, this);
    }
};

/**
 * Scene has started to unload
 * @todo clean media / background renderer
 *
 * @method FORGE.RenderManager#_onSceneUnloadStartHandler
 * @private
 */
FORGE.RenderManager.prototype._onSceneUnloadStartHandler = function()
{
    this._renderPipelineReady = false;

    this._clearBackgroundRenderer();

    // Clear fx composer and hotspot renderer
    if (this._objectRenderer !== null)
    {
        this._objectRenderer.clear();
    }

    if (this._pickingManager !== null)
    {
        this._pickingManager.clear();
    }

    if (this._renderPipeline !== null)
    {
        this._renderPipeline.clear();
    }

    // Destroy media
    if (this._mediaSound !== null)
    {
        this._mediaSound.destroy();
        this._mediaSound = null;
    }
};

/**
 * Init camera with info contained in configuration
 * @method FORGE.RenderManager#_initCamera
 * @param {SceneConfig} sceneConfig - scene configuration
 * @private
 */
FORGE.RenderManager.prototype._initCamera = function(sceneConfig)
{
    var sceneCameraConfig = /** @type {CameraConfig} */ (sceneConfig.camera);
    var storyCameraConfig = /** @type {CameraConfig} */ (this._viewer.mainConfig.camera);
    var extendedCameraConfig = /** @type {CameraConfig} */ (FORGE.Utils.extendMultipleObjects(storyCameraConfig, sceneCameraConfig));

    this._camera.load(extendedCameraConfig);
};

/**
 * Init the scene sound with info contained in configuration
 * @method FORGE.RenderManager#_initSound
 * @param {SceneConfig} sceneConfig - scene configuration
 * @private
 */
FORGE.RenderManager.prototype._initSound = function(sceneConfig)
{
    var soundConfig = /** @type {SoundConfig} */ (sceneConfig.sound);

    // Create sound from the SceneConfig
    if (typeof soundConfig !== "undefined" && typeof soundConfig.source !== "undefined")
    {
        var volume, loop, startTime, autoPlay;

        if (typeof soundConfig.options !== "undefined")
        {
            volume = (typeof soundConfig.options.volume === "number") ? FORGE.Math.clamp(soundConfig.options.volume, 0, 1) : 1;
            loop = (typeof soundConfig.options.loop === "boolean") ? soundConfig.options.loop : false;
            startTime = (typeof soundConfig.options.startTime === "number") ? soundConfig.options.startTime : 0;
            autoPlay = (typeof soundConfig.options.autoPlay === "boolean") ? soundConfig.options.autoPlay : false;
        }

        if (typeof soundConfig.source.url !== "undefined" && soundConfig.source.url !== "")
        {
            // Warning : UID is not registered and applied to the FORGE.Sound object for registration
            this._mediaSound = new FORGE.Sound(this._viewer, sceneConfig.sound.uid, sceneConfig.sound.source.url, (sceneConfig.sound.type === FORGE.SoundType.AMBISONIC));

            if (typeof soundConfig.options !== "undefined" && soundConfig.options !== null)
            {
                this._mediaSound.volume = volume;
                this._mediaSound.loop = loop;
                this._mediaSound.startTime = startTime;

                if (autoPlay === true)
                {
                    this._mediaSound.play(this._mediaSound.startTime, this._mediaSound.loop, true);
                }
            }
        }
        // @todo Ability to use a target uid rather than a source url (ie. soundConfig.source.target)
    }
};

/**
 * View change handler
 * @method FORGE.RenderManager#_onViewChangeHandler
 * @private
 */
FORGE.RenderManager.prototype._onViewChangeHandler = function()
{
    if (this._backgroundRenderer !== null)
    {
        this._backgroundRenderer.updateAfterViewChange();
    }

    this._pickingManager.updateForViewType(this._viewManager.type);

    if (this._viewManager.type === FORGE.ViewType.RECTILINEAR)
    {
        this._renderPipeline.enablePicking(false);
    }
    else
    {
        this._renderPipeline.enablePicking(true, this._pickingManager.material, this._pickingManager.renderTarget);
    }
};

/**
 * Handler of media load complete event
 * @method FORGE.RenderManager#_mediaLoadCompleteHandler
 * @param {FORGE.Event} event - Event object
 * @private
 */
FORGE.RenderManager.prototype._mediaLoadCompleteHandler = function(event)
{
    this.log("Media load is complete");

    var media = event.emitter;

    this._setBackgroundRendererType(this._renderDisplay.presentingVR);
    this._setBackgroundRenderer(this._backgroundRendererType);

    if (this._backgroundRenderer !== null)
    {
        this._backgroundRenderer.displayObject = media.displayObject;
    }

    this._setupRenderPipeline();
};

/**
 * Handler of media quality change event
 * @method FORGE.RenderManager#_mediaQualityChangeHandler
 * @private
 */
FORGE.RenderManager.prototype._mediaQualityChangeHandler = function(event)
{
    this.log("Media quality has changed");

    this._backgroundRenderer.displayObject = event.emitter;
};

/**
 * Setup render pipeline
 * @method FORGE.RenderManager#_setupRenderPipeline
 * @private
 */
FORGE.RenderManager.prototype._setupRenderPipeline = function()
{
    var fxSet = null;

    var sceneConfig = this._viewer.story.scene.config;
    var mediaConfig = sceneConfig.media;

    if (typeof mediaConfig !== "undefined" && mediaConfig !== null &&
        typeof mediaConfig.fx !== "undefined" && mediaConfig.fx !== null)
    {
        fxSet = this._viewer.postProcessing.getFxSetByUID(mediaConfig.fx);
    }

    if(this._backgroundRenderer !== null)
    {
        this._renderPipeline.addBackground(this._backgroundRenderer.renderTarget.texture, fxSet, 1.0);
    }

    if (typeof sceneConfig.fx !== "undefined" && sceneConfig.fx !== null)
    {
        var globalFxSet = this._viewer.postProcessing.getFxSetByUID(sceneConfig.fx);
        this._renderPipeline.addGlobalFx(globalFxSet);
    }

    this._renderPipelineReady = true;
};

/**
 * Render background.
 * @method FORGE.RenderManager#_drawBackground
 * @param {THREE.PerspectiveCamera} camera - perspective camera used to render mesh, N/A with shader rendering
 * @private
 */
FORGE.RenderManager.prototype._drawBackground = function(camera)
{
    // this.log("_drawBackground");

    if (this._backgroundRenderer === null)
    {
        return;
    }

    this._backgroundRenderer.render(camera || null);
};

/**
 * Set renderer size and all objects aware of resolution
 * @method FORGE.RenderManager#_setRendererSize
 * @param {FORGE.Size} size - new renderer size
 * @private
 */
FORGE.RenderManager.prototype._setRendererSize = function(size)
{
    var vr = this._renderDisplay.presentingVR;

    var keepCanvasStyle = true;

    if (vr === true)
    {
        size = this._renderDisplay.rendererSize;
        keepCanvasStyle = false;
    }
    else
    {
        this._renderDisplay.setSize(size);
    }

    this.log("set renderer size: " + size.width + "x" + size.height);

    this._webGLRenderer.setSize(size.width, size.height, keepCanvasStyle);
    this._canvasResolution = size;

    this._displayResolution = new FORGE.Size(size.width, size.height);

    if (vr === true)
    {
        this._displayResolution.width *= 0.5;
    }

    if (this._backgroundRenderer !== null)
    {
        this._backgroundRenderer.setSize(this._displayResolution);
    }

    this._pickingManager.setSize(this._displayResolution);

    this._renderPipeline.setSize(this._displayResolution);

    this.log("render size change in " + (vr ? "VR" : "screen") + " mode, resolution: " + this._displayResolution.width + "x" + this._displayResolution.height);
};

/**
 * Internal handler on canvas resize.
 * @method FORGE.RenderManager#_canvasResizeHandler
 * @private
 */
FORGE.RenderManager.prototype._canvasResizeHandler = function()
{
    this.log("canvas resize handler");

    var canvas = this._viewer.canvas.dom;
    this._setRendererSize(new FORGE.Size(canvas.width, canvas.height));
};

/**
 * VR Renderer display change event handler
 * @method FORGE.RenderManager#_renderDisplayChangeHandler
 * @private
 */
FORGE.RenderManager.prototype._renderDisplayChangeHandler = function()
{
    this.log("render display change handler");

    this._setRendererSize(this._renderDisplay.rendererSize);

    if (this._renderDisplay.presentingVR === true)
    {
        this._pickingManager.mode = FORGE.PickingManager.modes.GAZE;
    }
    else
    {
        this._pickingManager.mode = FORGE.PickingManager.modes.POINTER;
    }
};

/**
 * Renderer set background renderer
 *
 * @method FORGE.RenderManager#_setBackgroundRenderer
 * @param {string} type - type of background renderer
 * @private
 */
FORGE.RenderManager.prototype._setBackgroundRenderer = function(type)
{
    this.log("set background renderer");

    var displayObject = null;
    var renderTarget = null;

    if (this._backgroundRenderer !== null)
    {
        if (this._backgroundRenderer.displayObject !== null)
        {
            displayObject = this._backgroundRenderer.displayObject;
        }

        if (this._backgroundRenderer.renderTarget !== null)
        {
            renderTarget = this._backgroundRenderer.renderTarget;
        }
    }

    this._clearBackgroundRenderer();

    var config = {};
    var media = this._viewer.story.scene.media;
    var mediaConfig = media.config;

    if (typeof mediaConfig !== "undefined" && mediaConfig !== null)
    {
        config.type = mediaConfig.type;

        if (typeof mediaConfig.source !== "undefined" && mediaConfig.source !== null)
        {
            var source = mediaConfig.source;

            if (typeof source.levels === "undefined")
            {
                config.mediaFormat = mediaConfig.source.format;
                var ratio = media.displayObject.element.width / media.displayObject.element.height || 1;

                if (typeof source.fov !== "undefined")
                {
                    var vFov;
                    if (typeof source.fov === "number")
                    {
                        vFov = source.fov.vertical;
                    }
                    else if (typeof source.fov.vertical === "number")
                    {
                        vFov = source.fov.vertical;
                    }
                    else if (typeof source.fov.horizontal === "number")
                    {
                        vFov = source.fov.horizontal / ratio;
                    }
                    else if (typeof source.fov.diagonal === "number")
                    {
                        vFov = source.fov.diagonal / Math.sqrt(1 + ratio * ratio);
                    }
                    else
                    {
                        vFov = 90;
                    }

                    config.verticalFov = FORGE.Math.degToRad(vFov);
                }
            }
        }

        if (typeof mediaConfig.options !== "undefined" && mediaConfig.options !== null)
        {
            if (typeof mediaConfig.options.color !== "undefined")
            {
                config.color = mediaConfig.options.color;
            }
        }
    }

    if (type === FORGE.BackgroundType.SHADER)
    {
        this.log("Create background shader renderer");
        this._backgroundRenderer = new FORGE.BackgroundShaderRenderer(this._viewer, renderTarget, config);

        var size = this._webGLRenderer.getSize();
        this._setRendererSize(new FORGE.Size(size.width, size.height));
    }
    else if (type === FORGE.BackgroundType.PYRAMID)
    {
        this.log("Create background pyramid renderer (multiresolution image)");
        this._backgroundRenderer = new FORGE.BackgroundPyramidRenderer(this._viewer, renderTarget, mediaConfig);
    }
    else if (type === FORGE.BackgroundType.MESH)
    {
        this.log("Create background mesh renderer");

        if (typeof mediaConfig !== "undefined" && mediaConfig !== null)
        {
            if (typeof mediaConfig.source !== "undefined" && mediaConfig.source !== null)
            {
                config.order = mediaConfig.source.order || "RLUDFB";

                // Get the right tile
                if (typeof mediaConfig.source.tile === "number")
                {
                    config.tile = mediaConfig.source.tile;
                }
                else if (Array.isArray(mediaConfig.source.levels) && typeof mediaConfig.source.levels[0].tile === "number")
                {
                    config.tile = mediaConfig.source.levels[0].tile;
                }
            }
        }

        this._backgroundRenderer = new FORGE.BackgroundMeshRenderer(this._viewer, renderTarget, config);
    }
    else
    {
        //@todo not implemented
        // auto mode: try with fragment shader and fall back to mesh if fps is too low
    }

    if (displayObject !== null)
    {
        this._backgroundRenderer.displayObject = displayObject;
    }

    if (this._backgroundRenderer !== null)
    {
        this._backgroundRenderer.updateAfterViewChange();
    }

    this._backgroundReady = true;

    if (this._onBackgroundReady !== null)
    {
        this._onBackgroundReady.dispatch();
    }
};

/**
 * Set the background renderer depending on current media format and view type.
 * @method FORGE.RenderManager#_setBackgroundRendererType
 * @param {boolean} vrEnabled - VR enabled flag
 * @private
 */
FORGE.RenderManager.prototype._setBackgroundRendererType = function(vrEnabled)
{
    this.log("set background renderer type");

    var media = this._viewer.story.scene.media;

    if(media.type === FORGE.MediaType.UNDEFINED)
    {
        this._backgroundRendererType = FORGE.BackgroundType.UNDEFINED;
        return;
    }

    if (vrEnabled === true)
    {
        this.log("VR on - background type = MESH");
        this._backgroundRendererType = FORGE.BackgroundType.MESH;
        return;
    }

    var mediaConfig = media.config;

    if (mediaConfig.type === FORGE.MediaType.GRID)
    {
        this._backgroundRendererType = FORGE.BackgroundType.MESH;
    }
    else if (typeof mediaConfig.source !== "undefined")
    {
        if (typeof mediaConfig.source.levels !== "undefined" && media.type === FORGE.MediaType.IMAGE)
        {
            this._backgroundRendererType = FORGE.BackgroundType.PYRAMID;
        }
        else if (mediaConfig.source.format === FORGE.MediaFormat.CUBE)
        {
            this._backgroundRendererType = FORGE.BackgroundType.MESH;
        }
        else
        {
            this._backgroundRendererType = FORGE.BackgroundType.SHADER;
        }
    }
    else
    {
        this._backgroundRendererType = FORGE.BackgroundType.SHADER;
    }

    if (typeof mediaConfig.source === "undefined" || typeof mediaConfig.source.format === "undefined")
    {
        this.log("VR off - view " + this._viewManager.current.type + ", background type = " + this._backgroundRendererType);
    }
    else
    {
        this.log("VR off - media " + mediaConfig.source.format + ", view " + this._viewManager.current.type +
            ", background type = " + this._backgroundRendererType);
    }
};


/**
 * Clear the background renderer.
 * @method FORGE.RenderManager#_clearBackgroundRenderer
 * @private
 */
FORGE.RenderManager.prototype._clearBackgroundRenderer = function()
{
    this.log("clear background renderer");

    if (this._backgroundRenderer !== null)
    {
        this._backgroundRenderer.destroy();
        this._backgroundRenderer = null;
    }

    this._backgroundReady = false;
};

/**
 * Update routine
 * @method FORGE.RenderManager#update
 */
FORGE.RenderManager.prototype.update = function()
{
    this._camera.update();
};

/**
 * Render routine
 * @method FORGE.RenderManager#render
 */
FORGE.RenderManager.prototype.render = function()
{
    if (this._viewManager === null ||
        this._renderPipelineReady === false ||
        this._renderPipeline === null)
    {
        return;
    }

    if(this._onBeforeRender !== null)
    {
        this._onBeforeRender.dispatch();
    }

    if (this._backgroundRenderer !== null)
    {
        this._backgroundRenderer.update();
    }

    var vr = this._renderDisplay.presentingVR;
    var renderParams = this._renderDisplay.getRenderParams();

    for (var i = 0, ii = renderParams.length; i < ii; i++)
    {
        var params = renderParams[i];
        var rect = params.rectangle;
        var camera = params.camera;

        this._webGLRenderer.setViewport(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);

        this._drawBackground((vr === true) ? camera : null);

        this._renderPipeline.render(camera);

        // Render perspective camera children (objects in camera local space)
        this._webGLRenderer.clearDepth();

        if (vr === true)
        {
            var scene = new THREE.Scene();
            scene.add(camera);
            //window.scene = scene;

            this._webGLRenderer.render(scene, camera);
        }
    }

    if (this._renderDisplay.presentingVR === true)
    {
        this._renderDisplay.submitFrame();
    }

    if(this._onAfterRender !== null)
    {
        this._onAfterRender.dispatch();
    }

    // @todo implement event for render stats (fps, objects count...)
};

/**
 * Enable VR display
 * @method FORGE.RenderManager#enableVR
 */
FORGE.RenderManager.prototype.enableVR = function()
{
    if (this._renderDisplay.presentingVR === true || FORGE.Device.webVR !== true)
    {
        return;
    }

    this._renderDisplay.enableVR();
    this._viewManager.enableVR();

    var sceneConfig = this._viewer.story.scene.config;

    // If we enter VR with a cubemap: do nothing. With an equi: toggle to mesh renderer
    if (typeof sceneConfig.media !== "undefined" && sceneConfig.media !== null && typeof sceneConfig.media.source !== "undefined" && sceneConfig.media.source !== null && sceneConfig.media.source.format === FORGE.MediaFormat.EQUIRECTANGULAR)
    {
        this._setBackgroundRenderer(FORGE.BackgroundType.MESH);
    }
};

/**
 * Disable VR display
 * @method FORGE.RenderManager#disableVR
 */
FORGE.RenderManager.prototype.disableVR = function()
{
    if (this._renderDisplay.presentingVR === false || FORGE.Device.webVR !== true)
    {
        return;
    }

    this._renderDisplay.disableVR();
    this._viewManager.disableVR();

    // If we exit VR with a cubemap: do nothing. With an equi: toggle to shader renderer
    var sceneConfig = this._viewer.story.scene.config;
    var mediaConfig = sceneConfig.media;

    if (typeof mediaConfig !== "undefined" && mediaConfig !== null &&
        typeof mediaConfig.source !== "undefined" && mediaConfig.source !== null &&
        mediaConfig.source.format === FORGE.MediaFormat.EQUIRECTANGULAR)
    {
        this._setBackgroundRendererType(false);
        this._setBackgroundRenderer(this._backgroundRendererType);
    }
};

/**
 * Toggle VR display
 * @method FORGE.RenderManager#toggleVR
 */
FORGE.RenderManager.prototype.toggleVR = function()
{
    if(this._renderDisplay.presentingVR === true)
    {
        this.disableVR();
    }
    else
    {
        this.enableVR();
    }
};

/**
 * Renderer destroy sequence
 *
 * @method FORGE.RenderManager#destroy
 */
FORGE.RenderManager.prototype.destroy = function()
{
    this._viewer.canvas.onResize.remove(this._canvasResizeHandler, this);
    this._viewer.story.onSceneLoadStart.remove(this._onSceneLoadStartHandler, this);
    this._viewer.onConfigLoadComplete.remove(this._onViewerConfigLoadComplete, this);

    if (this._pickingManager !== null)
    {
        this._pickingManager.destroy();
        this._pickingManager = null;
    }

    if (this._onBackgroundReady !== null)
    {
        this._onBackgroundReady.destroy();
        this._onBackgroundReady = null;
    }

    if (this._mediaSound !== null)
    {
        this._mediaSound.destroy();
        this._mediaSound = null;
    }

    if (this._objectRenderer !== null)
    {
        this._objectRenderer.destroy();
        this._objectRenderer = null;
    }

    if (this._backgroundRenderer !== null)
    {
        this._backgroundRenderer.destroy();
        this._backgroundRenderer = null;
    }

    if (this._camera !== null)
    {
        this._camera.destroy();
        this._camera = null;
    }

    if (this._viewManager !== null)
    {
        this._viewManager.destroy();
        this._viewManager = null;
    }

    if (this._renderDisplay !== null)
    {
        this._renderDisplay.onDisplayChange.remove(this._renderDisplayChangeHandler, this);
        this._renderDisplay.destroy();
        this._renderDisplay = null;
    }

    if (this._renderPipeline !== null)
    {
        this._renderPipeline.destroy();
        this._renderPipeline = null;
    }

    if(this._onBeforeRender !== null)
    {
        this._onBeforeRender.destroy();
        this._onBeforeRender = null;
    }

    if(this._onAfterRender !== null)
    {
        this._onAfterRender.destroy();
        this._onAfterRender = null;
    }

    this._clock = null;
    this._webGLRenderer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get viewer.
 * @name FORGE.RenderManager#viewer
 * @type {FORGE.Viewer}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "viewer",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._viewer;
    }
});

/**
 * Get sound linked to the media.
 * @name FORGE.RenderManager#mediaSound
 * @type {(FORGE.Sound|Object)}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "mediaSound",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._mediaSound;
    }
});

/**
 * Get WebGL renderer.
 * @name FORGE.RenderManager#WebGLRenderer
 * @type {THREE.WebGLRenderer}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "webGLRenderer",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._webGLRenderer;
    }
});

/**
 * Get FX Composer.
 * @name FORGE.RenderManager#renderPipeline
 * @type {FORGE.RenderPipeline}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "renderPipeline",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._renderPipeline;
    }
});

/**
 * Get background renderer.
 * @name FORGE.RenderManager#backgroundRenderer
 * @type {(FORGE.BackgroundMeshRenderer|FORGE.BackgroundShaderRenderer)}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "backgroundRenderer",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._backgroundRenderer;
    }
});

/**
 * Get picking manager.
 * @name FORGE.RenderManager#pickingManager
 * @type {FORGE.PickingManager}
 */
Object.defineProperty(FORGE.RenderManager.prototype, "pickingManager",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._pickingManager;
    }
});

/**
 * Get the view manager.
 * @name FORGE.RenderManager#view
 * @type {FORGE.ViewManager}
 */
Object.defineProperty(FORGE.RenderManager.prototype, "view",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._viewManager;
    }
});

/**
 * Get camera.
 * @name FORGE.RenderManager#camera
 * @type {FORGE.Camera}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "camera",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._camera;
    }
});

/**
 * Get canvas resolution in pixels.
 * @name FORGE.RenderManager#canvasResolution
 * @type {FORGE.Size}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "canvasResolution",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._canvasResolution;
    }
});

/**
 * Get display resolution in pixels.
 * @name FORGE.RenderManager#displayResolution
 * @type {FORGE.Size}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "displayResolution",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._displayResolution;
    }
});

/**
 * VR presenting status.
 * @name FORGE.RenderManager#presentingVR
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "presentingVR",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._renderDisplay.presentingVR;
    }
});

/**
 * Get the render display.
 * @name FORGE.RenderManager#display
 * @type {FORGE.RenderDisplay}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "display",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._renderDisplay;
    }
});

/**
 * Get the backgroundReady flag
 * @name FORGE.RenderManager#backgroundReady
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "backgroundReady",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._backgroundReady;
    }
});

/**
 * Get the FORGE.ObjectRenderer instance
 * @name FORGE.RenderManager#objects
 * @type {FORGE.ObjectRenderer}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "objects",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        return this._objectRenderer;
    }
});

/**
 * Get the onBackgroundReady {@link FORGE.EventDispatcher}.
 * @name FORGE.RenderManager#onBackgroundReady
 * @type {FORGE.EventDispatcher}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "onBackgroundReady",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        if (this._onBackgroundReady === null)
        {
            this._onBackgroundReady = new FORGE.EventDispatcher(this, true);
        }

        return this._onBackgroundReady;
    }
});

/**
 * Get the onBeforeRender {@link FORGE.EventDispatcher}.
 * @name FORGE.RenderManager#onBeforeRender
 * @type {FORGE.EventDispatcher}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "onBeforeRender",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        if (this._onBeforeRender === null)
        {
            this._onBeforeRender = new FORGE.EventDispatcher(this);
        }

        return this._onBeforeRender;
    }
});

/**
 * Get the onAfterRender {@link FORGE.EventDispatcher}.
 * @name FORGE.RenderManager#onAfterRender
 * @type {FORGE.EventDispatcher}
 * @readonly
 */
Object.defineProperty(FORGE.RenderManager.prototype, "onAfterRender",
{
    /** @this {FORGE.RenderManager} */
    get: function()
    {
        if (this._onAfterRender === null)
        {
            this._onAfterRender = new FORGE.EventDispatcher(this);
        }

        return this._onAfterRender;
    }
});

/**
 * A render scene is an object responsible of preparing the draw of a scene
 * with a camera, applying a set of image effect.
 *
 * It creates an effect composer that will be called by render loop.
 * It writes the resulting image into a texture used in main render pipeline.
 *
 * @constructor FORGE.RenderScene
 * @param {FORGE.Viewer} viewer - viewer reference
 * @param {THREE.Scene} scene scene to render
 * @param {THREE.Camera} camera camera used to render the scene
 * @param {Array<FX>} fxConfig image fx configuration object
 * @extends {FORGE.BaseObject}
 */
FORGE.RenderScene = function(viewer, scene, camera, fxConfig)
{
    /**
     * The viewer reference.
     * @name FORGE.RenderScene#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Scene to be rendered
     * @name FORGE.RenderScene#_scene
     * @type {THREE.Scene}
     * @private
     */
    this._scene = scene;

    /**
     * Camera used to render the scene
     * @name FORGE.RenderScene#_camera
     * @type {THREE.Camera}
     * @private
     */
    this._camera = camera;

    /**
     * Set of image effect configuration
     * @name FORGE.RenderScene#_fxConfig
     * @type {Array<FX>}
     * @private
     */
    this._fxConfig = fxConfig;

    /**
     * Effect composer rendering the scene into a texture
     * @name FORGE.RenderScene#_sceneComposer
     * @type {FORGE.EffectComposer}
     * @private
     */
    this._sceneComposer = null;

    /**
     * Effect composer dedicated to object picking
     * @name FORGE.RenderScene#_pickingComposer
     * @type {FORGE.EffectComposer}
     * @private
     */
    this._pickingComposer = null;

    FORGE.BaseObject.call(this, "RenderScene");

    this._boot();
};

FORGE.RenderScene.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.RenderScene.prototype.constructor = FORGE.RenderScene;

/**
 * Boot sequence
 * @method FORGE.RenderScene#_boot
 * @private
 */
FORGE.RenderScene.prototype._boot = function()
{
    // Create main effect composer, add render pass and shader passes
    this._sceneComposer = new FORGE.EffectComposer(FORGE.EffectComposerType.RENDER,
                                                 this._viewer.renderer.webGLRenderer);

    var renderPass = new FORGE.RenderPass(this._scene, this._camera);
    renderPass.position = FORGE.PassPosition.RENDER;
    this._sceneComposer.addPass(renderPass);

    var shaderPasses = this._parseShaderPasses(this._fxConfig);
    for (var j = 0, jj = shaderPasses.length; j < jj; j++)
    {
        var shaderPass = shaderPasses[j];
        shaderPass.renderToScreen = false;
        shaderPass.position = FORGE.PassPosition.RENDER;
        this._sceneComposer.addPass(shaderPass);
    }

    // Create picking effect composer and add render pass
    this._pickingComposer = new FORGE.EffectComposer(FORGE.EffectComposerType.PICKING,
                                                   this._viewer.renderer.webGLRenderer);

    var pickingPass = new FORGE.RenderPass(this._scene, this._camera);
    pickingPass.position = FORGE.PassPosition.RENDER;
    this._pickingComposer.addPass(pickingPass);
};

/**
 * Parse shader passes
 * @method FORGE.RenderScene#_parseShaderPasses
 * @param {Array<FX>} config shader passes configuration
 * @return {Array<THREE.ShaderPass>} array of shader passes
 * @private
 */
FORGE.RenderScene.prototype._parseShaderPasses = function(config)
{
    return this._viewer.postProcessing.parseShaderPasses(config);
};

/**
 * Set size of each pass of the render scene
 * @method FORGE.RenderScene#setSize
 * @param {number} width composer width
 * @param {number} height composer height
 */
FORGE.RenderScene.prototype.setSize = function(width, height)
{
    this._sceneComposer.setSize(width, height);
    this._pickingComposer.setSize(width, height);
};

/**
 * Destroy sequence
 * @method FORGE.RenderScene#destroy
 */
FORGE.RenderScene.prototype.destroy = function()
{
    this._sceneComposer.readBuffer.dispose();
    this._sceneComposer.writeBuffer.dispose();

    while (this._sceneComposer.passes.length > 0)
    {
        var pass = this._sceneComposer.passes.pop();

        if (pass instanceof FORGE.TexturePass && pass.hasOwnProperty("tDiffuse"))
        {
            pass.uniforms["tDiffuse"].value.texture.dispose();
            pass.uniforms["tDiffuse"].value = null;
        }
    }

    this._sceneComposer = null;

    this._pickingComposer.passes.length = 0;
    this._pickingComposer = null;

    this._viewer = null;
    this._scene = null;
    this._camera = null;
    this._fxConfig = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get scene.
 * @name FORGE.RenderScene#scene
 * @type {THREE.Scene}
 */
Object.defineProperty(FORGE.RenderScene.prototype, "scene",
{
    /** @this {FORGE.RenderScene} */
    get: function()
    {
        return this._scene;
    }
});

/**
 * Get camera.
 * @name FORGE.RenderScene#camera
 * @type {THREE.Camera}
 */
Object.defineProperty(FORGE.RenderScene.prototype, "camera",
{
    /** @this {FORGE.RenderScene} */
    get: function()
    {
        return this._camera;
    }
});

/**
 * Get scene composer.
 * @name FORGE.RenderScene#sceneComposer
 * @type {FORGE.EffectComposer}
 */
Object.defineProperty(FORGE.RenderScene.prototype, "sceneComposer",
{
    /** @this {FORGE.RenderScene} */
    get: function()
    {
        return this._sceneComposer;
    }
});

/**
 * Get scene composer.
 * @name FORGE.RenderScene#pickingComposer
 * @type {FORGE.EffectComposer}
 */
Object.defineProperty(FORGE.RenderScene.prototype, "pickingComposer",
{
    /** @this {FORGE.RenderScene} */
    get: function()
    {
        return this._pickingComposer;
    }
});

/**
 * FXComposer class.
 *
 * @constructor FORGE.RenderPipeline
 * @param {FORGE.Viewer} viewer - viewer reference
 * @extends {FORGE.BaseObject}
 *
 * @todo think about how to render multiple scene at the same time, with blending / overlap / viewport layouting...
 * maybe add a layer object encapsulating background / foreground renderings to ease the process
 */
FORGE.RenderPipeline = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.RenderPipeline#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Render composer
     * @name FORGE.RenderPipeline#_renderComposer
     * @type {FORGE.EffectComposer}
     * @private
     */
    this._renderComposer = null;

    /**
     * Sub composers array, created for each pass including texture/render + some shaders
     * @name FORGE.RenderPipeline#_subComposers
     * @type {Array<FORGE.EffectComposer>}
     * @private
     */
    this._subComposers = null;

    /**
     * Internal clock used to feed time to effect shaders
     * @name FORGE.RenderPipeline#_clock
     * @type {THREE.Clock}
     * @private
     */
    this._clock = null;

    /**
     * Enabled status flag
     * @name FORGE.RenderPipeline#_enabled
     * @type boolean
     * @private
     */
    this._enabled = true;

    FORGE.BaseObject.call(this, "RenderPipeline");

    this._boot();
};

FORGE.RenderPipeline.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.RenderPipeline.prototype.constructor = FORGE.RenderPipeline;

/**
 * Boot sequence
 * @method FORGE.RenderPipeline#_boot
 * @private
 */
FORGE.RenderPipeline.prototype._boot = function()
{
    this._clock = new THREE.Clock();
    this._subComposers = [];

    this._renderComposer = new FORGE.EffectComposer(FORGE.EffectComposerType.MAIN, this._viewer.renderer.webGLRenderer);
};

/**
 * Get pass type of a THREE.Pass
 * @method FORGE.RenderPipeline#_getPassType
 * @param {THREE.Pass} pass - THREE pass object
 * @private
 * @return {string} - Returns the pass type.
 */
FORGE.RenderPipeline.prototype._getPassType = function(pass)
{
    if (pass instanceof FORGE.TexturePass)
    {
        if (pass.hasOwnProperty("map"))
        {
            var uid = pass.map.uuid.split("-")[0].slice(0, 4);
            return "Texture(" + uid + ")";
        }
        return "Texture";
    }

    if (pass instanceof FORGE.RenderPass)
    {
        return "Render";
    }

    if (pass instanceof THREE.ClearMaskPass)
    {
        return "ClearMask";
    }

    if (pass instanceof THREE.MaskPass)
    {
        return "Mask";
    }

    if (pass instanceof FORGE.ShaderPass)
    {
        return "Shader(" + pass.type.replace("Shader", "") + ")";
    }

    return "Pass";
};

/**
 * Dump some effect composer to console output
 * @method FORGE.RenderPipeline#_dumpComposer
 * @param {FORGE.EffectComposer} composer - The effect composer to dump
 * @private
 */
FORGE.RenderPipeline.prototype._dumpComposer = function(composer)
{
    this.log("COMPOSER: " + composer.name);

    if (composer.passes.length === 0 )
    {
        return;
    }

    var types = [];
    var typesLength = 0;

    for (var i = 0, ii = composer.passes.length; i < ii; i++)
    {
        var typei = this._getPassType(composer.passes[i]);
        types.push(typei);
        typesLength += typei.length;
    }

    // Header/Footer
    var hdft = "";
    for (var j = 0, jj = types.length; j < jj; j++)
    {
        var type = types[j];

        hdft += "| ";
        for (var m=0; m<type.length; m++)
        {
            hdft += "-";
        }
        hdft += " |";

        if (j < jj - 1)
        {
            for (var l=0; l<5; l++)
            {
                hdft += " ";
            }
        }
    }

    // Header
    this.log(hdft);

    // Types
    var line = "";
    for (var k = 0, kk = types.length; k < kk; k++)
    {
        var typek = types[k];
        line += "| " + typek + " |";
        if (k < kk - 1)
        {
            line += " --- ";
        }
    }

    // Add composer output texture to the line if not render to screen
    if (composer.passes[composer.passes.length - 1].renderToScreen === false)
    {
        line += " --- tex";
        if (composer.readBuffer !== null && typeof composer.readBuffer.name !== "undefined")
        {
            line += "(" + composer.readBuffer.name + ")";
        };
        // line += " --- tex";
    }

    this.log(line);

    // Footer
    this.log(hdft);
};

/**
 * Dump whole composing pipeline to console output
 * @method FORGE.RenderPipeline#_dumpPipeline
 * @private
 */
FORGE.RenderPipeline.prototype._dumpPipeline = function()
{
    for (var i = 0, ii = this._subComposers.length; i < ii; i++)
    {
        var composer = this._subComposers[i];
        this._dumpComposer(composer);
    }

    this._dumpComposer(this._renderComposer);
};

/**
 * Add a subcomposer to compositing pipeline
 * Add subcomposer to inner list and add a texture pass drawing subcomposer output
 * @method FORGE.RenderPipeline#_addSubComposer
 * @param {FORGE.EffectComposer} subComposer - new effect composer
 * @param {boolean} renderToTarget - subcomposer should render to target
 * @private
 */
FORGE.RenderPipeline.prototype._addSubComposer = function(subComposer, renderToTarget)
{
    // Add a ForgeJS object into subcomposer to set some private properties
    this._subComposers.push(subComposer);

    if (renderToTarget === false)
    {
        var additionPass = new FORGE.AdditionPass(subComposer);
        this._renderComposer.addPass(additionPass);
    }

    this._updateRenderPipeline();
};

/**
 * Add shader passes to an effect composer
 * @method FORGE.RenderPipeline#_addShaderPasses
 * @param {FORGE.EffectComposer} composer - effect composer
 * @param {Array<THREE.Pass>|THREE.Pass} passes - pass or array of passes to be added to the composer
 * @param {number=} index - index where passes should be inserted
 * @private
 */
FORGE.RenderPipeline.prototype._addShaderPasses = function(composer, passes, index)
{
    index = typeof index !== "undefined" ? index : composer.passes.length;

    if (Array.isArray(passes))
    {
        for (var i = passes.length - 1; i >= 0; i--)
        {
            var shaderPass = passes[i];
            composer.insertPass(shaderPass, index);
        }
    }
    else if (passes instanceof THREE.Pass)
    {
        var shaderThreePass = passes;
        composer.insertPass(shaderThreePass, index);
    }
};

/**
 * Change status of all shader passes in a composer
 * @method FORGE.RenderPipeline#_setComposerShaderPassesStatus
 * @param {FORGE.EffectComposer} composer - effect composer.
 * @param {boolean} status - The status you want to set.
 * @private
 */
FORGE.RenderPipeline.prototype._setComposerShaderPassesStatus = function(composer, status)
{
    if (status === false)
    {
        this._enabled = false;
    }

    for (var i = composer.passes.length - 1; i >= 0; i--)
    {
        var pass = composer.passes[i];

        // Enable/disable shader passes except for Addition passes
        if (pass instanceof THREE.ShaderPass)
        {
            if (pass instanceof FORGE.AdditionPass)
            {
                continue;
            }

            pass.enabled = status;
        }
    }

    if (composer.hasOwnProperty("enabled"))
    {
        composer.enabled = status;
    }

    this._updateRenderPipeline();
};

/**
 * Set all shader passes status
 * @method FORGE.RenderPipeline#_setAllShaderPassesStatus
 * @param {boolean} status - new shader passes status.
 * @private
 */
FORGE.RenderPipeline.prototype._setAllShaderPassesStatus = function(status)
{
    var composers = this._subComposers.concat(this._renderComposer);

    for (var i = 0, ii = composers.length; i < ii; i++)
    {
        var composer = composers[i];
        this._setComposerShaderPassesStatus(composer, status);
    }

    this._enabled = status;
};

/**
 * Update rendering pipeline
 * Called whenever pipeline has changed to optimize the render stream.
 * @method FORGE.RenderPipeline#_updateRenderPipeline
 * @private
 */
FORGE.RenderPipeline.prototype._updateRenderPipeline = function()
{
    // First check render composer order
    // background passes --> render passes --> global passes
    var passes = this._renderComposer.passes;

    // Collect background passes in reverse order and reinsert them at zero index
    var backgrounds = [];

    passes.filter(function(element, index) //array
    {
        if (element.position === FORGE.PassPosition.BACKGROUND)
        {
            backgrounds.push(index);
        }
    });

    if (backgrounds.length > 0 && backgrounds[0] > 0)
    {
        var bgdPasses = [];

        for (var i = backgrounds.length - 1; i >= 0; i--)
        {
            var index = backgrounds[i];
            var passi = passes.splice(index, 1)[0];
            bgdPasses.push(passi);
        }

        for (var j = 0, jj = bgdPasses.length; j < jj; j++)
        {
            this._renderComposer.insertPass(bgdPasses[j], 0);
        }
    }

    // Collect global passes in normal order and reinsert them at the end
    var globals = [];
    passes.filter(function(element, index) //array
    {
        if (element.position === FORGE.PassPosition.GLOBAL)
        {
            globals.push(index);
        }
    });

    // Check if last global pass is at the end of passes array
    if (globals.length > 0 && globals[globals.length - 1] < passes.length - 1)
    {
        var globalPasses = [];

        for (var k = 0, kk = globals.length; k < kk; k++)
        {
            var indexk = globals[k];
            var passk = passes.splice(indexk, 1)[0];
            globalPasses.push(passk);
        }

        for (var l = 0, ll = globalPasses.length; l < ll; l++)
        {
            var passl = globalPasses[l];
            this._renderComposer.addPass(passl);
        }
    }

    // Only first pass of each composer should clear the target
    for (var m = 0, mm = this._subComposers.length; m < mm; m++)
    {
        var composer = this._subComposers[m];

        // First check if a composer share a target with another one
        // Then only the first should clear the target
        var sharingTarget = false;
        var s, ss = this._subComposers.length;
        for (s = 0; s < ss; s++)
        {
            if (s === m)
            {
                continue;
            }

            var anotherComposer = this._subComposers[s];
            if (composer.readBuffer === anotherComposer.readBuffer)
            {
                sharingTarget = true;
                break;
            }
        }
        sharingTarget = sharingTarget && (m > s);

        for (var n = 0, nn = composer.passes.length; n < nn; n++)
        {
            var passn = composer.passes[n];

            // If sharing target with a previous subcomposer, force clear to false
            if (sharingTarget === true)
            {
                passn.clear = false;
            }
            else
            {
                passn.clear = (n === 0);
            }
        }

    }

    // Only last enabled pass of render composer should render to screen
    var rts = false;
    for (var p = passes.length - 1; p >= 0; p--)
    {
        var passp = passes[p];

        if (rts === true)
        {
            passp.renderToScreen = false;
        }
        else if (passp.enabled === true)
        {
            passp.renderToScreen = true;
            rts = true;
        }
    }

    this._dumpPipeline();
};

/**
 * Setup default background texture pass.
 * @method FORGE.RenderPipeline#_setupDefaultBackground.
 * @private
 */
FORGE.RenderPipeline.prototype._setupDefaultBackground = function()
{
    var canvas = document.createElement("canvas");
    canvas.width = canvas.height = 1;
    var context = canvas.getContext("2d");
    context.fillStyle = "rgb(0, 0, 0)";
    context.fillRect(0, 0, canvas.width, canvas.height);

    var defaultTexture = new THREE.TextureLoader().load(canvas.toDataURL());
    defaultTexture.name = "forge-default-texture";

    this.addBackground(defaultTexture, null, 0);
};

/**
 * Set all render passes camera.
 * @method FORGE.RenderPipeline#_setAllRenderPassCamera.
 * @param {THREE.Camera} camera render pass camera.
 * @private
 */
FORGE.RenderPipeline.prototype._setAllRenderPassCamera = function(camera)
{
    var composers = this._subComposers.concat(this._renderComposer);

    for (var i = 0, ii = composers.length; i < ii; i++)
    {
        var composer = composers[i];

        for (var j=0, jj=composer.passes.length; j<jj; j++)
        {
            var pass = composer.passes[j];

            if (pass instanceof FORGE.RenderPass)
            {
                pass.camera = camera;
            }
        }
    }
};

/**
 * Enable/Disable picking.
 * @method FORGE.RenderPipeline#enablePicking
 * @param {boolean} status new picking state
 * @param {THREE.Material=} material picking material
 * @param {THREE.WebGLRenderTarget=} renderTarget picking render target
 */
FORGE.RenderPipeline.prototype.enablePicking = function(status, material, renderTarget)
{
    for (var i = 0, ii = this._subComposers.length; i < ii; i++)
    {
        var composer = this._subComposers[i];
        if (composer.type === FORGE.EffectComposerType.PICKING)
        {
            composer.enabled = status;

            if (typeof material !== "undefined")
            {
                composer.passes[0].overrideMaterial = material;
            }

            if (typeof renderTarget !== "undefined")
            {
                composer.renderTarget = renderTarget;
            }
        }
    }
};

/**
 * Add background to the rendering pipeline.
 * @method FORGE.RenderPipeline#addBackground
 * @param {THREE.Texture} texture texture object used as background.
 * @param {Array<FX>} fxSet image fx set to apply to background only.
 * @param {number=} opacity texture pass opacity
 */
FORGE.RenderPipeline.prototype.addBackground = function(texture, fxSet, opacity)
{
    // Background addition will be an insertion of all passes at index 0
    // First we add all shaders passes in reverse order at index 0
    // Then we insert the texture pass so everything ends up in the right order

    if (typeof fxSet !== "undefined" && fxSet !== null && fxSet.length > 0)
    {
        var shaderPasses = this._viewer.postProcessing.parseShaderPasses(fxSet);

        for (var i = 0, ii = shaderPasses.length; i < ii; i++)
        {
            var pass = shaderPasses[i];
            pass.position = FORGE.PassPosition.BACKGROUND;
        }

        this._addShaderPasses(this._renderComposer, shaderPasses, 0);
    }

    var texturePass = new FORGE.TexturePass(texture, opacity);
    texturePass.position = FORGE.PassPosition.BACKGROUND;

    this._renderComposer.insertPass(texturePass, 0);

    this._updateRenderPipeline();
};

/**
 * Add render scenes to the rendering pipeline
 * @method FORGE.RenderPipeline#addRenderScenes
 * @param {Array<FORGE.RenderScene>} renderScenes array of render scenes
 */
FORGE.RenderPipeline.prototype.addRenderScenes = function(renderScenes)
{
    for (var i = 0, ii = renderScenes.length; i < ii; i++)
    {
        this._addSubComposer(renderScenes[i].sceneComposer, false);
        this._addSubComposer(renderScenes[i].pickingComposer, true);
    }

    this._updateRenderPipeline();
};

/**
 * Add fx at the end of the whole rendering pipeline
 * @method FORGE.RenderPipeline#addGlobalFx
 * @param {Array<FX>} fxSet set of effects
 */
FORGE.RenderPipeline.prototype.addGlobalFx = function(fxSet)
{
    var shaderPasses = this._viewer.postProcessing.parseShaderPasses(fxSet);

    for (var i = 0, ii = shaderPasses.length; i < ii; i++)
    {
        var pass = shaderPasses[i];
        pass.position = FORGE.PassPosition.GLOBAL;
    }

    this._addShaderPasses(this._renderComposer, shaderPasses);
    this._updateRenderPipeline();
};

/**
 * Get a shader pass with an UID
 * @method FORGE.RenderPipeline#getShaderPassByUID
 * @param {string} uid - the uid of the ShaderPass
 * @return {THREE.Pass} shader pass
 */
FORGE.RenderPipeline.prototype.getShaderPassByUID = function(uid)
{
    if (this._renderComposer !== null)
    {
        for (var i = 0, ii = this._renderComposer.passes.length; i < ii; i++)
        {
            var pass = this._renderComposer.passes[i];

            if (pass.uid === uid)
            {
                return pass;
            }
        }
    }

    if (this._subComposers !== null)
    {
        for (var k = 0, kk = this._subComposers.length; k < kk; k++)
        {
            var composer = this._subComposers[k];

            for (var j = 0, jj = composer.passes.length; j < jj; j++)
            {
                var subPass = composer.passes[j];

                if (subPass.uid === uid)
                {
                    return subPass;
                }
            }
        }
    }

    return null;
};

/**
 * Set size of each composers
 * @method FORGE.RenderPipeline#setSize
 * @param {FORGE.Size} size new composer size
 */
FORGE.RenderPipeline.prototype.setSize = function(size)
{
    for (var i = 0, ii = this._subComposers.length; i < ii; i++)
    {
        var composer = this._subComposers[i];
        composer.setSize(size.width, size.height);

        for (var c = 0, cc = composer.passes.length; c < cc; c++)
        {
            var pass = composer.passes[c];

            if (pass instanceof THREE.ShaderPass)
            {
                if (typeof pass.uniforms.resolution !== "undefined")
                {
                    pass.uniforms.resolution.value = new THREE.Vector2(1 / size.width, 1 / size.height);
                }
            }
        }
    }

    this._renderComposer.setSize(size.width, size.height);

    for (var c = 0, cc = this._renderComposer.passes.length; c < cc; c++)
    {
        var pass = this._renderComposer.passes[c];

        if (pass instanceof THREE.ShaderPass)
        {
            if (typeof pass.uniforms.resolution !== "undefined")
            {
                pass.uniforms.resolution.value = new THREE.Vector2(1 / size.width, 1 / size.height);
            }
        }
    }
};

/**
 * Render routine
 *
 * @method FORGE.RenderPipeline#render
 * @param {THREE.PerspectiveCamera} camera - The camera to use for render.
 */
FORGE.RenderPipeline.prototype.render = function(camera)
{
    if (this._renderComposer === null)
    {
        return;
    }

    // Create default texture and use it if there is no texture in background
    if (!(this._renderComposer.passes[0] instanceof FORGE.TexturePass))
    {
        this._setupDefaultBackground();
    }

    for (var i = 0, ii = this._renderComposer.passes.length; i < ii; i++)
    {
        var pass = this._renderComposer.passes[i];
        if (pass instanceof FORGE.AdditionPass)
        {
            // Pick right buffer as texture provider for addition pass
            var composer = pass.composer;
            var lastPass = composer.passes[composer.passes.length - 1];

            // Addition pass will blend readbuffer content unless last pass needs swap (ShaderPass for example)
            var texture = composer.readBuffer.texture;

            if (typeof lastPass !== "undefined" && lastPass.needsSwap === true)
            {
                texture = composer.writeBuffer.texture;
            }

            pass.uniforms["tAdd"].value = texture;
        }
    }

    var delta = this._clock.getDelta();

    this._setAllRenderPassCamera(camera);

    for (var j = 0, jj = this._subComposers.length; j < jj; j++)
    {
        if (this._subComposers[j].enabled)
        {
            this._subComposers[j].render(delta);
        }
    }

    this._renderComposer.render(delta);
};

/**
 * Clear composer components
 * @method FORGE.RenderPipeline#clear
 */
FORGE.RenderPipeline.prototype.clear = function()
{
    if (this._renderComposer !== null)
    {
        this._renderComposer.readBuffer.dispose();
        this._renderComposer.writeBuffer.dispose();

        for (var i = 0, ii = this._renderComposer.passes.length; i < ii; i++)
        {
            var pass = this._renderComposer.passes[i];
            if (pass instanceof FORGE.ShaderPass && pass.uniforms.hasOwnProperty("tAdd"))
            {
                pass.uniforms["tAdd"].value = null;
            }
        }

        this._renderComposer.passes = [];
    }

    this._subComposers = [];
};

/**
 * Destroy sequence
 * @method FORGE.RenderPipeline#destroy
 */
FORGE.RenderPipeline.prototype.destroy = function()
{
    this.clear();
    this._clock = null;

    for (var i = this._subComposers.length - 1; i > 0; i--)
    {
        var composer = this._subComposers[i];

        for (var j=0, jj=composer.passes.length; j<jj; j++)
        {
            var pass = composer.passes[j];

            if (typeof pass.destroy === "function")
            {
                pass.destroy();
            }
        }
        composer.passes.length = 0;
    }
    this._subComposers = null;

    for (var j=0, jj=this._renderComposer.passes.length; j<jj; j++)
    {
        var pass = this._renderComposer.passes[j];

        if (typeof pass.destroy === "function")
        {
            pass.destroy();
        }
    }
    this._renderComposer.passes.length = 0;
    this._renderComposer = null;

    this._viewer = null;
};

/**
 * FX pipeline status.
 * @name FORGE.RenderPipeline#enabled
 * @type {boolean}
 */
Object.defineProperty(FORGE.RenderPipeline.prototype, "enabled",
{
    /** @this {FORGE.RenderPipeline} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {FORGE.RenderPipeline} */
    set: function(status)
    {
        this._setAllShaderPassesStatus(status);
    }
});

/**
 * @constructor FORGE.RenderDisplay
 * @param {FORGE.Viewer} viewer - viewer reference
 * @extends {FORGE.BaseObject}
 */
FORGE.RenderDisplay = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.RenderDisplay#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * WebVR flag, true if runtime supports WebVR.
     * @name FORGE.RenderDisplay#_webVR
     * @type {boolean}
     * @private
     */
    this._webVR = false;

    /**
     * Presenting VR status.
     * @name FORGE.RenderDisplay#_presentingVR
     * @type {boolean}
     * @private
     */
    this._presentingVR = false;

    /**
     * WebVR VRDisplay interface.
     * @name FORGE.RenderDisplay#_vrDisplay
     * @type {VRDisplay}
     * @private
     */
    this._vrDisplay = null;

    /**
     * VRDisplay boundaries for left eye.
     * @name FORGE.RenderDisplay#_leftBounds
     * @type {Array<number>}
     * @private
     */
    this._leftBounds = null;

    /**
     * VRDisplay boundaries for right eye.
     * @name FORGE.RenderDisplay#_rightBounds
     * @type {Array<number>}
     * @private
     */
    this._rightBounds = null;

    /**
     * Renderer size.
     * @name FORGE.RenderDisplay#_rendererSize
     * @type {FORGE.Size}
     * @private
     */
    this._rendererSize = null;

    /**
     * Renderer size for screen display.
     * @name FORGE.RenderDisplay#_rendererSizeScreen
     * @type {FORGE.Size}
     * @private
     */
    this._rendererSizeScreen = null;

    /**
     * Renderer pixel ratio.
     * @name FORGE.RenderDisplay#_rendererPixelRatio
     * @type {number}
     * @private
     */
    this._rendererPixelRatio = 1;

    /**
     * WebVR frame data receiver
     * @name FORGE.RenderDisplay#_frameData
     * @type {VRFrameData}
     * @private
     */
    this._frameData = null;

    /**
     * On display change event dispatcher.
     * @name  FORGE.RenderDisplay#_onDisplayChange
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onDisplayChange = null;

    FORGE.BaseObject.call(this, "RenderDisplay");

    this._boot();
};

FORGE.RenderDisplay.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.RenderDisplay.prototype.constructor = FORGE.RenderDisplay;

/**
 * Boot sequence
 * @method FORGE.RenderDisplay#_boot
 * @private
 */
FORGE.RenderDisplay.prototype._boot = function()
{
    var renderer = this._viewer.renderer.webGLRenderer;
    this._rendererPixelRatio = renderer.getPixelRatio();
    var size = renderer.getSize();
    this._rendererSizeScreen = new FORGE.Size(size.width, size.height);
    this._rendererSize = this._rendererSizeScreen;

    // Bounds will be set when user request fullscreen VR display
    this._leftBounds = [ 0.0, 0.0, 0.5, 1.0 ];
    this._rightBounds = [ 0.5, 0.0, 0.5, 1.0 ];

    // Create frame data receiver
    if ("VRFrameData" in window)
    {
        this._frameData = new VRFrameData();
    }

    if(FORGE.Device.webVR === true)
    {
        var self = this;

        navigator.getVRDisplays().then(
            function(displays)
            {
                self._gotVRDisplays(displays);
            }
        );

        this._addFullscreenListener();
    }
    else
    {
        this.warn("missing api navigator.getVRDisplays");
    }
};

/**
 * VR display interface found callback
 * Just keep the first interface available
 * @method FORGE.RenderDisplay#_gotVRDisplays
 * @param {Array<VRDisplay>} displays - array of VRDisplay interfaces available
 * @param {Function=} onError - error callback
 * @private
 */
FORGE.RenderDisplay.prototype._gotVRDisplays = function(displays, onError)
{
    this._webVR = displays.length > 0;

    for (var i=0, ii=displays.length; i<ii; i++)
    {
        if ("VRDisplay" in window && displays[i] instanceof VRDisplay)
        {
            this._vrDisplay = displays[i];
            this._vrDisplay.depthNear = FORGE.RenderManager.DEPTH_NEAR;
            this._vrDisplay.depthFar = 2 * FORGE.RenderManager.DEPTH_FAR;
            break;
        }
    }

    if (typeof this._vrDisplay === "undefined")
    {
        if (typeof onError === "function")
        {
            onError("HMD not available");
        }
    }
};

/**
 * Add event listeners for fullscreen and VR display change
 * Cross browser implementation
 * @method FORGE.RenderDisplay#_addFullscreenListener
 * @private
 */
FORGE.RenderDisplay.prototype._addFullscreenListener = function()
{
    this._viewer.container.onFullscreenEnter.add(this._displayChangeHandler, this);
    this._viewer.container.onFullscreenExit.add(this._displayChangeHandler, this);

    window.addEventListener("vrdisplaypresentchange", this._displayChangeHandler.bind(this), false);
};

/**
 * Remove event listeners for fullscreen and VR display change
 * Cross browser implementation
 * @method FORGE.RenderDisplay#_addFullscreenListener
 * @private
 */
FORGE.RenderDisplay.prototype._removeFullscreenListener = function()
{
    this._viewer.container.onFullscreenEnter.remove(this._displayChangeHandler, this);
    this._viewer.container.onFullscreenExit.remove(this._displayChangeHandler, this);

    window.removeEventListener("vrdisplaypresentchange", this._displayChangeHandler.bind(this));
};

/**
 * Display change event handler
 * @method FORGE.RenderDisplay#_displayChangeHandler
 * @private
 */
FORGE.RenderDisplay.prototype._displayChangeHandler = function()
{
    var wasPresentingVR = this._presentingVR;
    var renderer = this._viewer.renderer.webGLRenderer;

    this._presentingVR = typeof this._vrDisplay !== "undefined" &&
        (this._vrDisplay.isPresenting === true ||
            (this._webVR === false && document[FORGE.Device.fullscreenElement] instanceof window.HTMLElement));

    var displaySize;

    if (this._presentingVR === true)
    {
        var eyeParamsL = this._vrDisplay.getEyeParameters("left");

        if (this._webVR === true)
        {
            this._eyeWidth = eyeParamsL.renderWidth;
            this._eyeHeight = eyeParamsL.renderHeight;

            this.log("Window size: " + window.innerWidth + "x" + window.innerHeight);
            this.log("Render size: " + this._eyeWidth + "x" + this._eyeHeight);

            this._leftBounds = [ 0.0, 0.0, 0.5, 1.0 ];
            this._rightBounds = [ 0.5, 0.0, 0.5, 1.0 ];

            if (this._vrDisplay.getLayers)
            {
                var layers = this._vrDisplay.getLayers();

                if (layers.length > 0 && layers[0].leftBounds !== null && layers[0].leftBounds.length === 4)
                {
                    this._leftBounds = layers[0].leftBounds;
                    this._rightBounds = layers[0].rightBounds;
                }
            }

            this.log("Bounds L:[" + this._leftBounds[0] + ", " + this._leftBounds[1] + ", " + this._leftBounds[2] + ", " + this._leftBounds[3] + "], " +
                            "R:[" + this._rightBounds[0] + ", " + this._rightBounds[1] + ", " + this._rightBounds[2] + ", " + this._rightBounds[3] + "]");
        }

        if (wasPresentingVR === false)
        {
            this._rendererPixelRatio = renderer.getPixelRatio();
            var size = renderer.getSize();
            this._rendererSizeScreen.width = size.width;
            this._rendererSizeScreen.height = size.height;
            this._rendererSize = new FORGE.Size(this._eyeWidth * 2, this._eyeHeight);
            renderer.setPixelRatio( 1 );
        }
    }
    else if (wasPresentingVR === true)
    {
        this._rendererSize = this._rendererSizeScreen;
        renderer.setPixelRatio( this._rendererPixelRatio );
    }

    // dispatch change event only when display is impacted
    if (this._presentingVR !== wasPresentingVR && this._onDisplayChange !== null)
    {
        this._onDisplayChange.dispatch();
    }
};

/**
 * Set fullscreen
 * @method FORGE.RenderDisplay#_setFullScreen
 * @param {boolean} status fullscreen status
 * @private
 */
FORGE.RenderDisplay.prototype._setFullScreen = function (status)
{
    var canvas = this._viewer.renderer.webGLRenderer.domElement;

    return new Promise(function (resolve, reject)
    {
        if (typeof this._vrDisplay === "undefined")
        {
            reject(new Error("No VR hardware found."));
            return;
        }

        if (this._presentingVR === status)
        {
            resolve();
            return;
        }

        if (this._webVR === true)
        {
            if (status)
            {
                resolve(this._vrDisplay.requestPresent([ { source: canvas } ] ));
            }
            else
            {
                resolve(this._vrDisplay.exitPresent());
            }
        }

    }.bind(this));
};

/**
 * VR controls reset routine
 * @method FORGE.RenderDisplay#_vrControlsReset
 * @private
 */
FORGE.RenderDisplay.prototype._vrControlsReset = function()
{
    if (this._vrDisplay !== null)
    {
        if (typeof this._vrDisplay.resetPose !== "undefined")
        {
            this._vrDisplay.resetPose();
        }
        else if (typeof this._vrDisplay.resetSensor !== "undefined")
        {
            // Deprecated API.
            this._vrDisplay.resetSensor();
        }
        else if (typeof this._vrDisplay.zeroSensor !== "undefined")
        {
            // Really deprecated API.
            this._vrDisplay.zeroSensor();
        }
    }
};

/**
 * Request presentation through VR display interface
 * @method FORGE.RenderDisplay#_requestPresent
 * @private
 */
FORGE.RenderDisplay.prototype._requestPresent = function()
{
    this._viewer.raf.stop();
    this._viewer.raf.start(this._vrDisplay);
    return this._setFullScreen(true);
};

/**
 * Exit presentation from VR display interface
 * @method FORGE.RenderDisplay#_exitPresent
 * @private
 */
FORGE.RenderDisplay.prototype._exitPresent = function()
{
    this._viewer.raf.stop();
    this._viewer.raf.start(window);
    return this._setFullScreen(false);
};

/**
 * Enable VR display
 * @method FORGE.RenderDisplay#enableVR
 */
FORGE.RenderDisplay.prototype.enableVR = function()
{
    this._requestPresent();
};

/**
 * Start or stop VR display
 * @method FORGE.RenderDisplay#disableVR
 */
FORGE.RenderDisplay.prototype.disableVR = function()
{
    this._exitPresent();
};

/**
 * Get camera orientation quaternion when presenting VR
 * @method FORGE.RenderDisplay#getQuaternionFromPose
 * @return {THREE.Quaternion} quaternion extracted from pose or null if vrDisplay is not available
 * @private
 */
FORGE.RenderDisplay.prototype.getQuaternionFromPose = function()
{
    if ( this._vrDisplay === null )
    {
        return null;
    }

    var pose = null;
    if (this._frameData !== null && typeof this._frameData.pose !== "undefined")
    {
        pose = this._frameData.pose;
    }
    else
    {
        pose = this._vrDisplay.getPose();
    }

    if (pose === null || pose.orientation === null)
    {
        return new THREE.Quaternion();
    }

    var o = pose.orientation;
    return new THREE.Quaternion(-o[1], -o[0], -o[2], o[3]);
};

/**
 * Get render parameters
 * @method FORGE.RenderDisplay#getRenderParams
 * @return {Array<FORGE.RenderParams>} Returns an array of render parameters.
 */
FORGE.RenderDisplay.prototype.getRenderParams = function()
{
    var renderer = this._viewer.renderer.webGLRenderer;
    var canvas = renderer.domElement;
    var camera = this._viewer.renderer.camera;
    var renderParams = [];

    if (typeof this._vrDisplay !== "undefined" && this._vrDisplay !== null && this._presentingVR === true)
    {
        // Setup render rectangle, that will be use as glViewport
        var rx = this._rendererSize.width * this._leftBounds[0],
        ry = this._rendererSize.height * this._leftBounds[1],
        rw = this._rendererSize.width * this._leftBounds[2],
        rh = this._rendererSize.height * this._leftBounds[3];

        var renderRectL = new FORGE.Rectangle(rx, ry, rw, rh);

        rx = this._rendererSize.width * this._rightBounds[0];
        ry = this._rendererSize.height * this._rightBounds[1];
        rw = this._rendererSize.width * this._rightBounds[2];
        rh = this._rendererSize.height * this._rightBounds[3];

        var renderRectR = new FORGE.Rectangle(rx, ry, rw, rh);

        renderParams.push(new FORGE.RenderParams(renderRectL, camera.left));
        renderParams.push(new FORGE.RenderParams(renderRectR, camera.right));
    }
    else
    {
        var rectangle = new FORGE.Rectangle(0, 0, this._rendererSizeScreen.width, this._rendererSizeScreen.height);
        var renderCamera = this._viewer.renderer.view.type === FORGE.ViewType.FLAT ? camera.flat : camera.main;
        renderParams.push(new FORGE.RenderParams(rectangle, renderCamera));
    }

    return renderParams;
};

/**
 * Set size of rendering objects
 * @method FORGE.RenderDisplay#setSize
 * @param {FORGE.Size} size - new renderer size
 */
FORGE.RenderDisplay.prototype.setSize = function(size)
{
    this._rendererSizeScreen = size;

    var renderer = this._viewer.renderer.webGLRenderer;
    renderer.setPixelRatio( 1 );
};

/**
 * Submit current frame to VR display interface
 * @method FORGE.RenderDisplay#submitFrame
 */
FORGE.RenderDisplay.prototype.submitFrame = function()
{
    if (this._webVR === true && typeof this._vrDisplay !== "undefined" && this._presentingVR === true)
    {
        if (this._vrDisplay.capabilities.hasExternalDisplay === true)
        {
            this._vrDisplay.submitFrame();
        }
    }
};

/**
 * Destroy sequence
 * @method FORGE.RenderDisplay#destroy
 */
FORGE.RenderDisplay.prototype.destroy = function()
{
    this._removeFullscreenListener();

    this._vrDisplay = null;
    this._frameData = null;
    this._leftBounds = null;
    this._rightBounds = null;
    this._rendererSize = null;
    this._viewer = null;
};

/**
 * Presenting in VR or not.
 * @name FORGE.RenderDisplay#presentingVR
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.RenderDisplay.prototype, "presentingVR",
{
    /** @this {FORGE.RenderDisplay} */
    get: function()
    {
        return this._presentingVR;
    }
});

/**
 * Get the VR display.
 * @name FORGE.RenderDisplay#vrDisplay
 * @type {VRDisplay}
 * @readonly
 */
Object.defineProperty(FORGE.RenderDisplay.prototype, "vrDisplay",
{
    /** @this {FORGE.RenderDisplay} */
    get: function()
    {
        return this._vrDisplay;
    }
});

/**
 * Get the VR display.
 * @name FORGE.RenderDisplay#vrFrameData
 * @type {VRFrameData}
 * @readonly
 */
Object.defineProperty(FORGE.RenderDisplay.prototype, "vrFrameData",
{
    /** @this {FORGE.RenderDisplay} */
    get: function()
    {
        if(this._vrDisplay !== null && typeof this._vrDisplay.getFrameData === "function" && this._frameData !== null)
        {
            this._vrDisplay.getFrameData(this._frameData);
            return this._frameData;
        }

        return null;
    }
});

/**
 * Render size.
 * @name FORGE.RenderDisplay#rendererSize
 * @readonly
 * @type {FORGE.Size}
 */
Object.defineProperty(FORGE.RenderDisplay.prototype, "rendererSize",
{
    /** @this {FORGE.RenderDisplay} */
    get: function()
    {
        return this._rendererSize;
    }
});

/**
 * Get the onDisplayChange {@link FORGE.EventDispatcher}.
 * @name FORGE.RenderDisplay#onDisplayChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.RenderDisplay.prototype, "onDisplayChange",
{
    /** @this {FORGE.RenderDisplay} */
    get: function()
    {
        if(this._onDisplayChange === null)
        {
            this._onDisplayChange = new FORGE.EventDispatcher(this);
        }

        return this._onDisplayChange;
    }
});

/**
 * Render parameters
 *
 * @constructor FORGE.RenderParams
 * @param {FORGE.Rectangle} rectangle render rectangle
 * @param {THREE.PerspectiveCamera} camera render camera
 */
FORGE.RenderParams = function(rectangle, camera)
{
    /**
     * Render rectangle.
     * @name FORGE.RenderParams#_rectangle
     * @type {FORGE.Rectangle}
     * @private
     */
    this._rectangle = rectangle || null;

    /**
     * Render camera.
     * @name FORGE.RenderParams#_camera
     * @type {THREE.PerspectiveCamera}
     * @private
     */
    this._camera = camera || null;
};

FORGE.RenderParams.prototype.constructor = FORGE.RenderParams;

/**
 * Get rectangle.
 * @name FORGE.RenderParams#rectangle
 * @type {FORGE.Rectangle}
 */
Object.defineProperty(FORGE.RenderParams.prototype, "rectangle",
{
    /** @this {FORGE.RenderParams} */
    get: function()
    {
        return this._rectangle;
    }
});

/**
 * Get camera.
 * @name FORGE.RenderParams#camera
 * @type {THREE.PerspectiveCamera}
 */
Object.defineProperty(FORGE.RenderParams.prototype, "camera",
{
    /** @this {FORGE.RenderParams} */
    get: function()
    {
        return this._camera;
    }
});

/**
 * FORGE.BackgroundRenderer
 * BackgroundRenderer class.
 *
 * @constructor FORGE.BackgroundRenderer
 * @param {FORGE.Viewer} viewer - viewer reference
 * @param {THREE.WebGLRenderTarget} target - render target
 * @param {SceneMediaOptionsConfig} options - the options for the cubemap
 * @param {string=} type - The type of the object as long as many other object inherits from this one.
 * @extends {FORGE.BaseObject}
 */
FORGE.BackgroundRenderer = function(viewer, target, options, type)
{
    /**
     * @name FORGE.BackgroundRenderer#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * @name FORGE.BackgroundRenderer#_canvas
     * @type {FORGE.Canvas}
     * @private
     */
    this._canvas = null;

    /**
     * The mesh (cube) the video is on.
     * @type {THREE.Mesh}
     * @private
     */
    this._mesh = null;

    /**
     * @name FORGE.BackgroundRenderer#_scene
     * @type {THREE.Scene}
     * @private
     */
    this._scene = null;

    /**
     * @name FORGE.BackgroundRenderer#_camera
     * @type {THREE.Camera}
     * @private
     */
    this._camera = null;

    /**
     * @name FORGE.BackgroundRenderer#_frustum
     * @type {THREE.Frustum}
     * @private
     */
    this._frustum = null;

    /**
     * Media format (cubemap, equi...)
     * @type {string}
     * @private
     */
    this._mediaFormat = options.mediaFormat || FORGE.MediaFormat.CUBE;

    /**
     * @name FORGE.BackgroundRenderer#_renderTarget
     * @type {THREE.WebGLRenderTarget}
     * @private
     */
    this._renderTarget = target || null;

    FORGE.BaseObject.call(this, type || "BackgroundRenderer");

    this._boot();
};

FORGE.BackgroundRenderer.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.BackgroundRenderer.prototype.constructor = FORGE.BackgroundRenderer;

/**
 * Init routine.
 * @method FORGE.BackgroundRenderer#_boot
 * @private
 */
FORGE.BackgroundRenderer.prototype._boot = function()
{
    this._scene = new THREE.Scene();
    this._scene.name = "Background scene";

    if (this._renderTarget === null)
    {
        var width = this._viewer.renderer.canvasResolution.width;
        var height = this._viewer.renderer.canvasResolution.height;

        var rtParams =
        {
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: THREE.RGBAFormat,
            stencilBuffer: false
        };

        this._renderTarget = new THREE.WebGLRenderTarget(width, height, rtParams);
    }

    this._frustum = new THREE.Frustum();
};

/**
 * Abstract method that should be implemented by subclass.
 * @method FORGE.BackgroundRenderer#_setDisplayObject
 * @param {FORGE.DisplayObject} displayObject - The display object to set.
 * @private
 */
FORGE.BackgroundRenderer.prototype._setDisplayObject = function(displayObject)
{
    this.log(displayObject); //@closure
    throw "Please implement " + this._className + "::_setDisplayObject";
};

/**
 * Abstract method that should be implemented by subclass.
 * @method FORGE.BackgroundRenderer#_clear
 * @private
 */
FORGE.BackgroundRenderer.prototype._clear = function()
{
    throw "Please implement " + this._className + "::_clear";
};

/**
 * Update texture if needed (video only).
 * @method FORGE.BackgroundRenderer#_updateTexture
 * @private
 */
FORGE.BackgroundRenderer.prototype._updateTexture = function()
{
    // doesn't refresh when there is no texture or texture container and when a video as WebGL texture is paused
    if (this._texture === null || this._textureCanvas === null ||
        this._textureContext === null || typeof this._displayObject === "undefined" || this._displayObject === null ||
        this._displayObject.element === null || (FORGE.Utils.isTypeOf(this._displayObject, ["VideoHTML5", "VideoDash"]) === true && this._displayObject.playing === false))
    {
        return;
    }

    var video = this._displayObject.element;
    if (video instanceof HTMLVideoElement && video.readyState === HTMLMediaElement.HAVE_ENOUGH_DATA)
    {
        if (this._textureContext)
        {
            this._textureContext.drawImage(video,
                0, 0, video.videoWidth, video.videoHeight,
                0, 0, this._textureCanvas.width, this._textureCanvas.height);
            this._texture.needsUpdate = true;
            this.log("texture update done");
        }
    }
};

/**
 * Update after view change
 * @todo change name of this method to be more generic (used by init and )
 * Should be overriden by subclass
 * @method FORGE.BackgroundRenderer#updateAfterViewChange
 */
FORGE.BackgroundRenderer.prototype.updateAfterViewChange = function()
{
    throw new Error(this._className + "::updateAfterViewChange not implemented");
};

/**
 * Update size (resolution)
 * @method FORGE.BackgroundRenderer#setSize
 * @param {FORGE.Size} size - size [px]
 */
FORGE.BackgroundRenderer.prototype.setSize = function(size)
{
    if (this.renderTarget !== null)
    {
        this.renderTarget.setSize(size.width, size.height);
    }
};

/**
 * Render routine.
 * @method FORGE.BackgroundRenderer#render
 * @param {THREE.PerspectiveCamera} camera - perspective camera with mesh rendering, N/A with shader rendering (null)
 */
FORGE.BackgroundRenderer.prototype.render = function(camera)
{
    if (this._viewer.renderer === null || this._renderTarget === null)
    {
        return;
    }

    this._updateTexture();

    var renderCamera = (camera !== null) ? camera : this._camera;
    this._frustum.setFromMatrix( new THREE.Matrix4().multiplyMatrices( renderCamera.projectionMatrix, renderCamera.matrixWorldInverse ) );
    this._viewer.renderer.webGLRenderer.render ( this._scene, renderCamera, this._renderTarget, true );
};

/**
 * Check if some 3D object is interesecting the rendering frustum.
 * @method FORGE.BackgroundRenderer#isObjectInFrustum
 * @param {THREE.Object3D} object - 3D object
 */
FORGE.BackgroundRenderer.prototype.isObjectInFrustum = function(object)
{
    return this._frustum.intersectsObject(object);
};

/**
 * Check if some 3D object is in the scene
 * @method FORGE.BackgroundRenderer#isObjectInScene
 * @param {THREE.Object3D} object - 3D object
 */
FORGE.BackgroundRenderer.prototype.isObjectInScene = function(object)
{
    return this._scene.getObjectByName(object.name) !== undefined;
};

/**
 * Update routine.
 * @method FORGE.BackgroundRenderer#update
 */
FORGE.BackgroundRenderer.prototype.update = function()
{
    if (this._mesh === null || !(this._mesh.material instanceof THREE.ShaderMaterial))
    {
        this._viewer.renderer.view.current.updateUniforms();
        return;
    }

    var resolution = this._viewer.renderer.displayResolution;

    if (this._mesh.material.uniforms.hasOwnProperty("tViewportResolution"))
    {
        this._mesh.material.uniforms.tViewportResolution.value = new THREE.Vector2(resolution.width, resolution.height);
    }

    if (this._mesh.material.uniforms.hasOwnProperty("tViewportResolutionRatio"))
    {
        this._mesh.material.uniforms.tViewportResolutionRatio.value = resolution.ratio;
    }

    if (this._mesh.material.uniforms.hasOwnProperty("tModelViewMatrixInverse"))
    {
        this._mesh.material.uniforms.tModelViewMatrixInverse.value = this._viewer.renderer.camera.modelViewInverse;
    }

    this._viewer.renderer.view.current.updateUniforms(this._mesh.material.uniforms);
};

/**
 * Destroy sequence.
 * @method FORGE.BackgroundRenderer#destroy
 */
FORGE.BackgroundRenderer.prototype.destroy = function()
{
    this._camera = null;
    this._frustum = null;

    if (this._renderTarget !== null)
    {
        this._renderTarget.dispose();
        this._renderTarget = null;
    }

    while (this._scene.children.length > 0)
    {
        var mesh = this._scene.children.pop();

        if (mesh.geometry !== null)
        {
            mesh.geometry.dispose();
            mesh.geometry = null;
        }

        this._scene.remove(mesh);
    }

    this._scene = null;
    this._viewer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get texture size.
 * @name FORGE.BackgroundRenderer#textureSize
 * @type {FORGE.Size}
 */
Object.defineProperty(FORGE.BackgroundRenderer.prototype, "textureSize",
{
    /** @this {FORGE.BackgroundRenderer} */
    get: function()
    {
        if (this._texture === null || typeof this._texture.image === "undefined")
        {
            return null;
        }

        return new FORGE.Size(this._texture.image.width, this._texture.image.height);
    }
});

/**
 * Get background render target.
 * @name FORGE.BackgroundRenderer#renderTarget
 * @type {THREE.WebGLRenderTarget}
 */
Object.defineProperty(FORGE.BackgroundRenderer.prototype, "renderTarget",
{
    /** @this {FORGE.BackgroundRenderer} */
    get: function()
    {
        return this._renderTarget;
    }
});

/**
 * Get/Set background renderer displayObject.
 * @name FORGE.BackgroundRenderer#displayObject
 * @type {string}
 */
Object.defineProperty(FORGE.BackgroundRenderer.prototype, "displayObject",
{
    /** @this {FORGE.BackgroundRenderer} */
    get: function()
    {
        return this._displayObject;
    },
    /** @this {FORGE.BackgroundRenderer} */
    set: function(value)
    {
        if (value === null)
        {
            this._clear();
        }
        else
        {
            this._setDisplayObject(value);
        }
    }
});

/**
 * Get background scene.
 * @name FORGE.BackgroundRenderer#scene
 * @type {THREE.Scene}
 */
Object.defineProperty(FORGE.BackgroundRenderer.prototype, "scene",
{
    /** @this {FORGE.BackgroundRenderer} */
    get: function()
    {
        return this._scene;
    }
});

/**
 * Get camera frustum.
 * @name FORGE.BackgroundRenderer#frustum
 * @type {THREE.Frustum}
 */
Object.defineProperty(FORGE.BackgroundRenderer.prototype, "frustum",
{
    /** @this {FORGE.BackgroundRenderer} */
    get: function()
    {
        return this._frustum;
    }
});

/**
 * @namespace {Object} FORGE.BackgroundType
 */
FORGE.BackgroundType = {};

/**
 * @name FORGE.BackgroundType.UNDEFINED
 * @type {string}
 * @const
 */
FORGE.BackgroundType.UNDEFINED = "undefined";

/**
 * @name FORGE.BackgroundType.SHADER
 * @type {string}
 * @const
 */
FORGE.BackgroundType.SHADER = "shader";

/**
 * @name FORGE.BackgroundType.MESH
 * @type {string}
 * @const
 */
FORGE.BackgroundType.MESH = "mesh";

/**
 * @name FORGE.BackgroundType.PYRAMID
 * @type {string}
 * @const
 */
FORGE.BackgroundType.PYRAMID = "pyramid";

/**
 * FORGE.BackgroundMeshRenderer
 * BackgroundMeshRenderer class.
 *
 * @constructor FORGE.BackgroundMeshRenderer
 * @extends {FORGE.BackgroundRenderer}
 *
 * @param {FORGE.Viewer} viewer - viewer reference
 * @param {THREE.WebGLRenderTarget} target - render target
 * @param {SceneMediaOptionsConfig} options - the options for the cubemap
 */
FORGE.BackgroundMeshRenderer = function(viewer, target, options)
{
    /**
     * Display object (image, canvas or video)
     * @type {FORGE.DisplayObject}
     * @private
     */
    this._displayObject = null;

    /**
     * Texture used for video rendering
     * @type {THREE.Texture}
     * @private
     */
    this._texture = null;

    /**
     * Texture canvas used for video rendering
     * @type {Element|HTMLCanvasElement}
     * @private
     */
    this._textureCanvas = null;

    /**
     * Texture context associated with texture canvas
     * @type {CanvasRenderingContext2D}
     * @private
     */
    this._textureContext = null;

    /**
     * Media type
     * @type {string}
     * @private
     */
    this._mediaType = options.type || FORGE.MediaType.GRID;

    /**
     * Media vertical fov (radians)
     * @type {number}
     * @private
     */
    this._mediaVFov = options.verticalFov || 90;

    /**
     * Grid color
     * @type {string}
     * @private
     */
    this._gridColor = options.color || "#ffffff";

    /**
     * The layout of the faces in the texture. There are six faces to specify:
     * Right (R), Left (L), Up (U), Down (D), Front (F), Back (B). The default
     * layout is the Facebook one, with RLUDFB.
     * @type {string}
     * @private
     */
    this._layout = options.order || "RLUDFB";

    /**
     * The number of horizontal faces and vertical ones in the media.
     * @type {THREE.Vector2}
     * @private
     */
    this._faces = new THREE.Vector2(0, 0);

    /**
     * The size of a tile (width = height)
     * @type {number}
     * @private
     */
    this._tile = options.tile || 512;

    /**
     * The size of the cube.
     * @type {number}
     * @private
     */
    this._size = 0;

    /**
     * The number of subdivision of a face, per direction. For example, if the
     * subdivision is 4, the cube would be composed of 4 * 4 quads per face (in
     * reality it is 4 * 4 * 2 triangles).
     * @type {number}
     * @private
     */
    this._subdivision = 0;

    /**
     * When source is a video, a reduction factor can be set to improve perf by lowering quality
     * @type {number}
     * @private
     */
    this._videoReductionFactor = 1;

    FORGE.BackgroundRenderer.call(this, viewer, target, options, "BackgroundMeshRenderer");
};

FORGE.BackgroundMeshRenderer.prototype = Object.create(FORGE.BackgroundRenderer.prototype);
FORGE.BackgroundMeshRenderer.prototype.constructor = FORGE.BackgroundMeshRenderer;

/**
 * Default texture name
 * @type {string}
 */
FORGE.BackgroundMeshRenderer.DEFAULT_TEXTURE_NAME = "Default Texture";

/**
 * Init routine.
 * @method FORGE.BackgroundMeshRenderer#_boot
 * @private
 */
FORGE.BackgroundMeshRenderer.prototype._boot = function()
{
    FORGE.BackgroundRenderer.prototype._boot.call(this);

    // Set perspective camera
    this._camera = this._viewer.renderer.camera.main;

    this._size = 2 * FORGE.RenderManager.DEPTH_FAR;

    this._subdivision = 32;
};

/**
 * Set display object.
 * @method FORGE.BackgroundMeshRenderer#_setDisplayObject
 * @private
 */
FORGE.BackgroundMeshRenderer.prototype._setDisplayObject = function(displayObject)
{
    if (this._mesh === null)
    {
        this._updateInternals();
    }

    this._displayObject = displayObject;

    if (FORGE.Utils.isTypeOf(displayObject, "Image"))
    {
        this._texture = new THREE.Texture();
        this._texture.image = displayObject.element;
    }
    else if (FORGE.Utils.isTypeOf(displayObject, "Canvas"))
    {
        this._texture = new THREE.Texture();
        this._texture.image = displayObject.element;
    }
    else if (FORGE.Utils.isTypeOf(displayObject, ["VideoHTML5", "VideoDash"]))
    {
        // Evil hack from Hell
        // Reduce texture size for big videos on safari
        if (FORGE.Device.browser.toLowerCase() === "safari" && displayObject.originalHeight > 1440)
        {
            this._videoReductionFactor = 2;
        }

        this._textureCanvas = document.createElement("canvas");
        this._textureCanvas.width = displayObject.originalWidth / this._videoReductionFactor;
        this._textureCanvas.height = displayObject.originalHeight / this._videoReductionFactor;
        this._textureContext = this._textureCanvas.getContext("2d");
        this._texture = new THREE.Texture(this._textureCanvas);
    }
    else
    {
        throw "Wrong type of display object " + displayObject.type;
    }

    this._texture.format = THREE.RGBAFormat;
    this._texture.mapping = THREE.Texture.DEFAULT_MAPPING;

    if (typeof this._mesh.material.uniforms.tTextureRatio !== "undefined")
    {
        this._mesh.material.uniforms.tTextureRatio.value = this._texture.image.width / this._texture.image.height;
    }

    this._texture.generateMipmaps = false;
    this._texture.minFilter = THREE.LinearFilter;

    if (this._mediaFormat === FORGE.MediaFormat.FLAT)
    {
        if (FORGE.Math.isPowerOfTwo(displayObject.width) && FORGE.Math.isPowerOfTwo(displayObject.height))
        {
            // Enable mipmaps for flat rendering to avoid aliasing
            this._texture.generateMipmaps = true;
            this._texture.minFilter = THREE.LinearMipMapLinearFilter;
        }

        // Replace geometry with a rectangle matching texture ratio
        // First release previous default geometry
        if (this._mesh.geometry != null)
        {
            this._mesh.geometry.dispose();
            this._mesh.geometry = null;
        }

        // Compute camera fov limits depending on geometry size and position and on display object size
        var canvasHeight = this._viewer.container.height;
        var canvasWidth = this._viewer.container.width;
        var canvasRatio = canvasWidth / canvasHeight;

        var texHeight = displayObject.height;
        var texRatio = displayObject.width / displayObject.height;

        var geomWidth = this._size;
        var geomHeight = Math.round(geomWidth / texRatio);
        var geomDepth = geomHeight / (2 * Math.tan(0.5 * this._mediaVFov));

        var geometry = new THREE.PlaneBufferGeometry(geomWidth, geomHeight);
        this._mesh.geometry = geometry;
        this._mesh.position.set(0, 0, -geomDepth);

        var fovMax = FORGE.Math.radToDeg(2 * Math.atan(0.5 * geomHeight / geomDepth));
        var fovMin = FORGE.Math.radToDeg(2 * Math.atan((0.5 * geomHeight / geomDepth) * (canvasHeight / texHeight)));

        this.log("Flat rendering boundaries [" + fovMin.toFixed() + ", " + fovMax.toFixed() + "]");
    }

    this._texture.needsUpdate = true;

    this._mesh.material.wireframe = false;

    if (this._texture.image !== null)
    {
        this._faces.x = this._texture.image.width / this._tile;
        this._faces.y = this._texture.image.height / this._tile;
    }

    this._mesh.onBeforeRender = this._onBeforeRender.bind(this);

    var uvMap = this._setUVMapping();
    if (uvMap !== null)
    {
        this._mesh.geometry.attributes.uv.set(uvMap);
    }
};

/**
 * Before render handler
 * @method FORGE.BackgroundMeshRenderer#_onBeforeRender
 * @private
 */
FORGE.BackgroundMeshRenderer.prototype._onBeforeRender = function()
{
    if (typeof this._mesh.material.uniforms === "undefined")
    {
        return;
    }

    if (this._mesh.material.uniforms.hasOwnProperty("tTexture"))
    {
        this._mesh.material.uniforms.tTexture.value = this._texture;
    }

    if (this._mesh.material.uniforms.hasOwnProperty("tOpacity"))
    {
        this._mesh.material.uniforms.tOpacity.value = 1.0;
    }
};

/**
 * Return an array containing each coord for the uv mapping of the cube geometry
 * @method FORGE.BackgroundMeshRenderer#_setUVMappingCube
 * @return {Float32Array} The array containing the UVs
 * @private
 */
FORGE.BackgroundMeshRenderer.prototype._setUVMappingCube = function()
{
    // the final array of uv coord for mapping
    var uvMap = new Float32Array((this._subdivision + 1) * (this._subdivision + 1) * 6 * 2);

    // iterator accross the uv coord
    var it = FORGE.Utils.arrayKeys(uvMap);

    // layout of the texture
    var layout = this._layout.split("");

    // the width/height of a division in uv coord
    // the 1.01 is the default value for expand_coef in the ffmpeg filter
    // see https://github.com/facebook/transform/blob/04ec220a5c066a75d87f9e463b219262f7527421/vf_transform.c#L961
    var u = (1 / 1.01) * ((1 / this._faces.x) / this._subdivision);
    var v = (1 / 1.01) * ((1 / this._faces.y) / this._subdivision);

    // tiny offsets are for compensating the expand_coef of the ffmpeg filter
    // u tiny offset
    var uto = 0.005 * (1 / this._faces.x);
    // v tiny offset
    var vto = 0.005 * (1 / this._faces.y);

    /**
     * Apply the correct UV to the uv map
     * @param  {number} idx
     * @param  {number} x
     * @param  {number} y
     * @param  {number} sub
     * @param  {boolean=} upOrDown
     */
    function applyUVMapForFace(idx, x, y, sub, upOrDown)
    {
        if (idx === -1)
        {
            throw "Unknown face for cube mapping.";
        }

        // iterator
        var i, j, ii, jj;

        // u offset, where is it in the layout, change for each face
        var uo = (idx % x) / x;
        // v offset, where is it in the layout, change for each face
        var vo = 1 - ((1 + parseInt(idx / x, 10)) / y);

        // not the same inversion if up or down
        if (upOrDown)
        {
            // vertical
            for (i = 0, ii = sub; i <= ii; i++)
            {
                // horizontal
                for (j = 0, jj = sub; j <= jj; j++)
                {
                    // u
                    uvMap[it.next().value] = uto + u * j + uo;
                    // v
                    uvMap[it.next().value] = vto + v * i + vo;
                }
            }
        }
        else
        {
            // vertical
            for (i = 0, ii = sub; i <= ii; ii--)
            {
                // horizontal
                for (j = 0, jj = sub; j <= jj; jj--)
                {
                    // u
                    uvMap[it.next().value] = uto + u * jj + uo;
                    // v
                    uvMap[it.next().value] = vto + v * ii + vo;
                }
            }
        }
    }

    applyUVMapForFace(layout.indexOf("R"), this._faces.x, this._faces.y, this._subdivision);
    applyUVMapForFace(layout.indexOf("L"), this._faces.x, this._faces.y, this._subdivision);
    applyUVMapForFace(layout.indexOf("U"), this._faces.x, this._faces.y, this._subdivision, true);
    applyUVMapForFace(layout.indexOf("D"), this._faces.x, this._faces.y, this._subdivision, true);
    applyUVMapForFace(layout.indexOf("B"), this._faces.x, this._faces.y, this._subdivision);
    applyUVMapForFace(layout.indexOf("F"), this._faces.x, this._faces.y, this._subdivision);

    return uvMap;
};

/**
 * Return an array containing each coord for the uv mapping of the sphere geometry
 * @method FORGE.BackgroundMeshRenderer#_setUVMappingSphere
 * @return {Float32Array} The array containing the UVs
 * @private
 */
FORGE.BackgroundMeshRenderer.prototype._setUVMappingSphere = function()
{
    // the final array of uv coord for mapping
    var uvMap = new Float32Array(this._mesh.geometry.attributes.uv.array.byteLength / 4);

    // iterator accross the uv coord
    var it = uvMap.keys();

    var div = this._subdivision;
    var d = 1 / div;

    var ix, iy;

    for (iy = 0; iy <= div; iy++)
    {
        var v = iy * d;

        for (ix = 0; ix <= div; ix++)
        {
            var u = ix * d;
            uvMap[it.next().value] = 1 - u;
            uvMap[it.next().value] = 1 - v;
        }
    }

    return uvMap;
};

/**
 * Return an array containing each coord for the uv mapping
 * @method FORGE.BackgroundMeshRenderer#_setUVMapping
 * @return {Float32Array} The array containing the UVs
 * @private
 */
FORGE.BackgroundMeshRenderer.prototype._setUVMapping = function()
{
    // BoxGeometry uv are not ok, compute them in our own way
    if (this._mesh.geometry instanceof THREE.BoxBufferGeometry)
    {
        return this._setUVMappingCube();
    }

    // Sphere uv are facing backward
    if (this._mesh.geometry instanceof THREE.SphereBufferGeometry)
    {
        return this._setUVMappingSphere();
    }

    return null;
};

/**
 * Clear background.
 * @method FORGE.BackgroundMeshRenderer#_clear
 * @private
 */
FORGE.BackgroundMeshRenderer.prototype._clear = function()
{
    // Draw to clear screen, then clear display object / texture
    this._viewer.renderer.webGLRenderer.clearColor();
};

/**
 * Add quadrilateral coordinates as geometry attribute
 * Used to draw wireframe
 * @method FORGE.BackgroundMeshRenderer#_addQuadrilateralCoordsAttribute
 * @private
 */
FORGE.BackgroundMeshRenderer.prototype._addQuadrilateralCoordsAttribute = function()
{
    if (this._mesh === null || typeof this._mesh.geometry === "undefined")
    {
        return;
    }

    // Quadrilateral is a 2 components system, reduce vertices array size from 3:2
    var size = this._mesh.geometry.attributes.position.array.length * 2 / 3;
    var quadri = new Int8Array(size);
    var it = FORGE.Utils.arrayKeys(quadri);

    var qa = new THREE.Vector2(1, 1);
    var qb = new THREE.Vector2(1, -1);
    var qc = new THREE.Vector2(-1, 1);
    var qd = new THREE.Vector2(-1, -1);

    var ipd = this._subdivision + 1; // indices per dimension
    for (var f = 0; f < 6; f++)
    {
        for (var r=0; r < ipd; r++)
        {
            var q0, q1;

            if (r & 1)
            {
                q0 = qa;
                q1 = qb;
            }
            else
            {
                q0 = qc;
                q1 = qd;
            }

            for (var c=0; c < ipd; c++)
            {
                if (c & 1)
                {
                    quadri[it.next().value] = q1.x;
                    quadri[it.next().value] = q1.y;
                }
                else
                {
                    quadri[it.next().value] = q0.x;
                    quadri[it.next().value] = q0.y;
                }
            }
        }
    }

    this._mesh.geometry.addAttribute("quadrilateralCoords", new THREE.BufferAttribute(quadri, 2));
};

/**
 * Update internals
 * @method FORGE.BackgroundMeshRenderer#_updateInternals
 * @private
 */
FORGE.BackgroundMeshRenderer.prototype._updateInternals = function()
{
    if (this._viewer.renderer.view.current === null)
    {
        this.log("Background renderer cannot update internals without a defined view");
        return;
    }

    var shader;
    if (this._mediaType === FORGE.MediaType.GRID)
    {
        shader = FORGE.Utils.clone(this._viewer.renderer.view.current.shaderWTS).wireframe;
        this.log("Media " + this._mediaType + ", use wireframe shader");
        this._subdivision = 8;
    }
    else
    {
        shader = FORGE.Utils.clone(this._viewer.renderer.view.current.shaderWTS).mapping;
        this.log("Media " + this._mediaType + ", use mapping shader");
    }

    var vertexShader = FORGE.ShaderLib.parseIncludes(shader.vertexShader);
    var fragmentShader = FORGE.ShaderLib.parseIncludes(shader.fragmentShader);

    var material = new THREE.RawShaderMaterial(
    {
        fragmentShader: fragmentShader,
        vertexShader: vertexShader,
        uniforms: /** @type {FORGEUniform} */ (shader.uniforms),
        name: "BackgroundMeshMaterial",
        transparent: true,
        side: THREE.BackSide
    });
    var geometry = null;

    if (this._texture !== null)
    {
        if (this._mesh.material.uniforms.hasOwnProperty("tTexture"))
        {
            material.uniforms.tTexture.value = this._texture;

        }

        if (this._mesh.material.uniforms.hasOwnProperty("tTextureRatio"))
        {
            material.uniforms.tTextureRatio.value = this._texture.image.width / this._texture.image.height;
        }
    }

    if (this._mediaType === FORGE.MediaType.GRID)
    {
        material.uniforms.tColor.value = new THREE.Color(this._gridColor);
        material.blending = THREE.CustomBlending;
        material.blendEquationAlpha = THREE.AddEquation;
        material.blendSrcAlpha = THREE.SrcAlphaFactor;
        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;
    }

    if (this._scene.children.length === 0)
    {
        if (this._mediaFormat === FORGE.MediaFormat.EQUIRECTANGULAR)
        {
            // Sphere mapping of equirectangular texture becomes acceptable with subdivision greater or equal to 64
            this._subdivision = 64;
            geometry = new THREE.SphereBufferGeometry(this._size, this._subdivision, this._subdivision);
            this.log("Create sphere geometry");
        }
        else if (this._mediaFormat === FORGE.MediaFormat.FLAT)
        {
            geometry = new THREE.PlaneBufferGeometry(this._size, this._size);
            this.log("Create plane geometry");
        }
        else
        {
            geometry = new THREE.BoxBufferGeometry(this._size, this._size, this._size, this._subdivision, this._subdivision, this._subdivision);
            this.log("Create box geometry");
        }

        this._mesh = new THREE.Mesh(geometry, material);

        if (this._mediaType === FORGE.MediaType.GRID)
        {
            this._addQuadrilateralCoordsAttribute();
        }

        if (this._mediaFormat === FORGE.MediaFormat.FLAT)
        {
            this._mesh.position.set(0, 0, -this._size * 0.5);
            this._mesh.material.side = THREE.FrontSide;
        }

        // Equirectangular mapping on a sphere needs a yaw shift of PI/2 to set front at center of the texture
        if (this._mediaFormat === FORGE.MediaFormat.EQUIRECTANGULAR)
        {
            this._mesh.rotation.set(0, Math.PI / 2, 0, "YXZ");
        }

        this._scene.add(this._mesh);
    }
    else
    {
        this._mesh = /** @type {THREE.Mesh} */ (this._scene.children[0]);
        this._mesh.material.dispose();
    }

    this._mesh.material = material;
    material.needsUpdate = true;
};

/**
 * Update after view change
 * @method FORGE.BackgroundMeshRenderer#updateAfterViewChange
 */
FORGE.BackgroundMeshRenderer.prototype.updateAfterViewChange = function()
{
    this._updateInternals();

    if (typeof this._mesh.material.uniforms.tTextureRatio !== "undefined")
    {
        this._mesh.material.uniforms.tTextureRatio.value = this._texture.image.width / this._texture.image.height;
    }
};

/**
 * Render routine.
 * Do preliminary job of specific background renderer, then summon superclass method
 * @method FORGE.BackgroundMeshRenderer#render
 * @param {THREE.PerspectiveCamera} camera - perspective camera
 */
FORGE.BackgroundMeshRenderer.prototype.render = function(camera)
{
    if (this._viewer.renderer === null)
    {
        return;
    }

    FORGE.BackgroundRenderer.prototype.render.call(this, camera);
};

/**
 * Destroy sequence.
 * @method FORGE.BackgroundMeshRenderer#destroy
 */
FORGE.BackgroundMeshRenderer.prototype.destroy = function()
{
    this._clear();

    this._displayObject = null;
    this._textureCanvas = null;
    this._textureContext = null;

    if (this._mesh !== null)
    {
        this.log ("Destroy mesh (dispose geometry and material)");
        if (this._mesh.geometry !== null)
        {
            this._mesh.geometry.dispose();
            this._mesh.geometry = null;
        }

        if (this._mesh.material !== null)
        {
            this._mesh.material.dispose();
            this._mesh.material = null;
        }

        this._mesh = null;
    }

    if (this._texture !== null)
    {
        this._texture.dispose();
        this._texture = null;
    }

    FORGE.BackgroundRenderer.prototype.destroy.call(this);
};

/**
 * Get background renderer texture.
 * @name FORGE.BackgroundMeshRenderer#texture
 * @type {string}
 */
Object.defineProperty(FORGE.BackgroundMeshRenderer.prototype, "texture",
{
    /** @this {FORGE.BackgroundMeshRenderer} */
    get: function()
    {
        return this._texture;
    }
});


/**
 * FORGE.BackgroundPyramidRenderer
 * BackgroundPyramidRenderer class.
 *
 * @constructor FORGE.BackgroundPyramidRenderer
 * @extends {FORGE.BackgroundRenderer}
 *
 * @param {FORGE.Viewer} viewer - viewer reference
 * @param {THREE.WebGLRenderTarget} target - render target
 * @param {SceneMediaConfig} config - media config
 */
FORGE.BackgroundPyramidRenderer = function(viewer, target, config)
{
    /**
     * Input scene and media config
     * @name FORGE.BackgroundPyramidRenderer#_config
     * @type {?SceneMediaConfig}
     * @private
     */
    this._config = config;

    /**
     * Current level of the pyramid
     * @type {number}
     * @private
     */
    this._level = 0;

    /**
     * The size of the cube.
     * @type {number}
     * @private
     */
    this._size = 0;

    /**
     * Texture store
     * @type {?FORGE.MediaStore}
     * @private
     */
    this._textureStore = null;

    /**
     * Cache of tiles
     * @type {?Object}
     * @private
     */
    this._tileCache = null;

    /**
     * Number of pixels at current level
     * @type {number}
     * @private
     */
    this._levelPixels = 0;

    /**
     * Minimum fov computed with max level
     * @type {number}
     * @private
     */
    this._fovMin = 0;

    /**
     * Number of tiles for all levels
     * @type {Array<TilesOnLevel>}
     * @private
     */
    this._tilesLevel = null;

    /**
     * List of renderered tiles
     * @type {?Array<FORGE.Tile>}
     * @private
     */
    this._renderList = null;

    /**
     * List of tiles in renderered tiles neighborhood
     * @type {?Array<FORGE.Tile>}
     * @private
     */
    this._renderNeighborList = null;

    /**
     * Enable tile clearing policy
     * @type {boolean}
     * @private
     */
    this._clearTilesEnabled = true;

    /**
     * Number of pixels at current level presented in human readable format
     * @type {string}
     * @private
     */
    this._levelPixelsHumanReadable = "";

    FORGE.BackgroundRenderer.call(this, viewer, target, config, "BackgroundPyramidRenderer");
};

FORGE.BackgroundPyramidRenderer.prototype = Object.create(FORGE.BackgroundRenderer.prototype);
FORGE.BackgroundPyramidRenderer.prototype.constructor = FORGE.BackgroundPyramidRenderer;

/**
 * Max allowed time since a tile has been created before discarding it
 * @type {number}
 */
FORGE.BackgroundPyramidRenderer.MAX_ALLOWED_TIME_SINCE_CREATION_MS = 2000;

/**
 * Max allowed time since a tile has been displayed before discarding it
 * @type {number}
 */
FORGE.BackgroundPyramidRenderer.MAX_ALLOWED_TIME_SINCE_DISPLAY_MS = 3000;

/**
 * Boot routine.
 * @method FORGE.BackgroundPyramidRenderer#_boot
 * @private
 */
FORGE.BackgroundPyramidRenderer.prototype._boot = function()
{
    FORGE.BackgroundRenderer.prototype._boot.call(this);

    this.log("boot");

    this._parseConfig(this._config);

    this._size = 2 * FORGE.RenderManager.DEPTH_FAR;

    this._tileCache = {};
    this._textureStore = this._viewer.story.scene.media.store;

    this._camera = this._viewer.renderer.camera.main;
    this._viewer.camera.onChange.add(this._onCameraChange, this);

    if (typeof this._config.preview !== "undefined")
    {
        this._createPreview();
    }

    for (var f = 0; f < 6; f++)
    {
        var face = Object.keys(FORGE.MediaStore.CUBE_FACE_CONFIG)[f];

        for (var y = 0, ty = this.nbTilesPerAxis(0, "y"); y < ty; y++)
        {
            for (var x = 0, tx = this.nbTilesPerAxis(0, "x"); x < tx; x++)
            {
                this.getTile(null, 0, face, x, y, "pyramid init");
            }
        }
    }
};

/**
 * Parse configuration.
 * @method FORGE.BackgroundPyramidRenderer#_parseConfig
 * @private
 */
FORGE.BackgroundPyramidRenderer.prototype._parseConfig = function(config)
{
    // Store all tiles number per level for quick access
    this._tilesLevel = [];
    if (typeof this._config.source.levels !== "undefined")
    {
        var level;

        for (var l = 0, levels = this._config.source.levels.length; l < levels; l++)
        {
            level = this._config.source.levels[l];
            this._tilesLevel.push({
                x: level.width / level.tile,
                y: level.height / level.tile
            });
        }
    }

    // Set min fov to be used to reach max level of resolution
    this._fovMin = 1.01 * FORGE.Math.degToRad(this._pyramidLevelToCameraFov(config.source.levels.length - 1));
};

/**
 * Create the preview (sub zero level)
 * @method FORGE.BackgroundPyramidRenderer.prototype._createPreview
 * @private
 */
FORGE.BackgroundPyramidRenderer.prototype._createPreview = function()
{
    for (var f = 0; f < 6; f++)
    {
        var face = Object.keys(FORGE.MediaStore.CUBE_FACE_CONFIG)[f];

        this.getTile(null, FORGE.Tile.PREVIEW, face, 0, 0, "pyramid preview");
    }

    if (typeof(this._tileCache[FORGE.Tile.PREVIEW]) !== "undefined")
    {
        this._tileCache[FORGE.Tile.PREVIEW].forEach(function(tile)
        {
            this._scene.add(tile);
        }.bind(this));
    }
};

/**
 * Clear routine.
 * @method FORGE.BackgroundPyramidRenderer#_clear
 * @private
 */
FORGE.BackgroundPyramidRenderer.prototype._clear = function()
{
    // Draw to clear screen, then clear display object / texture
    this._viewer.renderer.webGLRenderer.clearColor();
};


/**
 * Update after view change
 * @method FORGE.BackgroundPyramidRenderer#updateAfterViewChange
 */
FORGE.BackgroundPyramidRenderer.prototype.updateAfterViewChange = function()
{
    if (this._viewer.view.type !== FORGE.ViewType.RECTILINEAR)
    {
        this.warn("Only Rectilinear view is supported for multi resolution scene");
        this._viewer.view.type = FORGE.ViewType.RECTILINEAR;
    }
};

/**
 * Get pyramid level for a given fov
 * @method FORGE.BackgroundPyramidRenderer#_cameraFovToPyramidLevel
 * @param {number} fov camera field of view [degrees]
 * @private
 */
FORGE.BackgroundPyramidRenderer.prototype._cameraFovToPyramidLevel = function(fov)
{
    // compute the optimal number of tiles on the y axis for this fov
    var tiles = Math.floor(180 / fov);

    // check the nearest level to this optimal number
    var level = this._tilesLevel.findIndex(function(lvl)
    {
        return lvl.y >= tiles;
    });

    if (level === -1)
    {
        level = this._tilesLevel.length - 1;
    }

    return Math.max(0, level);
};

/**
 * Get fov threshold from a pyramid level
 * @method FORGE.BackgroundPyramidRenderer#_pyramidLevelToCameraFov
 * @param {number} level pyramid level
 * @return {number} fov camera field of view [degrees]
 * @private
 */
FORGE.BackgroundPyramidRenderer.prototype._pyramidLevelToCameraFov = function(level)
{
    var lvl = this._tilesLevel[level];
    var fov = 90 / lvl.y;
    return fov;
};

/**
 * Camera change callback.
 * @method FORGE.BackgroundPyramidRenderer#_onCameraChange
 * @private
 */
FORGE.BackgroundPyramidRenderer.prototype._onCameraChange = function(event)
{
    var camera = event.emitter;
    var fov = camera.fov;

    var level = this._cameraFovToPyramidLevel(fov);
    if (this._level !== level)
    {
        this.selectLevel(level);
    }
};

/**
 * Tile destroyed event handler
 * @param {FORGE.Event} event - event
 * @method FORGE.BackgroundPyramidRenderer#_onTileDestroyed
 * @private
 */
FORGE.BackgroundPyramidRenderer.prototype._onTileDestroyed = function(event)
{
    var tile = event.emitter;
    tile.onDestroy.remove(this._onTileDestroyed, this);
    this._tileCache[tile.level].delete(tile.name);
    this._scene.remove(tile);
};

/**
 * Get XnYn normalized tile coords at a given level
 * @method FORGE.BackgroundPyramidRenderer#_levelXYToXnYn
 * @param {number} level - pyramid level
 * @param {THREE.Vector2} XY - coordinates
 * @return {THREE.Vector2} normalized tile coordinates vector
 * @private
 */
FORGE.BackgroundPyramidRenderer.prototype._levelXYToXnYn = function(level, XY)
{
    var tx = this.nbTilesPerAxis(level, "x"),
        ty = this.nbTilesPerAxis(level, "y");

    return XY.divide(new THREE.Vector2(tx, ty));
};

/**
 * Get XY tile coords at a given level depending on normalized coordinates
 * @method FORGE.BackgroundPyramidRenderer#_levelXnYnToXY
 * @param {number} level - pyramid level
 * @param {THREE.Vector2} xnyn - normalized coordinates
 * @return {THREE.Vector2} tile coordinates vector
 * @private
 */
FORGE.BackgroundPyramidRenderer.prototype._levelXnYnToXY = function(level, xnyn)
{
    var tx = this.nbTilesPerAxis(level, "x"),
        ty = this.nbTilesPerAxis(level, "y");

    var x = Math.min(Math.floor(tx * xnyn.x), Math.ceil(tx) - 1);
    var y = Math.min(Math.floor(ty * xnyn.y), Math.ceil(ty) - 1);

    return new THREE.Vector2(x, y);
};

/**
 * Tile clearing routine.
 * Clear tile policy
 * Only applies to tiles with non zero level
 * Delete all tiles with zero opacity
 * Delete all tiles that has been created more than 2s ago and have never been displayed
 * Delete all tiles that has not been displayed since 30s
 * @method FORGE.BackgroundPyramidRenderer#_clearTiles
 * @private
 */
FORGE.BackgroundPyramidRenderer.prototype._clearTiles = function()
{
    if (this._clearTilesEnabled === false)
    {
        return;
    }

    var clearList = [];

    var now = Date.now();

    this._scene.children.forEach(function(tile)
    {
        // Tile with level greater than renderer level -> always removed
        var tileLevelHigher = tile.level > this._level;

        // Tile with level different than renderer level
        var tileLevelEqualsCurrent = tile.level === this._level;

        // Tile with level different than renderer level
        var tileLevelPreview = tile.level === FORGE.Tile.PREVIEW;

        // Tile with level different than renderer level
        var tileLevelZero = tile.level === 0;

        // Only clear tiles from level different from current and higher than preview and zero
        var tileLevelClearable = !tileLevelEqualsCurrent && !tileLevelPreview && !tileLevelZero;

        // Tile has a texture set in its material map
        // Never clear a tile without a texture set to keep parents of the current displayed tile
        // available (with their texture) when the user quickly zooms out
        var tileHasATexture = tile.textureIsSet === true;

        // Tile is part of the neighbour list
        var isANeighbourTile = this._renderNeighborList.indexOf(tile) !== -1;

        // Tile has never been displayed and time to live delay has been exceeded
        var timeSinceCreate = now - tile.createTS;
        var tileNeverDisplayedAndTTLExceeded = tile.displayTS === null
            && timeSinceCreate > FORGE.BackgroundPyramidRenderer.MAX_ALLOWED_TIME_SINCE_CREATION_MS;

        // Tile has been displayed a too long time ago
        var timeSinceDisplay = now - tile.displayTS;
        var tileNotDisplayedRecentlyEnough = tile.displayTS !== null
            && timeSinceDisplay > FORGE.BackgroundPyramidRenderer.MAX_ALLOWED_TIME_SINCE_DISPLAY_MS;

        // Tile is out of delay and could be cleared
        // This flag will force clearing tiles with lower levels not displayed for a while
        // Tiles at lower level (parents) rendered but hidden by current level tiles should not
        // be cleared to keep them available immediatly when zooming out 
        var tileOutOfDelay = tileNeverDisplayedAndTTLExceeded || tileNotDisplayedRecentlyEnough;

        // Always clear all tiles from higher levels (performance and aliasing issues)
        // OR
        // Clear tiles from lower levels (except preview or zero) AND out of delay
        // AND with a texture set AND out of the neighbour list
        if (tileLevelHigher || (tileLevelClearable && tileOutOfDelay && tileHasATexture && !isANeighbourTile))
        {
            clearList.push(tile);
        }

    }.bind(this));

    clearList.forEach(function(tile)
    {
        this._scene.remove(tile);
    }.bind(this));
};

/**
 * Get parent tile reference and create it if does not exist
 * @method FORGE.BackgroundPyramidRenderer#getParentTile
 * @param {FORGE.Tile} tile - tile
 * @return {FORGE.Tile} parent tile or null if it has no parent (level 0)
 */
FORGE.BackgroundPyramidRenderer.prototype.getParentTile = function(tile)
{
    if (tile.level === FORGE.Tile.PREVIEW)
    {
        return null;
    }

    if (tile.level === 0)
    {
        return this.getTile(null, FORGE.Tile.PREVIEW, tile.face, 0, 0, "pyramid preview");
    }

    var xnyn = this._levelXYToXnYn(tile.level, new THREE.Vector2(tile.x, tile.y));

    var parentLevel = tile.level - 1;
    var parentCoords = this._levelXnYnToXY(parentLevel, xnyn);

    return this.getTile(null, parentLevel, tile.face, parentCoords.x, parentCoords.y, "parent of " + tile.name);
};

/**
 * Get tile
 * Lookup in cache first or create it if not already in cache
 * @method FORGE.BackgroundPyramidRenderer#getTile
 */
FORGE.BackgroundPyramidRenderer.prototype.getTile = function(parent, level, face, x, y, creator)
{
    if (typeof this._tileCache[level] === "undefined")
    {
        this._tileCache[level] = new Map();
    }

    var name = FORGE.Tile.createName(face, level, x, y);

    var tile = this._tileCache[level].get(name);

    if (typeof tile === "undefined")
    {
        tile = new FORGE.Tile(parent, this, x, y, level, face, creator);

        tile.onDestroy.add(this._onTileDestroyed, this);
        this.log("Create tile " + tile.name + " (" + creator + ")");
        this._tileCache[level].set(name, tile);
    }

    if (this._scene.children.indexOf(tile) === -1)
    {
        this._scene.add(tile);
    }

    return tile;
};

/**
 * Get number of tiles per axis for a given level
 * @param {number} level - pyramid level
 * @param {string} axis - axis ("x" or "y")
 * @method FORGE.BackgroundPyramidRenderer#nbTilesPerAxis
 */
FORGE.BackgroundPyramidRenderer.prototype.nbTilesPerAxis = function(level, axis)
{
    if (this._tilesLevel === null || level === FORGE.Tile.PREVIEW)
    {
        return 1;
    }

    var lvl = this._tilesLevel[level];

    if (typeof lvl !== "undefined")
    {
        if (axis === "x")
        {
            return lvl.x;
        }
        else if (axis === "y")
        {
            return lvl.y;
        }
    }

    return Math.pow(2, level);
};

/**
 * Get number of tiles for a given level
 * @method FORGE.BackgroundPyramidRenderer#nbTiles
 */
FORGE.BackgroundPyramidRenderer.prototype.nbTiles = function(level)
{
    return 6 * this.nbTilesPerAxis(level, "x") * this.nbTilesPerAxis(level, "y");
};

/**
 * Get tile size at a given level (world units)
 * @method FORGE.BackgroundPyramidRenderer#tileSize
 * @return {FORGE.Size} size of a tile in world units
 */
FORGE.BackgroundPyramidRenderer.prototype.tileSize = function(level)
{
    return new FORGE.Size(this._size / this.nbTilesPerAxis(level, "x"), this._size / this.nbTilesPerAxis(level, "y"));
};

/**
 * Select current level for the pyramid
 * @method FORGE.BackgroundPyramidRenderer#selectLevel
 * @param {number} level pyramid level
 */
FORGE.BackgroundPyramidRenderer.prototype.selectLevel = function(level)
{
    this._level = level;

    var tilesOnAxisX = this.nbTilesPerAxis(this._level, "x");
    var tilesOnAxisY = this.nbTilesPerAxis(this._level, "y");

    this.log("Tiles per axis - X: " + tilesOnAxisX + ", Y: " + tilesOnAxisY);

    if (typeof(this._tileCache[this._level]) !== "undefined")
    {
        this._tileCache[this._level].forEach(function(tile)
        {
            this._scene.add(tile);
        }.bind(this));
    }

    var levelConfig;
    if (level === FORGE.Tile.PREVIEW)
    {
        levelConfig = this._config.preview;
        levelConfig.width = levelConfig.tile;
        levelConfig.height = levelConfig.tile;
    }
    else
    {
        levelConfig = this._config.source.levels[level];
    }

    // Compute pixels count
    var tilePixels = levelConfig.width * levelConfig.height;

    this._levelPixels = this.nbTiles(this._level) * tilePixels;

    var prefixes = {
        3: "kilo",
        6: "mega",
        9: "giga",
        12: "tera",
        15: "peta",
        18: "exa",
        21: "zetta",
        24: "yotta"
    };

    var rank = Math.floor(Math.log(this._levelPixels) / (Math.LN10 * 3)) * 3;
    var humanPixels = this._levelPixels / Math.pow(10, rank);

    var prefix = "";
    if (rank >= 27)
    {
        prefix = " too many ";
    }
    else if (rank >= 3)
    {
        prefix = " " + prefixes[rank];
    }

    this._levelPixelsHumanReadable = humanPixels.toFixed(1) + prefix + "pixels";
    this.log("Select new level: " + level + ", " + this._levelPixelsHumanReadable + " (" + this._levelPixels + ")");
};

/**
 * Add tile to render list
 * @method FORGE.BackgroundPyramidRenderer#addToRenderList
 * @param {FORGE.Tile} tile - tile
 */
FORGE.BackgroundPyramidRenderer.prototype.addToRenderList = function(tile)
{
    this._renderList.push(tile);

    // Add tile neighbours to the list only if its level is the current one
    if (tile.level === this._level)
    {
        this._renderNeighborList = this._renderNeighborList.concat(tile.neighbours);
    }
};

/**
 * Render routine.
 * Do preliminary job of specific background renderer, then summon superclass method
 * @method FORGE.BackgroundPyramidRenderer#render
 * @param {THREE.PerspectiveCamera} camera - perspective camera
 */
FORGE.BackgroundPyramidRenderer.prototype.render = function(camera)
{
    // Renderer should find if some tile at current level are currently rendered
    this._renderList = [];
    this._renderNeighborList = [];

    FORGE.BackgroundRenderer.prototype.render.call(this, camera);

    this._renderNeighborList = FORGE.Utils.arrayUnique(this._renderNeighborList);

    this._clearTiles();
};

/**
 * Destroy sequence.
 * @method FORGE.BackgroundPyramidRenderer#destroy
 */
FORGE.BackgroundPyramidRenderer.prototype.destroy = function()
{
    this._viewer.camera.onChange.remove(this._onCameraChange, this);

    this._clear();

    var tile;
    for (var level in this._tileCache)
    {
        while (this._tileCache[level].length)
        {
            tile = this._tileCache[level].pop();
            tile.destroy();
        }

        this._tileCache[level] = null;
    }

    this._textureStore = null;
    this._tileCache = null;
    this._renderNeighborList.length = 0;
    this._renderNeighborList = null;
    this._renderList.length = 0;
    this._renderList = null;
    this._config = null;

    FORGE.BackgroundRenderer.prototype.destroy.call(this);
};

/**
 * Get cube size in world units.
 * @name FORGE.BackgroundPyramidRenderer#cubeSize
 * @type {number}
 */
Object.defineProperty(FORGE.BackgroundPyramidRenderer.prototype, "cubeSize",
{
    /** @this {FORGE.BackgroundPyramidRenderer} */
    get: function()
    {
        return this._size;
    }
});

/**
 * Get texture store.
 * @name FORGE.BackgroundPyramidRenderer#textureStore
 * @type {FORGE.MediaStore}
 */
Object.defineProperty(FORGE.BackgroundPyramidRenderer.prototype, "textureStore",
{
    /** @this {FORGE.BackgroundPyramidRenderer} */
    get: function()
    {
        return this._textureStore;
    }
});

/**
 * Get pyramid max level.
 * @name FORGE.BackgroundPyramidRenderer#levelMax
 * @type {string}
 */
Object.defineProperty(FORGE.BackgroundPyramidRenderer.prototype, "levelMax",
{
    /** @this {FORGE.BackgroundPyramidRenderer} */
    get: function()
    {
        return this._config.source.levels.length - 1;
    }
});

/**
 * Get pyramid current level.
 * @name FORGE.BackgroundPyramidRenderer#level
 * @type {string}
 */
Object.defineProperty(FORGE.BackgroundPyramidRenderer.prototype, "level",
{
    /** @this {FORGE.BackgroundPyramidRenderer} */
    get: function()
    {
        return this._level;
    }
});

/**
 * Get number of pixels at current level.
 * @name FORGE.BackgroundPyramidRenderer#pixelsAtCurrentLevel
 * @type {number}
 */
Object.defineProperty(FORGE.BackgroundPyramidRenderer.prototype, "pixelsAtCurrentLevel",
{
    /** @this {FORGE.BackgroundPyramidRenderer} */
    get: function()
    {
        return this._levelPixels;
    }
});

/**
 * Get number of pixels at current level presented as human readable string.
 * @name FORGE.BackgroundPyramidRenderer#pixelsAtCurrentLevelHumanReadable
 * @type {string}
 */
Object.defineProperty(FORGE.BackgroundPyramidRenderer.prototype, "pixelsAtCurrentLevelHumanReadable",
{
    /** @this {FORGE.BackgroundPyramidRenderer} */
    get: function()
    {
        return this._levelPixelsHumanReadable;
    }
});

/**
 * Get fov min.
 * @name FORGE.BackgroundPyramidRenderer#fovMin
 * @type {number}
 */
Object.defineProperty(FORGE.BackgroundPyramidRenderer.prototype, "fovMin",
{
    /** @this {FORGE.BackgroundPyramidRenderer} */
    get: function()
    {
        return this._fovMin;
    }
});

/**
 * Get number of tiles on axis X for current level.
 * @name FORGE.BackgroundPyramidRenderer#tilesOnAxisX
 * @type {number}
 */
Object.defineProperty(FORGE.BackgroundPyramidRenderer.prototype, "tilesOnAxisX",
{
    /** @this {FORGE.BackgroundPyramidRenderer} */
    get: function()
    {
        return this.nbTilesPerAxis(this._level, "x");
    }
});

/**
 * Get number of tiles on axis Y for current level.
 * @name FORGE.BackgroundPyramidRenderer#tilesOnAxisY
 * @type {number}
 */
Object.defineProperty(FORGE.BackgroundPyramidRenderer.prototype, "tilesOnAxisY",
{
    /** @this {FORGE.BackgroundPyramidRenderer} */
    get: function()
    {
        return this.nbTilesPerAxis(this._level, "y");
    }
});

/**
 * FORGE.BackgroundShaderRenderer
 * BackgroundShaderRenderer class.
 *
 * @constructor FORGE.BackgroundShaderRenderer
 * @param {FORGE.Viewer} viewer - viewer reference
 * @param {THREE.WebGLRenderTarget} target - render target
 * @param {SceneMediaOptionsConfig} options - the options for the cubemap
 * @extends {FORGE.BackgroundRenderer}
 */
FORGE.BackgroundShaderRenderer = function(viewer, target, options)
{
    /**
     * Display object (image, canvas or video)
     * @name FORGE.BackgroundShaderRenderer#_displayObject
     * @type {FORGE.DisplayObject}
     * @private
     */
    this._displayObject = null;

    /**
     * Texture used for video rendering
     * @name FORGE.BackgroundShaderRenderer#_texture
     * @type {THREE.Texture}
     * @private
     */
    this._texture = null;

    /**
     * Texture canvas used for video rendering
     * @name FORGE.BackgroundShaderRenderer#_textureCanvas
     * @type {Element|HTMLCanvasElement}
     * @private
     */
    this._textureCanvas = null;

    /**
     * Texture context associated with texture canvas
     * @name FORGE.BackgroundShaderRenderer#_textureContext
     * @type {CanvasRenderingContext2D}
     * @private
     */
    this._textureContext = null;

    /**
     * When source is a video, a reduction factor can be set to improve perf by lowering quality
     * @name FORGE.BackgroundShaderRenderer#_videoReductionFactor
     * @type {number}
     * @private
     */
    this._videoReductionFactor = 1;

    FORGE.BackgroundRenderer.call(this, viewer, target, options, "BackgroundShaderRenderer");
};

FORGE.BackgroundShaderRenderer.prototype = Object.create(FORGE.BackgroundRenderer.prototype);
FORGE.BackgroundShaderRenderer.prototype.constructor = FORGE.BackgroundShaderRenderer;

/**
 * Init routine.
 * @method FORGE.BackgroundShaderRenderer#_boot
 * @private
 */
FORGE.BackgroundShaderRenderer.prototype._boot = function()
{
    FORGE.BackgroundRenderer.prototype._boot.call(this);

    // Finalize now
    this._updateInternals();

    // Set orthographic camera
    this._camera = new THREE.OrthographicCamera(-1, 1, 1, -1, -1, 1);

    // Debug: attach scene to window context to expose it into Three.js Inspector
    // window.scene = this._scene;
};

/**
 * Set display object.
 * @method FORGE.BackgroundShaderRenderer#_setDisplayObject
 * @private
 */
FORGE.BackgroundShaderRenderer.prototype._setDisplayObject = function(displayObject)
{
    this._displayObject = displayObject;

    if (FORGE.Utils.isTypeOf(displayObject, "Image") || FORGE.Utils.isTypeOf(displayObject, "Canvas"))
    {
        this._texture = new THREE.Texture();
        this._texture.image = displayObject.element;
    }
    else if (FORGE.Utils.isTypeOf(displayObject, ["VideoHTML5", "VideoDash"]))
    {
        // Evil hack from Hell
        // Reduce texture size for big videos on safari
        if (FORGE.Device.browser.toLowerCase() === "safari" && displayObject.originalHeight > 1440)
        {
            this._videoReductionFactor = 2;
        }

        if (this._displayObject.onQualityChange.has(this._mediaQualityChangeHandler, this))
        {
            this._displayObject.onQualityChange.remove(this._mediaQualityChangeHandler, this);
        }

        this._displayObject.onQualityChange.add(this._mediaQualityChangeHandler, this);

        this._textureCanvas = document.createElement("canvas");
        this._textureCanvas.width = displayObject.originalWidth / this._videoReductionFactor;
        this._textureCanvas.height = displayObject.originalHeight / this._videoReductionFactor;
        this._textureContext = this._textureCanvas.getContext("2d");
        this._texture = new THREE.Texture(this._textureCanvas);
    }
    else
    {
        throw "Wrong type of display object " + displayObject.className;
    }

    this._texture.format = THREE.RGBFormat;
    this._texture.mapping = THREE.Texture.DEFAULT_MAPPING;
    this._texture.magFilter = THREE.LinearFilter;
    this._texture.wrapS = THREE.ClampToEdgeWrapping;
    this._texture.wrapT = THREE.ClampToEdgeWrapping;

    this._texture.generateMipmaps = false;
    this._texture.minFilter = THREE.LinearFilter;

    if (this._mediaFormat === FORGE.MediaFormat.FLAT &&
        FORGE.Math.isPowerOfTwo(displayObject.width) && FORGE.Math.isPowerOfTwo(displayObject.height))
    {
        // Enable mipmaps for flat rendering to avoid aliasing
        this._texture.generateMipmaps = true;
        this._texture.minFilter = THREE.LinearMipMapLinearFilter;
    }

    this._texture.needsUpdate = true;

    this._mesh.material.uniforms.tTexture.value = this._texture;

    if (this._mesh.material.uniforms.hasOwnProperty("tTextureRatio"))
    {
        this._mesh.material.uniforms.tTextureRatio.value = this._texture.image.width / this._texture.image.height;
    }

    if (this._mesh.material.uniforms.hasOwnProperty("tTextureSize"))
    {
        this._mesh.material.uniforms.tTextureSize.value = new THREE.Vector2(this._texture.image.width, this._texture.image.height);
    }
};

/**
 * Handler of media quality change event
 * @method FORGE.BackgroundShaderRenderer#_mediaQualityChangeHandler
 * @private
 */
FORGE.BackgroundShaderRenderer.prototype._mediaQualityChangeHandler = function(event)
{
    this.log("Media quality has changed");

    var displayObject = event.emitter;
    this._textureCanvas.width = displayObject.originalWidth / this._videoReductionFactor;
    this._textureCanvas.height = displayObject.originalHeight / this._videoReductionFactor;
};

/**
 * Update internals
 * @method FORGE.BackgroundShaderRenderer#_updateInternals
 * @private
 */
FORGE.BackgroundShaderRenderer.prototype._updateInternals = function()
{
    var shaderSTW = this._viewer.renderer.view.current.shaderSTW;

    var vertexShader = FORGE.ShaderLib.parseIncludes(shaderSTW.vertexShader);
    var fragmentShader = FORGE.ShaderLib.parseIncludes(shaderSTW.fragmentShader);

    var material = new THREE.ShaderMaterial({
        uniforms: /** @type {FORGEUniform} */ (shaderSTW.uniforms),
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        side: THREE.FrontSide
    });

    if (this._texture !== null)
    {
        material.uniforms.tTexture.value = this._texture;
    }

    if (this._scene.children.length === 0)
    {
        var geometry = new THREE.PlaneBufferGeometry( 2, 2 );
        this._mesh = new THREE.Mesh(geometry, material);
        this._scene.add(this._mesh);
    }
    else
    {
        this._mesh = /** @type {THREE.Mesh} */ (this._scene.children[0]);
        this._mesh.material = null;
    }

    this._mesh.material = material;
    material.needsUpdate = true;
};

/**
 * Clear background.
 * @method FORGE.BackgroundShaderRenderer#clear
 * @private
 */
FORGE.BackgroundShaderRenderer.prototype._clear = function()
{
    // Draw to clear screen, then clear display object / texture
    this._viewer.renderer.webGLRenderer.clearColor();
};

/**
 * Do preliminary job of specific background renderer, then summon superclass method
 * @method FORGE.BackgroundShaderRenderer#render
 * @param {?THREE.PerspectiveCamera} camera perspective camera
 */
FORGE.BackgroundShaderRenderer.prototype.render = function(camera)
{
    if (this._viewer.renderer === null)
    {
        return;
    }

    camera = null; //@closure

    FORGE.BackgroundRenderer.prototype.render.call(this, camera);
};

/**
 * Update after view change
 * @method FORGE.BackgroundShaderRenderer#updateAfterViewChange
 */
FORGE.BackgroundShaderRenderer.prototype.updateAfterViewChange = function()
{
    this._updateInternals();

    if (this._texture !== null && typeof this._texture.image !== "undefined")
    {
        if (this._mesh.material.uniforms.hasOwnProperty("tTextureRatio"))
        {
            this._mesh.material.uniforms.tTextureRatio.value = this._texture.image.width / this._texture.image.height;
        }

        if (this._mesh.material.uniforms.hasOwnProperty("tTextureSize"))
        {
            this._mesh.material.uniforms.tTextureSize.value = new THREE.Vector2(this._texture.image.width, this._texture.image.height);
        }
    }
};

/**
 * Destroy sequence.
 * @method FORGE.BackgroundShaderRenderer#destroy
 */
FORGE.BackgroundShaderRenderer.prototype.destroy = function()
{
    this._clear();

    if (typeof this._displayObject.onQualityChange !== "undefined" &&
        this._displayObject.onQualityChange.has(this._mediaQualityChangeHandler, this))
    {
        this._displayObject.onQualityChange.remove(this._mediaQualityChangeHandler, this);
    }

    this._displayObject = null;
    this._textureCanvas = null;
    this._textureContext = null;

    if (this._texture !== null)
    {
        this._texture.dispose();
        this._texture = null;
    }

    FORGE.BackgroundRenderer.prototype.destroy.call(this);
};

/**
 * Get background renderer texture.
 * @name FORGE.BackgroundShaderRenderer#texture
 * @type {string}
 */
Object.defineProperty(FORGE.BackgroundShaderRenderer.prototype, "texture",
{
    /** @this {FORGE.BackgroundShaderRenderer} */
    get: function()
    {
        return this._texture;
    }
});
/**
 * FORGE.PostProcessing
 * Post processing class.
 *
 * @constructor FORGE.PostProcessing
 * @param {FORGE.Viewer} viewer {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.PostProcessing = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.PostProcessing#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Input config.
     * @name FORGE.PostProcessing#_config
     * @type {?FXConfig}
     * @private
     */
    this._config = null;

    /**
     * Shader pass sets.
     * @name FORGE.PostProcessing#_sets
     * @type {Object<string, Array<FX>>}
     * @private
     */
    this._sets = null;

    FORGE.BaseObject.call(this, "PostProcessing");

    this._boot();
};

FORGE.PostProcessing.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.PostProcessing.prototype.constructor = FORGE.PostProcessing;


/**
 * Init routine
 * @method FORGE.PostProcessing#_boot
 * @private
 */
FORGE.PostProcessing.prototype._boot = function()
{
    this._sets = {};
};

/**
 * Configuration parsing
 * @method FORGE.PostProcessing#_parseConfig
 * @param {FXConfig} config input media configuration
 * @private
 */
FORGE.PostProcessing.prototype._parseConfig = function(config)
{
    this._uid = config.uid;

    if (typeof config.fxSets !== "undefined" && config.fxSets.length > 0)
    {
        // Create sets of fx configuration
        for (var i = 0, ii = config.fxSets.length; i < ii; i++)
        {
            var fxConfig = config.fxSets[i];
            this._sets[fxConfig.uid] = fxConfig.set;
        }
    }
};

/**
 * Parse shader config
 * @method FORGE.PostProcessing#_parseShaderConfig
 * @param {FX} shaderConfig - a shader configuration
 * @return {THREE.Pass} pass to be added to the render pipeline
 */
FORGE.PostProcessing.prototype._parseShaderConfig = function(shaderConfig)
{
    var shader = THREE[shaderConfig.type];
    var pass = new FORGE.ShaderPass(shaderConfig.uid, shaderConfig.type, shader);

    if (typeof pass.uniforms !== "undefined")
    {
        for (var param in shaderConfig.params)
        {
            var paramValue = shaderConfig.params[param];
            var value = paramValue;

            // Check if param is an object to build
            if (typeof paramValue === "object" && paramValue.hasOwnProperty("type") && paramValue.hasOwnProperty("args"))
            {
                var args = paramValue.args;
                switch (paramValue.type)
                {
                    case "THREE.Color":
                        if (args.length === 3)
                        {
                            value = new THREE.Color(args[0], args[1], args[2]);
                        }
                        else if (typeof args === "string" || typeof args === "number")
                        {
                            value = new THREE.Color(args);
                        }
                        else
                        {
                            throw new Error("Cannot create THREE.Color with " + (typeof args) + " (length " + args.length + ")");
                        }
                        break;

                    case "THREE.Vector2":
                        value = new THREE.Vector2(args[0], args[1]);
                        break;

                    case "THREE.Vector3":
                        value = new THREE.Vector3(args[0], args[1], args[2]);
                        break;
                }
            }

            pass.uniforms[param].value = value;
        }
    }

    return pass;
};

/**
 * Parse shader config
 * @method FORGE.PostProcessing#_parsePassConfig
 * @param {FX} passConfig - a pass configuration
 * @return {THREE.Pass} pass to be added to the render pipeline
 */
FORGE.PostProcessing.prototype._parsePassConfig = function(passConfig)
{
    var constructor = THREE[passConfig.type];

    var args = [];
    if (typeof passConfig.args !== "undefined")
    {
        // If args is an array, feed constructor with it, else create array from values if it's an object
        if (passConfig.args instanceof Array)
        {
            args = [null].concat(passConfig.args);
        }
        else
        {
            args = [null];
            for (var prop in passConfig.args)
            {
                args.push(passConfig.args[prop]);
            }
        }
    }

    var pass = new (Function.prototype.bind.apply(constructor, args));
    pass.uid = passConfig.uid;

    if (typeof passConfig.params !== "undefined")
    {
        for (var param in passConfig.params)
        {
            pass[param] = passConfig.params[param];    
        }        
    }

    return pass;
};

/**
 * Parse shader passes from FX configuration object
 * @method FORGE.PostProcessing#parseShaderPasses
 * @param {Array<FX>} fxConfig - a set of FX
 * @return {Array<THREE.ShaderPass>} array of shader passes
 */
FORGE.PostProcessing.prototype.parseShaderPasses = function(fxConfig)
{
    if (typeof fxConfig === "undefined" ||
        fxConfig === null ||
        fxConfig.length === 0)
    {
        return [];
    }

    var passes = [];

    for (var j = 0, jj = fxConfig.length; j < jj; j++)
    {
        var fx = /** type {FX} */ (fxConfig[j]);

        if (!THREE.hasOwnProperty(fx.type))
        {
            this.warn("Unknown image effect (" + fx.type + ")");
            continue;
        }

        var pass = null;
        if (fx.type.indexOf("Shader") != -1)
        {
            pass = this._parseShaderConfig(fx);
        }
        else if (fx.type.indexOf("Pass") != -1)
        {
            pass = this._parsePassConfig(fx);
        }

        if (pass !== null)
        {
            passes.push(pass);
        }
    }

    return passes;
};

/**
 * Add a post processing config.
 * @method FORGE.PostProcessing#addConfig
 * @param {string} uid fx unique identifier
 * @return {Array<FX>} fx set
 */
FORGE.PostProcessing.prototype.getFxSetByUID = function(uid)
{
    return this._sets[uid];
};

/**
 * Add a post processing config.
 * @method FORGE.PostProcessing#addConfig
 * @param {FXConfig} config - The config you want to add.
 */
FORGE.PostProcessing.prototype.addConfig = function(config)
{
    this._config = config;
    this._parseConfig(this._config);
};

/**
 * Destroy sequence
 * @method FORGE.PostProcessing#destroy
 */
FORGE.PostProcessing.prototype.destroy = function()
{
    this._viewer = null;
    this._sets = null;
};

/**
 * @namespace {Object} FORGE.EffectComposerType
 */
FORGE.EffectComposerType = {};

/**
 * Main effect composer
 * @name FORGE.EffectComposerType.MAIN
 * @type {string}
 * @const
 */
FORGE.EffectComposerType.MAIN = "main";

/**
 * Render effect composer
 * @name FORGE.EffectComposerType.RENDER
 * @type {string}
 * @const
 */
FORGE.EffectComposerType.RENDER = "render";

/**
 * Picking effect composer
 * @name FORGE.EffectComposerType.PICKING
 * @type {string}
 * @const
 */
FORGE.EffectComposerType.PICKING = "picking";

/**
 * EffectComposer class.
 *
 * Used to feed time to shader when uniform is declared
 *
 * @constructor FORGE.EffectComposer
 * @param {string} type - effect composer type
 * @param {THREE.WebGLRenderer} renderer - WebGL renderer
 * @param {THREE.WebGLRenderTarget=} renderTarget - render target
 * @extends {THREE.EffectComposer}
 */
FORGE.EffectComposer = function(type, renderer, renderTarget)
{
    /**
     * Effect composer type
     * @name FORGE.EffectComposer#_type
     * @type {string}
     * @private
     */
    this._type = type || FORGE.EffectComposerType.RENDER;

    /**
     * Rendering target
     * @name FORGE.EffectComposer#_renderTarget
     * @type {?THREE.WebGLRenderTarget}
     * @private
     */
    this._renderTarget = renderTarget || null;

    /**
     * Name
     * @name FORGE.EffectComposer#_name
     * @type {string}
     * @private
     */
    this._name = "";

    /**
     * Enabled flag
     * @name FORGE.EffectComposer#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * Sum of clock deltas.
     * @name FORGE.ShaderPass#_deltaSum
     * @type {number}
     * @private
     */
    this._deltaSum = 0;

    THREE.EffectComposer.call(this, renderer, renderTarget);

    this._boot();
};

FORGE.EffectComposer.prototype = Object.create(THREE.EffectComposer.prototype);
FORGE.EffectComposer.prototype.constructor = FORGE.EffectComposer;

/**
 * Boot sequence
 * @method FORGE.EffectComposer#_boot
 * @private
 */
FORGE.EffectComposer.prototype._boot = function()
{
    this._name = FORGE.EffectComposer.getUniqueName(this._type);
};

/**
 * Render
 * Set time for all passes
 * @method FORGE.EffectComposer#render
 */
FORGE.EffectComposer.prototype.render = function(delta)
{
    this._deltaSum += delta;
    var time = this._deltaSum;

    for (var i=0, ii=this.passes.length; i<ii; i++)
    {
        var pass = this.passes[i];

        if (typeof pass.uniforms !== "undefined")
        {
            if (typeof pass.uniforms.time !== "undefined")
            {
                pass.uniforms.time.value = time;
            }
        }

        if (typeof pass.time !== "undefined")
        {
            pass.time = time;
        }
    }
    
    THREE.EffectComposer.prototype.render.call(this, delta);
};

/**
 * Destroy sequence
 * @method FORGE.EffectComposer#destroy
 */
FORGE.EffectComposer.prototype.destroy = function()
{
    this._renderTarget = null;

    this.writeBuffer.dispose();
    this.writeBuffer = null;

    this.readBuffer.dispose();
    this.readBuffer = null;
};

/**
 * Static EffectComposer uid
 * @name FORGE.EffectComposer#uid
 * @type {number}
 */
FORGE.EffectComposer.uid = 0;

/**
 * Get EffectComposer unique name
 * @name FORGE.EffectComposer#getUniqueName
 * @param {string} type effect composer type
 * @return {string} unique name
 */
FORGE.EffectComposer.getUniqueName = function(type)
{
    return "FORGE.EffectComposer." + type + "." + (FORGE.EffectComposer.uid++);
};

/**
 * Get EffectComposer type
 * @name FORGE.EffectComposer#type
 * @type {string}
 */
Object.defineProperty(FORGE.EffectComposer.prototype, "type",
{
    /** @this {FORGE.EffectComposer} */
    get: function()
    {
        return this._type;
    }
});

/**
 * EffectComposer render target
 * @name FORGE.EffectComposer#renderTarget
 * @type {THREE.WebGLRenderTarget}
 */
Object.defineProperty(FORGE.EffectComposer.prototype, "renderTarget",
{
    /** @this {FORGE.EffectComposer} */
    get: function()
    {
        return this.readBuffer;
    },

    /** @this {FORGE.EffectComposer} */
    set: function(value)
    {
        if (this.readBuffer !== null)
        {
            this.readBuffer.dispose();
        }
        this.readBuffer = value;
    }
});

/**
 * EffectComposer enabled flag
 * @name FORGE.EffectComposer#enabled
 * @type {boolean}
 */
Object.defineProperty(FORGE.EffectComposer.prototype, "enabled",
{
    /** @this {FORGE.EffectComposer} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {FORGE.EffectComposer} */
    set: function(value)
    {
        this._enabled = value;
    }
});

/**
 * Get EffectComposer name
 * @name FORGE.EffectComposer#name
 * @type {string}
 */
Object.defineProperty(FORGE.EffectComposer.prototype, "name",
{
    /** @this {FORGE.EffectComposer} */
    get: function()
    {
        return this._name;
    }
});

/**
 * @namespace {Object} FORGE.PassPosition
 */
FORGE.PassPosition = {};

/**
 * @name FORGE.PassPosition.UNKNOWN
 * @type {string}
 * @const
 */
FORGE.PassPosition.UNKNOWN = "";

/**
 * @name FORGE.PassPosition.BACKGROUND
 * @type {string}
 * @const
 */
FORGE.PassPosition.BACKGROUND = "background";

/**
 * @name FORGE.PassPosition.RENDER
 * @type {string}
 * @const
 */
FORGE.PassPosition.RENDER = "render";

/**
 * @name FORGE.PassPosition.GLOBAL
 * @type {string}
 * @const
 */
FORGE.PassPosition.GLOBAL = "global";

/**
 * @constructor FORGE.TexturePass
 * @param {THREE.Texture} map - map texture
 * @param {number=} opacity - opacity
 * @extends {THREE.TexturePass}
 */
FORGE.TexturePass = function( map, opacity )
{
    /**
     * Rendering position.
     * @name FORGE.TexturePass#_position
     * @type {string}
     * @private
     */
    this._position = "";

    THREE.TexturePass.call(this, map, opacity);
};

FORGE.TexturePass.prototype = Object.create(THREE.TexturePass.prototype);
FORGE.TexturePass.prototype.constructor = FORGE.TexturePass;

/**
 * Get TexturePass position
 * @name FORGE.TexturePass#position
 * @type {string}
 */
Object.defineProperty(FORGE.TexturePass.prototype, "position",
{
    /** @this {FORGE.TexturePass} */
    get: function()
    {
        return this._position;
    },

    /** @this {FORGE.TexturePass} */
    set: function(position)
    {
        this._position = position;
    }
});

/**
 * Used to feed time to shader when uniform is declared
 *
 * @constructor FORGE.ShaderPass
 * @param {string} uid unique identifier
 * @param {string} type shader type
 * @param {Object} shader shader object
 * @param {string=} textureID uniform texture string identifier
 * @extends {THREE.ShaderPass}
 */
FORGE.ShaderPass = function(uid, type, shader, textureID)
{
    /**
     * Unique id
     * @name FORGE.ShaderPass#_uid
     * @type {string}
     * @private
     */
    this._uid = uid;

    /**
     * Shader pass type.
     * @name FORGE.ShaderPass#_type
     * @type {string}
     * @private
     */
    this._type = type || "shader";

    /**
     * Rendering position.
     * @name FORGE.ShaderPass#_position
     * @type {string}
     * @private
     */
    this._position = FORGE.PassPosition.UNKNOWN;

    /**
     * Sum of clock deltas.
     * @name FORGE.ShaderPass#_deltaSum
     * @type {number}
     * @private
     */
    this._deltaSum = 0;

    THREE.ShaderPass.call(this, shader, textureID || "tDiffuse");
};

FORGE.ShaderPass.prototype = Object.create(THREE.ShaderPass.prototype);
FORGE.ShaderPass.prototype.constructor = FORGE.ShaderPass;

/**
 * @method  FORGE.ShaderPass#render
 * @param  {THREE.WebGLRenderer} renderer
 * @param  {THREE.WebGLRenderTarget} writeBuffer
 * @param  {THREE.WebGLRenderTarget} readBuffer
 * @param  {number=} delta
 * @param  {boolean=} maskActive
 */
FORGE.ShaderPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive)
{
    this._deltaSum += delta;

    if (this.uniforms.hasOwnProperty("time"))
    {
        this.uniforms["time"].value = this._deltaSum;
    }

    THREE.ShaderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, delta, maskActive);
};

/**
 * Get ShaderPass uid
 * @name FORGE.ShaderPass#uid
 * @type {string}
 */
Object.defineProperty(FORGE.ShaderPass.prototype, "uid",
{
    /** @this {FORGE.ShaderPass} */
    get: function()
    {
        return this._uid;
    }
});

/**
 * Get ShaderPass type
 * @name FORGE.ShaderPass#type
 * @type {string}
 */
Object.defineProperty(FORGE.ShaderPass.prototype, "type",
{
    /** @this {FORGE.ShaderPass} */
    get: function()
    {
        return this._type;
    }
});

/**
 * Get ShaderPass position
 * @name FORGE.ShaderPass#position
 * @type {string}
 */
Object.defineProperty(FORGE.ShaderPass.prototype, "position",
{
    /** @this {FORGE.ShaderPass} */
    get: function()
    {
        return this._position;
    },

    /** @this {FORGE.ShaderPass} */
    set: function(position)
    {
        this._position = position;
    }
});

/**
 * @constructor FORGE.AdditionPass
 * @param {FORGE.EffectComposer} composer - effect composer reference
 * @extends {FORGE.ShaderPass}
 */
FORGE.AdditionPass = function(composer)
{
    /**
     * Reference on composer rendering texture to be added by the pass
     * @name FORGE.AdditionPass#_enabled
     * @type {FORGE.EffectComposer}
     * @private
     */
    this._composer = composer;

    /**
     * Shader material
     * @name FORGE.AdditionPass#_material
     * @type {THREE.Material}
     * @private
     */
    this._material = null;

    var vertexShader = FORGE.ShaderLib.parseIncludes( FORGE.ShaderChunk.wts_vert_rectilinear );
    var fragmentShader = FORGE.ShaderLib.parseIncludes( FORGE.ShaderChunk.wts_frag_addition );

    /** @type (FORGEUniform) */
    var uniforms =
    {
        tTexture: { type: "t", value: null },
        tAdd: { type: "t", value: null }
    };

    this._material = new THREE.RawShaderMaterial({
        fragmentShader: fragmentShader,
        vertexShader: vertexShader,
        uniforms: uniforms,
        side: THREE.FrontSide,
        name: "FORGE.AdditionPassMaterial"
    });

    FORGE.ShaderPass.call(this, "", "Addition", this._material, "tTexture");
};

FORGE.AdditionPass.prototype = Object.create(FORGE.ShaderPass.prototype);
FORGE.AdditionPass.prototype.constructor = FORGE.AdditionPass;

/**
 * Boot sequence
 * @method FORGE.AdditionPass#_boot
 * @private
 */
FORGE.AdditionPass.prototype._boot = function()
{

};

/**
 * Destroy sequence
 * @method FORGE.AdditionPass#destroy
 */
FORGE.AdditionPass.prototype.destroy = function()
{
    if (this._material === null)
    {
        this._material.dispose();
        this._material = null;
    }

    this._composer = null;
};

/**
 * Get linked AdditionPass
 * @name FORGE.AdditionPass#composer
 * @type {FORGE.EffectComposer}
 */
Object.defineProperty(FORGE.AdditionPass.prototype, "composer",
{
    /** @this {FORGE.AdditionPass} */
    get: function()
    {
        return this._composer;
    }
});

/**
 * @constructor FORGE.RenderPass
 * @param {THREE.Scene} scene - scene to be rendered
 * @param {THREE.Camera} camera - rendering camera
 * @param {THREE.Material=} overrideMaterial - optional override material
 * @param {THREE.Color=} clearColor - optional clear color
 * @param {boolean=} clearAlpha - optional clear alpha
 * @extends {THREE.RenderPass}
 */
FORGE.RenderPass = function( scene, camera, overrideMaterial, clearColor, clearAlpha )
{
    /**
     * Rendering position.
     * @name FORGE.RenderPass#_position
     * @type {string}
     * @private
     */
    this._position = "";

    THREE.RenderPass.call(this, scene, camera, overrideMaterial, clearColor, clearAlpha);
};

FORGE.RenderPass.prototype = Object.create(THREE.RenderPass.prototype);
FORGE.RenderPass.prototype.constructor = FORGE.RenderPass;

/**
 * Get RenderPass position
 * @name FORGE.RenderPass#position
 * @type {string}
 */
Object.defineProperty(FORGE.RenderPass.prototype, "position",
{
    /** @this {FORGE.RenderPass} */
    get: function()
    {
        return this._position;
    },

    /** @this {FORGE.RenderPass} */
    set: function(position)
    {
        this._position = position;
    }
});

/**
 * @namespace {Object} FORGE.ShaderChunk
 */

FORGE.ShaderChunk = {};
var coordinates = "\nvec3 toCartesian(in vec3 rtp) {\n    float r = rtp.x;\n    float theta = rtp.y;\n    float phi = rtp.z;\n    float x = r * cos(phi) * sin(theta);\n    float y = r * sin(phi);\n    float z = r * cos(phi) * cos(theta);\n    return vec3(x,y,z);\n}\nvec3 toSpherical(in vec3 pt) {\n    float r = length(pt);\n    float theta = -atan(pt.x, pt.z);\n    float phi = asin(pt.y / r);\n    return vec3(r,theta,phi);\n}\n";

FORGE.ShaderChunk["coordinates"] = coordinates;

var defines = "precision highp float;\nprecision highp int;\n#define PI_2  1.5707963268\n#define PI  3.141592653589793\n#define PI2 6.28318530717959\n#define RECIPROCAL_PI2 0.1591549430919\n#define isTrue(a) ((a) != 0)\n";

FORGE.ShaderChunk["defines"] = defines;

var helpers = "\nfloat wrap(in float x, in float min, in float max) {\n    return x - ((max - min) * (1.0 - step(x, min) - step(x, max)));\n}\nvec2 getFragment() {\n    return (2.0 * gl_FragCoord.xy / tViewportResolution - 1.0) * vec2(tViewportResolutionRatio, 1.0);\n}\nvec2 smoothTexUV(vec2 uv, vec2 texSize) {\n    uv = uv * texSize + 0.5;\n    vec2 iuv = floor(uv);\n    vec2 fuv = uv - iuv;\n    uv = iuv + fuv * fuv * fuv * (fuv * (fuv * 6.0 - 15.0) + 10.0);\n    return (uv - 0.5) / texSize;\n}\n";

FORGE.ShaderChunk["helpers"] = helpers;

var texcoords = "\nvec2 toEquirectangularTexCoords(in vec2 thetaphi) {\n    thetaphi.x = wrap(thetaphi.x + PI, -PI, PI);\n    vec2 coords = 0.5 + thetaphi / vec2(PI2, PI);\n    return coords;\n}\n";

FORGE.ShaderChunk["texcoords"] = texcoords;

var uniforms = "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n";

FORGE.ShaderChunk["uniforms"] = uniforms;

var vert_attributes = "attribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n";

FORGE.ShaderChunk["vert_attributes"] = vert_attributes;

var vert_attributes_wireframe = "attribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 quadrilateralCoords;\n";

FORGE.ShaderChunk["vert_attributes_wireframe"] = vert_attributes_wireframe;

var stw_frag_proj_flat = "\n#include <defines>\nuniform sampler2D tTexture;\nuniform vec2 tViewportResolution;\nuniform float tViewportResolutionRatio;\nuniform float tTextureRatio;\nuniform float tFov;\nuniform float tYaw;\nuniform float tPitch;\nuniform int tRepeatX;\nuniform int tRepeatY;\n#include <helpers>\n#include <coordinates>\n#include <texcoords>\nvoid main() {\n    vec2 sTexResolution = PI * vec2(tTextureRatio, 1.0);\n    vec2 sReference = vec2(tYaw, tPitch) + sTexResolution / 2.0;\n    vec2 sTexel = sReference + (tFov * 0.5) * getFragment();\n    vec2 uv = sTexel / sTexResolution;\n    if (isTrue(tRepeatX)) {\n        uv.x = mod(uv.x, 1.0);\n    }\n    else if (uv.x > 1.0 || uv.x < 0.0) {\n        discard;\n    }\n    if (isTrue(tRepeatY)) {\n        uv.y = mod(uv.y, 1.0);\n    }\n    else if (uv.y > 1.0 || uv.y < 0.0) {\n        discard;\n    }\n    gl_FragColor = vec4(texture2D(tTexture, uv).rgb, 1.0);\n}\n";

FORGE.ShaderChunk["stw_frag_proj_flat"] = stw_frag_proj_flat;

var stw_frag_proj_gopro = "\n#include <defines>\nuniform sampler2D tTexture;\nuniform vec2 tViewportResolution;\nuniform float tViewportResolutionRatio;\nuniform mat4 tModelViewMatrixInverse;\nuniform float tProjectionDistance;\nuniform float tProjectionScale;\n#include <helpers>\n#include <coordinates>\n#include <texcoords>\nvec2 projection() {\n    vec2 frag = getFragment();\n    vec2 c = tProjectionScale * frag;\n    float zs = tProjectionDistance;\n    float xy2 = dot(c,c);\n    float zs12 = (zs + 1.0) * (zs + 1.0);\n    float delta = 4.0 * (zs * zs * xy2 * xy2 - (xy2 + zs12) * (xy2 * zs * zs - zs12));\n    if (delta < 0.0) { return vec2(-1.); }\n    float z = (2.0 * zs * xy2 - sqrt(delta)) / (2.0 * (zs12 + xy2));\n    float x = c.x * ((zs - z) / (zs + 1.0));\n    float y = c.y * ((zs - z) / (zs + 1.0));\n    vec3 vx = vec3(tModelViewMatrixInverse * vec4(x, y, z, 1.0));\n    return toSpherical(vx).yz;\n}\nvoid main() {\n    vec2 texCoords = toEquirectangularTexCoords(projection());\n    gl_FragColor = vec4(texture2D(tTexture, texCoords).rgb, 1.0);\n}\n";

FORGE.ShaderChunk["stw_frag_proj_gopro"] = stw_frag_proj_gopro;

var stw_frag_proj_rectilinear = "\n#include <defines>\nuniform sampler2D tTexture;\nuniform vec2 tViewportResolution;\nuniform float tViewportResolutionRatio;\nuniform mat4 tModelViewMatrixInverse;\nuniform float tProjectionScale;\n#include <helpers>\n#include <coordinates>\n#include <texcoords>\nvec2 projection() {\n    vec2 frag = tProjectionScale * getFragment();\n    vec4 screenPT = vec4(frag, -1.0, 1.0);\n    vec4 worldPT = tModelViewMatrixInverse * screenPT;\n    return toSpherical(worldPT.xyz).yz;\n}\nvoid main() {\n    vec2 texCoords = toEquirectangularTexCoords(projection());\n    gl_FragColor = vec4(texture2D(tTexture, texCoords).rgb, 1.0);\n}\n";

FORGE.ShaderChunk["stw_frag_proj_rectilinear"] = stw_frag_proj_rectilinear;

var stw_vert_proj = "\n#include <defines>\nvoid main() {\n   gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n";

FORGE.ShaderChunk["stw_vert_proj"] = stw_vert_proj;

var wts_frag = "\n#include <defines>\nuniform sampler2D tTexture;\nuniform float tOpacity;\nvarying vec2 vUv;\nvoid main() {\n    vec4 texel = texture2D( tTexture, vUv );\n    gl_FragColor = vec4(texel.rgb, texel.a * tOpacity);\n}\n";

FORGE.ShaderChunk["wts_frag"] = wts_frag;

var wts_frag_addition = "\n#include <defines>\nuniform sampler2D tTexture;\nuniform sampler2D tAdd;\nvarying vec2 vUv;\nvoid main() {\n    vec4 texel = texture2D( tTexture, vUv );\n    vec4 texelAdd = texture2D( tAdd, vUv );\n    float alpha = max(texel.a, texelAdd.a);\n    gl_FragColor = vec4(vec3(texelAdd.a * texelAdd.rgb + (1.0 - texelAdd.a) * texel.rgb), alpha);\n}\n";

FORGE.ShaderChunk["wts_frag_addition"] = wts_frag_addition;

var wts_frag_color = "\n#include <defines>\nuniform vec3 tColor;\nuniform float tOpacity;\nvarying vec2 vUv;\nvoid main() {\n    vec2 texCoords = vUv;\n    gl_FragColor = vec4(tColor, tOpacity);\n}\n";

FORGE.ShaderChunk["wts_frag_color"] = wts_frag_color;

var wts_frag_wireframe = "\n#extension GL_OES_standard_derivatives : enable \n#include <defines>\n#define WIRE_THICKNESS 1.50\nuniform vec3 tColor;\nvarying vec2 vQuadrilateralCoords;\nvoid main() {\n    vec2 dfdx = dFdx(vQuadrilateralCoords);\n    vec2 dfdy = dFdy(vQuadrilateralCoords);\n    vec2 threshold = vec2(WIRE_THICKNESS * sqrt(dfdx * dfdx + dfdy * dfdy));\n    vec2 amount = smoothstep(vec2(0.0), WIRE_THICKNESS * threshold, vec2(1.0) - abs(vQuadrilateralCoords));\n    float alpha = 1.0 - amount.x * amount.y;\n    gl_FragColor = vec4(tColor.rgb, alpha);\n}\n";

FORGE.ShaderChunk["wts_frag_wireframe"] = wts_frag_wireframe;

var wts_vert_gopro = "\n#include <defines>\n#include <vert_attributes>\n#include <uniforms>\nuniform float tProjectionDistance;\nvarying vec2 vUv;\nvoid main() {\n    vec4 spherePt = normalize(modelViewMatrix * vec4( position, 1.0 ));\n    float radius = 1.0 - 0.5 * tProjectionDistance;\n    float offset = radius - 1.0;\n    spherePt.xyz *= radius;\n    spherePt.z += offset;\n    gl_Position = projectionMatrix * spherePt;\n    vUv = uv;\n}\n";

FORGE.ShaderChunk["wts_vert_gopro"] = wts_vert_gopro;

var wts_vert_gopro_wireframe = "\n#include <defines>\n#include <vert_attributes_wireframe>\n#include <uniforms>\nuniform float tProjectionDistance;\nvarying vec2 vQuadrilateralCoords;\nvoid main() {\n    vec4 spherePt = normalize(modelViewMatrix * vec4( position, 1.0 ));\n    float radius = 1.0 - 0.5 * tProjectionDistance;\n    float offset = radius - 1.0;\n    spherePt.xyz *= radius;\n    spherePt.z += offset;\n    gl_Position = projectionMatrix * spherePt;\n    vQuadrilateralCoords = quadrilateralCoords;\n}\n";

FORGE.ShaderChunk["wts_vert_gopro_wireframe"] = wts_vert_gopro_wireframe;

var wts_vert_rectilinear = "\n#include <defines>\n#include <vert_attributes>\n#include <uniforms>\nvarying vec2 vUv;\nvoid main() {\n    vec4 camPt = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * camPt;\n    vUv = uv;\n}\n";

FORGE.ShaderChunk["wts_vert_rectilinear"] = wts_vert_rectilinear;

var wts_vert_rectilinear_wireframe = "\n#include <defines>\n#include <vert_attributes_wireframe>\n#include <uniforms>\nvarying vec2 vQuadrilateralCoords;\nvoid main() {\n    vec4 camPt = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * camPt;\n    vQuadrilateralCoords = quadrilateralCoords;\n}\n";

FORGE.ShaderChunk["wts_vert_rectilinear_wireframe"] = wts_vert_rectilinear_wireframe;

/**
 * @namespace {FORGEProgram} FORGE.ShaderLib
 */

//jscs:disable

FORGE.ShaderLib = {

    screenToWorld:
    {
        rectilinear:
        {
            /** @type {FORGEUniform} */
            uniforms:
            {
                tTexture: { type: "t", value: null },
                tViewportResolution: { type: "v2", value: new THREE.Vector2() },
                tViewportResolutionRatio: { type: "f", value: 1.0 },
                tModelViewMatrixInverse: { type: "m4", value: new THREE.Matrix4() },
                tProjectionScale: { type: "f", value: 1.0 }
            },

            vertexShader: FORGE.ShaderChunk.stw_vert_proj,
            fragmentShader: FORGE.ShaderChunk.stw_frag_proj_rectilinear
        },

        flat:
        {
            /** @type {FORGEUniform} */
            uniforms:
            {
                tTexture: { type: "t", value: null },
                tTextureRatio: { type: "f", value: 1.0 },
                tViewportResolution: { type: "v2", value: new THREE.Vector2() },
                tViewportResolutionRatio: { type: "f", value: 1.0 },
                tFov: { type: "f", value: 0.0 },
                tYaw: { type: "f", value: 0.0 },
                tPitch: { type: "f", value: 0.0 },
                tRepeatX: { type: "i", value: 0 },
                tRepeatY: { type: "i", value: 0 }
            },

            vertexShader: FORGE.ShaderChunk.stw_vert_proj,
            fragmentShader: FORGE.ShaderChunk.stw_frag_proj_flat
        },

        gopro:
        {
            /** @type {FORGEUniform} */
            uniforms:
            {
                tTexture: { type: "t", value: null },
                tViewportResolution: { type: "v2", value: new THREE.Vector2() },
                tViewportResolutionRatio: { type: "f", value: 1.0 },
                tModelViewMatrixInverse: { type: "m4", value: new THREE.Matrix4() },
                tProjectionDistance: { type: "f", value: 0.0 },
                tProjectionScale: { type: "f", value: 1.0 }
            },

            vertexShader: FORGE.ShaderChunk.stw_vert_proj,
            fragmentShader: FORGE.ShaderChunk.stw_frag_proj_gopro
        }
    },

    worldToScreen:
    {
        rectilinear:
        {
            mapping:
            {
                /** @type {FORGEUniform} */
                uniforms:
                {
                    tOpacity: { type: "f", value: 1.0 },
                    tTexture: { type: "t", value: null }
                },
                vertexShader: FORGE.ShaderChunk.wts_vert_rectilinear,
                fragmentShader: FORGE.ShaderChunk.wts_frag
            },

            wireframe:
            {
                /** @type {FORGEUniform} */
                uniforms:
                {
                    tColor: { type: "c", value: null },
                    tModelViewMatrixInverse: { type: "m4", value: null }
                },
                vertexShader: FORGE.ShaderChunk.wts_vert_rectilinear_wireframe,
                fragmentShader: FORGE.ShaderChunk.wts_frag_wireframe
            }
        },

        flat:
        {
            mapping:
            {
                /** @type {FORGEUniform} */
                uniforms:
                {
                    tOpacity: { type: "f", value: 1.0 },
                    tTexture: { type: "t", value: null }
                },
                vertexShader: FORGE.ShaderChunk.wts_vert_rectilinear,
                fragmentShader: FORGE.ShaderChunk.wts_frag
            },

             wireframe:
            {
                /** @type {FORGEUniform} */
                uniforms:
                {
                    tColor: { type: "c", value: null },
                    tModelViewMatrixInverse: { type: "m4", value: null }
                },
                vertexShader: FORGE.ShaderChunk.wts_vert_rectilinear_wireframe,
                fragmentShader: FORGE.ShaderChunk.wts_frag_wireframe
            }
        },

        gopro:
        {
            mapping:
            {
                /** @type {FORGEUniform} */
                uniforms:
                {
                    tOpacity: { type: "f", value: 1.0 },
                    tTexture: { type: "t", value: null },
                    tProjectionDistance: { type: "f", value: 1 }
                },
                vertexShader: FORGE.ShaderChunk.wts_vert_gopro,
                fragmentShader: FORGE.ShaderChunk.wts_frag
            },

            wireframe:
            {
                /** @type {FORGEUniform} */
                uniforms:
                {
                    tColor: { type: "c", value: null },
                    tProjectionDistance: { type: "f", value: 1 }
                },
                vertexShader: FORGE.ShaderChunk.wts_vert_gopro_wireframe,
                fragmentShader: FORGE.ShaderChunk.wts_frag_wireframe
            }
        }
    }
};

//jscs:enable

FORGE.ShaderLib.parseIncludes = function(string)
{
    var pattern = /#include +<([\w\d.]+)>/g;

    function replace( match, include )
    {
        var r = FORGE.ShaderChunk[include];

        if (typeof r === "undefined")
        {
            r = THREE.ShaderChunk[include];

            if (typeof r === "undefined")
            {
                throw new Error( "Can not resolve #include <" + include + ">" );
            }
        }

        return FORGE.ShaderLib.parseIncludes(r);
    }

    return string.replace( pattern, replace );
};

/**
 * View manager class
 *
 * @constructor FORGE.ViewManager
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.ViewManager = function(viewer)
{
    /**
     * The Viewer reference.
     * @name FORGE.ViewManager#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The current view reference
     * @name FORGE.ViewManager#_view
     * @type {FORGE.ViewBase}
     * @private
     */
    this._view = null;

    /**
     * Ready flag
     * @name FORGE.ViewManager#_ready
     * @type {boolean}
     */
    this._ready = false;

    /**
     * The view type to restore when the user quit VR mode
     * @name  FORGE.ViewManager#_viewTypeBackup
     * @type {string}
     * @private
     */
    this._viewTypeBackup = "";

    /**
     * The view options to restore when the user quit VR mode
     * @name  FORGE.ViewManager#_viewOptionsBackup
     * @type {?ViewOptionsConfig}
     * @private
     */
    this._viewOptionsBackup = null;

    /**
     * Event dispatcher for view change.
     * @name FORGE.ViewManager#_onChange
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onChange = null;


    FORGE.BaseObject.call(this, "ViewManager");
};

FORGE.ViewManager.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.ViewManager.prototype.constructor = FORGE.ViewManager;

/**
 * Set the view type
 * @method FORGE.ViewManager#_setView
 * @param {string} type - The type of the view to set.
 * @param {?ViewOptionsConfig} options - The view options.
 * @private
 */
FORGE.ViewManager.prototype._setView = function(type, options)
{
    if (this._view !== null && this._view.type === type)
    {
        return;
    }

    this._clearView();

    this.log("set view "+type);

    options = options || null;

    switch (type)
    {
        case FORGE.ViewType.GOPRO:
            this._view = new FORGE.ViewGoPro(this._viewer, options);
            break;

        case FORGE.ViewType.FLAT:
            this._view = new FORGE.ViewFlat(this._viewer, options);
            break;

        case FORGE.ViewType.RECTILINEAR:
        default:
            this._view = new FORGE.ViewRectilinear(this._viewer, options);
            break;
    }

    this._ready = true;

    this.notifyChange();
};

/**
 * Clear the view
 * @method FORGE.ViewManager#_clearView
 * @private
 */
FORGE.ViewManager.prototype._clearView = function()
{
    this._ready = false;

    if (this._view !== null)
    {
        this.log("clear view");

        this._view.destroy();
        this._view = null;
    }
};

/**
 * Used by views to notify a change to the manager.
 * @method FORGE.ViewManager#notifyChange
 * @private
 */
FORGE.ViewManager.prototype.notifyChange = function()
{
    if(this._onChange !== null)
    {
        this._onChange.dispatch();
    }
};

/**
 * Load a view configuration
 * @method FORGE.ViewManager#load
 * @param  {ViewConfig} config - The configuration of the view to load
 * @private
 */
FORGE.ViewManager.prototype.load = function(config)
{
    var sceneViewConfig = /** @type {ViewConfig} */ (config);
    var globalViewConfig = /** @type {ViewConfig} */ (this._viewer.mainConfig.view);
    var extendedViewConfig = /** @type {ViewConfig} */ (FORGE.Utils.extendMultipleObjects(globalViewConfig, sceneViewConfig));

    var type = (typeof extendedViewConfig.type === "string") ? extendedViewConfig.type.toLowerCase() : FORGE.ViewType.RECTILINEAR;
    var options = /** @type {ViewOptionsConfig} */ (extendedViewConfig.options);

    this._setView(type, options);
};

/**
 * Enable VR backup the view type then force to rectilinear
 * @method FORGE.ViewManager#enableVR
 */
FORGE.ViewManager.prototype.enableVR = function()
{
    this._viewTypeBackup = this._view.type;
    this._viewOptionsBackup = this._view.options;
    this._setView(FORGE.ViewType.RECTILINEAR, null);
};

/**
 * Disable VR restore the view type.
 * @method FORGE.ViewManager#disableVR
 */
FORGE.ViewManager.prototype.disableVR = function()
{
    if(this._viewTypeBackup !== "")
    {
        this._setView(this._viewTypeBackup, this._viewOptionsBackup); // Restore the view as before the VR mode
        this._viewer.camera.roll = 0; // Reset the roll to 0
    }
};

/**
 * Convert a point from world space to screen space with the current view type.
 *
 * @method FORGE.ViewManager#worldToScreen
 * @param {THREE.Vector3} worldPt - Point in world space
 * @param {number} parallax - Parallax factor [0..1]
 * @return {THREE.Vector2} Point in screen coordinates
 * @todo Implement worldToScreen
 */
FORGE.ViewManager.prototype.worldToScreen = function(worldPt, parallax)
{
    return this._view.worldToScreen(worldPt, parallax);
};

/**
 * Convert a point from screen space to world space with the current view type.
 *
 * @method FORGE.ViewManager#screenToWorld
 * @param {THREE.Vector2} screenPt point in screen space
 * @return {THREE.Vector3}
 * @todo Implement screenToWorld
 */
FORGE.ViewManager.prototype.screenToWorld = function(screenPt)
{
    return this._view.screenToWorld(screenPt);
};

/**
 * Destroy sequence
 * @method FORGE.ViewManager#destroy
 */
FORGE.ViewManager.prototype.destroy = function()
{
    this._viewer = null;

    if (this._view !== null)
    {
        this._view.destroy();
        this._view = null;
    }

    if (this._onChange !== null)
    {
        this._onChange.destroy();
        this._onChange = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the current view object.
 * @name  FORGE.ViewManager#current
 * @type {FORGE.ViewBase}
 * @readonly
 */
Object.defineProperty(FORGE.ViewManager.prototype, "current",
{
    /** @this {FORGE.ViewManager} */
    get: function()
    {
        return this._view;
    }
});

/**
 * Get the view ready flag.
 * @name  FORGE.ViewManager#ready
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.ViewManager.prototype, "ready",
{
    /** @this {FORGE.ViewManager} */
    get: function()
    {
        return this._ready;
    }
});

/**
 * Get and set the current view type.
 * @name  FORGE.ViewManager#type
 * @type {string}
 */
Object.defineProperty(FORGE.ViewManager.prototype, "type",
{
    /** @this {FORGE.ViewManager} */
    get: function()
    {
        return (this._view !== null) ? this._view.type : null;
    },

    /** @this {FORGE.ViewManager} */
    set: function(value)
    {
        this._setView(value, null);
    }
});

/**
 * Get the onChange {@link FORGE.EventDispatcher}.
 * @name  FORGE.ViewManager#onChange
 * @type {FORGE.EventDispatcher}
 * @readonly
 */
Object.defineProperty(FORGE.ViewManager.prototype, "onChange",
{
    /** @this {FORGE.ViewManager} */
    get: function()
    {
        if (this._onChange === null)
        {
            this._onChange = new FORGE.EventDispatcher(this);
        }

        return this._onChange;
    }
});

/**
 * @namespace {Object} FORGE.ViewType
 */
FORGE.ViewType = {};

/**
 * @name FORGE.ViewType.UNDEFINED
 * @type {string}
 * @const
 */
FORGE.ViewType.UNDEFINED = "undefined";

/**
 * @name FORGE.ViewType.FLAT
 * @type {string}
 * @const
 */
FORGE.ViewType.FLAT = "flat";

/**
 * @name FORGE.ViewType.RECTILINEAR
 * @type {string}
 * @const
 */
FORGE.ViewType.RECTILINEAR = "rectilinear";

/**
 * @name FORGE.ViewType.GOPRO
 * @type {string}
 * @const
 */
FORGE.ViewType.GOPRO = "gopro";

/**
 * Abstract base class for projeted views. Should be subclassed for every supported projection / view type.
 *
 * @constructor FORGE.ViewBase
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {?ViewOptionsConfig} options - The view options.
 * @param {string} className - object className.
 * @param {string} type - object view type.
 * @extends {FORGE.BaseObject}
 */
FORGE.ViewBase = function(viewer, options, className, type)
{
    /**
     * The Viewer reference.
     * @name FORGE.ViewBase#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The view options
     * @name FORGE.ViewBase#_options
     * @type {?ViewOptionsConfig}
     * @private
     */
    this._options = options || null;

    /**
     * Projection scale.
     * @name FORGE.ViewBase#_projectionScale
     * @type {number}
     * @private
     */
    this._projectionScale = 1.0;

    /**
     * View type.
     * @name FORGE.ViewBase#_type
     * @type {string}
     * @private
     */
    this._type = type;

    /**
     * Yaw min angle for current view type [radians].
     * @name FORGE.ViewBase#_yawMin
     * @type {number}
     * @private
     */
    this._yawMin = -Infinity;

    /**
     * Yaw max angle for current view type [radians].
     * @name FORGE.ViewBase#_yawMax
     * @type {number}
     * @private
     */
    this._yawMax = Infinity;

    /**
     * Pitch min angle for current view type [radians].
     * @name FORGE.ViewBase#_pitchMin
     * @type {number}
     * @private
     */
    this._pitchMin = -Infinity;

    /**
     * Pitch min angle for current view type [radians].
     * @name FORGE.ViewBase#_pitchMax
     * @type {number}
     * @private
     */
    this._pitchMax = Infinity;

    /**
     * Roll min angle for current view type [radians].
     * @name FORGE.ViewBase#_rollMin
     * @type {number}
     * @private
     */
    this._rollMin = -Infinity;

    /**
     * Roll max angle for current view type [radians].
     * @name FORGE.ViewBase#_rollMax
     * @type {number}
     * @private
     */
    this._rollMax = Infinity;

    /**
     * Fov min angle for current view type [radians].
     * @name FORGE.ViewBase#_fovMin
     * @type {number}
     * @private
     */
    this._fovMin = 0;

    /**
     * Fov max angle for current view type [radians].
     * @name FORGE.ViewBase#_fovMax
     * @type {number}
     * @private
     */
    this._fovMax = Infinity;

    /**
     * Shader screen to world
     * @name FORGE.ViewBase#_shaderSTW
     * @type {?ScreenToWorldProgram}
     * @private
     */
    this._shaderSTW = null;

    /**
     * Shader world to screen
     * @name FORGE.ViewBase#_shaderWTS
     * @type {?WorldToScreenProgram}
     * @private
     */
    this._shaderWTS = null;

    FORGE.BaseObject.call(this, className || "ViewBase");
};

FORGE.ViewBase.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.ViewBase.prototype.constructor = FORGE.ViewBase;

/**
 * Boot sequence.
 *
 * @method FORGE.ViewBase#_boot
 * @private
 */
FORGE.ViewBase.prototype._boot = function()
{
    this._viewer.story.onSceneLoadComplete.add(this.updateUniforms, this);
};

/**
 * Compute fragment from a screen point.
 *
 * @method FORGE.ViewBase#_screenToFragment
 * @param  {THREE.Vector2} screenPt - Point in screen space
 * @return {THREE.Vector2} Fragment in normalized space
 * @private
 */
FORGE.ViewBase.prototype._screenToFragment = function(screenPt)
{
    var resolution = this._viewer.renderer.displayResolution;
    var fx = (2.0 * screenPt.x / resolution.width) - 1.0;
    var fy = (2.0 * screenPt.y / resolution.height) - 1.0;
    return new THREE.Vector2(fx * resolution.ratio, fy);
};

/**
 * Compute screen point from a fragment.
 *
 * @method FORGE.ViewBase#_fragmentToScreen
 * @param {THREE.Vector2} fragment - Fragment in normalized space
 * @return  {THREE.Vector2} Point in screen space
 * @private
 */
FORGE.ViewBase.prototype._fragmentToScreen = function(fragment)
{
    var resolution = this._viewer.renderer.displayResolution;
    var sx = ((fragment.x / resolution.ratio) + 1.0) * (resolution.width / 2.0);
    var sy = (fragment.y + 1.0) * (resolution.height / 2.0);
    return new THREE.Vector2(Math.round(sx), resolution.height - Math.round(sy));
};

/**
 * Update uniforms.
 * Abstract method that should be implemented by subclass.
 *
 * @method FORGE.ViewBase#updateUniforms
 * @param {FORGEUniform} uniforms
 */
FORGE.ViewBase.prototype.updateUniforms = function(uniforms)
{
    this.log(uniforms); //@closure
    throw "Please implement " + this._className + "::updateUniforms";
};

/**
 * Convert a point from world space to screen space.
 * Abstract method that should be implemented by subclass.
 *
 * @method FORGE.ViewBase#worldToScreen
 * @param {THREE.Vector3} worldPt - Point in world space
 * @param {number} parallax - Parallax factor [0..1]
 * @return {?THREE.Vector2} Point in screen coordinates or null if the point is out of bounds.
 * @todo Implement worldToScreen
 */
FORGE.ViewBase.prototype.worldToScreen = function(worldPt, parallax)
{
    this.log(worldPt); //@closure
    this.log(parallax); //@closure
    throw "Please implement " + this._className + "::worldToScreen";
};

/**
 * Convert a point from screen space to world space.
 * Abstract method that should be implemented by subclass.
 * @method FORGE.ViewBase#screenToWorld
 * @param {THREE.Vector2} screenPt point in screen space
 * @return {?THREE.Vector3} Point in world space or null if the screenPt is out of bounds.
 * @todo Implement screenToWorld
 */
FORGE.ViewBase.prototype.screenToWorld = function(screenPt)
{
    this.log(screenPt); //@closure
    throw "Please implement " + this._className + "::screenToWorld";
};

/**
 * Get fov computed for projection.
 * @method FORGE.ViewBase#getProjectionFov
 */
FORGE.ViewBase.prototype.getProjectionFov = function()
{
    return FORGE.Math.degToRad(this._viewer.renderer.camera.fov);
};

/**
 * Destroy method.
 *
 * @method FORGE.ViewBase#destroy
 */
FORGE.ViewBase.prototype.destroy = function()
{
    this._viewer = null;
    this._camera = null;

    this._shaderSTW = null;
    this._shaderWTS = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the view type.
 * @name FORGE.ViewBase#type
 * @type {string}
 * @readonly
 */
Object.defineProperty(FORGE.ViewBase.prototype, "type",
{
    /** @this {FORGE.ViewBase} */
    get: function()
    {
        return this._type;
    }
});

/**
 * Get the minimum yaw value in radians.
 * @name FORGE.ViewBase#yawMin
 * @type {number}
 */
Object.defineProperty(FORGE.ViewBase.prototype, "yawMin",
{
    /** @this {FORGE.ViewBase} */
    get: function()
    {
        return this._yawMin;
    }
});

/**
 * Get the maximum yaw value in radians.
 * @name FORGE.ViewBase#yawMax
 * @type {number}
 */
Object.defineProperty(FORGE.ViewBase.prototype, "yawMax",
{
    /** @this {FORGE.ViewBase} */
    get: function()
    {
        return this._yawMax;
    }
});

/**
 * Get the minimum pitch value in radians.
 * @name FORGE.ViewBase#pitchMin
 * @type {number}
 */
Object.defineProperty(FORGE.ViewBase.prototype, "pitchMin",
{
    /** @this {FORGE.ViewBase} */
    get: function()
    {
        return this._pitchMin;
    }
});

/**
 * Get the maximum pitch value in radians.
 * @name FORGE.ViewBase#pitchMax
 * @type {number}
 */
Object.defineProperty(FORGE.ViewBase.prototype, "pitchMax",
{
    /** @this {FORGE.ViewBase} */
    get: function()
    {
        return this._pitchMax;
    }
});

/**
 * Get the minimum roll value in radians.
 * @name FORGE.ViewBase#rollMin
 * @type {number}
 */
Object.defineProperty(FORGE.ViewBase.prototype, "rollMin",
{
    /** @this {FORGE.ViewBase} */
    get: function()
    {
        return this._rollMin;
    }
});

/**
 * Get the maximum roll value in radians.
 * @name FORGE.ViewBase#rollMax
 * @type {number}
 */
Object.defineProperty(FORGE.ViewBase.prototype, "rollMax",
{
    /** @this {FORGE.ViewBase} */
    get: function()
    {
        return this._rollMax;
    }
});

/**
 * Get minimum fov for current view in radians.
 * @name FORGE.ViewBase#fovMin
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.ViewBase.prototype, "fovMin",
{
    /** @this {FORGE.ViewBase} */
    get: function()
    {
        return this._fovMin;
    }
});

/**
 * Get maximum fov for current view in radians.
 * @name FORGE.ViewBase#fovMax
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.ViewBase.prototype, "fovMax",
{
    /** @this {FORGE.ViewBase} */
    get: function()
    {
        return this._fovMax;
    }
});

/**
 * Shader screen to world
 * @name FORGE.ViewBase#shaderSTW
 * @type {ScreenToWorldProgram}
 * @readonly
 */
Object.defineProperty(FORGE.ViewBase.prototype, "shaderSTW",
{
    /** @this {FORGE.ViewBase} */
    get: function()
    {
        return this._shaderSTW;
    }
});

/**
 * Shader world to screen
 * @name FORGE.ViewBase#shaderWTS
 * @type {WorldToScreenProgram}
 * @readonly
 */
Object.defineProperty(FORGE.ViewBase.prototype, "shaderWTS",
{
    /** @this {FORGE.ViewBase} */
    get: function()
    {
        return this._shaderWTS;
    }
});

/**
 * Options getter
 * @name FORGE.ViewBase#options
 * @type {ViewOptionsConfig}
 * @readonly
 */
Object.defineProperty(FORGE.ViewBase.prototype, "options",
{
    /** @this {FORGE.ViewBase} */
    get: function()
    {
        return this._options;
    }
});

/**
 * Flat view class.
 *
 * @constructor FORGE.ViewFlat
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {?ViewOptionsConfig} options - The view options.
 * @extends {FORGE.ViewBase}
 */
FORGE.ViewFlat = function(viewer, options)
{
    FORGE.ViewBase.call(this, viewer, options, "ViewFlat", FORGE.ViewType.FLAT);

    this._boot();
};

FORGE.ViewFlat.prototype = Object.create(FORGE.ViewBase.prototype);
FORGE.ViewFlat.prototype.constructor = FORGE.ViewFlat;

/**
 * Flat view default options
 * @name FORGE.ViewFlat.DEFAULT_OPTIONS
 * @type {ViewOptionsConfig}
 * @const
 */
FORGE.ViewFlat.DEFAULT_OPTIONS =
{
    repeatX: false,
    repeatY: false
};

/**
 * Boot sequence.
 *
 * @method FORGE.ViewFlat#_boot
 * @private
 */
FORGE.ViewFlat.prototype._boot = function()
{
    FORGE.ViewBase.prototype._boot.call(this);

    this._shaderSTW = /** @type {ScreenToWorldProgram} */ (FORGE.Utils.extendSimpleObject({}, FORGE.ShaderLib.screenToWorld.flat));
    this._shaderWTS = /** @type {WorldToScreenProgram} */ (FORGE.Utils.extendSimpleObject({}, FORGE.ShaderLib.worldToScreen.flat));

    this._yawMin = FORGE.Math.degToRad(-360);
    this._yawMax = FORGE.Math.degToRad(360);

    this._pitchMin = FORGE.Math.degToRad(-180);
    this._pitchMax = FORGE.Math.degToRad(180);

    this._fovMin = FORGE.Math.degToRad(20);
    this._fovMax = FORGE.Math.degToRad(180);

    this._options = FORGE.Utils.extendSimpleObject(FORGE.ViewFlat.DEFAULT_OPTIONS, this._options);
};

/**
 * Update view params.
 * @method FORGE.ViewFlat#_updateViewParams
 * @private
 */
FORGE.ViewFlat.prototype._updateViewParams = function()
{
    if (this._viewer !== null)
    {
        // When repeat is ON, set yaw and pitch min and max depending on
        // texture and screen ratios

        if (this._viewer.renderer.backgroundRenderer instanceof FORGE.BackgroundShaderRenderer)
        {
            var vfov = FORGE.Math.degToRad(this._viewer.camera.fov);

            if (this._options.repeatX === false)
            {
                var hfov = vfov * this._viewer.renderer.displayResolution.ratio;
                var texRatio = this._viewer.renderer.backgroundRenderer.textureSize.ratio;
                this._yawMax = Math.min(360, Math.max(0, (Math.PI * texRatio - hfov) * 0.5)); // image
                this._yawMin = -this._yawMax;
            }
            else
            {
                this._yawMin = FORGE.Math.degToRad(-360);
                this._yawMax = FORGE.Math.degToRad(360);
            }

            if (this._options.repeatY === false)
            {
                this._pitchMax = 0.5 * Math.max(0, Math.PI - vfov);
                this._pitchMin = -this._pitchMax;
            }
            else
            {
                this._pitchMin = FORGE.Math.degToRad(-180);
                this._pitchMax = FORGE.Math.degToRad(180);
            }
        }

        // Mesh rendering in flat view is limited around -+ 20 degrees
        else
        {
            this._yawMax = this._pitchMax = FORGE.Math.degToRad(20);
            this._yawMin = -this._yawMax;
            this._pitchMin = -this._pitchMax;
        }
    }
};

/**
 * Update uniforms.
 *
 * @method FORGE.ViewFlat#updateUniforms
 * @param {FORGEUniform} uniforms
 */
FORGE.ViewFlat.prototype.updateUniforms = function(uniforms)
{
    this._updateViewParams();

    if (typeof uniforms === "undefined")
    {
        return;
    }

    if (uniforms.hasOwnProperty("tRepeatX"))
    {
        uniforms.tRepeatX.value = this._options.repeatX ? 1 : 0;
    }

    if (uniforms.hasOwnProperty("tRepeatY"))
    {
        uniforms.tRepeatY.value = this._options.repeatY ? 1 : 0;
    }

    if (uniforms.hasOwnProperty("tYaw"))
    {
        uniforms.tYaw.value = FORGE.Math.degToRad(this._viewer.camera.yaw);
    }

    if (uniforms.hasOwnProperty("tPitch"))
    {
        uniforms.tPitch.value = FORGE.Math.degToRad(this._viewer.camera.pitch);
    }

    if (uniforms.hasOwnProperty("tFov"))
    {
        uniforms.tFov.value = FORGE.Math.degToRad(this._viewer.renderer.camera.fov);
    }
};

/**
 * Convert a point from world space to screen space.
 *
 * @method FORGE.ViewFlat#worldToScreen
 * @return {THREE.Vector2} point in screen coordinates
 */
FORGE.ViewFlat.prototype.worldToScreen = function()
{
    return new THREE.Vector2();
};

/**
 * Convert a point from screen space to world space.
 *
 * @method FORGE.ViewFlat#screenToWorld
 * @return {THREE.Vector3} world point
 */
FORGE.ViewFlat.prototype.screenToWorld = function()
{
    return new THREE.Vector3();
};

/**
 * Destroy method.
 *
 * @method FORGE.ViewFlat#destroy
 */
FORGE.ViewFlat.prototype.destroy = function()
{
    FORGE.ViewBase.prototype.destroy.call(this);
};

/**
 * Get and set the repeat X beahvior.
 * @name  FORGE.ViewFlat#repeatX
 * @type {string}
 */
Object.defineProperty(FORGE.ViewFlat.prototype, "repeatX",
{
    /** @this {FORGE.ViewFlat} */
    get: function()
    {
        return this._options.repeatX;
    },

    /** @this {FORGE.ViewFlat} */
    set: function(value)
    {
        this._options.repeatX = value;
        this._updateViewParams();

        // Notify the view manager of the change
        this._viewer.view.notifyChange();
    }
});

/**
 * Get and set the repeat Y beahvior.
 * @name  FORGE.ViewFlat#repeatY
 * @type {string}
 */
Object.defineProperty(FORGE.ViewFlat.prototype, "repeatY",
{
    /** @this {FORGE.ViewFlat} */
    get: function()
    {
        return this._options.repeatY;
    },

    /** @this {FORGE.ViewFlat} */
    set: function(value)
    {
        this._options.repeatY = value;
        this._updateViewParams();

        // Notify the view manager of the change
        this._viewer.view.notifyChange();
    }
});

/**
 * GoPro view class.
 *
 * @constructor FORGE.ViewGoPro
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {?ViewOptionsConfig} options - The view options.
 * @extends {FORGE.ViewBase}
 */
FORGE.ViewGoPro = function(viewer, options)
{
    /**
     * Projection distance.
     * @name FORGE.ViewGoPro#_projectionDistance
     * @type {number}
     * @private
     */
    this._projectionDistance = 0;

    FORGE.ViewBase.call(this, viewer, options, "ViewGoPro", FORGE.ViewType.GOPRO);

    this._boot();
};

FORGE.ViewGoPro.prototype = Object.create(FORGE.ViewBase.prototype);
FORGE.ViewGoPro.prototype.constructor = FORGE.ViewGoPro;

/**
 * Boot sequence.
 *
 * @method FORGE.ViewGoPro#_boot
 * @private
 */
FORGE.ViewGoPro.prototype._boot = function()
{
    FORGE.ViewBase.prototype._boot.call(this);

    this._shaderSTW = /** @type {ScreenToWorldProgram} */ (FORGE.Utils.extendSimpleObject({}, FORGE.ShaderLib.screenToWorld.gopro));
    this._shaderWTS = /** @type {WorldToScreenProgram} */ (FORGE.Utils.extendSimpleObject({}, FORGE.ShaderLib.worldToScreen.gopro));

    this._fovMin = FORGE.Math.degToRad(30);
    this._fovMax = FORGE.Math.degToRad(330);
};

/**
 * Update view params.
 * @method FORGE.ViewGoPro#_updateViewParams
 * @private
 */
FORGE.ViewGoPro.prototype._updateViewParams = function()
{
    if (this._viewer !== null)
    {
        var projFovLow = 90;
        var projFovHigh = 180;
        var distance = 0;

        var fov = this._viewer.camera.fov;

        var fn = 0;

        if (fov < projFovLow)
        {
            distance = 0;
            fn = 0;
        }
        else if (fov > projFovHigh)
        {
            distance = 1;
            fn = 1;
        }
        else
        {
            // Apply sinus in out interpolation to smooth the transition
            fn = (fov - projFovLow) / (projFovHigh - projFovLow);
            distance = 0.5 * (1.0 + Math.sin(Math.PI / 2.0 * (2.0 * fn - 1)));
        }

        this._projectionDistance = distance;

        var fovRad = 0.5 * FORGE.Math.degToRad(fov);
        this._projectionScale = (distance + 1) * Math.sin(fovRad) / (distance + Math.cos(fovRad));
    }
};

/**
 * Update uniforms.
 *
 * @method FORGE.ViewGoPro#updateUniforms
 * @param {FORGEUniform} uniforms
 */
FORGE.ViewGoPro.prototype.updateUniforms = function(uniforms)
{
    this._updateViewParams();

    if (typeof uniforms === "undefined")
    {
        return;
    }

    if (uniforms.hasOwnProperty("tProjectionDistance"))
    {
        uniforms.tProjectionDistance.value = this._projectionDistance;
    }

    if (uniforms.hasOwnProperty("tProjectionScale"))
    {
        uniforms.tProjectionScale.value = this._projectionScale;
    }
};

/**
 * Convert a point from world space to screen space.
 *
 * @method FORGE.ViewGoPro#worldToScreen
 * @param {THREE.Vector3} worldPt - 3D point in world space
 * @param {number} parallaxFactor - parallax factor [0..1]
 * @return {?THREE.Vector2} point in screen coordinates
 */
FORGE.ViewGoPro.prototype.worldToScreen = function(worldPt, parallaxFactor)
{
    worldPt = worldPt || new THREE.Vector3();
    worldPt.normalize();
    parallaxFactor = parallaxFactor || 0;

    var worldPt4 = new THREE.Vector4(-worldPt.x, -worldPt.y, worldPt.z, 1.0);
    var camEuler = FORGE.Math.rotationMatrixToEuler(this._viewer.camera.modelView);
    var rotation = FORGE.Math.eulerToRotationMatrix(camEuler.yaw, camEuler.pitch, -camEuler.roll, true);
    rotation = rotation.transpose();
    worldPt4.applyMatrix4(rotation);

    if (worldPt4.z > this._projectionDistance)
    {
        return null;
    }

    var alpha = (this._projectionDistance + 1) / (this._projectionDistance - worldPt4.z);
    var x = -worldPt4.x * alpha;
    var y = -worldPt4.y * alpha;

    x /= (1 + parallaxFactor) * this._projectionScale;
    y /= this._projectionScale;

    return this._fragmentToScreen(new THREE.Vector2(x, y));
};

/**
 * Convert a point from screen space to world space.
 *
 * @method FORGE.ViewGoPro#screenToWorld
 * @param {THREE.Vector2} screenPt - 2D point in screen space [0..w, 0..h]
 * @return {?THREE.Vector3} world point
 */
FORGE.ViewGoPro.prototype.screenToWorld = function(screenPt)
{
    var resolution = this._viewer.renderer.displayResolution;

    screenPt = screenPt || new THREE.Vector2(resolution.width / 2, resolution.height / 2);

    var widthMargin = FORGE.ViewRectilinear.OFF_SCREEN_MARGIN * resolution.width,
        heightMargin = FORGE.ViewRectilinear.OFF_SCREEN_MARGIN * resolution.height;
    if (screenPt.x < -widthMargin || screenPt.x > resolution.width + widthMargin
        || screenPt.y < -heightMargin || screenPt.y > resolution.height + heightMargin)
    {
        return null;
    }

    var fragment = this._screenToFragment(screenPt);
    fragment.multiplyScalar(this._projectionScale);

    var xy2 = fragment.dot(fragment);
    var zs12 = Math.pow(this._projectionDistance + 1, 2);
    var delta = 4 * (this._projectionDistance * this._projectionDistance * xy2 * xy2
                    - (xy2 + zs12) * (xy2 * this._projectionDistance * this._projectionDistance - zs12));

    if (delta < 0)
    {
        return null;
    }

    // world coordinates
    var worldPt = new THREE.Vector4();
    worldPt.z = (2 * this._projectionDistance * xy2 - Math.sqrt(delta)) / (2 * (zs12 + xy2));
    worldPt.x = fragment.x * ((this._projectionDistance - worldPt.z) / (this._projectionDistance + 1));
    worldPt.y = fragment.y * ((this._projectionDistance - worldPt.z) / (this._projectionDistance + 1));

    // move the point in the world system
    var camEuler = FORGE.Math.rotationMatrixToEuler(this._viewer.camera.modelView);
    var rotation = FORGE.Math.eulerToRotationMatrix(-camEuler.yaw, camEuler.pitch, -camEuler.roll, true);
    worldPt.applyMatrix4(rotation);

    return new THREE.Vector3(worldPt.x, -worldPt.y, worldPt.z).normalize();
};

/**
 * Get fov computed for projection.
 * @method FORGE.ViewGoPro#getProjectionFov
 */
FORGE.ViewGoPro.prototype.getProjectionFov = function()
{
    this._updateViewParams();

    var theta = 0.5 * FORGE.Math.degToRad(this._viewer.camera.fov);

    var radius = 1.0 - this._projectionDistance / 2.0;
    var offset = Math.abs(radius - 1);

    var fov = 2 * Math.atan2(radius * Math.sin(theta), offset + radius * Math.cos(theta));

    return fov;
};

/**
 * Destroy method.
 *
 * @method FORGE.ViewGoPro#destroy
 */
FORGE.ViewGoPro.prototype.destroy = function()
{
    FORGE.ViewBase.prototype.destroy.call(this);
};


/**
 * Rectilinear view class.
 *
 * @constructor FORGE.ViewRectilinear
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {?ViewOptionsConfig} options - The view options.
 * @extends {FORGE.ViewBase}
 */
FORGE.ViewRectilinear = function(viewer, options)
{
    FORGE.ViewBase.call(this, viewer, options, "ViewRectilinear", FORGE.ViewType.RECTILINEAR);

    this._boot();
};

FORGE.ViewRectilinear.prototype = Object.create(FORGE.ViewBase.prototype);
FORGE.ViewRectilinear.prototype.constructor = FORGE.ViewRectilinear;

/**
 * Screen margin allowed for semi off screen elements (percentage)
 * @type {number}
 */
FORGE.ViewRectilinear.OFF_SCREEN_MARGIN = 0.5;

/**
 * Boot sequence.
 *
 * @method FORGE.ViewRectilinear#_boot
 * @private
 */
FORGE.ViewRectilinear.prototype._boot = function()
{
    FORGE.ViewBase.prototype._boot.call(this);

    this._shaderSTW = /** @type {ScreenToWorldProgram} */ (FORGE.Utils.extendSimpleObject({}, FORGE.ShaderLib.screenToWorld.rectilinear));
    this._shaderWTS = /** @type {WorldToScreenProgram} */ (FORGE.Utils.extendSimpleObject({}, FORGE.ShaderLib.worldToScreen.rectilinear));

    this._pitchMin = -FORGE.Math.degToRad(90);
    this._pitchMax = FORGE.Math.degToRad(90);

    this._fovMin = FORGE.Math.degToRad(40);
    this._fovMax = FORGE.Math.degToRad(140);
};

/**
 * Update view params.
 * @method FORGE.ViewRectilinear#_updateViewParams
 * @private
 */
FORGE.ViewRectilinear.prototype._updateViewParams = function()
{
    if (this._viewer !== null)
    {
        this._projectionScale = Math.tan(FORGE.Math.degToRad(this._viewer.camera.fov / 2));
    }
};

/**
 * Update uniforms.
 *
 * @method FORGE.ViewRectilinear#updateUniforms
 * @param {FORGEUniform} uniforms
 */
FORGE.ViewRectilinear.prototype.updateUniforms = function(uniforms)
{
    this._updateViewParams();

    if (typeof uniforms === "undefined")
    {
        return;
    }

    if (uniforms.hasOwnProperty("tProjectionScale"))
    {
        uniforms.tProjectionScale.value = this._projectionScale;
    }
};

/**
 * Convert a point from world space to screen space.
 *
 * @method FORGE.ViewRectilinear#worldToScreen
 * @param {THREE.Vector3} worldPt - 3D point in world space
 * @param {number} parallaxFactor - parallax factor [0..1]
 * @return {?THREE.Vector2} point in screen coordinates
 */
FORGE.ViewRectilinear.prototype.worldToScreen = function(worldPt, parallaxFactor)
{
    worldPt = worldPt || new THREE.Vector3();
    worldPt.normalize();
    parallaxFactor = parallaxFactor || 0;

    // Get point projected on unit sphere and apply camera rotation
    var worldPt4 = new THREE.Vector4(worldPt.x, worldPt.y, -worldPt.z, 1.0);
    var camEuler = FORGE.Math.rotationMatrixToEuler(this._viewer.camera.modelView);
    var rotation = FORGE.Math.eulerToRotationMatrix(camEuler.yaw, camEuler.pitch, -camEuler.roll, true);
    rotation = rotation.transpose();
    worldPt4.applyMatrix4(rotation);

    if (worldPt4.z < 0)
    {
        return null;
    }

    // Project on zn plane by dividing x,y components by z
    var projScale = Math.max(Number.EPSILON, worldPt4.z);
    var znPt = new THREE.Vector2(worldPt4.x, worldPt4.y).divideScalar(projScale);

    // Apply fov scaling
    znPt.x /= (1 + parallaxFactor) * this._projectionScale;
    znPt.y /= this._projectionScale;

    // Return fragment
    return this._fragmentToScreen(znPt);
};

/**
 * Convert a point from screen space to world space.
 *
 * @method FORGE.ViewRectilinear#screenToWorld
 * @param {THREE.Vector2} screenPt - 2D point in screen space [0..w, 0..h]
 * @return {?THREE.Vector3} world point
 */
FORGE.ViewRectilinear.prototype.screenToWorld = function(screenPt)
{
    var resolution = this._viewer.renderer.displayResolution;

    screenPt = screenPt || new THREE.Vector2(resolution.width / 2, resolution.height / 2);

    var widthMargin = FORGE.ViewRectilinear.OFF_SCREEN_MARGIN * resolution.width,
        heightMargin = FORGE.ViewRectilinear.OFF_SCREEN_MARGIN * resolution.height;
    if (screenPt.x < -widthMargin || screenPt.x > resolution.width + widthMargin
        || screenPt.y < -heightMargin || screenPt.y > resolution.height + heightMargin)
    {
        return null;
    }

    // move the point in a -1..1 square
    var fragment = this._screenToFragment(screenPt);

    // scale it (see _updateViewParams above)
    fragment.multiplyScalar(this._projectionScale);

    var worldPt = new THREE.Vector4(fragment.x, fragment.y, -1, 0);

    // move the point in the world system
    var camEuler = FORGE.Math.rotationMatrixToEuler(this._viewer.camera.modelView);
    var rotation = FORGE.Math.eulerToRotationMatrix(-camEuler.yaw, camEuler.pitch, -camEuler.roll, true);
    worldPt.applyMatrix4(rotation);

    return new THREE.Vector3(worldPt.x, -worldPt.y, worldPt.z).normalize();
};

/**
 * Destroy method.
 *
 * @method FORGE.ViewRectilinear#destroy
 */
FORGE.ViewRectilinear.prototype.destroy = function()
{
    FORGE.ViewBase.prototype.destroy.call(this);
};


/**
 * Timeline
 *
 * @constructor FORGE.Timeline
 * @param {?Array<FORGE.Keyframe>=} keyframes - Array of keyframes for this timeline.
 *
 * @extends {FORGE.BaseObject}
 */
FORGE.Timeline = function(keyframes)
{
    /**
     * Array of {@link FORGE.Keyframe} for this timeline
     * @name  FORGE.Timeline#_keyframes
     * @type {Array<FORGE.Keyframe>}
     * @private
     */
    this._keyframes = keyframes || [];

    FORGE.BaseObject.call(this, "Timeline");

    this._boot();
};

FORGE.Timeline.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Timeline.prototype.constructor = FORGE.Timeline;

/**
 * Boot routine, sort keyframes if any
 *
 * @method FORGE.Timeline#_boot
 * @private
 */
FORGE.Timeline.prototype._boot = function()
{
    if (FORGE.Utils.isArrayOf(this._keyframes, "Keyframe"))
    {
        this._keyframes = FORGE.Utils.sortArrayByProperty(this._keyframes, "time");
    }
    else
    {
        this._keyframes = [];
    }
};

/**
 * Check if this Timeline object has keyframes.
 *
 * @method  FORGE.Timeline#hasKeyframes
 * @return {boolean}
 */
FORGE.Timeline.prototype.hasKeyframes = function()
{
    return (this._keyframes !== null && this._keyframes.length > 0);
};

/**
 * Add a keyframe to the timeline.
 *
 * @method FORGE.Timeline#addKeyframe
 * @param {FORGE.Keyframe} keyframe - Keyframe to add.
 */
FORGE.Timeline.prototype.addKeyframe = function(keyframe)
{
    if (FORGE.Utils.isTypeOf(keyframe, "Keyframe"))
    {
        this._keyframes.push(keyframe);
        this._keyframes = FORGE.Utils.sortArrayByProperty(this._keyframes, "time");
    }
};

/**
 * Get an object containing the previous and next keyframes given a specific time.
 *
 * @method FORGE.Timeline#getKeyframes
 * @param  {number} time - Time to get the keyframes at
 * @return {TimelinePrevNext} The two keyframes
 */
FORGE.Timeline.prototype.getKeyframes = function(time)
{
    var indexes = this.getKeyframesIndexes(time);

    return {
        previous: this._keyframes[indexes.previous],
        next: this._keyframes[indexes.next] || null
    };
};

/**
 * Get an object containing the indexes of the previous and next keyframes given
 * a specific time.
 *
 * @method FORGE.Timeline#getKeyframesIndexes
 * @param  {number} time - Time to get the keyframes at
 * @return {TimelinePrevNextIndexes} The two indexes
 */
FORGE.Timeline.prototype.getKeyframesIndexes = function(time)
{
    var previous = -1,
        next = -1;

    // Check on each keyframe if there is one with a time shorter than
    // this one. If it exists, it is the previous keyframe
    for (var i = this._keyframes.length - 1; i >= 0; i--)
    {
        if (time >= this._keyframes[i].time)
        {
            previous = i;
            break; // Break allowed as keyframes should be sorted by time
        }
    }

    // If the previous is the last keyframes, consider that there is no more next keyframe. So only allow the set of next if there is a next keyframe.
    if (previous !== this._keyframes.length - 1)
    {
        next = previous + 1;
    }

    return {
        previous: previous,
        next: next
    };
};

/**
 * Get the side keyframes of the two keyframes associated to the given time.
 *
 * @method FORGE.Timeline#getSideKeyframes
 * @param  {number} time - Time to get the keyframes at
 * @return {TimelinePrevNext} The two keyframes
 */
FORGE.Timeline.prototype.getSideKeyframes = function(time)
{
    var indexes = this.getSideKeyframesIndexes(time);

    return {
        previous: this._keyframes[indexes.previous] || null,
        next: this._keyframes[indexes.next] || null
    };
};

/**
 * Get the indexes of the side keyframes of the two keyframes associated to the given time.
 *
 * @method FORGE.Timeline#getSideKeyframesIndexes
 * @param  {number} time - Time to get the keyframes at
 * @return {TimelinePrevNextIndexes} The two keyframes
 */
FORGE.Timeline.prototype.getSideKeyframesIndexes = function(time)
{
    var indexes = this.getKeyframesIndexes(time);

    var previous = 0,
        next = indexes.next;

    if (indexes.previous > 0)
    {
        previous = indexes.previous - 1;
    }

    if (indexes.next < this._keyframes.length - 2)
    {
        next = indexes.next + 1;
    }

    return {
        previous: previous,
        next: next
    };
};

/**
 * Clear all keyframes.
 *
 * @method FORGE.Timeline#emptyKeyframes
 */
FORGE.Timeline.prototype.emptyKeyframes = function()
{

    while (this._keyframes.length > 0)
    {
        var kf = this._keyframes.pop();
        kf.data = null;
        kf = null;
    }

    this._keyframes = [];
};

/**
 * Destroy this object.
 */
FORGE.Timeline.prototype.destroy = function()
{
    while (this._keyframes.length > 0)
    {
        var kf = this._keyframes.pop();
        kf.data = null;
        kf = null;
    }

    this._keyframes = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the keyframes array.
 * @name FORGE.Timeline#keyframes
 * @readonly
 * @type {Array<FORGE.Keyframe>}
 */
Object.defineProperty(FORGE.Timeline.prototype, "keyframes",
{
    /** @this {FORGE.Timeline} */
    get: function()
    {
        return this._keyframes;
    },

    /** @this {FORGE.Timeline} */
    set: function(value)
    {
        if (FORGE.Utils.isArrayOf(value, "Keyframe"))
        {
            this._keyframes = FORGE.Utils.sortArrayByProperty(value, "time");
        }
    }
});
/**
 * A keyframe is a data associated to a time.
 * @constructor FORGE.Keyframe
 * @param {number} time - Time of the keyframe.
 * @param {Object} data - Data bound to the keyframe.
 * @extends {FORGE.BaseObject}
 */
FORGE.Keyframe = function(time, data)
{
    FORGE.BaseObject.call(this, "Keyframe");

    /**
     * The time associated to this keyframe.
     * @name  FORGE.Keyframe#_time
     * @type {number}
     * @private
     */
    this._time = time;

    /**
     * The data associated to this keyframe.
     * @name FORGE.Keyframe#_data
     * @type {Object}
     * @private
     */
    this._data = data;
};

FORGE.Keyframe.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Keyframe.prototype.constructor = FORGE.Keyframe;

/**
 * Get and set the time of keyframe.
 * @name FORGE.Keyframe#time
 * @type {number}
 */
Object.defineProperty(FORGE.Keyframe.prototype, "time",
{
    /** @this {FORGE.Keyframe} */
    get: function()
    {
        return this._time;
    },

    /** @this {FORGE.Keyframe} */
    set: function(value)
    {
        if (typeof value === "number")
        {
            this._time = value;
        }
    }
});

/**
 * Get and set the data of keyframe.
 * @name FORGE.Keyframe#data
 * @type {Object}
 */
Object.defineProperty(FORGE.Keyframe.prototype, "data",
{
    /** @this {FORGE.Keyframe} */
    get: function()
    {
        return this._data;
    },

    /** @this {FORGE.Keyframe} */
    set: function(value)
    {
        this._data = value;
    }
});
/**
 * Abstract class allowing the animation of an element, given instructions about it.
 *
 * @constructor FORGE.Animation
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference
 * @param {*} target - The element to animate
 * @extends {FORGE.BaseObject}
 */
FORGE.Animation = function(viewer, target)
{
    /**
     * Viewer reference.
     * @name FORGE.Animation#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The target of the animation
     * @name FORGE.Animation#_target
     * @type {*}
     * @private
     */
    this._target = target || null;

    /**
     * The instruction to apply on the target.
     * @name FORGE.Animation#_instruction
     * @type {?AnimationInstruction}
     * @private
     */
    this._instruction = null;

    /**
     * Timeline reference.
     * @name FORGE.Animation#_timeline
     * @type {FORGE.Timeline}
     * @private
     */
    this._timeline = null;

    /**
     * The index of the previous keyframe in the timeline.
     * @name FORGE.Animation#_kfp
     * @type {?FORGE.Keyframe}
     * @private
     */
    this._kfp = null;

    /**
     * The index of the next keyframe in the timeline.
     * @name FORGE.Animation#_kfn
     * @type {?FORGE.Keyframe}
     * @private
     */
    this._kfn = null;

    /**
     * Current animation time.
     * @name FORGE.Animation#_time
     * @type {number}
     * @private
     */
    this._time = 0;

    /**
     * Duration of the animation
     * @name FORGE.Animation#_duration
     * @type {number}
     * @private
     */
    this._duration = 0;

    /**
     * Running flag.
     * @name FORGE.Animation#_running
     * @type {boolean}
     * @private
     */
    this._running = false;

    /**
     * Tween object.
     * @name FORGE.Animation#_tween
     * @type {FORGE.Tween}
     * @private
     */
    this._tween = null;

    /**
     * Tween time reference.
     * @name FORGE.Animation#_tweenTime
     * @type {number}
     * @private
     */
    this._tweenTime = 0;

    /**
     * Smooth interpolation flag.
     * @name FORGE.Animation#_smooth
     * @type {boolean}
     * @private
     */
    this._smooth = false;

    /**
     * Left spline for SQUAD algo.
     * @name FORGE.Animation#_sp
     * @type {THREE.Quaternion}
     * @private
     */
    this._sp = null;

    /**
     * Righ spline for SQUAD algo.
     * @name FORGE.Animation#_sn
     * @type {THREE.Quaternion}
     * @private
     */
    this._sn = null;

    /**
     * On animation play event dispatcher.
     * @name FORGE.Animation#_onPlay
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On animation stop event dispatcher.
     * @name FORGE.Animation#_onStop
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onStop = null;

    /**
     * On animation progress event dispatcher.
     * @name FORGE.Animation#_onProgress
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onProgress = null;

    /**
     * On animation complete event dispatcher.
     * @name FORGE.Animation#_onComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onComplete = null;

    FORGE.BaseObject.call(this, "Animation");

    this._boot();
};

FORGE.Animation.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Animation.prototype.constructor = FORGE.Animation;

/**
 * Boot sequence
 *
 * @method FORGE.Animation#_boot
 * @private
 */
FORGE.Animation.prototype._boot = function()
{
    this._register();

    // Create the tween object
    this._tween = new FORGE.Tween(this._viewer, this);
    this._tween.onStart.add(this._onTweenStartHandler, this);
    this._tween.onStop.add(this._onTweenStopHandler, this);
    this._tween.onProgress.add(this._onTweenProgressHandler, this);
    this._tween.onComplete.add(this._onTweenCompleteHandler, this);
    this._viewer.tween.add(this._tween);

    this._timeline = new FORGE.Timeline();
};

/**
 * Get the property from a target and the associated instructions
 *
 * @method FORGE.Animation#_getProp
 * @param  {string} prop - The instruction describing the access of the property
 * @param  {*} target - The target
 * @return {Array} An array composed of the property without the last accessor + the last accessor
 * @private
 */
FORGE.Animation.prototype._getProp = function(prop, target)
{
    var acc = prop.split(".");
    var res = target;

    for (var i = 0, ii = acc.length; i < ii - 1; i++)
    {
        res = res[acc[i]];
    }

    return [res, acc[i]];
};

/**
 * Interpolation evaluation function
 *
 * @method FORGE.Animation#_at
 * @param  {number} t - Current time [0...1]
 * @private
 */
FORGE.Animation.prototype._at = function(t)
{
    // If there is no next keyframe, abort
    if (this._kfn === null)
    {
        return;
    }

    // Update the time, given the current keyframes
    this._time = (t * this._duration) + this._kfp.time;

    var props = [],
        prop, i, ii;

    if (!Array.isArray(this._instruction.prop))
    {
        this._instruction.prop = [this._instruction.prop];
    }

    ii = this._instruction.prop.length;

    // Get all properties to update
    for (i = 0; i < ii; i++)
    {
        props.push(this._getProp(this._instruction.prop[i], this._target));
    }

    // If smooth, interpolate all properties together
    if (this._instruction.smooth === true && this._instruction.prop[0] === "quaternion")
    {
        // SQUAD interpolation
        prop = props[0];
        prop[0].quaternion = FORGE.Quaternion.squadNoInvert(this._kfp.data.quaternion, this._sp, this._sn, this._kfn.data.quaternion, t);
    }
    // Else no smooth interpolation, interpolate properties one by one
    else if (this._instruction.prop[0] === "quaternion")
    {
        prop = props[0];
        prop[0].quaternion = FORGE.Quaternion.slerp(this._kfp.data.quaternion, this._kfn.data.quaternion, t);
    }
    else
    {
        var alpha = this._tween.easing(t);
        var pp, pn, offset = 0;

        // For each property of the instruction
        for (i = 0; i < ii; i++)
        {
            // Get the previous and the next properties related to the current one
            pp = this._getProp(this._instruction.prop[i], this._kfp.data);
            pn = this._getProp(this._instruction.prop[i], this._kfn.data);

            prop = props[i];

            pp = pp[0][pp[1]];
            pn = pn[0][pn[1]];

            // Wrap it if necessary
            if (this._instruction.wrap && this._instruction.wrap[i])
            {
                var ilow = this._instruction.wrap[i][0];
                var ihigh = this._instruction.wrap[i][1];

                offset = Math.abs(ilow - ihigh) / 2;

                // Change the direction
                if (Math.abs(pp - pn) > offset)
                {
                    pp = FORGE.Math.wrap(pp + offset, ilow, ihigh);
                    pn = FORGE.Math.wrap(pn + offset, ilow, ihigh);
                }
                else
                {
                    offset = 0;
                }
            }

            // Update it using a classic alpha
            prop[0][prop[1]] = (1 - alpha) * pp + alpha * pn - offset;
        }
    }

    if (typeof this._instruction.fun === "function")
    {
        this._instruction.fun.call(this, t);
    }
};

/**
 * Go from the current keyframe to the next one. If no time is specified, it
 * takes the two next keyframes if there are one, given the current time.
 *
 * @method FORGE.Animation#_goTo
 * @param {number=} time - Time to start the animation at
 * @private
 */
FORGE.Animation.prototype._goTo = function(time)
{
    time = time || this._time;

    this.log("going to the next keyframes at " + time);

    // By default, increase keyframes by 1
    var kfs = this._timeline.getKeyframesIndexes(time || this._time);
    this._kfn = this._timeline.keyframes[kfs.next];
    this._kfp = this._timeline.keyframes[kfs.previous];

    if (this._kfn === null || kfs.next === -1)
    {
        return false;
    };

    // If smooth, prepare SQUAD interpolation
    if (this._smooth)
    {
        this._prepareSQUAD(time);
    }

    // Configure the tween
    this._duration = this._kfn.time - this._kfp.time;

    this._tween.to(
    {
        "tweenTime": 1
    }, this._duration);

    this._tweenTime = 0;

    // Start the tween
    this._tween.start();

    return true;
};

/**
 * Prepare the SQUAD interpolation if wanted.
 * From Shoemake 85 at SIGGRAPH
 * http://run.usc.edu/cs520-s12/assign2/p245-shoemake.pdf
 *
 * @method FORGE.Animation#_prepareSQUAD
 * @param {number} time - Time to start the animation at
 * @private
 */
FORGE.Animation.prototype._prepareSQUAD = function(time)
{
    var sideKfs = this._timeline.getSideKeyframes(time);

    if (sideKfs.previous === null || sideKfs.next === null)
    {
        return;
    }

    // Quaternions to join with a path
    var qp = new THREE.Quaternion().copy(this._kfp.data.quaternion).normalize();
    var qn = new THREE.Quaternion().copy(this._kfn.data.quaternion).normalize();

    // Quaternions before and after the previous ones, used for interpolation
    var qpp = new THREE.Quaternion().copy(sideKfs.previous.data.quaternion).normalize();
    var qnn = new THREE.Quaternion().copy(sideKfs.next.data.quaternion).normalize();

    // Compute the splines used for describing the path of the camera
    this._sp = FORGE.Quaternion.spline(qpp, qp, qn);
    this._sn = FORGE.Quaternion.spline(qp, qn, qnn);
};

/**
 * On tween start event handler
 *
 * @method FORGE.Animation#_onTweenStartHandler
 * @private
 */
FORGE.Animation.prototype._onTweenStartHandler = function()
{
    // Don't dispatch the event if the animation is already running
    if (this._running !== true)
    {
        if (this._onPlay !== null)
        {
            this._onPlay.dispatch();
        }

        this._running = true;
    }
};

/**
 * On tween stop event handler
 *
 * @method FORGE.Animation#_onTweenStopHandler
 * @private
 */
FORGE.Animation.prototype._onTweenStopHandler = function()
{
    this._running = false;

    if (this._onStop !== null)
    {
        this._onStop.dispatch();
    }
};

/**
 * On tween progress event handler
 *
 * @method FORGE.Animation#_onTweenProgressHandler
 * @private
 */
FORGE.Animation.prototype._onTweenProgressHandler = function()
{
    // Interpolate
    this._at(this._tweenTime);

    if (this._onProgress !== null)
    {
        this._onProgress.dispatch(
        {
            progress: this._time / this._duration
        });
    }
};

/**
 * On tween complete event handler
 *
 * @method FORGE.Animation#_onTweenCompleteHandler
 * @private
 */
FORGE.Animation.prototype._onTweenCompleteHandler = function()
{
    // Don't dispatch the event until the whole animation is stopped
    if (!this._goTo())
    {
        if (this._onComplete !== null)
        {
            this._onComplete.dispatch();
        }
    }
};

/**
 * Play the animation.
 *
 * @method  FORGE.Animation#play
 * @param {number=} time - Time to start the animation at
 */
FORGE.Animation.prototype.play = function(time)
{
    // Reset the time
    this._time = time || 0;

    // Start the animation
    this._goTo(this._time);
};

/**
 * Stop the animation.
 *
 * @method  FORGE.Animation#stop
 */
FORGE.Animation.prototype.stop = function()
{
    this._tween.stop();
};

/**
 * Resume the animation.
 *
 * @method  FORGE.Animation#resume
 */
FORGE.Animation.prototype.resume = function()
{
    this._goTo();
};

/**
 * Destroy sequence.
 *
 * @method FORGE.Animation#destroy
 */
FORGE.Animation.prototype.destroy = function()
{
    if (this._timeline !== null)
    {
        this._timeline.destroy();
        this._timeline = null;
    }

    if (this._tween !== null)
    {
        this._tween.destroy();
        this._tween = null;
    }

    if (this._onPlay !== null)
    {
        this._onPlay.destroy();
        this._onPlay = null;
    }

    if (this._onStop !== null)
    {
        this._onStop.destroy();
        this._onStop = null;
    }

    if (this._onProgress !== null)
    {
        this._onProgress.destroy();
        this._onProgress = null;
    }

    if (this._onComplete !== null)
    {
        this._onComplete.destroy();
        this._onComplete = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Accessors to the running flag
 * @name FORGE.Animation#running
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Animation.prototype, "running",
{
    /** @this {FORGE.Animation} */
    get: function()
    {
        return this._running;
    }
});

/**
 * Accessors to timeline
 * @name FORGE.Animation#timeline
 * @readonly
 * @type {FORGE.Timeline}
 */
Object.defineProperty(FORGE.Animation.prototype, "timeline",
{
    /** @this {FORGE.Animation} */
    get: function()
    {
        return this._timeline;
    }
});

/**
 * Accessors to instruction.
 * @name FORGE.Animation#instruction
 * @type {AnimationInstruction}
 */
Object.defineProperty(FORGE.Animation.prototype, "instruction",
{
    /** @this {FORGE.Animation} */
    get: function()
    {
        return this._instruction;
    },

    /** @this {FORGE.Animation} */
    set: function(value)
    {
        this._instruction = value;
    }
});

/**
 * Accessors to tween.
 * @name FORGE.Animation#tween
 * @type {number}
 */
Object.defineProperty(FORGE.Animation.prototype, "tween",
{
    /** @this {FORGE.Animation} */
    get: function()
    {
        return this._tween;
    },

    /** @this {FORGE.Animation} */
    set: function(value)
    {
        this._tween = value;
    }
});

/**
 * Accessors to normalized tween time.
 * @name FORGE.Animation#tweenTime
 * @type {number}
 */
Object.defineProperty(FORGE.Animation.prototype, "tweenTime",
{
    /** @this {FORGE.Animation} */
    get: function()
    {
        return this._tweenTime;
    },

    /** @this {FORGE.Animation} */
    set: function(value)
    {
        this._tweenTime = value;
    }
});

/**
 * Accessors to smooth.
 * @name FORGE.Animation#smooth
 * @type {number}
 */
Object.defineProperty(FORGE.Animation.prototype, "smooth",
{
    /** @this {FORGE.Animation} */
    get: function()
    {
        return this._smooth;
    },

    /** @this {FORGE.Animation} */
    set: function(value)
    {
        this._smooth = value;
    }
});

/**
 * Get the "onPlay" {@link FORGE.EventDispatcher} of the target.
 * @name FORGE.Animation#onPlay
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Animation.prototype, "onPlay",
{
    /** @this {FORGE.Animation} */
    get: function()
    {
        if (this._onPlay === null)
        {
            this._onPlay = new FORGE.EventDispatcher(this);
        }

        return this._onPlay;
    }
});

/**
 * Get the "onStop" {@link FORGE.EventDispatcher} of the target.
 * @name FORGE.Animation#onStop
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Animation.prototype, "onStop",
{
    /** @this {FORGE.Animation} */
    get: function()
    {
        if (this._onStop === null)
        {
            this._onStop = new FORGE.EventDispatcher(this);
        }

        return this._onStop;
    }
});

/**
 * Get the "onProgress" {@link FORGE.EventDispatcher} of the target.
 * @name FORGE.Animation#onProgress
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Animation.prototype, "onProgress",
{
    /** @this {FORGE.Animation} */
    get: function()
    {
        if (this._onProgress === null)
        {
            this._onProgress = new FORGE.EventDispatcher(this);
        }

        return this._onProgress;
    }
});

/**
 * Get the "onComplete" {@link FORGE.EventDispatcher} of the target.
 * @name FORGE.Animation#onComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Animation.prototype, "onComplete",
{
    /** @this {FORGE.Animation} */
    get: function()
    {
        if (this._onComplete === null)
        {
            this._onComplete = new FORGE.EventDispatcher(this);
        }

        return this._onComplete;
    }
});

/**
 * A meta-animation, used to provide basic functionnality for the interface
 * between an ObjectAnimation and FORGE.Animation.
 *
 * @constructor FORGE.MetaAnimation
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {*} target - Target reference.
 * @param {string} name - Name of the ObjectAnimation.
 * @extends {FORGE.BaseObject}
 */
FORGE.MetaAnimation = function(viewer, target, name)
{
    /**
     * Viewer reference.
     * @name FORGE.MetaAnimation#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The target of the animation
     * @name FORGE.MetaAnimation#_target
     * @type {*}
     * @private
     */
    this._target = target || null;

    /**
     * The array of animations related to the camera.
     * @name FORGE.MetaAnimation#_animations
     * @type {Array<FORGE.Animation>}
     * @private
     */
    this._animations = null;

    /**
     * The number of finished animations.
     * @name FORGE.MetaAnimation#_finished
     * @type {number}
     * @private
     */
    this._finished = 0;

    /**
     * The instructions to apply on the target.
     * @name FORGE.MetaAnimation#_instructions
     * @type {Array<AnimationInstruction>}
     * @private
     */
    this._instructions = null;

    /**
     * On animation complete event dispatcher.
     * @name FORGE.MetaAnimation#_onComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onComplete = null;

    FORGE.BaseObject.call(this, name);
};

FORGE.MetaAnimation.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.MetaAnimation.prototype.constructor = FORGE.MetaAnimation;

/**
 * Stop the animations.
 *
 * @method FORGE.MetaAnimation#stop
 */
FORGE.MetaAnimation.prototype.stop = function()
{
    if (this._animations === null)
    {
        return;
    }

    for (var i = 0, ii = this._animations.length; i < ii; i++)
    {
        this._animations[i].stop();
    }
};

/**
 * Resume the animations.
 *
 * @method FORGE.MetaAnimation#resume
 */
FORGE.MetaAnimation.prototype.resume = function()
{
    if (this._animations === null)
    {
        return;
    }

    for (var i = 0, ii = this._animations.length; i < ii; i++)
    {
        this._animations[i].resume();
    }
};

/**
 * On animation complete event handler.
 *
 * @method FORGE.Animation#_onTrackPartialCompleteHandler
 * @private
 */
FORGE.MetaAnimation.prototype._onTrackPartialCompleteHandler = function()
{
    this._finished++;

    if (this._finished === this._animations.length && this._onComplete !== null)
    {
        this._onComplete.dispatch();
    }
};

/**
 * Compute the intermediate value of a property, approximatly.
 *
 * @method FORGE.MetaAnimation#_computeIntermediateValue
 * @param  {number} time - the time when to interpolate
 * @param  {Array<FORGE.Keyframe>} kfs - The list of keyframes
 * @param  {string} prop - The name of the property
 * @param  {Function} easing - The name of the easing property
 * @param  {string=} ns - The namespace to add before the property
 * @return {number} the interpolated property
 * @private
 */
FORGE.MetaAnimation.prototype._computeIntermediateValue = function(time, kfs, prop, easing, ns)
{
    var kp = null,
        kn = null,
        res;

    // Sort by time
    kfs = FORGE.Utils.sortArrayByProperty(kfs, "time");

    // Search for the two nearest keyframes
    for (var i = 0; i < kfs.length; i++)
    {
        var p = (typeof ns === "string") ? kfs[i].data[ns][prop] : kfs[i].data[prop];

        if (typeof p !== "undefined" && p !== null)
        {
            // Update previous key if time is still inferior
            if (kfs[i].time < time)
            {
                kp = kfs[i];
            }

            // Update next key on first one and break the loop
            if (kfs[i].time > time)
            {
                kn = kfs[i];
                break;
            }
        }
    }

    // If no kp, let's consider it is the data of the current target
    if (kp === null)
    {
        kp = {
            time: 0,
            data: {}
        };

        if (typeof ns === "string")
        {
            kp.data[ns] = this._target[ns];
        }
        else
        {
            kp.data[prop] = this._target[prop];
        }
    }

    // If no kn, then nothing needs to be done
    if (kn === null)
    {
        return (typeof ns === "string") ? kp.data[ns][prop] : kp.data[prop];
    }

    // Now that we have the two, we can compute the proportion of the time
    var ratio = (time - kp.time) / (kn.time - kp.time);
    var alpha = easing(ratio);

    // Return the interpolated property
    var kpp = (typeof ns === "string") ? kp.data[ns][prop] : kp.data[prop];
    var knp = (typeof ns === "string") ? kn.data[ns][prop] : kn.data[prop];
    return (1 - alpha) * kpp + alpha * knp;
};

/**
 * Empty the array of animations.
 *
 * @method FORGE.MetaAnimation#_emptyAnimations
 * @private
 */
FORGE.MetaAnimation.prototype._emptyAnimations = function()
{
    var animation;

    while (this._animations && this._animations.length > 0)
    {
        animation = this._animations.pop();
        animation.onComplete.remove(this._onTrackPartialCompleteHandler, this);
        animation.destroy();
    }

    this._animations = [];
    this._finished = 0;
};

/**
 * Destroy sequence.
 * @method FORGE.MetaAnimation#destroy
 */
FORGE.MetaAnimation.prototype.destroy = function()
{
    this._emptyAnimations();

    this._animations = null;

    var instruction;

    while (this._instructions && this._instructions.length > 0)
    {
        instruction = this._instructions.pop();
        instruction = null;
    }

    this._instructions = null;

    if (this._onComplete !== null)
    {
        this._onComplete.destroy();
        this._onComplete = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Accessors to timeline
 * @name FORGE.MetaAnimation#running
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.MetaAnimation.prototype, "running",
{
    /** @this {FORGE.MetaAnimation} */
    get: function()
    {
        for(var i = 0, ii = this._animations.length; i < ii; i++)
        {
            if(this._animations[i].running === true)
            {
                return true;
            }
        }

        return false;
    }
});

/**
 * Get the "onComplete" {@link FORGE.EventDispatcher} of the target.
 * @name FORGE.MetaAnimation#onComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.MetaAnimation.prototype, "onComplete",
{
    /** @this {FORGE.MetaAnimation} */
    get: function()
    {
        if (this._onComplete === null)
        {
            this._onComplete = new FORGE.EventDispatcher(this);
        }

        return this._onComplete;
    }
});

/**
 * Abstract class for Track used in animations. Contains three basic elements: name, description and keyframe. Useful for i18n. It also contains the number of time the track has been played.
 *
 * @constructor FORGE.Track
 * @param {string} name - The name of the class
 * @extends {FORGE.BaseObject}
 */
FORGE.Track = function(name)
{
    /**
     * Name of the track
     * @name FORGE.Track#_name
     * @type {?string}
     * @private
     */
    this._name = null;

    /**
     * Description of the track
     * @name FORGE.Track#_description
     * @type {?string}
     * @private
     */
    this._description = null;

    /**
     * List of keyframes composing the track
     * @name FORGE.Track#_keyframes
     * @type {Array}
     * @private
     */
    this._keyframes = null;

    /**
     * This is the number of times this track has been played.
     * @name  FORGE.Track#_count
     * @type {number}
     * @private
     */
    this._count = 0;

    /**
     * Easing curve for the tween between each keyframe.
     * @name FORGE.Track#_easing
     * @type {?string}
     * @private
     */
    this._easing = null;

    /**
     * Time to take to reach the current position to the first one.
     * @name  FORGE.Track#_offset
     * @type {number}
     * @private
     */
    this._offset = 0;

    FORGE.BaseObject.call(this, name);
};

FORGE.Track.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Track.prototype.constructor = FORGE.Track;

/**
 * Boot sequence
 *
 * @method FORGE.Track#_boot
 * @param  {Object} config - The information on the track
 * @private
 */
FORGE.Track.prototype._boot = function(config)
{
    this._uid = config.uid;
    this._name = config.name;
    this._description = config.description;
    this._keyframes = config.keyframes;

    this._easing = "linear";
    this._offset = 0;

    if (typeof config.easing === "object" && config.easing !== null)
    {
        this._easing = config.easing.default || this._easing;
        this._offset = config.easing.offset || this._offset;
    }

    this._register();
};

FORGE.Track.prototype.destroy = function()
{
    this._unregister();
};

/**
 * Get the name of the track.
 * @name FORGE.Track#name
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Track.prototype, "name",
{
    /** @this {FORGE.Track} */
    get: function()
    {
        return this._name;
    }
});

/**
 * Get the description of the track.
 * @name FORGE.Track#description
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Track.prototype, "description",
{
    /** @this {FORGE.Track} */
    get: function()
    {
        return this._description;
    }
});

/**
 * Get the keyframes of the track.
 * @name FORGE.Track#keyframes
 * @readonly
 * @type {Array}
 */
Object.defineProperty(FORGE.Track.prototype, "keyframes",
{
    /** @this {FORGE.Track} */
    get: function()
    {
        return this._keyframes;
    }
});

/**
 * Get the number of times this director track has been played.
 * @name FORGE.Track#count
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.Track.prototype, "count",
{
    /** @this {FORGE.Track} */
    set: function(value)
    {
        if (typeof value === "number")
        {
            this._count = value;
        }
    },

    /** @this {FORGE.Track} */
    get: function()
    {
        return this._count;
    }
});

/**
 * Get the easing of the track.
 * @name FORGE.Track#easing
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Track.prototype, "easing",
{
    /** @this {FORGE.Track} */
    get: function()
    {
        return this._easing;
    }
});

/**
 * Get the starting time of the track.
 * @name FORGE.Track#offset
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Track.prototype, "offset",
{
    /** @this {FORGE.Track} */
    get: function()
    {
        return this._offset;
    }
});

/**
 * Get the total duration of the track.
 * @name FORGE.Track#duration
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.Track.prototype, "duration",
{
    /** @this {FORGE.Track} */
    get: function()
    {
        var res = this._keyframes[0].time;

        for (var i = 1, ii = this._keyframes.length; i < ii; i++)
        {
            if (this._keyframes[i].time > res)
            {
                res = this._keyframes[i].time;
            }
        }

        return res;
    }
});


/**
 * ForgeJS Base 3d object with a mesh and events mechanisms.
 * @constructor FORGE.Object3D
 * @param {FORGE.Viewer} viewer - Viewer reference.
 * @param {string=} className - Class name for objects that extends Object3D
 * @extends {FORGE.BaseObject}
 */
FORGE.Object3D = function(viewer, className)
{
    /**
     * Viewer reference
     * @name  FORGE.Object3D#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * THREE Mesh
     * @name FORGE.Object3D#_mesh
     * @type {THREE.Mesh}
     * @private
     */
    this._mesh = null;

    /**
     * The fx set id applied to the object
     * @name  FORGE.Object3D#_fx
     * @type {string}
     * @private
     */
    this._fx = "";

    /**
     * Visibility flag
     * @name  FORGE.Object3D#_visible
     * @type {boolean}
     * @private
     */
    this._visible = true;

    /**
     * Is this object is interactive / raycastable
     * @name FORGE.Object3D#_interactive
     * @type {boolean}
     * @private
     */
    this._interactive = true;

    /**
     * Events object that will keep references of the ActionEventDispatcher
     * @name FORGE.Object3D#_events
     * @type {Object<FORGE.ActionEventDispatcher>}
     * @private
     */
    this._events = null;

    /**
     * The hovered flag is set to true when any pointer is over the object.
     * @name FORGE.Object3D#_hovered
     * @type {boolean}
     * @private
     */
    this._hovered = false;

    /**
     * Color based on 3D Object id used for picking.
     * @name FORGE.Object3D#_pickingColor
     * @type {THREE.Color}
     * @private
     */
    this._pickingColor = null;

    /**
     * Is ready?
     * @name  FORGE.Object3D#_ready
     * @type {boolean}
     * @private
     */
    this._ready = false;

    /**
     * Click event dispatcher
     * @name FORGE.Object3D#_onClick
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onClick = null;

    /**
     * Over event dispatcher
     * @name FORGE.Object3D#_onOver
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onOver = null;

    /**
     * Out event dispatcher
     * @name FORGE.Object3D#_onOut
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onOut = null;

    /**
     * Event dispatcher for ready state.
     * @name FORGE.Object3D#_onReady
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onReady = null;

    FORGE.BaseObject.call(this, className || "Object3D");

    this._boot();
};

FORGE.Object3D.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Object3D.prototype.constructor = FORGE.Object3D;

/**
 * Boot sequence.
 * @method FORGE.Object3D#_boot
 */
FORGE.Object3D.prototype._boot = function()
{
    this._events = {};
    this._mesh = new THREE.Mesh();
    this._pickingColor = FORGE.PickingDrawPass.colorFrom3DObject(this._mesh);
    this._viewer.renderer.objects.register(this);
};

/**
 * Create action events dispatchers.
 * @method FORGE.Object3D#_createEvents
 * @private
 * @param {Object} events - The events config of the 3d object.
 */
FORGE.Object3D.prototype._createEvents = function(events)
{
    var event;
    for(var e in events)
    {
        event = new FORGE.ActionEventDispatcher(this._viewer, e);
        event.addActions(events[e]);
        this._events[e] = event;
    }
};

/**
 * Clear all object events.
 * @method FORGE.Object3D#_clearEvents
 * @private
 */
FORGE.Object3D.prototype._clearEvents = function()
{
    for(var e in this._events)
    {
        this._events[e].destroy();
        this._events[e] = null;
    }
};

/**
 * Triggers actions for the click event
 * @method FORGE.Object3D#click
 */
FORGE.Object3D.prototype.click = function()
{
    this.log("click " + this._mesh.id);

    // Actions defined from the json
    if(FORGE.Utils.isTypeOf(this._events.onClick, "ActionEventDispatcher") === true)
    {
        this._events.onClick.dispatch();
    }

    // Classical event dispatcher
    if(this._onClick !== null)
    {
        this._onClick.dispatch();
    }
};

/**
 * Triggers actions for the over event
 * @method FORGE.Object3D#over
 */
FORGE.Object3D.prototype.over = function()
{
    this.log("over " + this._mesh.id);

    // Actions defined from the json
    if(FORGE.Utils.isTypeOf(this._events.onOver, "ActionEventDispatcher") === true)
    {
        this._events.onOver.dispatch();
    }

    // Classical event dispatcher
    if(this._onOver !== null)
    {
        this._onOver.dispatch();
    }
};

/**
 * Triggers actions for the out event
 * @method FORGE.Object3D#out
 */
FORGE.Object3D.prototype.out = function()
{
    this.log("out " + this._mesh.id);

    // Actions defined from the json
    if(FORGE.Utils.isTypeOf(this._events.onOut, "ActionEventDispatcher") === true)
    {
        this._events.onOut.dispatch();
    }

    // Classical event dispatcher
    if(this._onOut !== null)
    {
        this._onOut.dispatch();
    }
};

/**
 * Destroy sequence
 * @method FORGE.Object3D#destroy
 */
FORGE.Object3D.prototype.destroy = function()
{
    this._viewer.renderer.objects.unregister(this);

    if (this._mesh !== null)
    {
        this._mesh.userData = null;

        if (this._mesh.geometry !== null)
        {
            this._mesh.geometry.dispose();
            this._mesh.geometry = null;
        }

        this._mesh.material = null;

        this._mesh = null;
    }

    if(this._onClick !== null)
    {
        this._onClick.destroy();
        this._onClick = null;
    }

    if(this._onOver !== null)
    {
        this._onOver.destroy();
        this._onOver = null;
    }

    if(this._onOut !== null)
    {
        this._onOut.destroy();
        this._onOut = null;
    }

    if(this._onReady !== null)
    {
        this._onReady.destroy();
        this._onReady = null;
    }

    this._clearEvents();
    this._events = null;

    this._viewer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * 3D object mesh
 * @name FORGE.Object3D#mesh
 * @readonly
 * @type {THREE.Mesh}
  */
Object.defineProperty(FORGE.Object3D.prototype, "mesh",
{
    /** @this {FORGE.Object3D} */
    get: function()
    {
        return this._mesh;
    }
});

/**
 * Get and set the visible flag
 * @name FORGE.Object3D#visible
 * @type {boolean}
 */
Object.defineProperty(FORGE.Object3D.prototype, "visible",
{
    /** @this {FORGE.Object3D} */
    get: function()
    {
        return this._visible;
    },
    /** @this {FORGE.Object3D} */
    set: function(value)
    {
        this._visible = Boolean(value);

        if(this._mesh !== null)
        {
            this._mesh.visible = this._visible;
        }
    }
});

/**
 * Get and set the hovered flag
 * @name FORGE.Object3D#hovered
 * @type {boolean}
 */
Object.defineProperty(FORGE.Object3D.prototype, "hovered",
{
    /** @this {FORGE.Object3D} */
    get: function()
    {
        return this._hovered;
    },
    /** @this {FORGE.Object3D} */
    set: function(value)
    {
        this._hovered = Boolean(value);
    }
});


/**
 * Get and set the interactive flag
 * @name FORGE.Object3D#interactive
 * @type {boolean}
 */
Object.defineProperty(FORGE.Object3D.prototype, "interactive",
{
    /** @this {FORGE.Object3D} */
    get: function()
    {
        return this._interactive;
    },
    /** @this {FORGE.Object3D} */
    set: function(value)
    {
        this._interactive = Boolean(value);
    }
});

/**
 * Get the FX applied to this object
 * @name FORGE.Object3D#fx
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Object3D.prototype, "fx",
{
    /** @this {FORGE.Object3D} */
    get: function()
    {
        return this._fx;
    }
});

/**
 * Get the events of this object
 * @name FORGE.Object3D#events
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.Object3D.prototype, "events",
{
    /** @this {FORGE.Object3D} */
    get: function()
    {
        return this._events;
    }
});

/**
 * Object3D ready flag
 * @name FORGE.Object3D#ready
 * @readonly
 * @type boolean
  */
Object.defineProperty(FORGE.Object3D.prototype, "ready",
{
    /** @this {FORGE.Object3D} */
    get: function()
    {
        return this._ready;
    }
});

/**
 * Get the onClick {@link FORGE.EventDispatcher}.
 * @name FORGE.Object3D#onClick
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Object3D.prototype, "onClick",
{
    /** @this {FORGE.Object3D} */
    get: function()
    {
        if (this._onClick === null)
        {
            this._onClick = new FORGE.EventDispatcher(this);
        }

        return this._onClick;
    }
});

/**
 * Get the onOver {@link FORGE.EventDispatcher}.
 * @name FORGE.Object3D#onOver
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Object3D.prototype, "onOver",
{
    /** @this {FORGE.Object3D} */
    get: function()
    {
        if (this._onOver === null)
        {
            this._onOver = new FORGE.EventDispatcher(this);
        }

        return this._onOver;
    }
});

/**
 * Get the onOut {@link FORGE.EventDispatcher}.
 * @name FORGE.Object3D#onOut
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Object3D.prototype, "onOut",
{
    /** @this {FORGE.Object3D} */
    get: function()
    {
        if (this._onOut === null)
        {
            this._onOut = new FORGE.EventDispatcher(this);
        }

        return this._onOut;
    }
});

/**
 * Get the onReady {@link FORGE.EventDispatcher}.
 * @name FORGE.Object3D#onReady
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Object3D.prototype, "onReady",
{
    /** @this {FORGE.Object3D} */
    get: function()
    {
        if (this._onReady === null)
        {
            this._onReady = new FORGE.EventDispatcher(this);
        }

        return this._onReady;
    }
});


/**
 * @constructor FORGE.ObjectRenderer
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.ObjectRenderer = function(viewer)
{
    /**
     * Viewer reference
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * List of object that have to be rendered
     * @name FORGE.ObjectRenderer#_objects
     * @type {Array<FORGE.Object3D>}
     * @private
     */
    this._objects = null;

    /**
     * Array of render passes
     * @type {Array<FORGE.RenderScene>}
     * @private
     */
    this._renderScenes = null;

    FORGE.BaseObject.call(this, "ObjectRenderer");

    this._boot();
};

FORGE.ObjectRenderer.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.ObjectRenderer.prototype.constructor = FORGE.ObjectRenderer;

/**
 * Init routine
 * @method FORGE.ObjectRenderer#_boot
 * @private
 */
FORGE.ObjectRenderer.prototype._boot = function()
{
    this._objects = [];
    this._renderScenes = [];
};

/**
 * Get 3d objects by FX
 * @method  FORGE.ObjectRenderer#_getByFX
 * @param  {?string} fx - The fx name you want to use to filter 3d objects. If undefined or null, will return 3d objects without fx.
 * @return {Array<FORGE.Object3D>}
 * @private
 */
FORGE.ObjectRenderer.prototype._getByFX = function(fx)
{
    var result = [];

    if(typeof fx === "undefined" || fx === "" || fx === null)
    {
        result = this._objects.filter(function(hs)
        {
            return (typeof hs.fx === "undefined" || hs.fx === "" || hs.fx === null);
        });
    }
    else
    {
        result = this._objects.filter(function(hs)
        {
            return hs.fx === fx;
        });
    }

    return result;
};

/**
 * Get 3d objects that have no fx
 * @method  FORGE.ObjectRenderer#_getWithoutFX
 * @return {Array<FORGE.Object3D>}
 * @private
 */
FORGE.ObjectRenderer.prototype._getWithoutFX = function()
{
    var result = this._getByFX(null);
    return result;
};

/**
 * Get 3d objects that have fx
 * @method  FORGE.ObjectRenderer#_getWithFX
 * @return {Array<FORGE.Object3D>}
 * @private
 */
FORGE.ObjectRenderer.prototype._getWithFX = function()
{
    var withoutFX = this._getWithoutFX();
    var result = FORGE.Utils.arrayByDifference(this._objects, withoutFX);
    return result;
};

/**
 * Get single fx list used by all objects
 * @method  FORGE.ObjectRenderer#_getFX
 * @return {Array<string>}
 * @private
 */
FORGE.ObjectRenderer.prototype._getFX = function()
{
    var withFX = this._getWithFX();

    var result = withFX.reduce(function(list, spot)
    {
        if (list.indexOf(spot.fx) < 0)
        {
            list.push(spot.fx);
        }

        return list;

    }, []);

    return result;
};

/**
 * Register an object to the object renderer
 * @method FORGE.ObjectRenderer#register
 * @param  {FORGE.Object3D} object - The object to register
 */
FORGE.ObjectRenderer.prototype.register = function(object)
{
    this._objects.push(object);
};

/**
 * Unregister an object from the object renderer.
 * @method  FORGE.ObjectRenderer#unregister
 * @param {FORGE.Object3D} object - The object to unregister from the object renderer.
 */
FORGE.ObjectRenderer.prototype.unregister = function(object)
{
    this._objects.splice(this._objects.indexOf(object), 1);
};

/**
 * @method FORGE.ObjectRenderer#createRenderScenes
 */
FORGE.ObjectRenderer.prototype.createRenderScenes = function()
{
    // First get all 3d objects without any FX and create a render pass for them
    // Then get all other 3d objects (with some FX), extract FX list and create
    // as many render passes as needed (one for each FX set).

    var camera = this._viewer.renderer.camera.main;

    // Get list of objects without any fx
    var withoutFX = this._getWithoutFX();

    // Create a render pass for them
    if (withoutFX.length > 0)
    {
        var scene = new THREE.Scene();

        for (var i = 0, ii = withoutFX.length; i < ii; i++)
        {
            scene.add(withoutFX[i].mesh);
        }

        var renderScene = new FORGE.RenderScene(this._viewer, scene, camera, null);
        this._renderScenes.push(renderScene);
    }

    var fxList = this._getFX();

    // For each FX in the list, create a render scene and assign all 3d objects
    // with the FX to it
    for (var j = 0, jj = fxList.length; j < jj; j++)
    {
        var fx = fxList[j];
        var renderList = this._getByFX(fx);
        var sceneFx = new THREE.Scene();

        for (var k = 0, kk = renderList.length; k < kk; k++)
        {
            sceneFx.add(renderList[k].mesh);
        }

        var fxSet = this._viewer.postProcessing.getFxSetByUID(fx);

        var renderScene = new FORGE.RenderScene(this._viewer, sceneFx, camera, fxSet);
        this._renderScenes.push(renderScene);
    }
};

/**
 * Get 3d objects that are eligible to raycast (interactive)
 * @method  FORGE.ObjectRenderer#getRaycastable
 * @return {Array<FORGE.Object3D>}
 */
FORGE.ObjectRenderer.prototype.getRaycastable = function()
{
    var result = this._objects.filter(function(object)
    {
        return (object.ready === true && object.interactive === true);
    });

    return result;
};

/**
 * Get a 3d object from it's mesh
 * @method  FORGE.ObjectRenderer#getByMesh
 * @return {?FORGE.Object3D}
 */
FORGE.ObjectRenderer.prototype.getByMesh = function(mesh)
{
    for(var i = 0, ii = this._objects.length; i < ii; i++)
    {
        if(this._objects[i].mesh === mesh)
        {
            return this._objects[i];
        }
    }

    return null;
};

/**
 * Clear all render scenes
 * @method FORGE.ObjectRenderer#clear
 */
FORGE.ObjectRenderer.prototype.clear = function()
{
    var count = this._renderScenes.length;
    while(count--)
    {
        var renderScene = this._renderScenes.pop();
        renderScene.destroy();
    }
};

/**
 * Destroy sequence
 * @method FORGE.ObjectRenderer#destroy
 */
FORGE.ObjectRenderer.prototype.destroy = function()
{
    this.clear();
    this._renderScenes = null;
    this._viewer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get all the objects
 * @name FORGE.ObjectRenderer#all
 * @type {Array<FORGE.Object3D>}
 */
Object.defineProperty(FORGE.ObjectRenderer.prototype, "all",
{
    /** @this {FORGE.ObjectRenderer} */
    get: function()
    {
        return this._objects;
    }
});


/**
 * Get background renderer render items array.
 * @name FORGE.ObjectRenderer#renderScenes
 * @type {Array<FORGE.RenderScene>}
 */
Object.defineProperty(FORGE.ObjectRenderer.prototype, "renderScenes",
{
    /** @this {FORGE.ObjectRenderer} */
    get: function()
    {
        return this._renderScenes;
    }
});



/**
 * Raycaster for mouse interaction with 3d objects of the scene
 * @constructor FORGE.Raycaster
 * @param {FORGE.Viewer} viewer - Viewer reference
 * @extends {FORGE.BaseObject}
 */
FORGE.Raycaster = function(viewer)
{
    /**
     * Viewer reference
     * @name FORGE.Raycaster#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * THREE raycaster instance.
     * @name FORGE.Raycaster#_raycaster
     * @type {THREE.Raycaster}
     * @private
     */
    this._raycaster = null;

    /**
     * The last hovered 3d object
     * @name FORGE.Raycaster#_hoveredObject
     * @type {?FORGE.Object3D}
     * @private
     */
    this._hoveredObject = null;

    FORGE.BaseObject.call(this, "Raycaster");

    this._boot();
};

FORGE.Raycaster.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Raycaster.prototype.constructor = FORGE.Raycaster;

/**
 * Boot sequence
 * @method FORGE.Raycaster#_boot
 * @private
 */
FORGE.Raycaster.prototype._boot = function()
{
    // this._viewer.story.onSceneLoadComplete.add(this._sceneLoadCompleteHandler, this);
};

/**
 * Start raycasting.
 * Add event on the main canvas for mouse interaction
 * @method FORGE.Raycaster#_start
 * @param {string} mode - picking mode
 */
FORGE.Raycaster.prototype.start = function(mode)
{
    this.log("Raycaster start");

    if (this._raycaster === null)
    {
        this._raycaster = new THREE.Raycaster();
    }

    if (mode === FORGE.PickingManager.modes.POINTER)
    {
        this._startPointer();
    }
    else if (mode === FORGE.PickingManager.modes.GAZE)
    {
        this._startGaze();
    }
};

/**
 * Add the listeners for the pointer mode.
 * @method FORGE.Raycaster#_startPointer
 * @private
 */
FORGE.Raycaster.prototype._startPointer = function()
{
    this.log("Raycating start pointer");

    if (this._viewer.canvas.pointer.onClick.has(this._canvasPointerClickHandler, this) === false)
    {
        this._viewer.canvas.pointer.onClick.add(this._canvasPointerClickHandler, this);
    }

    if (this._viewer.canvas.pointer.onMove.has(this._canvasPointerMoveHandler, this) === false)
    {
        this._viewer.canvas.pointer.onMove.add(this._canvasPointerMoveHandler, this);
    }
};

/**
 * Add the listeners for the gaze mode.
 * @method FORGE.Raycaster#_startGaze
 * @private
 */
FORGE.Raycaster.prototype._startGaze = function()
{
    this.log("Raycating start gaze");

    if (this._viewer.renderer.camera.onChange.has(this._cameraChangeHandler, this) === false)
    {
        this._viewer.renderer.camera.onChange.add(this._cameraChangeHandler, this);
    }
};

/**
 * Stop raycasting, removes all event listeners
 * @method FORGE.Raycaster#_stop
 */
FORGE.Raycaster.prototype.stop = function()
{
    this.log("Raycaster stop");

    // Remove pointer event listeners
    if (this._viewer.canvas.pointer.onClick.has(this._canvasPointerClickHandler, this))
    {
        this._viewer.canvas.pointer.onClick.remove(this._canvasPointerClickHandler, this);
    }

    if (this._viewer.canvas.pointer.onMove.has(this._canvasPointerMoveHandler, this))
    {
        this._viewer.canvas.pointer.onMove.remove(this._canvasPointerMoveHandler, this);
    }

    //Remove gaze handlers
    if (this._viewer.renderer.camera.onChange.has(this._cameraChangeHandler, this))
    {
        this._viewer.renderer.camera.onChange.remove(this._cameraChangeHandler, this);
    }

    this._out();

    this._raycaster = null;
};


/**
 * Pointer click handler, launch raycasting
 * @method FORGE.Raycaster#_canvasPointerClickHandler
 * @param {Object} event click event
 * @private
 */
FORGE.Raycaster.prototype._canvasPointerClickHandler = function(event)
{
    var position = FORGE.Pointer.getRelativeMousePosition(event.data);
    this._raycast("click", position);
};

/**
 * Pointer over handler, launch raycasting
 * @method FORGE.Raycaster#_canvasPointerMoveHandler
 * @param {Object} event move event
 * @private
 */
FORGE.Raycaster.prototype._canvasPointerMoveHandler = function(event)
{
    var position = FORGE.Pointer.getRelativeMousePosition(event.data);
    this._raycast("move", position);
};

/**
 * Camera change handler, launch raycasting
 * @method FORGE.Raycaster#_cameraChangeHandler
 * @private
 */
FORGE.Raycaster.prototype._cameraChangeHandler = function()
{
    this._raycast("move");
};

/**
 * Raycasting internal method
 * @method FORGE.Raycaster#_raycast
 * @param {string} event - triggering event
 * @param {THREE.Vector2=} screenPoint - raycasting point in screen coordinates, if no screen point defined, it will raycast in the center of the view.
 * @private
 */
FORGE.Raycaster.prototype._raycast = function(event, screenPoint)
{
    // If there is an hovered object but not ready (maybe the texture is updating), ignore the raycast
    if(this._hoveredObject !== null && this._hoveredObject.ready === false)
    {
        return;
    }

    var resolution = this._viewer.renderer.canvasResolution;

    screenPoint = screenPoint || new THREE.Vector2(resolution.width / 2, resolution.height / 2);

    var camera = this._viewer.renderer.camera;
    var ndc = new THREE.Vector2(screenPoint.x / resolution.width, 1.0 - screenPoint.y / resolution.height).multiplyScalar(2).addScalar(-1);

    // Get all objects of the object renderer that are ready and interactive
    var objects = this._viewer.renderer.objects.getRaycastable();

    //Reset the hovered flag to false for all the objects
    this._setHovered(objects, false);

    // Get the first intersected object
    var intersected = this._intersect(objects, ndc, camera);

    if (intersected !== null)
    {
        if (event === "click")
        {
            this._hoveredObject = intersected; // For mobile we have to set the last intersect as the hovered object.
            this.click();
        }
        else if (event === "move")
        {

            if (intersected !== this._hoveredObject)
            {
                this._out();

                this._hoveredObject = intersected;
                intersected.over();

                if (this._viewer.renderer.pickingManager.mode === FORGE.PickingManager.modes.GAZE)
                {
                    this._viewer.renderer.camera.gaze.start();
                }
            }
        }
    }
    else
    {
        this._out();
    }
};

/**
 * The out routine. Stops the timer, trigger the out method the hovered object and nullify its reference.
 * @method FORGE.Raycaster#_out
 * @private
 */
FORGE.Raycaster.prototype._out = function()
{
    if (this._hoveredObject !== null)
    {
        this._hoveredObject.out();
        this._hoveredObject = null;

        if (this._viewer.renderer.pickingManager.mode === FORGE.PickingManager.modes.GAZE)
        {
            this._viewer.renderer.camera.gaze.stop();
        }
    }
};

/**
 * Set the hovered flag to an array ok {@link FORGE.Object3D}
 * @method FORGE.Raycaster#_setHovered
 * @param {Array<FORGE.Object3D>} objects - The array of 3d objects who'll be affected
 * @param {boolean} hovered - The hovered flag you want to set to all the 3d objects of the array
 * @private
 */
FORGE.Raycaster.prototype._setHovered = function(objects, hovered)
{
    for (var i = 0, ii = objects.length; i < ii; i++)
    {
        objects[i].hovered = hovered;
    }
};

/**
 * Intrsect 3d objects from a ndc point and a camera
 * @param  {Array<FORGE.Object3D>} objects - Array of object to test
 * @param  {THREE.Vector2} ndc - Normalized device coordinate point
 * @param  {FORGE.Camera} camera - Camera to use
 * @return {?FORGE.Object3D} Return the first hitted 3d Object
 * @private
 */
FORGE.Raycaster.prototype._intersect = function(objects, ndc, camera)
{
    var result = null;

    // Set the three raycaster with the ndc coordinates and the camera.
    this._raycaster.setFromCamera(ndc, camera.main);

    // Make an array of meshes for the three raycaster
    var meshes = [];
    for (var i = 0, ii = objects.length; i < ii; i++)
    {
        meshes.push(objects[i].mesh);
    }

    // Get all objects intersected by the ray
    var intersects = this._raycaster.intersectObjects(meshes);

    while (result === null && intersects.length > 0)
    {
        var intersect = intersects.shift();
        var mesh = intersect.object;
        var uv = intersect.uv;
        var object = this._viewer.renderer.objects.getByMesh(mesh);

        if (mesh.material.transparent === false)
        {
            result = object;
        }
        else
        {
            var color = this._getObjectColorFromUVCoords(object, uv);

            // If color is null we consider that we are hitting the object but its texture is not ready
            if (color === null || (color != null && color.alpha > 10))
            {
                result = object;
            }
        }
    }

    return result;
};

/**
 * Get RGBA color at a given point on a texture
 * @method FORGE.Raycaster#_getObjectColorFromUVCoords
 * @param {THREE.Vector2} uv point with normalized coordinates
 * @return {FORGE.ColorRGBA} RGBA color at given point or null if image is not available
 * @private
 */
FORGE.Raycaster.prototype._getObjectColorFromUVCoords = function(object, uv)
{
    var color = null;

    if (object.mesh !== null && object.mesh.material !== null && typeof object.mesh.material.uniforms.tTexture !== "undefined")
    {
        var texture = object.mesh.material.uniforms.tTexture.value;
        var canvas = null;

        if (texture !== null && texture.image !== null)
        {
            if (texture.image.nodeName.toLowerCase() === "img")
            {
                canvas = document.createElement("canvas");
                canvas.width = texture.image.width;
                canvas.height = texture.image.height;
                canvas.getContext("2d").drawImage(texture.image, 0, 0);
            }
            else if (texture.image.nodeName.toLowerCase() === "canvas")
            {
                canvas = texture.image;
            }

            if (canvas !== null)
            {
                var w = canvas.width;
                var h = canvas.height;
                var x = Math.floor(uv.x * w);
                var y = Math.floor(h - uv.y * h);
                var idx = 4 * (y * w + x);

                var data = canvas.getContext("2d").getImageData(0, 0, w, h).data;
                color = new FORGE.ColorRGBA(data[idx + 0], data[idx + 1], data[idx + 2], data[idx + 3]);
            }
        }
    }
    else if (typeof object.mesh.material.color !== "undefined")
    {
        color = object.mesh.material.color;
    }

    return color;
};
/**
 * Triggers the click method of the hovered object if exists.
 * @method FORGE.Raycaster#click
 */
FORGE.Raycaster.prototype.click = function()
{
    if (this._hoveredObject !== null)
    {
        this._hoveredObject.click();
    }
};

/**
 * Clear raycaster.
 * Release all references related to the scene
 * @method FORGE.Raycaster#clear
 */
FORGE.Raycaster.prototype.clear = function()
{
    this._hoveredObject = null;
};

/**
 * Get the hovered object
 * @name FORGE.Raycaster#hoveredObject
 * @type {FORGE.Object3D}
 * @readonly
 */
Object.defineProperty(FORGE.Raycaster.prototype, "hoveredObject",
{
    /** @this {FORGE.Raycaster} */
    get: function()
    {
        return this._hoveredObject;
    }
});
/**
 * Picking draw pass
 * 3D object picker based on additional draw passes rendering objects with a single color based on object ID
 * Bottleneck: should be used carefully as it uses gl.readPixels to access render target texture syncing CPU and GPU
 *
 * @constructor FORGE.PickingDrawPass
 * @param {FORGE.Viewer} viewer - viewer reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.PickingDrawPass = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.PickingDrawPass#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Picking render target reference.
     * @name FORGE.PickingDrawPass#_target
     * @type {THREE.WebGLRenderTarget}
     * @private
     */
    this._target = null;

    /**
     * Picking material reference
     * Should be used to override all objects materials in some scene
     * @name FORGE.PickingDrawPass#_material
     * @type {THREE.Material}
     * @private
     */
    this._material = null;

    /**
     * The last hovered 3d object
     * @name FORGE.PickingDrawPass#_hoveredObject
     * @type {?FORGE.Object3D}
     * @private
     */
    this._hoveredObject = null;

    /**
     * Target scaling factor to reduce texture memory footprint
     * @name FORGE.PickingDrawPass#_scaling
     * @type {number}
     * @private
     */
    this._scaling = 3;

    FORGE.BaseObject.call(this, "PickingDrawPass");

    this._boot();
};

FORGE.PickingDrawPass.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.PickingDrawPass.prototype.constructor = FORGE.PickingDrawPass;


/**
 * Boot sequence
 * @method FORGE.PickingDrawPass#_boot
 * @private
 */
FORGE.PickingDrawPass.prototype._boot = function()
{
    // Create picking material reference
    // Replace fragment shader with picking shader only drawing objects with one flat colour
    var shader = FORGE.Utils.clone(this._viewer.renderer.view.current.shaderWTS.mapping);
    shader.uniforms.tColor = { type: "c", value: new THREE.Color( 0x000000 ) };

    this._material = new THREE.RawShaderMaterial({
        fragmentShader: FORGE.ShaderLib.parseIncludes(FORGE.ShaderChunk.wts_frag_color),
        vertexShader: FORGE.ShaderLib.parseIncludes(shader.vertexShader),
        uniforms: shader.uniforms,
        side: THREE.FrontSide,
        name: "PickingMaterial"
    });

    // Create picking render target
    // Should be RGBA to allow WebGLRenderer to read pixels
    var rtParams =
    {
        format: THREE.RGBAFormat
    };

    var width = this._viewer.renderer.canvasResolution.width / this._scaling;
    var height = this._viewer.renderer.canvasResolution.height / this._scaling;

    this._target = new THREE.WebGLRenderTarget(width, height, rtParams);
    this._target.name = "Picking RenderTarget";
};

/**
 * Get object by its mesh id
 * @method FORGE.PickingDrawPass#_getObjectByID
 * @param {number} id - The ID of the object to get
 * @return {?FORGE.Object3D}
 * @private
 */
FORGE.PickingDrawPass.prototype._getObjectByID = function(id)
{
    var objects = this._viewer.renderer.objects.all;

    for (var i = 0, ii = objects.length; i < ii; i++)
    {
        if (objects[i].mesh.id === id)
        {
            return objects[i];
        }
    }

    return null;
};

/**
 * Convert object into a color based on its unique identifier
 * @method FORGE.PickingDrawPass#_colorFrom3DObject
 * @return {THREE.Color}
 */
FORGE.PickingDrawPass.colorFrom3DObject = function(object)
{
    return new THREE.Color(object.id);
};

/**
 * Convert color into object ID
 * @method FORGE.PickingDrawPass#_colorTo3DObject
 * @private
 * @return {FORGE.Object3D}
 */
FORGE.PickingDrawPass.prototype._colorTo3DObject = function(color)
{
    var id = ((color.r & 0x0000ff) << 16) | ((color.g & 0x0000ff) << 8) + (color.b & 0x0000ff);
    return this._getObjectByID(id);
};

/**
 * Get object located at a given normalized set of coordinates
 * @method FORGE.PickingDrawPass#getObjectAtXnYn
 * @param {number} xn - x normalized coordinate
 * @param {number} yn - y normalized coordinate
 * @return {FORGE.Object3D}
 * @private
 */
FORGE.PickingDrawPass.prototype._getObjectAtXnYn = function(xn, yn)
{
    var renderer = this._viewer.renderer.webGLRenderer;

    var data = new Uint8Array(4);
    renderer.readRenderTargetPixels(this._target,
                                    xn * this._target.width,
                                    yn * this._target.height,
                                    1, 1, data );

    return this._colorTo3DObject(new THREE.Color(data[0], data[1], data[2]));
};

/**
 * Get object under pointer event
 * @method FORGE.PickingDrawPass#_getObjectUnderPointerEvent
 * @private
 * @return {FORGE.Object3D}
 */
FORGE.PickingDrawPass.prototype._getObjectUnderPointerEvent = function(event)
{
    var e = event.data;
    var position = FORGE.Pointer.getRelativeMousePosition(e);
    var xn = position.x / event.data.target.width;
    var yn = 1 - position.y / event.data.target.height;
    return this._getObjectAtXnYn(xn, yn);
};

/**
 * Pointer click handler
 * @method FORGE.PickingDrawPass#_canvasPointerClickHandler
 * @private
 */
FORGE.PickingDrawPass.prototype._canvasPointerClickHandler = function(event)
{
    var object = this._getObjectUnderPointerEvent(event);

    if (object === null)
    {
        return;
    }

    object.click();
};

/**
 * Pointer move handler
 * @method FORGE.PickingDrawPass#_canvasPointerMoveHandler
 * @private
 */
FORGE.PickingDrawPass.prototype._canvasPointerMoveHandler = function(event)
{
    var object = this._getObjectUnderPointerEvent(event);

    if (object === null)
    {
        if (this._hoveredObject !== null)
        {
            this._hoveredObject.out();
            this._hoveredObject = null;
        }

        return;
    }

    if (object !== this._hoveredObject)
    {
        // Pointer goes from one object to another one directly
        if (this._hoveredObject !== null)
        {
            this._hoveredObject.out();
        }

        // Invoke over method and store new hovered object
        object.over();
        this._hoveredObject = object;
    }
};


/**
 * Start picking
 * @method FORGE.PickingDrawPass#start
 */
FORGE.PickingDrawPass.prototype.start = function()
{
    this._viewer.canvas.pointer.enabled = true;

    if (this._viewer.canvas.pointer.onClick.has(this._canvasPointerClickHandler, this) === false)
    {
        this._viewer.canvas.pointer.onClick.add(this._canvasPointerClickHandler, this);
    }

    if (this._viewer.canvas.pointer.onMove.has(this._canvasPointerMoveHandler, this) === false)
    {
        this._viewer.canvas.pointer.onMove.add(this._canvasPointerMoveHandler, this);
    }
};

/**
 * Stop picking
 * @method FORGE.PickingDrawPass#start
 */
FORGE.PickingDrawPass.prototype.stop = function()
{
    if (this._viewer.canvas.pointer.onClick.has(this._canvasPointerClickHandler, this))
    {
        this._viewer.canvas.pointer.onClick.remove(this._canvasPointerClickHandler, this);
    }

    if (this._viewer.canvas.pointer.onMove.has(this._canvasPointerMoveHandler, this))
    {
        this._viewer.canvas.pointer.onMove.remove(this._canvasPointerMoveHandler, this);
    }
};

/**
 * Triggers the click method of the hovered object if exists.
 * @method FORGE.PickingDrawPass#click
 */
FORGE.PickingDrawPass.prototype.click = function()
{
    if(this._hoveredObject !== null && this._viewer.canvas.pointer.onClick.has(this._canvasPointerClickHandler, this))
    {
        this._hoveredObject.click();
    }
};

/**
 * Set size (resolution)
 * @method FORGE.PickingDrawPass#setSize
 * @param {FORGE.Size} size - size [px]
 */
FORGE.PickingDrawPass.prototype.setSize = function(size)
{
    if (this._target !== null)
    {
        this._target.setSize(size.width, size.height);
    }
};

/**
 * Clear draw pass.
 * Release all references related to the scene
 * @method FORGE.PickingDrawPass#clear
 */
FORGE.PickingDrawPass.prototype.clear = function()
{
    this._hoveredObject = null;
};

/**
 * Destroy routine
 * @method FORGE.PickingDrawPass#destroy
 */
FORGE.PickingDrawPass.prototype.destroy = function()
{
    if (this._material !== null)
    {
        this._material.dispose();
        this._material = null;
    }

    if (this._target !== null)
    {
        this._target.dispose();
        this._target = null;
    }

    this._viewer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get material.
 * @name FORGE.PickingDrawPass#material
 * @type {THREE.RawShaderMaterial}
 */
Object.defineProperty(FORGE.PickingDrawPass.prototype, "material",
{
    /** @this {FORGE.PickingDrawPass} */
    get: function()
    {
        return this._material;
    }
});

/**
 * Get render target.
 * @name FORGE.PickingDrawPass#renderTarget
 * @type {THREE.WebGLRenderTarget}
 */
Object.defineProperty(FORGE.PickingDrawPass.prototype, "renderTarget",
{
    /** @this {FORGE.PickingDrawPass} */
    get: function()
    {
        return this._target;
    }
});

/**
 * Picking manager
 *
 * @constructor FORGE.PickingManager
 * @param {FORGE.Viewer} viewer - viewer reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.PickingManager = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.RenderManager#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Picking draw pass.
     * @name FORGE.PickingManager#_pickingDrawPass
     * @type {FORGE.PickingDrawPass}
     * @private
     */
    this._pickingDrawPass = null;

    /**
     * Raycaster.
     * @name FORGE.PickingManager#_raycaster
     * @type {FORGE.Raycaster}
     * @private
     */
    this._raycaster = null;

    /**
     * The current picking mode (pointer or gaze)
     * @name {FORGE.PickingManager#_mode}
     * @type {string}
     * @private
     */
    this._mode = FORGE.PickingManager.modes.POINTER;

    FORGE.BaseObject.call(this, "PickingManager");

    this._boot();
};

FORGE.PickingManager.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.PickingManager.prototype.constructor = FORGE.PickingManager;

/**
 * List diffrent modes for picking
 * @type {Object}
 * @const
 */
FORGE.PickingManager.modes = {};

/**
 * This mode is for picking the pointer position (like mouse / touch)
 * @type {string}
 * @const
 */
FORGE.PickingManager.modes.POINTER = "pointer";

/**
 * This mode is for gaze picking for VR, always pick in the middle of the view.
 * @type {string}
 * @const
 */
FORGE.PickingManager.modes.GAZE = "gaze";

/**
 * Boot sequence
 * @method FORGE.PickingManager#_boot
 * @private
 */
FORGE.PickingManager.prototype._boot = function()
{

};

/**
 * Setup and start raycast picking
 * Destroy draw pass picking if it exists
 * @method FORGE.PickingManager#_startRaycasting
 * @private
 */
FORGE.PickingManager.prototype._startRaycastPicking = function()
{
    if (this._raycaster !== null)
    {
        return;
    }

    if (this._pickingDrawPass !== null)
    {
        this._pickingDrawPass.stop();
        this._pickingDrawPass.destroy();
        this._pickingDrawPass = null;
    }

    this._raycaster = new FORGE.Raycaster(this._viewer);
    this._raycaster.start(this._mode);
};

/**
 * Setup and start drawpass picking
 * Destroy raycaster if it exists
 * @method FORGE.PickingManager#_startDrawpassPicking
 * @private
 */
FORGE.PickingManager.prototype._startDrawpassPicking = function()
{
    if (this._pickingDrawPass !== null)
    {
        return;
    }

    if (this._raycaster !== null)
    {
        this._raycaster.stop();
        this._raycaster.destroy();
        this._raycaster = null;
    }

    this._pickingDrawPass = new FORGE.PickingDrawPass(this._viewer);
    this._pickingDrawPass.start();
};

/**
 * Update internals for a given view type
 * @method FORGE.PickingManager#updateForViewType
 * @param {string} type - view type
 */
FORGE.PickingManager.prototype.updateForViewType = function(type)
{
    // Check view type: rectilinear will use raycasting, otherwise picking draw passes
    if (type === FORGE.ViewType.RECTILINEAR)
    {
        this._startRaycastPicking();
    }
    else
    {
        this._startDrawpassPicking();
    }
};

/**
 * Clear picking manager
 * @method FORGE.PickingManager#clear
 */
FORGE.PickingManager.prototype.clear = function()
{
    if (this._raycaster !== null)
    {
        this._raycaster.clear();
    }

    if (this._pickingDrawPass !== null)
    {
        this._pickingDrawPass.clear();
    }
};

/**
 * Update size (resolution)
 * @method FORGE.PickingManager#setSize
 * @param {FORGE.Size} size - size [px]
 */
FORGE.PickingManager.prototype.setSize = function(size)
{
    if (this._pickingDrawPass !== null)
    {
        this._pickingDrawPass.setSize(size);
    }
};

/**
 * Trigger a click on hovered oject (if it exists)
 * @method FORGE.PickingManager#click
 */
FORGE.PickingManager.prototype.click = function()
{
    if (this._raycaster !== null)
    {
        this._raycaster.click();
    }

    if (this._pickingDrawPass !== null)
    {
        this._pickingDrawPass.click();
    }
};

/**
 * Start picking
 * @method FORGE.PickingManager#start
 */
FORGE.PickingManager.prototype.start = function()
{
    if (this._raycaster !== null)
    {
        this._raycaster.start(this._mode);
    }

    if (this._pickingDrawPass !== null)
    {
        this._pickingDrawPass.start();
    }
};

/**
 * Stop picking
 * @method FORGE.PickingManager#stop
 */
FORGE.PickingManager.prototype.stop = function()
{
    if (this._raycaster !== null)
    {
        this._raycaster.stop();
    }

    if (this._pickingDrawPass !== null)
    {
        this._pickingDrawPass.stop();
    }
};

/**
 * Destroy routine
 * @method FORGE.PickingManager#destroy
 */
FORGE.PickingManager.prototype.destroy = function()
{
    if (this._raycaster !== null)
    {
        this._raycaster.stop();
        this._raycaster.destroy();
        this._raycaster = null;
    }

    if (this._pickingDrawPass !== null)
    {
        this._pickingDrawPass.stop();
        this._pickingDrawPass.destroy();
        this._pickingDrawPass = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get picking render target.
 * @name FORGE.PickingManager#renderTarget
 * @type {THREE.WebGLRenderTarget}
 */
Object.defineProperty(FORGE.PickingManager.prototype, "renderTarget",
{
    /** @this {FORGE.PickingManager} */
    get: function()
    {
        if (this._pickingDrawPass === null)
        {
            return null;
        }

        return this._pickingDrawPass.renderTarget;
    }
});

/**
 * Get picking material.
 * @name FORGE.PickingManager#material
 * @type {THREE.Material}
 */
Object.defineProperty(FORGE.PickingManager.prototype, "material",
{
    /** @this {FORGE.PickingManager} */
    get: function()
    {
        if (this._pickingDrawPass === null)
        {
            return null;
        }

        return this._pickingDrawPass.material;
    }
});

/**
 * Get and set the raycaster mode between pointer or gaze
 * @name FORGE.PickingManager#mode
 * @type {string}
 */
Object.defineProperty(FORGE.PickingManager.prototype, "mode",
{
    /** @this {FORGE.PickingManager} */
    get: function()
    {
        return this._mode;
    },

    /** @this {FORGE.PickingManager} */
    set: function(value)
    {
        if(value !== FORGE.PickingManager.modes.POINTER && value !== FORGE.PickingManager.modes.GAZE)
        {
            return;
        }

        if(value !== this._mode)
        {
            this._mode = value;
            this.start();
        }
    }
});


/**
 * Tile class.
 *
 * @constructor FORGE.Tile
 * @param {?FORGE.Tile} parent - parent tile reference
 * @param {FORGE.BackgroundPyramidRenderer} renderer - renderer reference
 * @param {number} x - x coordinate (column)
 * @param {number} y - y coordinate (row)
 * @param {number} level - pyramid level
 * @param {string} face - cube face
 * @param {string} creator - string describing what created the tile
 * @extends {THREE.Mesh}
 */
FORGE.Tile = function(parent, renderer, x, y, level, face, creator)
{
    /**
     * String describing what created the tile
     * @type {string}
     */
    this._creator = creator;

    /**
     * Reference on background renderer
     * @name FORGE.Tile#_renderer
     * @type {FORGE.BackgroundPyramidRenderer}
     * @private
     */
    this._renderer = renderer;

    /**
     * X axis value on face coordinate system
     * @name FORGE.Tile#_x
     * @type {number}
     * @private
     */
    this._x = x;

    /**
     * Y axis value on face coordinate system
     * @name FORGE.Tile#_y
     * @type {number}
     * @private
     */
    this._y = y;

    /**
     * Resolution level
     * @name FORGE.Tile#_level
     * @type {number}
     * @private
     */
    this._level = level;

    /**
     * Cube face
     * @name FORGE.Tile#_face
     * @type {string}
     * @private
     */
    this._face = face;

    /**
     * Creation timestamp
     * @name FORGE.Tile#_createTS
     * @type {?number}
     * @private
     */
    this._createTS = null;

    /**
     * Last display timestamp
     * @name FORGE.Tile#_displayTS
     * @type {?number}
     * @private
     */
    this._displayTS = null;

    /**
     * Reference on parent tile
     * @name FORGE.Tile#_parent
     * @type {FORGE.Tile}
     * @private
     */
    this._parent = parent;

    /**
     * Reference on children tiles
     * @name FORGE.Tile#_children
     * @type {Array<FORGE.Tile>}
     * @private
     */
    this._children = null;

    /**
     * Array of references on neighbour tiles
     * @name FORGE.Tile#_neighbours
     * @type {Array<FORGE.Tile>}
     * @private
     */
    this._neighbours = null;

    /**
     * Flag to know if parent has been checked
     * @name FORGE.MediaStore#_parentNeedsCheck
     * @type {boolean}
     * @private
     */
    this._parentNeedsCheck = true;

    /**
     * Flag to know if neighbourhood has been checked
     * @name FORGE.MediaStore#_neighborsNeedCheck
     * @type {boolean}
     * @private
     */
    this._neighborsNeedCheck = true;

    /**
     * Global opacity value
     * @name FORGE.Tile#_opacity
     * @type {number}
     * @private
     */
    this._opacity = 0;

    /**
     * Texture set flag
     * @name FORGE.Tile#_textureIsSet
     * @type {boolean}
     * @private
     */
    this._textureIsSet = false;

    /**
     * Event dispatcher for destroy.
     * @name FORGE.Tile#_onDestroy
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onDestroy = null;

    THREE.Mesh.call(this);

    this._boot();
};

FORGE.Tile.prototype = Object.create(THREE.Mesh.prototype);
FORGE.Tile.prototype.constructor = FORGE.Tile;

/**
 * Cube faces table
 * @type {Array}
 */
FORGE.Tile.FACES = ["front", "right", "back", "left", "up", "down"];

/**
 * Preview tile
 * @type {number}
 */
FORGE.Tile.PREVIEW = -Infinity;

/**
 * Opacity increment [unit per render cycle]
 * @type {number}
 */
FORGE.Tile.OPACITY_INCREMENT = 0.04;

/**
 * Opacity decrement [unit per render cycle]
 * @type {number}
 */
FORGE.Tile.OPACITY_DECREMENT = 0.01;

/**
 * Texture load predelay (time between creation and display)
 * @type {number}
 */
FORGE.Tile.TEXTURE_LOADING_PREDELAY_MS = 200;

/**
 * Table describing previous cube face
 * @type {CubeFaceObject}
 */
FORGE.Tile.FACE_PREVIOUS = {
    "front": "left",
    "right": "front",
    "back": "right",
    "left": "back",
    "up": "up",
    "down": "down"
};

/**
 * Table describing next cube face
 * @type {CubeFaceObject}
 */
FORGE.Tile.FACE_NEXT = {
    "front": "right",
    "right": "back",
    "back": "left",
    "left": "front",
    "up": "up",
    "down": "down"
};

/**
 * Create tile name
 * @method FORGE.Tile#createName
 * @param {string|number} face - cube face
 * @param {number} level - pyramid level
 * @param {number} x - x coordinate (column)
 * @param {number} y - y coordinate (row)
 */
FORGE.Tile.createName = function(face, level, x, y)
{
    face = typeof face === "number" ? FORGE.Tile.FACES[face] : face.toLowerCase();
    if (level === FORGE.Tile.PREVIEW)
    {
        return face.substring(0, 1).toUpperCase() + "-preview";
    }

    return face.substring(0, 1).toUpperCase() + "-" + level + "-" + y + "-" + x;
};

/**
 * Get the coordinates of the parent tile
 * @method FORGE.Tile#getParentTileCoordinates
 * @param {FORGE.Tile} tile - tile
 * @return {THREE.Vector2} parent tile x,y coordinates
 */
FORGE.Tile.getParentTileCoordinates = function(tile)
{
    var px = Math.floor(tile.x / 2),
        py = Math.floor(tile.y / 2);

    return new THREE.Vector2(px, py);
};

/**
 * Boot sequence
 * @method FORGE.Tile#_boot
 * @private
 */
FORGE.Tile.prototype._boot = function()
{
    this._neighbours = [];
    this._children = [];

    this.name = FORGE.Tile.createName(this._face, this._level, this._x, this._y);

    // Always ensure a new tile has a parent tile
    // This will prevent from zomming out into some empty area
    if (this._level > 0 && this._parent === null)
    {
        this._checkParent();
    }

    this.renderOrder = this._level === FORGE.Tile.PREVIEW ? 0 : 2 * (this._level + 1);
    this.onBeforeRender = this._onBeforeRender.bind(this);
    this.onAfterRender = this._onAfterRender.bind(this);

    this._setGeometry();

    // Level 0 objects are opaque to be rendered first
    var transparent = (this._level !== FORGE.Tile.PREVIEW);
    this._opacity = transparent ? 0 : 1;

    this.material = new THREE.MeshBasicMaterial(
    {
        color: new THREE.Color(0x000000),
        transparent: transparent,
        opacity: this._opacity,
        depthTest: false,
        side: THREE.FrontSide
    });

    this._queryTexture();

    if (FORGE.Tile.DEBUG === true)
    {
        this._addDebugLayer();
    }

    this._createTS = Date.now();
};

/**
 * Before render callback
 * This is called by THREE.js render routine before render is done
 * Add to background renderer list and set opacity
 * @method FORGE.Tile#_onBeforeRender
 * @private
 */
FORGE.Tile.prototype._onBeforeRender = function()
{
    // Add to renderer render list
    this._renderer.addToRenderList(this);

    if (this._textureIsSet === true)
    {
        this._setOpacity(1);
    }
    else
    {
        this._setOpacity(0);
    }
};

/**
 * After render callback
 * This is called by THREE.js render routine after render has been done
 * Here we update all links to other tiles, ask for subdivision or neighbours
 * Request texture if none
 * @method FORGE.Tile#_onAfterRender
 * @private
 */
FORGE.Tile.prototype._onAfterRender = function()
{
    // Update last display timestamp
    this.refreshDisplayTS();

    if (this._level !== FORGE.Tile.PREVIEW)
    {
        // Check if tile should be divided
        if (this._renderer.level > this._level)
        {
            this._subdivide();

            // Restoration process for required tiles previously removed from the scene
            // Check if children are intersecting the frustum and add them back to the
            // scene (with refreshed display timer)
            for (var i=0, ii=this._children.length; i<ii; i++)
            {
                var child = this._children[i];

                if (!this._renderer.isObjectInScene(child) && this._renderer.isObjectInFrustum(child))
                {
                    this._renderer.scene.add(child);
                    child.refreshDisplayTS();
                }
            }
        }

        // Get all neighbour tiles references
        this._checkNeighbours();
    }

    this._queryTexture();
};

/**
 * Query texture for the tile
 * @method FORGE.Tile#_queryTexture
 * @private
 */
FORGE.Tile.prototype._queryTexture = function()
{
    // Update texture mapping
    if (this.material !== null && this.material.map === null && this._textureIsSet === false)
    {
        // Check if predelay since creation has been respected (except for preview)
        if ((this._level !== FORGE.Tile.PREVIEW || this._level !== this._renderer.level) &&
            this._displayTS - this._createTS < FORGE.Tile.TEXTURE_LOADING_PREDELAY_MS)
        {
            return;
        }

        var texPromise = this._renderer.textureStore.get(this);

        if (texPromise !== null)
        {
            texPromise.then(function(texture)
            {
                // Check if tile has been destroyed in the meantime
                if (this.material === null)
                {
                    return;
                }

                if (texture !== null && texture instanceof THREE.Texture)
                {
                    this._textureIsSet = true;

                    texture.generateMipmaps = false;
                    texture.minFilter = THREE.LinearFilter;
                    texture.needsUpdate = true;

                    this.material.color = new THREE.Color(0xffffff);
                    this.material.map = texture;
                    this.material.needsUpdate = true;
                }
            }.bind(this),

            function(error)
            {
                console.warn("Tile texture loading error: " + error);
            }.bind(this));
        }
    }
};

/**
 * Add graphical debug layer
 * @method FORGE.Tile#_addDebugLayer
 * @private
 */
FORGE.Tile.prototype._addDebugLayer = function()
{
    var canvas = document.createElement("canvas");
    canvas.width = canvas.height = 512;
    var ctx = canvas.getContext("2d");

    var x = canvas.width / 2;
    var y = canvas.height / 2 - 25;

    ctx.fillStyle = "gray";
    ctx.strokeStyle = "white";
    ctx.strokeRect(20, 20, canvas.width - 40, canvas.height - 40);

    // General font style
    ctx.textAlign = "center";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "white";

    ctx.font = "16px Courier";
    ctx.fillText("TILE " + this.name, x, y);
    y += 40;

    var fontSize = 12;
    ctx.font = fontSize + "px Courier";
    var ceiling = canvas.width - 20;

    ctx.textAlign = "left";
    ctx.font = "10px Courier";
    if (this._level === FORGE.Tile.PREVIEW)
    {
        ctx.fillText("Preview", 10, canvas.height - 10);
    }
    else
    {
        ctx.fillText("Level " + this._level, 10, canvas.height - 10);
    }

    ctx.textAlign = "right";
    ctx.fillText(this._renderer.pixelsAtCurrentLevelHumanReadable, canvas.width - 10, canvas.height - 10);

    var texture = new THREE.Texture(canvas);
    texture.needsUpdate = true;

    var material = new THREE.MeshBasicMaterial(
    {
        transparent: true,
        map: texture,
        depthTest: false
    });
    var mesh = new THREE.Mesh(this.geometry.clone(), material);
    mesh.name = this.name + "-debug-canvas";
    this.add(mesh);

    mesh.renderOrder = this.renderOrder + 1;
};

/**
 * Set opacity of the tile and its children (recursive)
 * @method FORGE.Tile#_setOpacity
 * @param {number} opacity - tile opacity
 * @private
 */
FORGE.Tile.prototype._setOpacity = function(opacity)
{
    opacity = FORGE.Math.clamp(opacity, 0, 1);

    this._opacity = opacity;

    var setNodeOpacity = function(node)
    {
        if (node !== null && node.material !== null &&
            typeof node.material.opacity !== "undefined")
        {
            if (node.material.transparent === true)
            {
                node.material.opacity = opacity;
            }
        }

        for (var i = 0, ii = node.children.length; i < ii; i++)
        {
            setNodeOpacity(node.children[i]);
        }
    };

    setNodeOpacity(this);
};

/**
 * Set geometry of the tile
 * This means rotation and position in world coordinates
 * @method FORGE.Tile#_setGeometry
 * @private
 */
FORGE.Tile.prototype._setGeometry = function()
{
    var tx = this._renderer.nbTilesPerAxis(this._level, "x");
    var ty = this._renderer.nbTilesPerAxis(this._level, "y");

    var fullTileWidth = this._renderer.cubeSize / tx;
    var fullTileHeight = this._renderer.cubeSize / ty;

    var scaleX = this._x < Math.floor(tx) ? 1 : tx - Math.floor(tx);
    var scaleY = this._y < Math.floor(ty) ? 1 : ty - Math.floor(ty);

    var tileSize = new FORGE.Size(scaleX * fullTileWidth, scaleY * fullTileHeight);

    this.geometry = new THREE.PlaneBufferGeometry(tileSize.width, tileSize.height);

    var baseOffset = -this._renderer.cubeSize * 0.5;

    // position = tile offset in XY plane - half cube size + half tile size
    var position = new THREE.Vector3(
        baseOffset + fullTileWidth * this._x + 0.5 * tileSize.width,
        -(baseOffset + fullTileHeight * this._y + 0.5 * tileSize.height),
        baseOffset);

    var rotation = this._getRotation();
    this.rotation.copy(rotation);

    position.applyEuler(rotation);
    this.position.copy(position);
};

/**
 * Get rotation of the tile
 * @method FORGE.Tile#_setRotation
 * @private
 */
FORGE.Tile.prototype._getRotation = function()
{
    if (this._parent !== null)
    {
        return this._parent.rotation;
    }

    switch (this._face)
    {
        case "front":
            return new THREE.Euler(0, 0, 0);

        case "back":
            return new THREE.Euler(0, Math.PI, 0);

        case "left":
            return new THREE.Euler(0, Math.PI / 2, 0);

        case "right":
            return new THREE.Euler(0, -Math.PI / 2, 0);

        case "up":
            return new THREE.Euler(Math.PI / 2, 0, 0);

        case "down":
            return new THREE.Euler(-Math.PI / 2, 0, 0);
    }
};

/**
 * Subdivide tile into n tiles
 * @method FORGE.Tile#subdivide
 * @private
 */
FORGE.Tile.prototype._subdivide = function()
{
    if (this._children.length > 0)
    {
        return;
    }

    var tile;
    var level = this._level + 1;

    if (this._level === FORGE.Tile.PREVIEW)
    {
        level = 0;
    }

    // tiles per axis on children level
    var tx = this._renderer.nbTilesPerAxis(level, "x");
    var ty = this._renderer.nbTilesPerAxis(level, "y");
    // ratio of tiles on this level compared to children level
    var rx = Math.round(tx / this._renderer.nbTilesPerAxis(this._level, "x"));
    var ry = Math.round(ty / this._renderer.nbTilesPerAxis(this._level, "y"));

    // load first tile
    tile = this._renderer.getTile(this, level, this._face, rx * this._x, ry * this._y, "top left quarter of " + this.name);
    if (this._children.indexOf(tile) === -1)
    {
        tile.onDestroy.add(this._onChildTileDestroyed, this);
        this._children.push(tile);
    }

    // get all other children in
    var xn, yn, xn_in, yn_in;
    for (var i = 0; i < rx; i++)
    {
        for (var j = 0; j < ry; j++)
        {
            xn = rx * this._x + i;
            yn = ry * this._y + j;

            xn_in = xn < tx;
            yn_in = yn < ty;

            if (xn_in === true && yn_in === true)
            {
                tile = this._renderer.getTile(this, level, this._face, xn, yn, "children of " + this.name);
                if (this._children.indexOf(tile) === -1)
                {
                    tile.onDestroy.add(this._onChildTileDestroyed, this);
                    this._children.push(tile);
                }
            }
        }
    }
};

/**
 * Child tile destroy event handler
 * @method FORGE.Tile#_onChildTileDestroyed
 */
FORGE.Tile.prototype._onChildTileDestroyed = function(event)
{
    var tile = event.emitter;
    tile.onDestroy.remove(this._onChildTileDestroyed, this);

    if (this._children === null)
    {
        return;
    }

    var idx = this._children.indexOf(tile);

    if (idx !== -1)
    {
        this._children.splice(idx, 1);
    }
};

/**
 * Neighbour tile destroy event handler
 * @method FORGE.Tile#_onNeighbourTileDestroyed
 */
FORGE.Tile.prototype._onNeighbourTileDestroyed = function(event)
{
    var tile = event.emitter;
    tile.onDestroy.remove(this._onNeighbourTileDestroyed, this);

    this._neighborsNeedCheck = true;

    if (this._neighbours === null)
    {
        return;
    }

    var idx = this._neighbours.indexOf(tile);

    if (idx !== -1)
    {
        this._neighbours.splice(idx, 1);
    }
};

/**
 * Parent tile destroy event handler
 * @method FORGE.Tile#_onParentTileDestroyed
 */
FORGE.Tile.prototype._onParentTileDestroyed = function(event)
{
    var tile = event.emitter;
    tile.onDestroy.remove(this._onParentTileDestroyed, this);

    this._parent = null;
    this._parentNeedsCheck = true;
};

/**
 * Get parent tile
 * @method FORGE.Tile#_checkParent
 * @private
 */
FORGE.Tile.prototype._checkParent = function()
{
    if (this._parent !== null ||
        this._parentNeedsCheck === false ||
        this._level <= 0)
    {
        return;
    }

    this._parentNeedsCheck = false;

    var sequence = Promise.resolve();
    sequence.then(function()
    {
        this._parent = this._renderer.getParentTile(this);
        this._parent.onDestroy.add(this._onParentTileDestroyed, this);
    }.bind(this));
};

/**
 * Lookup tiles around current one and create them if needed
 * @method FORGE.Tile#_checkNeighbours
 * @private
 */
FORGE.Tile.prototype._checkNeighbours = function()
{
    if (this._neighborsNeedCheck === false ||
        this._level === FORGE.Tile.PREVIEW ||
        this._level !== this._renderer.level)
    {
        return;
    }

    this._neighborsNeedCheck = false;

    var tx = Math.ceil(this._renderer.nbTilesPerAxis(this._level, "x"));
    var ty = Math.ceil(this._renderer.nbTilesPerAxis(this._level, "y"));

    var name = this.name;

    var sequence = Promise.resolve();
    var sequenceFn = function(prenderer, plevel, pface, px, py, neighbours, plog)
    {
        sequence.then(function()
        {
            var tile = prenderer.getTile(null, plevel, pface, px, py, plog);
            if (neighbours.indexOf(tile) === -1)
            {
                tile.onDestroy.add(tileDestroyedCallback);
                neighbours.push(tile);
            }
        });
    };

    // Check tile neighbors in current face
    var xmin = Math.max(0, this._x - 1);
    var xmax = Math.min(tx - 1, this._x + 1);

    var ymin = Math.max(0, this._y - 1);
    var ymax = Math.min(ty - 1, this._y + 1);

    var tileDestroyedCallback = this._onNeighbourTileDestroyed.bind(this);

    // and do the job for the current face
    for (var y = ymin; y <= ymax; y++)
    {
        for (var x = xmin; x <= xmax; x++)
        {
            if (x === this._x && y === this._y)
            {
                continue;
            }

            sequenceFn(this._renderer, this._level, this._face, x, y, this._neighbours, "foo");
        }
    }


    var tileX = this._x;
    var tileY = this._y;

    // Check if tile is on a left or right edge of the cube face
    if (tileX === 0 || tileX === tx - 1)
    {
        var edge = (tileX === 0); // true for left, false for right
        var log = "neighbour-" + (edge ? "left" : "right") + "-edge of " + name;
        var face = edge ? FORGE.Tile.FACE_PREVIOUS[this._face] : FORGE.Tile.FACE_NEXT[this._face];
        var x = edge ? tx - 1 : 0;

        sequenceFn(this._renderer, this._level, face, x, tileY, this._neighbours, log);
    }

    // Check if tile is on a bottom or top edge of the cube face
    if (tileY === ty - 1 || tileY === 0)
    {
        var edge = (tileY === 0); // true for top, false for bottom
        var fx, fy,
            face = edge ? "up" : "down";

        if (this._face === "front")
        {
            fx = tileX;
            fy = edge ? 0 : ty - 1;
        }
        else if (this._face === "back")
        {
            fx = tx - 1 - tileX;
            fy = edge ? ty - 1 : 0;
        }
        else if (this._face === "right")
        {
            fx = ty - 1;
            fy = edge ? tx - 1 - tileX : tileX;
        }
        else if (this._face === "left")
        {
            fx = 0;
            fy = edge ? tileX : tx - 1 - tileX;
        }
        else if (this._face === "up")
        {
            fx = edge ? tx - 1 - tileX : tileX;
            fy = 0;
            face = edge ? "back" : "front";
        }
        else if (this._face === "down")
        {
            fx = edge ? tileX : tx - 1 - tileX;
            fy = edge ? tx - 1 : ty - 1;
            face = "back";
        }

        var log = "neighbour-" + (edge ? "top" : "bottom") + "-edge of " + name;

        sequenceFn(this._renderer, this._level, face, fx, fy, this._neighbours, log);

        // if edge but ty = 1
        if (edge && ty === 1)
        {
            log = "neighbour-bottom-edge of " + name;
            sequenceFn(this._renderer, this._level, "down", fx, fy, this._neighbours, log);
        }
    }
};

/**
 * Get name of the parent tile
 * @method FORGE.Tile#getParentName
 * @return {?string} parent tile name
 */
FORGE.Tile.prototype.getParentName = function()
{
    if (this._level <= 0)
    {
        return null;
    }

    var coords = FORGE.Tile.getParentTileCoordinates(this);
    return FORGE.Tile.createName(this._face, this._level - 1, coords.x, coords.y);
};

/**
 * Refresh display timestamp with current date
 * @method FORGE.Tile#refreshDisplayTS
 */
FORGE.Tile.prototype.refreshDisplayTS = function()
{
    this._displayTS = Date.now();
};

/**
 * Destroy sequence
 * @method FORGE.Tile#destroy
 */
FORGE.Tile.prototype.destroy = function()
{
    if (this.material !== null)
    {
        if (typeof this.material.uniforms !== "undefined")
        {
            for (var u in this.material.uniforms)
            {
                this.material.uniforms[u].value = null;
            }
        }

        if (this.material.map !== null)
        {
            this.material.map.dispose();
            this.material.map = null;
        }

        this.material.dispose();
        this.material = null;
    }

    if (this.geometry !== null)
    {
        this.geometry.dispose();
        this.geometry = null;
    }

    this._parent = null;

    for (var i = 0, ii = this._children.length; i < ii; i++)
    {
        this._children[i].onDestroy.remove(this._onChildTileDestroyed, this);
    }
    this._children.length = 0;
    this._children = null;

    for (var i = 0, ii = this._neighbours.length; i < ii; i++)
    {
        this._neighbours[i].onDestroy.remove(this._onNeighbourTileDestroyed, this);
    }
    this._neighbours.length = 0;
    this._neighbours = null;

    this._position = null;

    this._renderer = null;

    if (this._onDestroy !== null)
    {
        this._onDestroy.dispatch();
        this._onDestroy.destroy();
        this._onDestroy = null;
    }
};

/**
 * Get the onDestroy {@link FORGE.EventDispatcher}.
 * @name FORGE.Tile#onDestroy
 * @type {FORGE.EventDispatcher}
 * @readonly
 */
Object.defineProperty(FORGE.Tile.prototype, "onDestroy",
{
    /** @this {FORGE.Tile} */
    get: function()
    {
        if (this._onDestroy === null)
        {
            this._onDestroy = new FORGE.EventDispatcher(this, true);
        }

        return this._onDestroy;
    }
});

/**
 * Get face.
 * @name FORGE.Tile#face
 * @type {string}
 */
Object.defineProperty(FORGE.Tile.prototype, "face",
{
    /** @this {FORGE.Tile} */
    get: function()
    {
        // return FORGE.Tile.FACES.indexOf(this._face);
        return this._face;
    }
});

/**
 * Get level.
 * @name FORGE.Tile#level
 * @type {string}
 */
Object.defineProperty(FORGE.Tile.prototype, "level",
{
    /** @this {FORGE.Tile} */
    get: function()
    {
        return this._level;
    }
});

/**
 * Get x coordinate.
 * @name FORGE.Tile#x
 * @type {number}
 */
Object.defineProperty(FORGE.Tile.prototype, "x",
{
    /** @this {FORGE.Tile} */
    get: function()
    {
        return this._x;
    }
});

/**
 * Get y coordinate.
 * @name FORGE.Tile#y
 * @type {number}
 */
Object.defineProperty(FORGE.Tile.prototype, "y",
{
    /** @this {FORGE.Tile} */
    get: function()
    {
        return this._y;
    }
});

/**
 * Get opacity.
 * @name FORGE.Tile#opacity
 * @type {number}
 */
Object.defineProperty(FORGE.Tile.prototype, "opacity",
{
    /** @this {FORGE.Tile} */
    get: function()
    {
        return this._opacity;
    }
});

/**
 * Create timestamp.
 * @name FORGE.Tile#createTS
 * @type {number}
 */
Object.defineProperty(FORGE.Tile.prototype, "createTS",
{
    /** @this {FORGE.Tile} */
    get: function()
    {
        return this._createTS;
    }
});

/**
 * Last display timestamp.
 * @name FORGE.Tile#displayTS
 * @type {number}
 */
Object.defineProperty(FORGE.Tile.prototype, "displayTS",
{
    /** @this {FORGE.Tile} */
    get: function()
    {
        return this._displayTS;
    }
});

/**
 * Neighbour tiles.
 * @name FORGE.Tile#neighbours
 * @type {Array<FORGE.Tile>}
 */
Object.defineProperty(FORGE.Tile.prototype, "neighbours",
{
    /** @this {FORGE.Tile} */
    get: function()
    {
        return this._neighbours;
    }
});

/**
 * Is the texture set
 * @name FORGE.Tile#textureIsSet
 * @type {boolean}
 */
Object.defineProperty(FORGE.Tile.prototype, "textureIsSet",
{
    /** @this {FORGE.Tile} */
    get: function()
    {
        return this._textureIsSet;
    }
});

/**
 * The FORGE.HotspotManager is an object that manages hotspots of the project.
 *
 * @constructor FORGE.HotspotManager
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.HotspotManager = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.HotspotManager#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The general config backup.
     * @name FORGE.HotspotManager#_config
     * @type {Object}
     * @private
     */
    this._config = null;

    /**
     * Hotspots array
     * @name  FORGE.HotspotManager#_hotspots
     * @type {Array<(FORGE.Hotspot3D|FORGE.HotspotDOM)>}
     * @private
     */
    this._hotspots = [];

    FORGE.BaseObject.call(this, "HotspotManager");

};

FORGE.HotspotManager.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.HotspotManager.prototype.constructor = FORGE.HotspotManager;

/**
 * Parse a hotspots config object.
 * @method FORGE.HotspotManager#_parseConfig
 * @private
 * @param {Array<HotspotConfig>} config - The array of hotspot config you want to parse.
 */
FORGE.HotspotManager.prototype._parseConfig = function(config)
{
    for (var i = 0, ii = config.length; i < ii; i++)
    {
        this.create(config[i]);
    }
};

/**
 * Create a hotspot from a hotpsot config object.
 * @method FORGE.HotspotManager#create
 * @param {HotspotConfig} config - The config of the hotspot you want to create.
 * @return {(FORGE.Hotspot3D|FORGE.HotspotDOM|boolean)} Returns the hotspot if the hotspot is created, false if not.
 */
FORGE.HotspotManager.prototype.create = function(config)
{
    var hotspot = null;
    var type = config.type || FORGE.HotspotType.THREE_DIMENSIONAL; //3d is the default type

    switch (type)
    {
        case FORGE.HotspotType.THREE_DIMENSIONAL:
            hotspot = new FORGE.Hotspot3D(this._viewer, config);
            break;

        case FORGE.HotspotType.DOM:
            hotspot = new FORGE.HotspotDOM(this._viewer, config);
            break;
    }

    if (hotspot !== null)
    {
        this._hotspots.push(hotspot);
        return hotspot;
    }

    return false;
};

/**
 * Remove a hotspot from the manager
 * @method FORGE.HotspotManager#remove
 * @param  {(string|FORGE.Hotspot3D)} hotspot - the hotspot or its uid to remove
 */
FORGE.HotspotManager.prototype.remove = function(hotspot)
{
    if(FORGE.Utils.isTypeOf(hotspot, "string") === true)
    {
        hotspot = FORGE.UID.get(hotspot);
    }

    if(FORGE.Utils.isTypeOf(hotspot, "Hotspot3D") === true)
    {
        var index = this._hotspots.indexOf(hotspot);
        this._hotspots.splice(index, 1);
        hotspot.destroy();
    }
};

/**
 * Parse a list of tracks for hotspots movement.
 * @method FORGE.HotspotManager#_parseTracks
 * @param {Array<HotspotTrackConfig>} tracks - The array of tracks to add.
 * @private
 */
FORGE.HotspotManager.prototype._parseTracks = function(tracks)
{
    for (var i = 0, ii = tracks.length; i < ii; i++)
    {
        new FORGE.HotspotAnimationTrack(tracks[i]);
    }
};

/**
 * Check if all hotspots are ready
 * @method FORGE.HotspotManager#_checkHotspotsReady
 * @return boolean true if all hotspots are ready, false otherwise
 * @private
 */
FORGE.HotspotManager.prototype._checkHotspotsReady = function()
{
    for (var i = 0, ii = this._hotspots.length; i < ii; i++)
    {
        var hotspot = this._hotspots[i];

        if (hotspot.ready === false)
        {
            return false;
        }
    }

    return true;
};

/**
 * Event handler for scene load start.
 * @method  FORGE.HotspotManager#_sceneLoadStartHandler
 * @private
 */
FORGE.HotspotManager.prototype._sceneLoadStartHandler = function()
{
    var scene = this._viewer.story.scene;
    scene.onUnloadStart.addOnce(this._sceneUnloadStartHandler, this);

    if (typeof scene.config.hotspots !== "undefined")
    {
        var hotspots = scene.config.hotspots;
        this.addConfig(hotspots);
    }
};

/**
 * Event handler for scene unload start.
 * @method  FORGE.HotspotManager#_sceneUnloadStartHandler
 * @private
 */
FORGE.HotspotManager.prototype._sceneUnloadStartHandler = function()
{
    this.clear();
};

/**
 * Boot sequence.
 * @method FORGE.HotspotManager#boot
 */
FORGE.HotspotManager.prototype.boot = function()
{
    this._config = [];

    this._viewer.story.onSceneLoadStart.add(this._sceneLoadStartHandler, this);
};

/**
 * Get hotspots by type
 * @method  FORGE.HotspotManager#getByType
 * @param  {string} type - The type of hotspots you want to get.
 * @return {Array<(FORGE.Hotspot3D|FORGE.HotspotDOM)>}
 */
FORGE.HotspotManager.prototype.getByType = function(type)
{
    var result = this._hotspots.filter(function(hotspot)
    {
        return hotspot.type === type;
    });

    return result;
};

/**
 * Add a hotspots config to the manager.
 * @method FORGE.HotspotManager#addConfig
 * @param {Array<HotspotConfig>} config - The config you want to add.
 */
FORGE.HotspotManager.prototype.addConfig = function(config)
{
    this._parseConfig(config);
};

/**
 * Add a list of tracks for the hotspots.
 * @method FORGE.HotspotManager#addTracks
 * @param {HotspotsConfig} config - The tracks you want to add.
 */
FORGE.HotspotManager.prototype.addTracks = function(config)
{
    if (config.tracks !== null && typeof config.tracks !== "undefined")
    {
        this._parseTracks(config.tracks);
    }
};

/**
 * Update loop
 * @method FORGE.HotspotManager#update
 */
FORGE.HotspotManager.prototype.update = function()
{
    for (var i = 0, ii = this._hotspots.length; i < ii; i++)
    {
        this._hotspots[i].update();
    }
};

/**
 * Clear all hotspots from the manager
 * @method FORGE.HotspotManager#clear
 * @param {string=} type - the type of hotspots to clear, nothing for all
 */
FORGE.HotspotManager.prototype.clear = function(type)
{
    this._hotspots = this._hotspots.filter(function(hs)
    {
        var keep = (typeof type === "string" && hs.type !== type);

        if (keep === false)
        {
            hs.destroy();
        }

        return keep;
    });
};

/**
 * Dump the array of hotspot configurations.
 * @method FORGE.HotspotManager#dump
 * @return {Array<HotspotConfig>} Return an array of hotspot configurations of the current scene.
 */
FORGE.HotspotManager.prototype.dump = function()
{
    var dump = [];

    for(var i = 0, ii = this._hotspots.length; i < ii; i++)
    {
        dump.push(this._hotspots[i].dump());
    }

    return dump;
};

/**
 * Destroy sequence
 * @method FORGE.HotspotManager#destroy
 */
FORGE.HotspotManager.prototype.destroy = function()
{
    this.clear();

    this._viewer = null;
    this._hotspots = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get all the hotspots.
 * @name FORGE.HotspotManager#all
 * @readonly
 * @type {Array<(FORGE.Hotspot3D|FORGE.HotspotDOM)>}
 */
Object.defineProperty(FORGE.HotspotManager.prototype, "all",
{
    /** @this {FORGE.HotspotManager} */
    get: function()
    {
        return this._hotspots;
    }
});

/**
 * Get all the hotspots uids.
 * @name FORGE.HotspotManager#uids
 * @readonly
 * @type {Array<string>}
 */
Object.defineProperty(FORGE.HotspotManager.prototype, "uids",
{
    /** @this {FORGE.HotspotManager} */
    get: function()
    {
        var uids = [];

        for(var i = 0, ii = this._hotspots.length; i < ii; i++)
        {
            uids.push(this._hotspots[i].uid);
        }

        return uids;
    }
});

/**
 * Get the hotspots count.
 * @name FORGE.HotspotManager#count
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.HotspotManager.prototype, "count",
{
    /** @this {FORGE.HotspotManager} */
    get: function()
    {
        return this._hotspots.length;
    }
});

/**
 * A HotspotDOM, to be displayed like a billboard. This hotspot provides a
 * single div positioned at the right position in the scene, without any
 * content in it and any deformation. It is up to the FORGE user to specify
 * those. Two things can be tweaked here: the displayObject property of this
 * hotspot, which is a {@link FORGE.DisplayObjectContainer}, and the DOM part
 * of this container, accessible through `displayObject.dom` or more directly
 * using the `dom` property on the object HotspotDOM.
 *
 * @constructor FORGE.HotspotDOM
 * @param {FORGE.Viewer} viewer - viewer reference
 * @param {HotspotConfig} config - hotspot configuration
 * @extends {FORGE.BaseObject}
 *
 * @todo facingCenter with CSS 3D, rotation values and scale values
 */
FORGE.HotspotDOM = function(viewer, config)
{
    /**
     * The viewer reference
     * @name FORGE.HotspotDOM#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Hotspot configuration
     * @name FORGE.HotspotDOM#_config
     * @type {HotspotConfig}
     * @private
     */
    this._config = config;

    /**
     * HotspotTransform object for the positioning and scaling (no rotation)
     * @name  FORGE.HotspotDOM#_transform
     * @type {FORGE.HotspotTransform}
     * @private
     */
    this._transform = null;

    /**
     * The offset applied to the DOM object from it's center.<br>
     * Is expressed in pixels (x, y).
     * @name FORGE.HotspotDOM#_offset
     * @type {HotspotDomOffset}
     * @private
     */
    this._offset = FORGE.HotspotDOM.DEFAULT_OFFSET;

    /**
     * The HTML element composing the hotspot
     * @name FORGE.HotspotDOM#_dom
     * @type {Element|HTMLElement}
     * @private
     */
    this._dom = null;

    /**
     * Events object that will keep references of the ActionEventDispatcher
     * @name FORGE.HotspotDOM#_events
     * @type {Object<FORGE.ActionEventDispatcher>}
     * @private
     */
    this._events = null;

    /**
     * Visibility flag
     * @name  FORGE.HotspotDOM#_visible
     * @type {boolean}
     * @private
     */
    this._visible = true;

    /**
     * Is this object is interactive / raycastable
     * @name FORGE.HotspotDOM#_interactive
     * @type {boolean}
     * @private
     */
    this._interactive = true;

    /**
     * Does the hotspot is facing the camera ? Useful for a flat hotspot we want
     * to always be facing to the camera.
     * @name FORGE.HotspotDOM#_facingCenter
     * @type {boolean}
     * @private
     */
    this._facingCenter = false;

    /**
     * The pointer cursor when pointer is over the hotspot zone
     * @name FORGE.HotspotDOM#_cursor
     * @type {string}
     * @private
     */
    this._cursor = "pointer";

    /**
     * Event handler for a click on the hotspot.
     * @name FORGE.HotspotDOM#_domClickHandlerBind
     * @type {Function}
     * @private
     */
    this._domClickHandlerBind = null;

    /**
     * Event handler for overing on the hotspot.
     * @name FORGE.HotspotDOM#_domOverHandlerBind
     * @type {Function}
     * @private
     */
    this._domOverHandlerBind = null;

    /**
     * Event handler for getting out on the hotspot.
     * @name FORGE.HotspotDOM#_domOutHandlerBind
     * @type {Function}
     * @private
     */
    this._domOutHandlerBind = null;

    FORGE.BaseObject.call(this, "HotspotDOM");

    this._boot();
};

FORGE.HotspotDOM.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.HotspotDOM.prototype.constructor = FORGE.HotspotDOM;

/**
 * @name FORGE.HotspotDOM.DEFAULT_CONFIG
 * @type {HotspotConfig}
 */
FORGE.HotspotDOM.DEFAULT_CONFIG =
{
    dom:
    {
        id: "hostpot-dom",
        width: 320,
        height: 240,
        color: "white",
        index: 10,
        offset: FORGE.HotspotDOM.DEFAULT_OFFSET
    }
};

/**
 * @name FORGE.HotspotDOM.DEFAULT_OFFSET
 * @type {HotspotDomOffset}
 */
FORGE.HotspotDOM.DEFAULT_OFFSET =
{
    x: 0,
    y: 0
};

/**
 * Boot sequence.
 * @method FORGE.HotspotDOM#_boot
 * @private
 */
FORGE.HotspotDOM.prototype._boot = function()
{
    this._transform = new FORGE.HotspotTransform();

    this._events = {};

    this._parseConfig(this._config);
    this._register();

    this._viewer.renderer.view.onChange.add(this._viewChangeHandler, this);
};

/**
 * Parse the config object
 * @method FORGE.HotspotDOM#_parseConfig
 * @param {HotspotConfig} config - the hotspot config to parse
 * @private
 */
FORGE.HotspotDOM.prototype._parseConfig = function(config)
{
    config = /** @type {HotspotConfig} */ (FORGE.Utils.extendMultipleObjects(FORGE.HotspotDOM.DEFAULT_CONFIG, config));

    this._uid = config.uid;

    if (typeof config.events === "object" && config.events !== null)
    {
        this._createEvents(config.events);
    }

    var dom = config.dom;

    if (dom !== null && typeof dom !== "undefined")
    {
        var id;

        if (typeof dom.id === "string")
        {
            id = dom.id;
        }
        else
        {
            id = this._uid;
        }

        // store the offset values
        this._offset = dom.offset || FORGE.HotspotDOM.DEFAULT_OFFSET;

        // get the already present hotspot in the dom, or create it
        var div = document.getElementById(id);

        if (div !== null)
        {
            this._dom = div;
        }
        else
        {
            this._dom = document.createElement("div");
            this._dom.id = id;
        }

        this._dom.classList.add("hotspot-dom");
        this._dom.style.position = "absolute";

        if (typeof dom.class === "string")
        {
            this._dom.classList.add(dom.class);
        }
        else if (Array.isArray(dom.class) === true)
        {
            for (var i = 0, ii = dom.class.length; i < ii; i++)
            {
                this._dom.classList.add(dom.class[i]);
            }
        }

        // basic CSS from json configuration
        var rule = "." + this._dom.id + "-basic-class {";

        if (typeof dom.width === "number")
        {
            rule += "width: " + dom.width + "px;";
        }
        else if (typeof dom.width === "string")
        {
            rule += "width: " + dom.width + ";";
        }

        if (typeof dom.height === "number")
        {
            rule += "height: " + dom.height + "px;";
        }
        else if (typeof dom.height === "string")
        {
            rule += "height: " + dom.height + ";";
        }

        if (typeof dom.color === "string")
        {
            rule += "background-color: " + dom.color + ";";
        }

        if (typeof dom.index === "number")
        {
            rule+= "z-index: " + dom.index + ";";
        }

        rule += "}";
        this._viewer.domHotspotStyle.sheet.insertRule(rule, 0);
        this._dom.classList.add(this._dom.id + "-basic-class");
    }

    this._dom.style.pointerEvents = "auto";
    this._domClickHandlerBind = this._domClickHandler.bind(this);
    this._domOverHandlerBind = this._domOverHandler.bind(this);
    this._domOutHandlerBind = this._domOutHandler.bind(this);
    this._dom.addEventListener("click", this._domClickHandlerBind);
    this._dom.addEventListener("mouseover", this._domOverHandlerBind);
    this._dom.addEventListener("mouseout", this._domOutHandlerBind);

    if (config.transform !== null && typeof config.transform !== "undefined")
    {
        this._transform.load(config.transform, false);
    }

    this._visible = (typeof config.visible === "boolean") ? config.visible : true;
    // this._facingCenter = (typeof config.facingCenter === "boolean") ? config.facingCenter : false;
    this._interactive = (typeof config.interactive === "boolean") ? config.interactive : true;
    this._cursor = (typeof config.cursor === "string") ? config.cursor : "pointer";

    this.show();
};

/**
 * DOM click handler
 * @method FORGE.HotspotDOM#_domClickHandler
 * @private
 */
FORGE.HotspotDOM.prototype._domClickHandler = function()
{
    // Actions defined from the json
    if(FORGE.Utils.isTypeOf(this._events.onClick, "ActionEventDispatcher") === true)
    {
        this._events.onClick.dispatch();
    }
};

/**
 * DOM over handler
 * @method FORGE.HotspotDOM#_domOverHandler
 * @private
 */
FORGE.HotspotDOM.prototype._domOverHandler = function()
{
    // Actions defined from the json
    if(FORGE.Utils.isTypeOf(this._events.onOver, "ActionEventDispatcher") === true)
    {
        this._events.onOver.dispatch();
    }

    this._dom.style.cursor = this._cursor;
};

/**
 * DOM out handler.
 * @method FORGE.HotspotDOM#_domOutHandler
 * @private
 */
FORGE.HotspotDOM.prototype._domOutHandler = function()
{
    // Actions defined from the json
    if(FORGE.Utils.isTypeOf(this._events.onOut, "ActionEventDispatcher") === true)
    {
        this._events.onOut.dispatch();
    }

    this._dom.style.cursor = "default";
};

/**
 * Create action events dispatchers.
 * @method FORGE.HotspotDOM#_createEvents
 * @private
 * @param {Object} events - The events config of the dom hotspot.
 */
FORGE.HotspotDOM.prototype._createEvents = function(events)
{
    var event;
    for(var e in events)
    {
        event = new FORGE.ActionEventDispatcher(this._viewer, e);
        event.addActions(events[e]);
        this._events[e] = event;
    }
};

/**
 * Clear all object events.
 * @method FORGE.HotspotDOM#_clearEvents
 * @private
 */
FORGE.HotspotDOM.prototype._clearEvents = function()
{
    for(var e in this._events)
    {
        this._events[e].destroy();
        this._events[e] = null;
    }
};

/**
 * Handles the changing view, as it can only be present in the Rectilinear and GoPro view.
 * @method FORGE.HotspotDOM#_viewChangeHandler
 * @private
 */
FORGE.HotspotDOM.prototype._viewChangeHandler = function()
{
    this._dom.style.display = "block";

    if ((this._viewer.view.type !== FORGE.ViewType.RECTILINEAR && this._viewer.view.type !== FORGE.ViewType.GOPRO) || this._visible === false)
    {
        this._dom.style.display = "none";
    }
};

/**
 * Show the hotspot by appending it to the DOM container.
 * @method FORGE.HotspotDOM#show
 */
FORGE.HotspotDOM.prototype.show = function()
{
    this._viewer.domHotspotContainer.dom.appendChild(this._dom);
};

/**
 * Hide the hotspot by removing it to the DOM container.
 * @method FORGE.HotspotDOM#hide
 */
FORGE.HotspotDOM.prototype.hide = function()
{
    this._viewer.domHotspotContainer.dom.removeChild(this._dom, false);
};

/**
 * Update routine.
 * @method FORGE.HotspotDOM#update
 */
FORGE.HotspotDOM.prototype.update = function()
{
    // get the screen position of the hotspots
    var position = this._viewer.view.worldToScreen(this._transform.position.values);

    if (position !== null)
    {
        var x = position.x + this._offset.x - this._dom.clientWidth / 2;
        var y = position.y + this._offset.y - this._dom.clientHeight / 2;
        this._dom.style.left = x + "px";
        this._dom.style.top = y + "px";
    }
    else
    {
        this._dom.style.left = "99999px";
        this._dom.style.top = "99999px";
    }
};

/**
 * Destroy routine.
 * @method FORGE.HotspotDOM#destroy
 */
FORGE.HotspotDOM.prototype.destroy = function()
{
    this._dom.removeEventListener("click", this._domClickHandlerBind);
    this._dom.removeEventListener("mouseover", this._domOverHandlerBind);
    this._dom.removeEventListener("mouseout", this._domOutHandlerBind);

    this._domClickHandlerBind = null;
    this._domOverHandlerBind = null;
    this._domOutHandlerBind = null;

    this._clearEvents();
    this._events = null;

    // Hide dom, don't destroy it, as it may be used later
    this._dom.style.left = "99999px";
    this._dom.style.top = "99999px";
    this._dom = null;

    this._transform.destroy();
    this._transform = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the DOM content of the hotspot.
 * @name FORGE.HotspotDOM#dom
 * @readonly
 * @type {?Element|HTMLElement}
 */
Object.defineProperty(FORGE.HotspotDOM.prototype, "dom",
{
    /** @this {FORGE.HotspotDOM} */
    get: function()
    {
        return this._dom;
    }
});

/**
 * Get and set the visible flag.
 * @name FORGE.HotspotDOM#visible
 * @type {boolean}
 */
Object.defineProperty(FORGE.HotspotDOM.prototype, "visible",
{
    /** @this {FORGE.HotspotDOM} */
    get: function()
    {
        return this._visible;
    },
    /** @this {FORGE.HotspotDOM} */
    set: function(value)
    {
        this._visible = Boolean(value);

        if (this._visible === true)
        {
            this._viewChangeHandler();
        }
        else
        {
            this._dom.style.display = "none";
        }
    }
});

/**
 * Get and set the interactive flag for the main hotspot DOM container.
 * @name FORGE.HotspotDOM#interactive
 * @type {boolean}
 */
Object.defineProperty(FORGE.HotspotDOM.prototype, "interactive",
{
    /** @this {FORGE.HotspotDOM} */
    get: function()
    {
        return this._interactive;
    },
    /** @this {FORGE.HotspotDOM} */
    set: function(value)
    {
        this._interactive = Boolean(value);

        if (this._interactive === true)
        {
            this._dom.style.pointerEvents = "auto";
        }
        else
        {
            this._dom.style.pointerEvents = "none";
        }
    }
});

/**
 * Get/set the offset of the DOM object.
 * @name FORGE.HotspotDOM#offset
 * @type {HotspotDomOffset}
 */
Object.defineProperty(FORGE.HotspotDOM.prototype, "offset",
{
    /** @this {FORGE.HotspotDOM} */
    get: function()
    {
        return this._offset;
    },

    /** @this {FORGE.HotspotDOM} */
    set: function(value)
    {
        if (typeof value !== "undefined" && (typeof value.x === "number" || typeof value.y === "number"))
        {
            this._offset = /** @type {HotspotDomOffset} */ (FORGE.Utils.extendSimpleObject(FORGE.HotspotDOM.DEFAULT_OFFSET, value));
        }
    }
});

/**
 * FORGE.Hotspot3D
 * Abstract base class for projeted views. Should be subclassed for every supported projection / view type.
 *
 * @constructor FORGE.Hotspot3D
 * @param {FORGE.Viewer} viewer - viewer reference
 * @param {HotspotConfig} config - hostspot configuration
 * @extends {FORGE.Object3D}
 */
FORGE.Hotspot3D = function(viewer, config)
{
    /**
     * Hotspot configuration
     * @name  FORGE.Hotspot3D#_config
     * @type {HotspotConfig}
     * @private
     */
    this._config = config;

    /**
     * Name
     * @name  FORGE.Hotspot3D#_name
     * @type {string}
     * @private
     */
    this._name = "";

    /**
     * HotspotTransform object for the 3D object.
     * @name  FORGE.Hotspot3D#_transform
     * @type {FORGE.HotspotTransform}
     * @private
     */
    this._transform = null;

    /**
     * HotspotGeometry object.
     * @name FORGE.Hotspot3D#_geometry
     * @type {FORGE.HotspotGeometry}
     * @private
     */
    this._geometry = null;

    /**
     * Material object for the 3D object.
     * @name  FORGE.Hotspot3D#_material
     * @type {FORGE.HotspotMaterial}
     * @private
     */
    this._material = null;

    /**
     * Sound object for the 3D object.
     * @name  FORGE.Hotspot3D#_sound
     * @type {FORGE.HotspotSound}
     * @private
     */
    this._sound = null;

    /**
     * Animation object for the 3D object.
     * @name FORGE.Hotspot3D#_animation
     * @type {FORGE.HotspotAnimation}
     * @private
     */
    this._animation = null;

    /**
     * Hotspots states manager
     * @name FORGE.Hotspot3D#_states
     * @type {FORGE.HotspotStates}
     * @private
     */
    this._states = null;

    /**
     * Does the hotspot is facing the camera ? Useful for a flat hotspot we want
     * to always be facing to the camera.
     * @name FORGE.Hotspot3D#_facingCenter
     * @type {boolean}
     * @private
     */
    this._facingCenter = false;

    /**
     * Does the hotspot changes its scale according to the fov ?
     * @name FORGE.Hotspot3D#_autoScale
     * @type {boolean}
     * @private
     */
    this._autoScale = false;

    /**
     * The pointer cursor when pointer is over the Object3D
     * @name FORGE.Hotspot3D#_cursor
     * @type {string}
     * @private
     */
    this._cursor = "pointer";

    /**
     * Before render bound callback.
     * @name FORGE.Hotspot3D#_onBeforeRenderBound
     * @type {?function(this:THREE.Object3D,?THREE.WebGLRenderer,?THREE.Scene,?THREE.Camera,?THREE.Geometry,?THREE.Material,?THREE.Group)}
     * @private
     */
    this._onBeforeRenderBound = null;

    /**
     * After render bound callback.
     * @name FORGE.Hotspot3D#_onAfterRenderBound
     * @type {?function(this:THREE.Object3D,?THREE.WebGLRenderer,?THREE.Scene,?THREE.Camera,?THREE.Geometry,?THREE.Material,?THREE.Group)}
     * @private
     */
    this._onAfterRenderBound = null;

    FORGE.Object3D.call(this, viewer, "Hotspot3D");
};

FORGE.Hotspot3D.prototype = Object.create(FORGE.Object3D.prototype);
FORGE.Hotspot3D.prototype.constructor = FORGE.Hotspot3D;

/**
 * Boot sequence.<br>
 * Call superclass boot when objects are created as it will trigger parse config
 * @private
 */
FORGE.Hotspot3D.prototype._boot = function()
{
    FORGE.Object3D.prototype._boot.call(this);

    this._transform = new FORGE.HotspotTransform();
    this._transform.onChange.add(this._onTransformChangeHandler, this);

    this._animation = new FORGE.HotspotAnimation(this._viewer, this._transform);

    this._onBeforeRenderBound = this._onBeforeRender.bind(this);
    this._onAfterRenderBound = this._onAfterRender.bind(this);

    this._mesh.visible = false;
    this._mesh.onBeforeRender = /** @type {function(this:THREE.Object3D,?THREE.WebGLRenderer,?THREE.Scene,?THREE.Camera,?THREE.Geometry,?THREE.Material,?THREE.Group)} */ (this._onBeforeRenderBound);
    this._mesh.onAfterRender = /** @type {function(this:THREE.Object3D,?THREE.WebGLRenderer,?THREE.Scene,?THREE.Camera,?THREE.Geometry,?THREE.Material,?THREE.Group)} */ (this._onAfterRenderBound);

    this._viewer.renderer.view.onChange.add(this._viewChangeHandler, this);

    if (typeof this._config !== "undefined" && this._config !== null)
    {
        this._parseConfig(this._config);
    }
};

/**
 * Parse the config object.
 * @method FORGE.Hotspot3D#_parseConfig
 * @param {HotspotConfig} config - The hotspot config to parse.
 * @private
 */
FORGE.Hotspot3D.prototype._parseConfig = function(config)
{
    this._uid = config.uid;
    this._tags = config.tags;
    this._register();

    // Set the mesh name
    this._mesh.name = "mesh-" + this._uid;
    this._mesh.userData = config;

    this._name = (typeof config.name === "string") ? config.name : "";
    this._visible = (typeof config.visible === "boolean") ? config.visible : true;
    this._facingCenter = (typeof config.facingCenter === "boolean") ? config.facingCenter : false;
    this._autoScale = (typeof config.autoScale === "boolean") ? config.autoScale : false;
    this._interactive = (typeof config.interactive === "boolean") ? config.interactive : true;
    this._cursor = (typeof config.cursor === "string") ? config.cursor : "pointer";

    this._geometry = new FORGE.HotspotGeometry();
    this._material = new FORGE.HotspotMaterial(this._viewer, this._uid);
    this._sound = new FORGE.HotspotSound(this._viewer, this._uid);
    this._states = new FORGE.HotspotStates(this._viewer, this._uid);

    if (typeof config.states === "object" && config.states !== null)
    {
        this._states.addConfig(config.states);
    }

    if (typeof config.fx === "string" && config.fx !== "")
    {
        this._fx = config.fx;
    }

    if (typeof config.events === "object" && config.events !== null)
    {
        this._createEvents(config.events);
    }

    this._states.onLoadComplete.add(this._stateLoadCompleteHandler, this);
    this._states.load();
};

/**
 * Before render handler
 * @method FORGE.Hotspot3D#_onBeforeRender
 * @private
 */
FORGE.Hotspot3D.prototype._onBeforeRender = function(renderer, scene, camera, geometry, material, group)
{
    var g = group; // Just to avoid the jscs warning about group parameter not used.

    this._viewer.renderer.view.current.updateUniforms(material.uniforms);

    // Check what is the current render pass looking at the material: Hotspot or Picking Material
    if (material.name === "HotspotMaterial")
    {
        this._material.update();
    }
    else if (material.name === "PickingMaterial")
    {
        // As picking material is the same for all spots renderer in this pass, material uniforms won't be refreshed
        // Setting material.uniforms.tColor value will be useless, set direct value by acceding program uniforms map
        // Call useProgram first to avoid WebGL warning if material.program is not the current program
        // Set also material uniform to avoid both settings will collide on first object
        if (material.program)
        {
            var gl = this._viewer.renderer.webGLRenderer.getContext();
            gl.useProgram(material.program.program);
            material.program.getUniforms().map.tColor.setValue(gl, this._pickingColor);
            material.uniforms.tColor.value = this._pickingColor;
        }
    }
};

/**
 * After render handler
 * @method FORGE.Hotspot3D#_onAfterRender
 * @private
 */
FORGE.Hotspot3D.prototype._onAfterRender = function()
{

};

/**
 * Event handler for material ready. Triggers the creation of the hotspot3D.
 * @method FORGE.Hotspot3D#_stateLoadCompleteHandler
 * @private
 */
FORGE.Hotspot3D.prototype._stateLoadCompleteHandler = function()
{
    this.log("state load complete handler");

    this._mesh.geometry = this._geometry.geometry;
    this._mesh.material = this._material.material;
    this._mesh.visible = this._visible;

    this._updatePosition();

    if (this._animation.autoPlay === true && document[FORGE.Device.visibilityState] === "visible")
    {
        this._animation.play();
    }

    if (this._onReady !== null)
    {
        this._onReady.dispatch();
    }
};

/**
 * transform change handler
 * @method FORGE.Hotspot3D#_onTransformChangeHandler
 * @private
 */
FORGE.Hotspot3D.prototype._onTransformChangeHandler = function()
{
    this.log("transform change handler");
    this._updatePosition();
};

/**
 * Setup hotspot spatial position.
 * @method FORGE.Hotspot3D#_setupPosition
 * @private
 */
FORGE.Hotspot3D.prototype._updatePosition = function()
{
    this.log("update position");

    this._mesh.position.x = this._transform.position.x;
    this._mesh.position.y = this._transform.position.y;
    this._mesh.position.z = this._transform.position.z;

    if (this._facingCenter === true)
    {
        var spherical = new THREE.Spherical().setFromVector3(new THREE.Vector3(this._transform.position.x, this._transform.position.y, this._transform.position.z));

        this._mesh.rotation.set(-spherical.phi + Math.PI / 2, spherical.theta + Math.PI, 0, "YXZ");

        // Apply rotation
        this._mesh.rotation.x += -FORGE.Math.degToRad(this._transform.rotation.x); // pitch
        this._mesh.rotation.y += FORGE.Math.degToRad(this._transform.rotation.y); // yaw
        this._mesh.rotation.z += FORGE.Math.degToRad(this._transform.rotation.z);
    }
    else
    {
        // Apply rotation
        var rx = -FORGE.Math.degToRad(this._transform.rotation.x); // pitch
        var ry = FORGE.Math.degToRad(this._transform.rotation.y); // yaw
        var rz = FORGE.Math.degToRad(this._transform.rotation.z);

        this._mesh.rotation.set(rx, ry, rz, "YXZ");
    }

    // Scale
    if(this._autoScale === true)
    {
        this._updateAutoScale();
    }
    else
    {
        this._mesh.scale.x = FORGE.Math.clamp(this._transform.scale.x, 0.000001, 100000);
        this._mesh.scale.y = FORGE.Math.clamp(this._transform.scale.y, 0.000001, 100000);
        this._mesh.scale.z = FORGE.Math.clamp(this._transform.scale.z, 0.000001, 100000);
    }
};

/**
 * Updates the mesh scale according to the fov to keep a constant screen size
 * @method FORGE.Hotspot3D#_updateAutoScale
 * @private
 */
FORGE.Hotspot3D.prototype._updateAutoScale = function()
{
    var factor = this._viewer.camera.fov / this._viewer.camera.config.fov.default;

    this._mesh.scale.x = FORGE.Math.clamp(this._transform.scale.x * factor, 0.000001, 100000);
    this._mesh.scale.y = FORGE.Math.clamp(this._transform.scale.y * factor, 0.000001, 100000);
    this._mesh.scale.z = FORGE.Math.clamp(this._transform.scale.z * factor, 0.000001, 100000);
};

/**
 * Check the ready flag of hotspot
 * @method FORGE.Hotspot3D#_checkReady
 * @return {boolean}
 * @private
 */
FORGE.Hotspot3D.prototype._checkReady = function()
{
    return (this._states.ready === true);
};

/**
 * View change handler
 * @method FORGE.Hotspot3D#_viewChangeHandler
 * @private
 */
FORGE.Hotspot3D.prototype._viewChangeHandler = function()
{
    // Only enable frustum culling when view is rectilinear and frustum makes sense
    this._mesh.frustumCulled = this._viewer.renderer.view.current instanceof FORGE.ViewRectilinear;

    this._material.updateShader();
    this._mesh.material = this._material.material;
};

/**
 * Override of the over method to trigger the state change
 * @method FORGE.Hotspot3D#over
 */
FORGE.Hotspot3D.prototype.over = function()
{
    FORGE.Object3D.prototype.over.call(this);

    if(this._states.auto === true)
    {
        this._states.load("over");
    }

    this._viewer.canvas.pointer.cursor = this._cursor;
};

/**
 * Override of the out method to trigger the state change
 * @method FORGE.Hotspot3D#out
 */
FORGE.Hotspot3D.prototype.out = function()
{
    FORGE.Object3D.prototype.out.call(this);

    if(this._states.auto === true)
    {
        this._states.load();
    }

    this._viewer.canvas.pointer.cursor = "default";
};

/**
 * Update hotspot content
 * @method FORGE.Hotspot3D#update
 */
FORGE.Hotspot3D.prototype.update = function()
{
    if (this._sound !== null)
    {
        this._sound.update();
    }

    if(this._autoScale === true)
    {
        this._updateAutoScale();
    }
};

/**
 * Dump the hotspot actual configuration
 * @method FORGE.Hotspot3D#dump
 * @return {HotspotConfig} Return the hotspot actual configuration object
 */
FORGE.Hotspot3D.prototype.dump = function()
{
    var dump =
    {
        uid: this._uid,
        name: this._name,
        tags: this._tags,
        visible: this._visible,
        interactive: this._interactive,
        cursor: this._cursor,
        fx: this._fx,
        facingCenter: this._facingCenter,
        geometry: this._geometry.dump(),
        transform: this._transform.dump(),
        material: this._material.dump()
    };

    return dump;
};

/**
 * Destroy routine
 * @method FORGE.Hotspot3D#destroy
 */
FORGE.Hotspot3D.prototype.destroy = function()
{
    this._viewer.renderer.view.onChange.remove(this._viewChangeHandler, this);

    this._onBeforeRenderBound = null;
    this._onAfterRenderBound = null;

    if(this._states !== null)
    {
        this._states.destroy();
        this._states = null;
    }

    if (this._transform !== null)
    {
        this._transform.destroy();
        this._transform = null;
    }

    if(this._geometry !== null)
    {
        this._geometry.destroy();
        this._geometry = null;
    }

    if (this._animation !== null)
    {
        this._animation.destroy();
        this._animation = null;
    }

    if (this._material !== null)
    {
        this._material.destroy();
        this._material = null;
    }

    if (this._sound !== null)
    {
        this._sound.destroy();
        this._sound = null;
    }

    FORGE.Object3D.prototype.destroy.call(this);
};

/**
 * Hotspot config accessor
 * @name FORGE.Hotspot3D#config
 * @readonly
 * @type {HotspotConfig}
 */
Object.defineProperty(FORGE.Hotspot3D.prototype, "config",
{
    /** @this {FORGE.Hotspot3D} */
    get: function()
    {
        return this._config;
    }
});

/**
 * Hotspot name accessor
 * @name FORGE.Hotspot3D#name
 * @type {string}
 */
Object.defineProperty(FORGE.Hotspot3D.prototype, "name",
{
    /** @this {FORGE.Hotspot3D} */
    get: function()
    {
        return this._name;
    },

    /** @this {FORGE.Hotspot3D} */
    set: function(value)
    {
        if(typeof value === "string")
        {
            this._name = value;
        }
    }
});

/**
 * Hotspot animation accessor
 * @name FORGE.Hotspot3D#animation
 * @readonly
 * @type {FORGE.HotspotAnimation}
 */
Object.defineProperty(FORGE.Hotspot3D.prototype, "animation",
{
    /** @this {FORGE.Hotspot3D} */
    get: function()
    {
        return this._animation;
    }
});

/**
 * Hotspot material accessor
 * @name FORGE.Hotspot3D#material
 * @readonly
 * @type {FORGE.HotspotMaterial}
 */
Object.defineProperty(FORGE.Hotspot3D.prototype, "material",
{
    /** @this {FORGE.Hotspot3D} */
    get: function()
    {
        return this._material;
    }
});

/**
 * Hotspot sound accessor
 * @name FORGE.Hotspot3D#sound
 * @readonly
 * @type {FORGE.HotspotSound}
 */
Object.defineProperty(FORGE.Hotspot3D.prototype, "sound",
{
    /** @this {FORGE.Hotspot3D} */
    get: function()
    {
        return this._sound;
    }
});

/**
 * Hotspot transform accessor
 * @name FORGE.Hotspot3D#transform
 * @readonly
 * @type {FORGE.HotspotTransform}
 */
Object.defineProperty(FORGE.Hotspot3D.prototype, "transform",
{
    /** @this {FORGE.Hotspot3D} */
    get: function()
    {
        return this._transform;
    }
});

/**
 * Hotspot geometry accessor
 * @name FORGE.Hotspot3D#geometry
 * @readonly
 * @type {FORGE.HotspotGeometry}
 */
Object.defineProperty(FORGE.Hotspot3D.prototype, "geometry",
{
    /** @this {FORGE.Hotspot3D} */
    get: function()
    {
        return this._geometry;
    }
});

/**
 * Hotspot3D ready flag
 * @name FORGE.Hotspot3D#ready
 * @readonly
 * @type boolean
  */
Object.defineProperty(FORGE.Hotspot3D.prototype, "ready",
{
    /** @this {FORGE.Object3D} */
    get: function()
    {
        this._ready = this._checkReady();
        return this._ready;
    }
});

/**
 * Hotspot states accessor
 * @name FORGE.Hotspot3D#states
 * @readonly
 * @type {FORGE.HotspotStates}
 */
Object.defineProperty(FORGE.Hotspot3D.prototype, "states",
{
    /** @this {FORGE.Hotspot3D} */
    get: function()
    {
        return this._states;
    }
});

/**
 * Hotspot states accessor
 * @name FORGE.Hotspot3D#states
 * @readonly
 * @type {FORGE.HotspotStates}
 */
Object.defineProperty(FORGE.Hotspot3D.prototype, "state",
{
    /** @this {FORGE.Hotspot3D} */
    get: function()
    {
        return this._states.state;
    },

    /** @this {FORGE.Hotspot3D} */
    set: function(value)
    {
        this._states.load(value);
    }
});

/**
 * Hotspot sound handles the parse of the sound config and the loading of the needed sound resource.
 * It also ajusts the volume of the sound depending of your camera position.
 *
 * @constructor FORGE.HotspotSound
 * @param {FORGE.Viewer} viewer - The viewer reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.HotspotSound = function(viewer, hotspotUid)
{
    /**
     * Viewer reference.
     * @name  FORGE.HotspotSound#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The hotspot uid
     * @name FORGE.HotspotMaterial#_hotspotUid
     * @type {string}
     * @private
     */
    this._hotspotUid = hotspotUid;

    /**
     * The FORGE.Sound object
     * @name FORGE.HotspotSound#_sound
     * @type {FORGE.Sound}
     * @private
     */
    this._sound = null;

    /**
     * The minimum volume when you are out of range
     * @name FORGE.HotspotSound#_volumeMin
     * @type {number}
     * @private
     */
    this._volumeMin = 0;

    /**
     * The maximum volume when you are in the center of the range
     * @name FORGE.HotspotSound#_volumeMax
     * @type {number}
     * @private
     */
    this._volumeMax = 1;

    /**
     * Is sound looped?
     * @name FORGE.HotspotSound#_loop
     * @type {boolean}
     * @private
     */
    this._loop = false;

    /**
     * Start time for the sound.
     * @name  FORGE.HotspotSound#_startTime
     * @type {number}
     * @private
     */
    this._startTime = 0;

    /**
     * Is sound auto started?
     * @name  FORGE.HotspotSound#_autoPlay
     * @type {boolean}
     * @private
     */
    this._autoPlay = false;

    /**
     * The theta/phi position of the sound.
     * @name  FORGE.HotspotSound#_position
     * @type {?HotspotTransformPosition}
     * @private
     *
     * @todo Use the HotspotTransformPosition object of the HotspotTransform class?
     */
    this._position = { x: 0, y: 0, z: 200 };

    /**
     * The range in degrees where sound can be played from it's position.
     * @name  FORGE.HotspotSound#_range
     * @type {number}
     * @default
     * @private
     */
    this._range = 360;

    /**
     * The onReady event dispatcher.
     * @name  FORGE.HotspotSound#_onReady
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onReady = null;

    FORGE.BaseObject.call(this, "HotspotSound");
};

FORGE.HotspotSound.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.HotspotSound.prototype.constructor = FORGE.HotspotSound;

/**
 * Parse the configuration object.
 * @method FORGE.HotspotSound#_parseConfig
 * @param {SoundConfig} config - The configuration object of the sound.
 * @private
 */
FORGE.HotspotSound.prototype._parseConfig = function(config)
{
    if (typeof config.source === "undefined" || typeof config.source !== "object")
    {
        return;
    }

    // Warning : UID is not registered and applied to the FORGE.Sound for registration
    this._uid = config.uid;

    // Is it a source url
    if (typeof config.source.url !== "undefined" && typeof config.source.url === "string" && config.source.url !== "")
    {
        this._url = config.source.url;
    }
    // or a source UID?
    else if (typeof config.source.target !== "undefined" && FORGE.UID.exists(config.source.target) === true)
    {
        //@todo
        var object = FORGE.UID.get(config.source.target);
        //this._url = "";
        return;
    }
    else
    {
        return;
    }

    if (typeof config.options !== "undefined" && typeof config.options === "object")
    {
        if(typeof config.options.volume === "number")
        {
            this._volumeMax = config.options.volume;
        }
        else if (typeof config.options.volume === "object")
        {
            var volume = /** @type {SoundVolumeConfig} */ (config.options.volume);
            this._volumeMin = (typeof volume.min === "number") ? FORGE.Math.clamp(volume.min, 0, 1) : 0;
            this._volumeMax = (typeof volume.max === "number") ? FORGE.Math.clamp(volume.max, 0, 1) : 1;
        }

        this._loop = (typeof config.options.loop === "boolean") ? config.options.loop : false;
        this._startTime = (typeof config.options.startTime === "number") ? config.options.startTime : 0; //in ms
        this._autoPlay = (typeof config.options.autoPlay === "boolean") ? config.options.autoPlay : false;
        this._range = (typeof config.options.range === "number") ? FORGE.Math.clamp(config.options.range, 1, 360) : 360;
    }

    var hotspot = FORGE.UID.get(this._hotspotUid);
    var position = hotspot.config.transform.position;

    this._position.theta = (typeof position.theta === "number") ? FORGE.Math.clamp(/** @type {number} */ (position.theta), -180, 180) : 0;
    this._position.phi = (typeof position.phi === "number") ? FORGE.Math.clamp(/** @type {number} */ (position.phi), -90, 90) : 0;
    //@todo manage radius

    this._setupSound();
};

/**
 * Setup the sound and apply options.
 * @method FORGE.HotspotSound#_setupSound
 * @private
 */
FORGE.HotspotSound.prototype._setupSound = function()
{
    this._sound = new FORGE.Sound(this._viewer, this._uid, this._url || "");
    this._sound.onCanPlayThrough.addOnce(this._onCanPlayThroughHandler, this);

    // spatial sound options
    if(this._isSpatialized() === true)
    {
        // Create world position from inversed theta angle and phi angle
        var positionWorld = FORGE.Math.sphericalToCartesian(1, /** @type {number} */ (this._position.theta), /** @type {number} */ (this._position.phi));

        this._sound.spatialized = this._isSpatialized();
        this._sound.x = positionWorld.x;
        this._sound.y = positionWorld.y;
        this._sound.z = positionWorld.z;
    }

    // sound options
    this._sound.volume = this._volumeMax;
    this._sound.loop = this._loop;
    this._sound.startTime = this._startTime;

    if (this._autoPlay === true)
    {
        if (document[FORGE.Device.visibilityState] === "visible")
        {
            this._sound.play(this._startTime, this._loop, true);
        }
        else
        {
            this._sound.resumed = true;
        }
    }
};

/**
 * Is the sound spatialized?
 * @method  FORGE.HotspotSound#_isSpatialized
 * @return {boolean} Is spatialized?
 * @private
 */
FORGE.HotspotSound.prototype._isSpatialized = function()
{
    return this._range < 360;
};

/**
 * On can play through handler.
 * @method  FORGE.HotspotSound#_onCanPlayThroughHandler
 * @private
 */
FORGE.HotspotSound.prototype._onCanPlayThroughHandler = function()
{
    this.log("Sound load complete");
    this._setupComplete();
};

/**
 * Setup completed handler.
 * @method FORGE.HotspotSound#_setupComplete
 * @private
 */
FORGE.HotspotSound.prototype._setupComplete = function()
{
    if(this._onReady !== null)
    {
        this._onReady.dispatch();
    }
};

/**
 * Set an observer cone for the sound volume.
 * @method FORGE.HotspotSound#_applyRange
 * @private
 *
 * @todo  doesn't work if the camera is reversed on the y axis !
 */
FORGE.HotspotSound.prototype._applyRange = function()
{
    if(this._isSpatialized() === true && typeof this._range === "number")
    {
        var camera = this._viewer.renderer.camera;
        var qCamera = FORGE.Quaternion.fromEuler(FORGE.Math.degToRad(camera.yaw), FORGE.Math.degToRad(camera.pitch), 0);
        var qSound = FORGE.Quaternion.fromEuler(FORGE.Math.degToRad(/** @type {number} */ (this._position.theta)), FORGE.Math.degToRad(/** @type {number} */ (this._position.phi)), 0);
        var distance = FORGE.Quaternion.angularDistance(qSound, qCamera);
        var radius = FORGE.Math.degToRad(this._range / 2); //from range to radius in radians

        // reduce the volume or "mute" volume when out of the range
        if (distance < radius)
        {
            var amplitude = this._volumeMax - this._volumeMin;
            var volume = this._volumeMin + (amplitude * (1 - distance / radius));
            this.log("in range | volume: "+volume);

            this._sound.volume = volume;
        }
        else
        {
            this.log("out range");
            this._sound.volume = this._volumeMin;
        }
    }
};

/**
 * Load a sound configuration
 * @method FORGE.HotspotSound#load
 * @param  {SoundConfig} config - The hotspot sound configuration object.
 */
FORGE.HotspotSound.prototype.load = function(config)
{
    if(FORGE.Utils.compareObjects(this._config, config) === true)
    {
        if(this._onReady !== null)
        {
            this._onReady.dispatch();
        }

        if(this._autoPlay === true && this._sound !== null)
        {
            this._sound.play(this._startTime, this._loop, true);
        }

        return;
    }

    this._config = config;

    if (this._sound !== null)
    {
        this._sound.destroy();
        this._sound = null;
    }

    this._parseConfig(config);
};

/**
 * Render sound.
 * @method FORGE.HotspotSound#update
 */
FORGE.HotspotSound.prototype.update = function()
{
    if (this._viewer.audio.enabled === false)
    {
        if(this._sound !== null)
        {
            this._sound.stop();
        }

        return;
    }

    if(this._isSpatialized() === true)
    {
        this._applyRange();
    }
};

/**
 * Destroy routine.
 * @method FORGE.HotspotSound#destroy
 */
FORGE.HotspotSound.prototype.destroy = function()
{
    if (this._sound !== null)
    {
        this._sound.destroy();
        this._sound = null;
    }

    if(this._onReady !== null)
    {
        this._onReady.destroy();
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the {@link FORGE.Sound} object.
 * @name FORGE.HotspotSound#sound
 * @readonly
 * @type {FORGE.Sound}
 */
Object.defineProperty(FORGE.HotspotSound.prototype, "sound",
{
    /** @this {FORGE.HotspotSound} */
    get: function()
    {
        return this._sound;
    }
});

/**
 * Get the "onReady" {@link FORGE.EventDispatcher} of this hotspot sound.
 * @name FORGE.HotspotSound#onReady
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.HotspotSound.prototype, "onReady",
{
    /** @this {FORGE.HotspotSound} */
    get: function()
    {
        if(this._onReady === null)
        {
            this._onReady = new FORGE.EventDispatcher(this);
        }

        return this._onReady;
    }
});

/**
 * Hotspot material handles the parse of the material config and the loading of the needed resource.<br>
 * In the end it provides a THREE.MeshBasicMaterial when the resources are loaded.
 *
 * @constructor FORGE.HotspotMaterial
 * @param {FORGE.Viewer} viewer - The viewer reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.HotspotMaterial = function(viewer, hotspotUid)
{
    /**
     * Viewer reference.
     * @name  FORGE.HotspotMaterial#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The hotspot uid
     * @name FORGE.HotspotMaterial#_hotspotUid
     * @type {string}
     * @private
     */
    this._hotspotUid = hotspotUid;

    /**
     * Hotspot material config
     * @name FORGE.HotspotMaterial#_config
     * @type {?HotspotMaterialConfig}
     * @private
     */
    this._config = null;

    /**
     * Material input type.<br>
     * Can be one of the values listed in FORGE.HotspotMaterial.types
     * @name  FORGE.HotspotMaterial#_type
     * @type {string}
     * @private
     */
    this._type = "";

    /**
     * THREE texture.
     * @name  FORGE.HotspotMaterial#_texture
     * @type {THREE.Texture|THREE.CanvasTexture}
     * @private
     */
    this._texture = null;

    /**
     * THREE material.
     * @name  FORGE.HotspotMaterial#_material
     * @type {THREE.RawShaderMaterial}
     * @private
     */
    this._material = null;

    /**
     * The opacity of the material (between 0 and 1)
     * @name  FORGE.HotspotMaterial#_opacity
     * @type {number}
     * @default
     * @private
     */
    this._opacity = 1;

    /**
     * The transparent flag of the material.<br>
     * if you use a PNG file as texture with some transparency, you have to set this to true.
     * @name  FORGE.HotspotMaterial#_transparent
     * @type {boolean}
     * @default
     * @private
     */
    this._transparent = false;

    /**
     * The base color of the material.<br>
     * Can be a number 0xff0000 or a string: rgb(255, 0, 0), rgb(100%, 0%, 0%), hsl(0, 100%, 50%), #ff0000.
     * @name  FORGE.HotspotMaterial#_opacity
     * @type {(number|string)}
     * @default
     * @private
     */
    this._color = 0xffffff;

    /**
     * The display object used for the texture
     * @name  FORGE.HotspotMaterial#_displayObject
     * @type {FORGE.DisplayObject}
     * @private
     */
    this._displayObject = null;

    /**
     * Does this material needs update
     * @name FORGE.HotspotMaterial#_update
     * @type {boolean}
     * @private
     */
    this._update = false;

    /**
     * Ready flag
     * @name FORGE.HotspotMaterial#_ready
     * @type {boolean}
     * @private
     */
    this._ready = false;

    /**
     * The onReady event dispatcher.
     * @name  FORGE.HotspotMaterial#_onReady
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onReady = null;

    FORGE.BaseObject.call(this, "HotspotMaterial");
};

FORGE.HotspotMaterial.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.HotspotMaterial.prototype.constructor = FORGE.HotspotMaterial;

/**
 * Material input type list.
 * @name FORGE.HotspotMaterial.types
 * @type {Object}
 * @const
 */
FORGE.HotspotMaterial.types = {};

/**
 * @name FORGE.HotspotMaterial.types.IMAGE
 * @type {string}
 * @const
 */
FORGE.HotspotMaterial.types.IMAGE = "image";

/**
 * @name FORGE.HotspotMaterial.types.SPRITE
 * @type {string}
 * @const
 */
FORGE.HotspotMaterial.types.SPRITE = "sprite";

/**
 * @name FORGE.HotspotMaterial.types.VIDEO
 * @type {string}
 * @const
 */
FORGE.HotspotMaterial.types.VIDEO = "video";

/**
 * @name FORGE.HotspotMaterial.types.PLUGIN
 * @type {string}
 * @const
 */
FORGE.HotspotMaterial.types.PLUGIN = "plugin";

/**
 * @name FORGE.HotspotMaterial.types.GRAPHICS
 * @type {string}
 * @const
 */
FORGE.HotspotMaterial.types.GRAPHICS = "graphics";

/**
 * Material sides list.
 * @name FORGE.HotspotMaterial.sides
 * @type {Object}
 * @const
 */
FORGE.HotspotMaterial.sides = {};

/**
 * @name FORGE.HotspotMaterial.sides.FRONT
 * @type {string}
 * @const
 */
FORGE.HotspotMaterial.sides.FRONT = "front";

/**
 * @name FORGE.HotspotMaterial.sides.BACK
 * @type {string}
 * @const
 */
FORGE.HotspotMaterial.sides.BACK = "back";

/**
 * @name FORGE.HotspotMaterial.sides.DOUBLE
 * @type {string}
 * @const
 */
FORGE.HotspotMaterial.sides.DOUBLE = "double";


/**
 * Materials presets.
 * @name FORGE.HotspotMaterial.presets
 * @type {Object}
 * @const
 */
FORGE.HotspotMaterial.presets = {};

/**
 * @name FORGE.HotspotMaterial.presets.TRANSPARENT
 * @type {HotspotMaterialConfig}
 * @const
 */
FORGE.HotspotMaterial.presets.TRANSPARENT =
{
    color: "#ffffff",
    opacity: 0,
    transparent: false
};

/**
 * @name FORGE.HotspotMaterial.presets.DEBUG
 * @type {HotspotMaterialConfig}
 * @const
 */
FORGE.HotspotMaterial.presets.DEBUG =
{
    color: "#00ff00",
    opacity: 0.8,
    transparent: false
};

/**
 * Parse the configuration object.
 * @method FORGE.HotspotMaterial#_parseConfig
 * @param  {HotspotMaterialConfig} config - Configuration object of the material.
 * @private
 */
FORGE.HotspotMaterial.prototype._parseConfig = function(config)
{
    this._opacity = (typeof config.opacity === "number") ? FORGE.Math.clamp(config.opacity, 0, 1) : 1;
    this._transparent = (typeof config.transparent === "boolean") ? config.transparent : false;
    this._color = (typeof config.color === "string") ? config.color : 0xffffff;
    this._update = (typeof config.update === "boolean") ? config.update : false;
    this._side = (typeof config.side === "string") ? config.side : FORGE.HotspotMaterial.sides.DOUBLE;

    // Hotspot with image as background
    if (typeof config.image !== "undefined" && config.image !== null)
    {
        this._setupWithImage(config.image);
    }

    // Hotspot with animated sprite as background
    else if (typeof config.sprite !== "undefined" && config.sprite !== null)
    {
        this._setupWithSprite(config.sprite);
    }

    // Hotspot with video as background
    else if (typeof config.video !== "undefined" && config.video !== null)
    {
        this._setupWithVideo(config.video);
    }

    // Hotspot with plugin that provide a texture as background
    else if (typeof config.plugin !== "undefined" && config.plugin !== null)
    {
        this._setupWithPlugin(config.plugin);
    }

    // Hotspot with graphical options as background
    else
    {
        this._setupWithGraphics();
    }
};

/**
 * Setup hotspot material with an image as texture.
 * @method FORGE.HotspotMaterial#_setupWithImage
 * @param {(string|ImageConfig)} config - The image configuration you want to load and use as a texture.
 * @private
 */
FORGE.HotspotMaterial.prototype._setupWithImage = function(config)
{
    this._type = FORGE.HotspotMaterial.types.IMAGE;

    // If the config is a string, we assume that this is the image url.
    // We convert the config into a image config object.
    if(typeof config === "string")
    {
        config = { url: config };
    }

    //Force the render mode to canvas
    config.renderMode = FORGE.Image.renderModes.CANVAS;

    this._displayObject = new FORGE.Image(this._viewer, config);
    this._displayObject.onLoadComplete.addOnce(this._imageLoadCompleteHandler, this);
};

/**
 * Image loaded event handler for the image setup.
 * @method FORGE.HotspotMaterial#_imageLoadCompleteHandler
 * @param {FORGE.Event} event - load event
 * @private
 */
FORGE.HotspotMaterial.prototype._imageLoadCompleteHandler = function(event)
{
    var image = /** @type {FORGE.Image} */ (event.emitter);

    this.log("image load complete : " + image.element.src);
    this._createTextureFromImage(image);
};

/**
 * Create a THREE.Texture from the loaded FORGE.Image
 * @method  FORGE.HotspotMaterial#_createTextureFromImage
 * @param  {FORGE.Image} image - The FORGE.Image used to create the texture.
 * @private
 */
FORGE.HotspotMaterial.prototype._createTextureFromImage = function(image)
{
    this._displayObject = image;

    this._texture = new THREE.Texture();
    this._texture.generateMipmaps = false;
    this._texture.minFilter = THREE.LinearFilter;

    this.setTextureFrame(image.frame);

    this.log("create texture from image");

    this._setupComplete();
};

/**
 * Setup hotspot material with a sprite as texture.
 * @method FORGE.HotspotMaterial#_setupWithSprite
 * @param {(string|SpriteConfig)} config - The sprite configuration you want to load and use as a texture.
 * @private
 */
FORGE.HotspotMaterial.prototype._setupWithSprite = function(config)
{
    this._type = FORGE.HotspotMaterial.types.SPRITE;
    this._update = true;

    this._displayObject = new FORGE.Sprite(this._viewer, config);
    this._displayObject.onLoadComplete.addOnce(this._spriteLoadCompleteHandler, this);
};

/**
 * Sprite loaded event handler for the sprite setup.
 * @method FORGE.HotspotMaterial#_spriteLoadCompleteHandler
 * @param {FORGE.Event} event - load event
 * @private
 */
FORGE.HotspotMaterial.prototype._spriteLoadCompleteHandler = function(event)
{
    var sprite = /** @type {FORGE.Sprite} */ (event.emitter);

    this.log("sprite load complete");
    this._createTextureFromSprite(sprite);
};

/**
 * Create a THREE.Texture from the loaded FORGE.Sprite
 * @method  FORGE.HotspotMaterial#_createTextureFromSprite
 * @param  {FORGE.Sprite} sprite - The FORGE.Sprite used to create the texture.
 * @private
 */
FORGE.HotspotMaterial.prototype._createTextureFromSprite = function(sprite)
{
    this._texture = new THREE.Texture();
    this._texture.generateMipmaps = false;
    this._texture.minFilter = THREE.LinearFilter;

    this.setTextureFrame(sprite.frame);

    this.log("create texture from sprite");

    this._setupComplete();
};

/**
 * Setup hotspot material with a video as texture.
 * @method FORGE.HotspotMaterial#_setupWithVideo
 * @param {(string|VideoConfig)} config - The video configuration you want to load and use as a texture.
 * @private
 */
FORGE.HotspotMaterial.prototype._setupWithVideo = function(config)
{
    this._type = FORGE.HotspotMaterial.types.VIDEO;
    this._update = true;

    this._displayObject = new FORGE.VideoHTML5(this._viewer, this._hotspotUid+"-material-video");
    this._displayObject.currentTime = 100000;
    this._displayObject.onLoadedMetaData.addOnce(this._videoLoadedMetaDataHandler, this);
    this._displayObject.load(config.url);
};

/**
 * Video meta data loaded event handler for the video setup.
 * @method FORGE.HotspotMaterial#_videoLoadedMetaDataHandler
 * @param {FORGE.Event} event - load event
 * @private
 */
FORGE.HotspotMaterial.prototype._videoLoadedMetaDataHandler = function(event)
{
    var video = /** @type {FORGE.VideoBase} */ (event.emitter);
    video.play();

    this.log("video load complete");
    this._createTextureFromVideo(video);
};

/**
 * Create a THREE.Texture from the loaded FORGE.Video
 * @method FORGE.HotspotMaterial#_createTextureFromVideo
 * @param {FORGE.VideoBase} video - The FORGE.Video used to create the texture.
 * @private
 */
FORGE.HotspotMaterial.prototype._createTextureFromVideo = function(video)
{
    this.log("create texture from video");

    this._texture = new THREE.Texture();
    this._texture.generateMipmaps = false;
    this._texture.minFilter = THREE.LinearFilter;

    this._texture.image = video.element;

    this._setupComplete();
};

/**
 * Create a hotspot with a plugin that will provide a texture as input.
 * @method FORGE.HotspotMaterial#_setupWithPlugin
 * @param {string} config - The plugin instance UID you want to use as a texture provider.<br>
 * The plugin have to have a "texture" public property.
 * @private
 */
FORGE.HotspotMaterial.prototype._setupWithPlugin = function(config)
{
    this._type = FORGE.HotspotMaterial.types.PLUGIN;

    var plugin = this._viewer.plugins.get(config);

    if (typeof plugin === "undefined" || plugin === null)
    {
        this._viewer.plugins.onInstanceCreate.add(this._pluginInstanceCreateHandler, this);
    }
    else
    {
        this._setPlugin(plugin);
    }
};

/**
 * Plugin instance create event handler.
 * @method FORGE.HotspotMaterial#_pluginInstanceCreateHandler
 * @param {FORGE.Event} event - instance create event
 * @private
 */
FORGE.HotspotMaterial.prototype._pluginInstanceCreateHandler = function(event)
{
    var plugin = /** @type {FORGE.Plugin} */ (event.data);

    if (plugin.uid === this._config.plugin)
    {
        this._viewer.plugins.onInstanceCreate.remove(this._pluginInstanceCreateHandler, this);
        this._setPlugin(plugin);
    }
};

/**
 * Once the plugin is created by the manager we can set the plugin that we will provide the texture.
 * This method will check if the instance is ready, if not will setup a listener.
 * @method FORGE.HotspotMaterial#_setPlugin
 * @param {FORGE.Plugin} plugin - The plugin that will provides the texture.
 * @private
 */
FORGE.HotspotMaterial.prototype._setPlugin = function(plugin)
{
    if (plugin.instanceReady === true)
    {
        this._createTextureFromPlugin(plugin);
    }
    else
    {
        plugin.onInstanceReady.addOnce(this._pluginInstanceReadyHandler, this);
    }
};

/**
 * Plugin instance ready event handler.
 * @method FORGE.HotspotMaterial#_pluginInstanceReadyHandler
 * @param {FORGE.Event} event - instance ready event
 * @private
 */
FORGE.HotspotMaterial.prototype._pluginInstanceReadyHandler = function(event)
{
    var plugin = /** @type {FORGE.Plugin} */ (event.emitter);

    if (plugin.instance === null || plugin.instanceReady === false)
    {
        throw new Error("Plugin instance not available");
    }

    this._createTextureFromPlugin(plugin);
};

/**
 * Create a texture from a plugin that provides a display object on a "texture" property.
 * @method FORGE.HotspotMaterial#_createTextureFromPlugin
 * @param {FORGE.Plugin} plugin - plugin that provides the texture.
 * @private
 */
FORGE.HotspotMaterial.prototype._createTextureFromPlugin = function(plugin)
{
    this._displayObject = plugin.instance.texture;

    this._texture = new THREE.Texture(this._displayObject.dom);
    this._texture.format = THREE.RGBAFormat;
    this._texture.minFilter = THREE.LinearFilter;
    this._texture.generateMipmaps = false;
    this._texture.needsUpdate = true;

    this.log("create texture from plugin");

    this._setupComplete();
};

/**
 * Create a hotspot material with graphical attributes.
 * @method FORGE.HotspotMaterial#_setupWithGraphics
 * @private
 * @todo Make a config to use only graphical properties
 */
FORGE.HotspotMaterial.prototype._setupWithGraphics = function()
{
    this._type = FORGE.HotspotMaterial.types.GRAPHICS;

    this._setupComplete();
};

/**
 * This is the final setup step when any of the loading or wainting instance ready process is complete.
 * @method FORGE.HotspotMaterial#_setupComplete
 * @private
 */
FORGE.HotspotMaterial.prototype._setupComplete = function()
{
    this._createShaderMaterial();

    this._ready = true;

    if (this._onReady !== null)
    {
        this._onReady.dispatch();
    }
};

/**
 * Create the THREE.MeshBasicMaterial that will be used on a THREE.Mesh
 * @method FORGE.HotspotMaterial#_createShaderMaterial
 * @private
 */
FORGE.HotspotMaterial.prototype._createShaderMaterial = function()
{
    this.log("create shader material");

    if(this._viewer.renderer.view.current === null)
    {
        return;
    }

    if (this._material !== null)
    {
        this._material.dispose();
        this._material = null;
    }

    var shader = FORGE.Utils.clone(this._viewer.renderer.view.current.shaderWTS.mapping);

    if (this._type === FORGE.HotspotMaterial.types.GRAPHICS)
    {
        shader.fragmentShader = FORGE.ShaderChunk.wts_frag_color;
        shader.uniforms.tColor = { type: "c", value: new THREE.Color(this._color) };
    }

    shader.uniforms.tOpacity = { type: "f", value: this._opacity };

    var vertexShader = FORGE.ShaderLib.parseIncludes(shader.vertexShader);
    var fragmentShader = FORGE.ShaderLib.parseIncludes(shader.fragmentShader);

    this._material = new THREE.RawShaderMaterial(
    {
        fragmentShader: fragmentShader,
        vertexShader: vertexShader,
        uniforms: /** @type {FORGEUniform} */ (shader.uniforms),
        side: this._getThreeSide(this._side),
        name: "HotspotMaterial"
    });

    this._material.transparent = this._transparent;
    this._material.needsUpdate = true;
};

/**
 * Converts the side string to the side number of Three
 * @method FORGE.HotspotMaterial#_getThreeSide
 * @param {string} [side] the string that represents the side of the material from the HotspotMaterial.sides
 * @return {number} [description]
 * @private
 */
FORGE.HotspotMaterial.prototype._getThreeSide = function(side)
{
    var result = THREE.DoubleSide; // Default is double

    switch(side)
    {
        case FORGE.HotspotMaterial.sides.FRONT:
            result = THREE.FrontSide;
            break;

        case FORGE.HotspotMaterial.sides.BACK:
            result = THREE.BackSide;
            break;

        case FORGE.HotspotMaterial.sides.DOUBLE:
            result = THREE.DoubleSide;
            break;
    }

    return result;
};

FORGE.HotspotMaterial.prototype.updateShader = function()
{
    this._createShaderMaterial();
};

/**
 * Load a material configuration
 * @method FORGE.HotspotMaterial#load
 * @param  {HotspotMaterialConfig} config - The hotspot material configuration object.
 */
FORGE.HotspotMaterial.prototype.load = function(config)
{
    this._config = config;
    this._ready = false;
    this._parseConfig(this._config);
};

/**
 * Update method taht will be called by the Hotspot.
 * @method FORGE.HotspotMaterial#update
 */
FORGE.HotspotMaterial.prototype.update = function()
{
    if (this._material && this._material.uniforms)
    {
        this._material.uniforms.tTexture.value = this._texture;
        this._material.uniforms.tOpacity.value = this._opacity;
    }

    if(this._texture !== null && this._update === true)
    {
        this._texture.needsUpdate = true;
    }
};


/**
 * Set texture frame
 * @method FORGE.HotspotMaterial#setTextureFrame
 * @param {FORGE.Rectangle=} frame - texture frame
 */
FORGE.HotspotMaterial.prototype.setTextureFrame = function(frame)
{
    // Only support type IMAGE and SPRITE
    if (this._displayObject === null || (this._type !== FORGE.HotspotMaterial.types.IMAGE && this._type !== FORGE.HotspotMaterial.types.SPRITE))
    {
        return;
    }

    var textureFrame = frame || new FORGE.Rectangle(0, 0, this._displayObject.element.naturalWidth, this._displayObject.element.naturalHeight);

    this._displayObject.frame = textureFrame;

    this._texture.image = this._displayObject.canvas;
    this._texture.image.crossOrigin = "anonymous";
    this._texture.needsUpdate = true;

    this.update();
};

/**
 * Dump the material configuration
 * @method FORGE.HotspotMaterial#dump
 * @return {HotspotMaterialConfig}
 */
FORGE.HotspotMaterial.prototype.dump = function()
{
    var dump =
    {
        color: this._color,
        opacity: this._opacity,
        transparent: this._transparent,
        side: this._side,
        update: this._update
    };

    switch(this._type)
    {
        case FORGE.HotspotMaterial.types.IMAGE:
            dump.image = this._config.image;
            break;

        case FORGE.HotspotMaterial.types.SPRITE:
            dump.sprite = this._config.sprite;
            break;

        case FORGE.HotspotMaterial.types.VIDEO:
            dump.video = this._config.video;
            break;

        case FORGE.HotspotMaterial.types.PLUGIN:
            dump.plugin = this._config.plugin;
            break;
    }

    return dump;
};

/**
 * Destroy sequence.
 * @method FORGE.HotspotMaterial#destroy
 */
FORGE.HotspotMaterial.prototype.destroy = function()
{
    if (this._texture !== null)
    {
        this._texture.dispose();
        this._texture = null;
    }

    if (this._material !== null)
    {
        this._material.dispose();
        this._material = null;
    }

    if(this._displayObject !== null)
    {
        // Don't destroy the texture from plugin.
        // Let the plugin erase its own content.
        if (this._type !== FORGE.HotspotMaterial.types.PLUGIN)
        {
            this._displayObject.destroy();
        }

        this._displayObject = null;
    }

    if(this._onReady !== null)
    {
        this._onReady.destroy();
        this._onReady = null;
    }

    this._viewer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the type of texture provider of this hotspot material.
 * @name FORGE.HotspotMaterial#type
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.HotspotMaterial.prototype, "type",
{
    /** @this {FORGE.HotspotMaterial} */
    get: function()
    {
        return this._type;
    }
});

/**
 * Get the THREE.Texture used for this hotspot material.
 * @name FORGE.HotspotMaterial#texture
 * @readonly
 * @type {THREE.Texture}
 */
Object.defineProperty(FORGE.HotspotMaterial.prototype, "texture",
{
    /** @this {FORGE.HotspotMaterial} */
    get: function()
    {
        return this._texture;
    }
});

/**
 * Get the THREE.MeshBasicMaterial used for this hotspot material.
 * @name FORGE.HotspotMaterial#material
 * @readonly
 * @type {THREE.MeshBasicMaterial}
 */
Object.defineProperty(FORGE.HotspotMaterial.prototype, "material",
{
    /** @this {FORGE.HotspotMaterial} */
    get: function()
    {
        return this._material;
    }
});

/**
 * Get the opacity of this hotspot material.
 * @name FORGE.HotspotMaterial#opacity
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.HotspotMaterial.prototype, "opacity",
{
    /** @this {FORGE.HotspotMaterial} */
    get: function()
    {
        return this._opacity;
    }
});

/**
 * Get the transparent flag of this hotspot material.
 * @name FORGE.HotspotMaterial#transparent
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.HotspotMaterial.prototype, "transparent",
{
    /** @this {FORGE.HotspotMaterial} */
    get: function()
    {
        return this._transparent;
    }
});

/**
 * Get the color of this hotspot material.
 * @name FORGE.HotspotMaterial#color
 * @readonly
 * @type {(string|number)}
 */
Object.defineProperty(FORGE.HotspotMaterial.prototype, "color",
{
    /** @this {FORGE.HotspotMaterial} */
    get: function()
    {
        return this._color;
    }
});

/**
 * Get the side of this hotspot material.
 * @name FORGE.HotspotMaterial#side
 * @readonly
 * @type {(string)}
 */
Object.defineProperty(FORGE.HotspotMaterial.prototype, "side",
{
    /** @this {FORGE.HotspotMaterial} */
    get: function()
    {
        return this._side;
    }
});

/**
 * Get the displayObject of this hotspot material.
 * @name FORGE.HotspotMaterial#displayObject
 * @readonly
 * @type {(FORGE.Image|FORGE.DisplayObject)}
 */
Object.defineProperty(FORGE.HotspotMaterial.prototype, "displayObject",
{
    /** @this {FORGE.HotspotMaterial} */
    get: function()
    {
        return this._displayObject;
    }
});

/**
 * Get the ready flag of this hotspot material.
 * @name FORGE.HotspotMaterial#ready
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.HotspotMaterial.prototype, "ready",
{
    /** @this {FORGE.HotspotMaterial} */
    get: function()
    {
        return this._ready;
    }
});

/**
 * Get the "onReady" {@link FORGE.EventDispatcher} of this hotspot material.<br/>
 * Dispatched when the material texture is loaded and ready to be used by a THREE.Texture.
 * @name FORGE.HotspotMaterial#onReady
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.HotspotMaterial.prototype, "onReady",
{
    /** @this {FORGE.HotspotMaterial} */
    get: function()
    {
        if (this._onReady === null)
        {
            this._onReady = new FORGE.EventDispatcher(this);
        }

        return this._onReady;
    }
});

/**
 * Forge Hotspot Geometry
 * @constructor FORGE.HotspotGeometry
 */
FORGE.HotspotGeometry = function()
{
    /**
     * Geometry configuration
     * @name FORGE.HotspotGeometry#_config
     * @type {HotspotGeometryConfig}
     * @private
     */
    this._config = FORGE.HotspotGeometry.DEFAULT_CONFIG;

    /**
     * The geometry type
     * @name FORGE.HotspotGeometry#_type
     * @type {string}
     * @private
     */
    this._type = "";

    /**
     * The THREE geometry object
     * @name FORGE.HotspotGeometry#_geometry
     * @type {(THREE.Geometry|THREE.PlaneBufferGeometry|THREE.BoxBufferGeometry|THREE.SphereBufferGeometry|THREE.CylinderBufferGeometry|THREE.ShapeBufferGeometry)}
     * @private
     */
    this._geometry = null;

    /**
     * The offset applied to the geometry object from it's center.<br>
     * Is expressed in world units (x, y, z).
     * @name FORGE.HotspotGeometry#_offset
     * @type {HotspotGeometryOffset}
     * @private
     */
    this._offset = FORGE.HotspotGeometry.DEFAULT_OFFSET;

    /**
     * Event dispatcher for the onLoadComplete
     * @name FORGE.HotspotGeometry#_onLoadComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;
};

/**
 * @name FORGE.HotspotGeometry.DEFAULT_CONFIG
 * @type {HotspotGeometryConfig}
 * @const
 */
FORGE.HotspotGeometry.DEFAULT_CONFIG =
{
    type: "plane",

    options:
    {
        width: 20,
        height: 20,
        widthSegments: 8,
        heightSegments: 8
    },

    offset: FORGE.HotspotGeometry.DEFAULT_OFFSET
};

/**
 * @name FORGE.HotspotGeometry.DEFAULT_OFFSET
 * @type {HotspotGeometryOffset}
 * @const
 */
FORGE.HotspotGeometry.DEFAULT_OFFSET =
{
    x: 0,
    y: 0,
    z: 0
};

/**
 * Parse the hotspot geometry config
 * @method FORGE.HotspotGeometry#_parseConfig
 * @param {HotspotGeometryConfig} config
 */
FORGE.HotspotGeometry.prototype._parseConfig = function(config)
{
    this._type = config.type;

    var options = config.options;

    this._offset = (typeof config.offset !== "undefined") ? config.offset : { x: 0, y: 0, z: 0 };

    switch (this._type)
    {
        case FORGE.HotspotGeometryType.PLANE:
            this._geometry = this._createPlane(options);
            break;

        case FORGE.HotspotGeometryType.BOX:
            this._geometry = this._createBox(options);
            break;

        case FORGE.HotspotGeometryType.SPHERE:
            this._geometry = this._createSphere(options);
            break;

        case FORGE.HotspotGeometryType.CYLINDER:
            this._geometry = this._createCylinder(options);
            break;

        case FORGE.HotspotGeometryType.SHAPE:
            this._geometry = this._createShape(options);
            break;

        default:
            this._geometry = this._createPlane(options);
            break;
    }

    // apply init offset values
    this._geometry.applyMatrix( new THREE.Matrix4().makeTranslation( this._offset.x, this._offset.y, this._offset.z ) );
};

/**
 * @method FORGE.HotspotGeometry#_createPlane
 * @param {HotspotGeometryPlane=} options
 * @return {THREE.PlaneBufferGeometry}
 * @private
 */
FORGE.HotspotGeometry.prototype._createPlane = function(options)
{
    options = options || {};

    var width = options.width || 20;
    var height = options.height || 20;
    var widthSegments = options.widthSegments || 8;
    var heightSegments = options.heightSegments || 8;

    return new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments);
};

/**
 * @method FORGE.HotspotGeometry#_createBox
 * @param {HotspotGeometryBox=} options
 * @return {THREE.BoxBufferGeometry}
 * @private
 */
FORGE.HotspotGeometry.prototype._createBox = function(options)
{
    options = options || {};

    var width = options.width || 20;
    var height = options.height || 20;
    var depth = options.depth || 20;
    var widthSegments = options.widthSegments || 8;
    var heightSegments = options.heightSegments || 8;
    var depthSegments = options.depthSegments || 8;

    return new THREE.BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments);
};

/**
 * @method FORGE.HotspotGeometry#_createSphere
 * @param {HotspotGeometrySphere=} options
 * @return {THREE.SphereBufferGeometry}
 * @private
 */
FORGE.HotspotGeometry.prototype._createSphere = function(options)
{
    options = options || {};

    var radius = options.radius || 10;
    var widthSegments = options.widthSegments || 64;
    var heightSegments = options.heightSegments || 64;
    var phiStart = options.phiStart || 0;
    var phiLength = options.phiLength || 2 * Math.PI;
    var thetaStart = options.thetaStart || 0;
    var thetaLength = options.thetaLength || 2 * Math.PI;

    return new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);
};

/**
 * @method FORGE.HotspotGeometry#_createCylinder
 * @param {HotspotGeometryCylinder=} options
 * @return {THREE.CylinderBufferGeometry}
 * @private
 */
FORGE.HotspotGeometry.prototype._createCylinder = function(options)
{
    options = options || {};

    var radiusTop = options.radiusTop || 10;
    var radiusBottom = options.radiusBottom || 10;
    var height = options.height || 20;
    var radiusSegments = options.radiusSegments || 32;
    var heightSegments = options.heightSegments || 1;
    var openEnded = options.openEnded || false;
    var thetaStart = options.thetaStart || 0;
    var thetaLength = options.thetaLength || 2 * Math.PI;

    return new THREE.CylinderBufferGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded, thetaStart, thetaLength);
};

/**
 * @method FORGE.HotspotGeometry#_createShape
 * @param {HotspotGeometryShape=} options
 * @return {THREE.ShapeBufferGeometry}
 * @private
 */
FORGE.HotspotGeometry.prototype._createShape = function(options)
{
    options = options || {};

    // clean the points given to remove any duplicate when points are following each other
    if (Array.isArray(options.points))
    {
        options.points.push(options.points[0]);

        var a, b, res = [];
        for (var i = 0, ii = options.points.length - 1; i < ii; i++)
        {
            a = options.points[i];
            b = options.points[i + 1];

            if (a[0] !== b[0] || a[1] !== b[1])
            {
                res.push(a);
            }
        }

        options.points = res;

        if (options.points.length < 3)
        {
            console.warn("FORGE.HotspotGeometry.SHAPE: the points given to draw the shape should be a least 3");
            options.points = null;
        }
    }

    //Default points array that is a square
    if (Array.isArray(options.points) === false)
    {
        //Arrow shape
        options.points =
        [
            [ -10, 3 ],
            [ 3, 3 ],
            [ 3, 8 ],
            [ 15, 0 ],
            [ 3, -8 ],
            [ 3, -3 ],
            [ -10, -3 ]
        ];
    }

    var points = [];
    for (var i = 0, ii = options.points.length; i < ii; i++)
    {
        var point = options.points[i];
        var x, y;

        if(Array.isArray(point) === true)
        {
            x = (typeof point[0] === "number" && isNaN(point[0]) === false) ? point[0] : 0;
            y = (typeof point[1] === "number" && isNaN(point[1]) === false) ? point[1] : 0;
            points.push(new THREE.Vector2(x, y));
        }
    }

    return new THREE.ShapeBufferGeometry(new THREE.Shape(points));
};

/**
 * Load a hotspot geometry config
 * @method FORGE.HotspotGeometry#load
 * @param {HotspotGeometryConfig} config
 */
FORGE.HotspotGeometry.prototype.load = function(config)
{
    if (typeof config !== "undefined" && typeof config.type === "string")
    {
        this._config = config;
    }
    else
    {
        this._config = /** @type {HotspotGeometryConfig} */ (FORGE.Utils.extendSimpleObject({}, FORGE.HotspotGeometry.DEFAULT_CONFIG));
    }

    this._parseConfig(this._config);

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.dispatch();
    }
};

/**
 * Dump the geometry configuration
 * @method FORGE.HotspotGeometry#dump
 * @return {HotspotGeometryConfig} Return the actual hotspot geometry config
 */
FORGE.HotspotGeometry.prototype.dump = function()
{
    var dump =
    {
        type: this._type
    };

    var options = {};

    switch(this._type)
    {
        case FORGE.HotspotGeometryType.PLANE:
        case FORGE.HotspotGeometryType.BOX:
        case FORGE.HotspotGeometryType.SPHERE:
        case FORGE.HotspotGeometryType.CYLINDER:
            options = this._geometry.parameters;
            break;

        case FORGE.HotspotGeometryType.SHAPE:

            var points = [];
            if(Array.isArray(this._geometry.parameters.shapes.curves) === true)
            {
                var c = this._geometry.parameters.shapes.curves;

                points.push([c[0].v1.x, c[0].v1.y]);
                points.push([c[0].v2.x, c[0].v2.y]);

                for(var i = 1, ii = c.length; i < ii; i++)
                {
                    points.push([c[i].v2.x, c[i].v2.y]);
                }
            }
            else
            {
                points = this._config.options.points;
            }

            options = { points: points };

            break;
    }

    dump.options = options;

    return dump;
};

/**
 * Destroy sequence
 * @method FORGE.HotspotGeometry#destroy
 */
FORGE.HotspotGeometry.prototype.destroy = function()
{
    if(this._geometry !== null)
    {
        this._geometry.dispose();
        this._geometry = null;
    }

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }
};

/**
 * Geometry type accessor
 * @name FORGE.HotspotGeometry#type
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.HotspotGeometry.prototype, "type",
{
    /** @this {FORGE.HotspotGeometry} */
    get: function()
    {
        return this._type;
    }
});

/**
 * Geometry accessor
 * @name FORGE.HotspotGeometry#geometry
 * @readonly
 * @type {THREE.Geometry}
 */
Object.defineProperty(FORGE.HotspotGeometry.prototype, "geometry",
{
    /** @this {FORGE.HotspotGeometry} */
    get: function()
    {
        return this._geometry;
    }
});

/**
 * Get the onLoadComplete {@link FORGE.EventDispatcher}.
 * @name  FORGE.HotspotGeometry#onLoadComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.HotspotGeometry.prototype, "onLoadComplete",
{
    /** @this {FORGE.HotspotGeometry} */
    get: function()
    {
        if (this._onLoadComplete === null)
        {
            this._onLoadComplete = new FORGE.EventDispatcher(this);
        }

        return this._onLoadComplete;
    }
});

/**
 * Get/set the offset of the geomerty object.<br>
 * The current offset is updated with these values and don't erase the init offset.
 * @name FORGE.HotspotGeometry#offset
 * @type {HotspotGeometryOffset}
 */
Object.defineProperty(FORGE.HotspotGeometry.prototype, "offset",
{
    /** @this {FORGE.HotspotGeometry} */
    get: function()
    {
        return this._offset;
    },

    /** @this {FORGE.HotspotGeometry} */
    set: function(value)
    {
        if (typeof value !== "undefined" && (typeof value.x === "number" || typeof value.y === "number" || typeof value.z === "number"))
        {
            var offset = /** @type {HotspotGeometryOffset} */ (FORGE.Utils.extendSimpleObject(FORGE.HotspotGeometry.DEFAULT_OFFSET, value));
            this._geometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );

            // update current offset values
            this._offset.x += offset.x;
            this._offset.y += offset.y;
            this._offset.z += offset.z;
        }
    }
});
/**
 * @namespace {Object} FORGE.HotspotGeometryType
 */
FORGE.HotspotGeometryType = {};

/**
 * @name FORGE.HotspotGeometryType.PLANE
 * @type {string}
 * @const
 */
FORGE.HotspotGeometryType.PLANE = "plane";

/**
 * @name FORGE.HotspotGeometryType.BOX
 * @type {string}
 * @const
 */
FORGE.HotspotGeometryType.BOX = "box";

/**
 * @name FORGE.HotspotGeometryType.SPHERE
 * @type {string}
 * @const
 */
FORGE.HotspotGeometryType.SPHERE = "sphere";

/**
 * @name FORGE.HotspotGeometryType.CYLINDER
 * @type {string}
 * @const
 */
FORGE.HotspotGeometryType.CYLINDER = "cylinder";

/**
 * @name FORGE.HotspotGeometryType.SHAPE
 * @type {string}
 * @const
 */
FORGE.HotspotGeometryType.SHAPE = "shape";


/**
 * HotspotTransform handle the parsing of the position, rotation and scale of a 3d Hotspot.
 *
 * @constructor FORGE.HotspotTransform
 * @extends {FORGE.BaseObject}
 */
FORGE.HotspotTransform = function()
{
    /**
     * The cartesian coordinates of a 3D object (x, y, z).
     * @name FORGE.HotspotTransform#_position
     * @type {FORGE.HotspotTransformValues}
     * @private
     */
    this._position = null;

    /**
     * The rotation of a 3D object (x, y, z).
     * @name FORGE.HotspotTransform#_rotation
     * @type {FORGE.HotspotTransformValues}
     * @private
     */
    this._rotation = null;

    /**
     * The scale of a 3D object.<br>
     * Is expressed in world units (x, y, z).
     * @name FORGE.HotspotTransform#_scale
     * @type {FORGE.HotspotTransformValues}
     * @private
     */
    this._scale = null;

    /**
     * onChange event dispatcher for transform change.
     * @name  FORGE.HotspotTransform#_onChange
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onChange = null;

    FORGE.BaseObject.call(this, "HotspotTransform");

    this._boot();
};

FORGE.HotspotTransform.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.HotspotTransform.prototype.constructor = FORGE.HotspotTransform;

/**
 * Init HotspotTransform.
 * @method  FORGE.HotspotTransform#_boot
 * @private
 */
FORGE.HotspotTransform.prototype._boot = function()
{
    this._register();

    this._position = new FORGE.HotspotTransformValues(this._uid, 0, 0, -200);
    this._rotation = new FORGE.HotspotTransformValues(this._uid, 0, 0, 0);
    this._scale = new FORGE.HotspotTransformValues(this._uid, 1, 1, 1);
};

/**
 * Parse the config object, set default values where values are undefined.
 * @method FORGE.HotspotTransform#_parseConfig
 * @param {HotspotTransformConfig} config - The transform config to parse.
 * @return {boolean} return true if one of the values has changed
 * @private
 */
FORGE.HotspotTransform.prototype._parseConfig = function(config)
{
    var changed = false;

    if (typeof config.position !== "undefined")
    {
        var position = FORGE.Utils.extendSimpleObject(this._position.dump(), this._parsePosition(config.position));

        if (FORGE.Utils.compareObjects(this._position.dump(), position) === false)
        {
            this._position.load(/** @type {HotspotTransformValuesConfig} */ (position), false);
            changed = true;
        }
    }

    if (typeof config.rotation !== "undefined")
    {
        var rotation = FORGE.Utils.extendSimpleObject({}, this._rotation.dump());

        rotation.x = (typeof config.rotation.x === "number") ? config.rotation.x : 0;
        rotation.y = (typeof config.rotation.y === "number") ? config.rotation.y : 0;
        rotation.z = (typeof config.rotation.z === "number") ? config.rotation.z : 0;

        if (FORGE.Utils.compareObjects(this._rotation.dump(), rotation) === false)
        {
            this._rotation.load(/** @type {HotspotTransformValuesConfig} */ (rotation), false);
            changed = true;
        }
    }

    if (typeof config.scale !== "undefined")
    {
        var scale = FORGE.Utils.extendSimpleObject({}, this._scale.dump());

        scale.x = (typeof config.scale.x === "number") ? FORGE.Math.clamp(config.scale.x, 0.000001, 100000) : 1;
        scale.y = (typeof config.scale.y === "number") ? FORGE.Math.clamp(config.scale.y, 0.000001, 100000) : 1;
        scale.z = (typeof config.scale.z === "number") ? FORGE.Math.clamp(config.scale.z, 0.000001, 100000) : 1;

        if (FORGE.Utils.compareObjects(this._scale.dump(), scale) === false)
        {
            this._scale.load(/** @type {HotspotTransformValuesConfig} */ (scale), false);
            changed = true;
        }
    }

    return changed;
};

/**
 * Parse the position object.
 * @method FORGE.HotspotTransform#_parsePosition
 * @param {HotspotTransformPosition} config - The transform position config to parse.
 * @private
 */
FORGE.HotspotTransform.prototype._parsePosition = function(config)
{
    var position =
    {
        x: 0,
        y: 0,
        z: -200
    };

    if (typeof config !== "undefined" && config !== null)
    {
        if (typeof config.radius === "number" || typeof config.theta === "number" || typeof config.phi === "number")
        {
            var radius = (typeof config.radius === "number") ? config.radius : 200;
            var theta = (typeof config.theta === "number") ? FORGE.Math.degToRad(config.theta) : 0;
            var phi = (typeof config.phi === "number") ? FORGE.Math.degToRad(config.phi) : 0;

            position = FORGE.Math.sphericalToCartesian(radius, theta, phi);
        }
        else
        {
            position.x = (typeof config.x === "number") ? config.x : 0;
            position.y = (typeof config.y === "number") ? config.y : 0;
            position.z = (typeof config.z === "number") ? config.z : -200;
        }
    }

    return position;
};

/**
 * Update all the transform values from the mesh.
 * @method FORGE.HotspotTransform#updateFromObject3D
 * @param {THREE.Object3D} object - The 3D object to read data from.
 */
FORGE.HotspotTransform.prototype.updateFromObject3D = function(object)
{
    this._position.load(object.position);

    var rotation =
    {
        x: -FORGE.Math.radToDeg(object.rotation.x),
        y: FORGE.Math.radToDeg(object.rotation.y),
        z: FORGE.Math.radToDeg(object.rotation.z)
    };

    this._rotation.load(rotation);

    this._scale.load(object.scale);
};

/**
 * Notify the transform that a value has changed.
 * @method FORGE.HotspotTransform#notifyChange
 */
FORGE.HotspotTransform.prototype.notifyChange = function()
{
    if(this._onChange !== null)
    {
        this._onChange.dispatch();
    }
};


/**
 * Load a transform configuration.
 * @method FORGE.HotspotTransform#load
 * @param {HotspotTransformConfig} config - The transform config to load.
 * @param {boolean} [notify=true] - Do we have to notify the change of the transform after the config loading
 */
FORGE.HotspotTransform.prototype.load = function(config, notify)
{
    var changed = this._parseConfig(config);

    if (notify !== false && changed === true)
    {
        this.notifyChange();
    }
};

/**
 * Dump the transform actual configuration
 * @method FORGE.HotspotTransform#dump
 * @return {HotspotTransformConfig} Return the hotspot transform configuration
 */
FORGE.HotspotTransform.prototype.dump = function()
{
    var dump =
    {
        position: this._position.dump(),
        rotation: this._rotation.dump(),
        scale: this._scale.dump()
    };

    return dump;
};

/**
 * Destroy sequence.
 * @method FORGE.HotspotTransform#destroy
 */
FORGE.HotspotTransform.prototype.destroy = function()
{
    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get/set the spherical position of the transform object
 * @name FORGE.HotspotTransform#position
 * @type {HotspotTransformPosition}
 */
Object.defineProperty(FORGE.HotspotTransform.prototype, "position",
{
    /** @this {FORGE.HotspotTransform} */
    get: function()
    {
        return this._position;
    },

    /** @this {FORGE.HotspotTransform} */
    set: function(value)
    {
        var config = { position: value };
        this._parseConfig(config);
    }
});

/**
 * Get/set the rotation of the transform object
 * @name FORGE.HotspotTransform#rotation
 * @type {HotspotTransformRotation}
 */
Object.defineProperty(FORGE.HotspotTransform.prototype, "rotation",
{
    /** @this {FORGE.HotspotTransform} */
    get: function()
    {
        return this._rotation;
    },

    /** @this {FORGE.HotspotTransform} */
    set: function(value)
    {
        var config = { rotation: value };
        this._parseConfig(config);
    }
});

/**
 * Get/set the scale of the transform object
 * @name FORGE.HotspotTransform#scale
 * @type {HotspotTransformScale}
 */
Object.defineProperty(FORGE.HotspotTransform.prototype, "scale",
{
    /** @this {FORGE.HotspotTransform} */
    get: function()
    {
        return this._scale;
    },

    /** @this {FORGE.HotspotTransform} */
    set: function(value)
    {
        var config = { scale: value };
        this._parseConfig(config);
    }
});

/**
 * Get the onChange {@link FORGE.EventDispatcher}.
 * @name FORGE.HotspotTransform#onChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.HotspotTransform.prototype, "onChange",
{
    /** @this {FORGE.HotspotTransform} */
    get: function()
    {
        if (this._onChange === null)
        {
            this._onChange = new FORGE.EventDispatcher(this);
        }

        return this._onChange;
    }
});

/**
 * HotspotTransformValues handle the three values x, y and z.
 *
 * @constructor FORGE.HotspotTransformValues
 * @param {number} x - The spherical coordinates of a 3D object (radius, theta, phi)
 * @param {number} y - The rotation of a 3D object (x, y, z).
 * @param {number} z - The scale of a 3D object (x, y, z).
 */
FORGE.HotspotTransformValues = function(transformUid, x, y, z)
{
    /**
     * The transformation related to this values.
     * @name FORGE.HotspotTransformValues#_transformUid
     * @type {string}
     * @private
     */
    this._transformUid = transformUid;

    /**
     * The x.
     * @name FORGE.HotspotTransformValues#_x
     * @type {number}
     * @private
     */
    this._x = typeof(x) === "number" ? x : 0;

    /**
     * The y.
     * @name FORGE.HotspotTransformValues#_y
     * @type {number}
     * @private
     */
    this._y = typeof(y) === "number" ? y : 0;

    /**
     * The z.
     * @name FORGE.HotspotTransformValues#_z
     * @type {number}
     * @private
     */
    this._z = typeof(z) === "number" ? z : 0;

    /**
     * onChange event dispatcher for transform values change.
     * @name  FORGE.HotspotTransformValues#_onChange
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onChange = null;
};

/**
 * Load values.
 * @method FORGE.HotspotTransformValues#load
 * @param {HotspotTransformValuesConfig} values
 * @param {boolean} [notify=true] - Do we notify the transform object after the load ?
 * @return {boolean} Returns if any value has changed.
 */
FORGE.HotspotTransformValues.prototype.load = function(values, notify)
{
    var changed = false;

    if(typeof values.x === "number" && isNaN(values.x) === false && this._x !== values.x)
    {
        this._x = values.x;
        changed = true;
    }

    if(typeof values.y === "number" && isNaN(values.y) === false && this._y !== values.y)
    {
        this._y = values.y;
        changed = true;
    }

    if(typeof values.z === "number" && isNaN(values.z) === false && this._z !== values.z)
    {
        this._z = values.z;
        changed = true;
    }

    if(notify !== false && changed === true)
    {
        if(this._onChange !== null)
        {
            this._onChange.dispatch();
        }

        var transform = FORGE.UID.get(this._transformUid);
        transform.notifyChange();
    }

    return changed;
};

/**
 * Dump values.
 * @method FORGE.HotspotTransformValues#dump
 * @return {HotspotTransformValuesConfig}
 */
FORGE.HotspotTransformValues.prototype.dump = function()
{
    var dump =
    {
        x: this._x,
        y: this._y,
        z: this._z
    };

    return dump;
};

/**
 * Destroy sequence.
 * @method FORGE.HotspotTransformValues#destroy
 */
FORGE.HotspotTransformValues.prototype.destroy = function()
{
    if(this._onChange !== null)
    {
        this._onChange.destroy();
        this._onChange = null;
    }
};

/**
 * Get/set the x value
 * @name FORGE.HotspotTransformValues#x
 * @type {number}
 */
Object.defineProperty(FORGE.HotspotTransformValues.prototype, "x",
{
    /** @this {FORGE.HotspotTransformValues} */
    get: function()
    {
        return this._x;
    },

    /** @this {FORGE.HotspotTransformValues} */
    set: function(value)
    {
        if(typeof value !== "number" || isNaN(value) === true || this._x === value)
        {
            return;
        }

        this._x = value;

        if(this._onChange !== null)
        {
            this._onChange.dispatch();
        }

        var transform = FORGE.UID.get(this._transformUid);
        transform.notifyChange();
    }
});

/**
 * Get/set the y value
 * @name FORGE.HotspotTransformValues#y
 * @type {number}
 */
Object.defineProperty(FORGE.HotspotTransformValues.prototype, "y",
{
    /** @this {FORGE.HotspotTransformValues} */
    get: function()
    {
        return this._y;
    },

    /** @this {FORGE.HotspotTransformValues} */
    set: function(value)
    {
        if(typeof value !== "number" || isNaN(value) === true || this._y === value)
        {
            return;
        }

        this._y = value;

        if(this._onChange !== null)
        {
            this._onChange.dispatch();
        }

        var transform = FORGE.UID.get(this._transformUid);
        transform.notifyChange();
    }
});

/**
 * Get/set the x value
 * @name FORGE.HotspotTransformValues#x
 * @type {number}
 */
Object.defineProperty(FORGE.HotspotTransformValues.prototype, "z",
{
    /** @this {FORGE.HotspotTransformValues} */
    get: function()
    {
        return this._z;
    },

    /** @this {FORGE.HotspotTransformValues} */
    set: function(value)
    {
        if(typeof value !== "number" || isNaN(value) === true || this._z === value)
        {
            return;
        }

        this._z = value;

        if(this._onChange !== null)
        {
            this._onChange.dispatch();
        }

        var transform = FORGE.UID.get(this._transformUid);
        transform.notifyChange();
    }
});

/**
 * Get the vector representing the values
 * @name FORGE.HotspotTransformValues#values
 * @type {THREE.Vector3}
 */
Object.defineProperty(FORGE.HotspotTransformValues.prototype, "values",
{
    /** @this {FORGE.HotspotTransformValues} */
    get: function()
    {
        return new THREE.Vector3(this._x, this._y, this._z);
    }
});

/**
 * Get the onChange {@link FORGE.EventDispatcher}.
 * @name FORGE.HotspotTransformValues#onChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.HotspotTransformValues.prototype, "onChange",
{
    /** @this {FORGE.HotspotTransformValues} */
    get: function()
    {
        if (this._onChange === null)
        {
            this._onChange = new FORGE.EventDispatcher(this);
        }

        return this._onChange;
    }
});

/**
 * A FORGE.HotspotAnimation is used to animate a hotspot.
 *
 * @constructor FORGE.HotspotAnimation
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference
 * @param {FORGE.HotspotTransform} hotspotTransform - {@link FORGE.HotspotTransform} reference
 * @extends {FORGE.MetaAnimation}
 */
FORGE.HotspotAnimation = function(viewer, hotspotTransform)
{
    /**
     * The UID of the selected track.
     * @name FORGE.HotspotAnimation#_track
     * @type {string}
     * @private
     */
    this._track = "";

    /**
     * The list of the tracks composing the animation
     * @name FORGE.HotspotAnimation#_track
     * @type {?Array<string>}
     * @private
     */
    this._tracks = null;

    /**
     * Does the animation loop ?
     * @name FORGE.HotspotAnimation#_loop
     * @type {boolean}
     * @private
     */
    this._loop = false;

    /**
     * Does the animation randomized ?
     * @name FORGE.HotspotAnimation#_random
     * @type {boolean}
     * @private
     */
    this._random = false;

    /**
     * Does the animation auto play ?
     * @name FORGE.HotspotAnimation#_autoPlay
     * @type {boolean}
     * @private
     */
    this._autoPlay = false;

    /**
     * Enabled flag
     * @name FORGE.HotspotAnimation#_autoPlay
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * On animation progress event dispatcher.
     * @name FORGE.HotspotAnimation#_onProgress
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onProgress = null;

    FORGE.MetaAnimation.call(this, viewer, hotspotTransform, "HotspotAnimation");
    this._boot();
};

FORGE.HotspotAnimation.prototype = Object.create(FORGE.MetaAnimation.prototype);
FORGE.HotspotAnimation.prototype.constructor = FORGE.HotspotAnimation;

/**
 * Boot sequence
 *
 * @method FORGE.HotspotAnimation#_boot
 * @private
 */
FORGE.HotspotAnimation.prototype._boot = function()
{
    this._instructions =
    [
        {
            prop: [ "rotation.x", "rotation.y", "rotation.z" ],
            wrap: [ [-180, 180], [-180, 180], [-180, 180] ],
            smooth: false
        },
        {
            prop: [ "position.x", "position.y", "position.z" ],
            smooth: false
        },
        {
            prop: [ "scale.x", "scale.y", "scale.z" ],
            smooth: false
        }
    ];
};

/**
 * Load an animation configuration.
 *
 * @method FORGE.HotspotAnimation#load
 * @param {HotspotTrackConfig} config - The animation config to load.
 */
FORGE.HotspotAnimation.prototype.load = function(config)
{
    this.stop(); // Stop current aimation if any in all cases.

    this._enabled = (typeof config.enabled === "boolean") ? config.enabled : true;
    this._loop = (typeof config.loop === "boolean") ? config.loop : false;
    this._random = (typeof config.random === "boolean") ? config.random : false;
    this._autoPlay = (typeof config.autoPlay === "boolean") ? config.autoPlay : false;

    if (config.tracks !== null && FORGE.Utils.isArrayOf(config.tracks, "string"))
    {
        // If it is random, mix it here
        this._tracks = (this._random === true) ? FORGE.Utils.randomize(config.tracks) : config.tracks;
    }
};

/**
 * On track complete event handler
 *
 * @method FORGE.HotspotAnimation#_onTrackPartialCompleteHandler
 * @private
 */
FORGE.HotspotAnimation.prototype._onTrackPartialCompleteHandler = function()
{
    if (this._tracks.length > 1)
    {
        // Go to the next track if any
        var idx = this._tracks.indexOf( /** @type {string} */ (this._track)) + 1;

        // If the index is too high, play the track
        if (idx < this._tracks.length)
        {
            this.play(idx);
            return;
        }
    }

    // Loop only if it is the end of the last track
    if (this._loop === true)
    {
        // If it is random, change the entire order
        if (this._random === true)
        {
            this._tracks = FORGE.Utils.randomize(this._tracks);
        }

        this.play(0);
        return;
    }

    FORGE.MetaAnimation.prototype._onTrackPartialCompleteHandler.call(this);
};

/**
 * On tween progress event handler.
 *
 * @method FORGE.HotspotAnimation#_onTweenProgressHandler
 * @private
 */
FORGE.HotspotAnimation.prototype._onTweenProgressHandler = function()
{
    if (this._onProgress !== null)
    {
        this._onProgress.dispatch();
    }
};

/**
 * Play a set of tracks if specified, else the current one, from the start.
 *
 * @method FORGE.HotspotAnimation#play
 * @param {(string|number)=} track - A track
 */
FORGE.HotspotAnimation.prototype.play = function(track)
{
    if(this._enabled === false)
    {
        return;
    }

    if (typeof track === "number")
    {
        this._track = this._tracks[track];
    }
    else if (typeof track === "string")
    {
        this._track = track;
    }
    else
    {
        this._track = this._tracks[0];
    }

    track = FORGE.UID.get(this._track);

    this._emptyAnimations();

    var kf;
    var offset = track.offset;

    // First instruction - rotation
    var rotAnimation = new FORGE.Animation(this._viewer, this._target);
    rotAnimation.tween.easing = track.easing;
    rotAnimation.instruction = this._instructions[0];
    rotAnimation.instruction.smooth = track.smooth;
    rotAnimation.onComplete.add(this._onTrackPartialCompleteHandler, this);
    rotAnimation.onProgress.add(this._onTweenProgressHandler, this);

    var rot, x, y, z, time;

    for (var i = 0, ii = track.keyframes.length; i < ii; i++)
    {
        time = track.keyframes[i].time + offset;
        rot = track.keyframes[i].data.rotation;

        if (typeof rot !== "undefined" && rot !== null)
        {
            x = (typeof rot.x !== "undefined" && rot.x !== null) ? rot.x : this._computeIntermediateValue(time, track.keyframes, "x", rotAnimation.tween.easing, "rotation");
            y = (typeof rot.y !== "undefined" && rot.y !== null) ? rot.y : this._computeIntermediateValue(time, track.keyframes, "y", rotAnimation.tween.easing, "rotation");
            z = (typeof rot.z !== "undefined" && rot.z !== null) ? rot.z : this._computeIntermediateValue(time, track.keyframes, "z", rotAnimation.tween.easing, "rotation");

            kf = new FORGE.Keyframe(time + offset,
            {
                rotation:
                {
                    x: x,
                    y: y,
                    z: z
                }
            });

            rotAnimation.timeline.addKeyframe(kf);
        }
    }

    // If the first keyframe is not at time 0 or there is an offset, add a
    // virtual keyframe
    if (rotAnimation.timeline.keyframes.length > 0 && rotAnimation.timeline.keyframes[0].time > 0 || offset > 0)
    {
        var data = { rotation: FORGE.Utils.clone(this._target.rotation) };
        kf = new FORGE.Keyframe(0, data);
        rotAnimation.timeline.addKeyframe(kf);
    }

    this._animations.push(rotAnimation);

    // Second instruction - position
    var posAnimation = new FORGE.Animation(this._viewer, this._target);
    posAnimation.tween.easing = track.easing;
    posAnimation.instruction = this._instructions[1];
    posAnimation.instruction.smooth = track.smooth;
    posAnimation.onComplete.add(this._onTrackPartialCompleteHandler, this);
    posAnimation.onProgress.add(this._onTweenProgressHandler, this);

    var pos;

    for (var i = 0, ii = track.keyframes.length; i < ii; i++)
    {
        time = track.keyframes[i].time + offset;
        pos = track.keyframes[i].data.position;

        if (typeof pos !== "undefined" && pos !== null)
        {
            // If no x/y/z are defined, AND there is at least one radius/theta/phi, convert it to x/y/z
            if (typeof pos.x !== "number" && typeof pos.y !== "number" && typeof pos.z !== "number" && (typeof pos.radius === "number" || typeof pos.theta === "number" || typeof pos.phi === "number"))
            {
                var radius = (typeof pos.radius === "number") ? pos.radius : this._computeIntermediateValue(time, track.keyframes, "radius", posAnimation.tween.easing, "position");
                var theta = (typeof pos.theta === "number") ? FORGE.Math.degToRad(pos.theta) : FORGE.Math.degToRad(this._computeIntermediateValue(time, track.keyframes, "theta", posAnimation.tween.easing, "position"));
                var phi = (typeof pos.phi === "number") ? FORGE.Math.degToRad(pos.phi) : FORGE.Math.degToRad(this._computeIntermediateValue(time, track.keyframes, "phi", posAnimation.tween.easing, "position"));

                var cartesian = FORGE.Math.sphericalToCartesian(radius, theta, phi);

                x = cartesian.x;
                y = cartesian.y;
                z = cartesian.z;
            }
            else
            {

                x = (typeof pos.x !== "undefined" && pos.x !== null) ? pos.x : this._computeIntermediateValue(time, track.keyframes, "x", posAnimation.tween.easing, "position");
                y = (typeof pos.y !== "undefined" && pos.y !== null) ? pos.y : this._computeIntermediateValue(time, track.keyframes, "y", posAnimation.tween.easing, "position");
                z = (typeof pos.z !== "undefined" && pos.z !== null) ? pos.z : this._computeIntermediateValue(time, track.keyframes, "z", posAnimation.tween.easing, "position");
            }

            kf = new FORGE.Keyframe(time + offset,
            {
                position:
                {
                    x: x,
                    y: y,
                    z: z
                }
            });

            posAnimation.timeline.addKeyframe(kf);
        }
    }

    // If the first keyframe is not at time 0 or there is an offset, add a
    // virtual keyframe
    if (posAnimation.timeline.keyframes.length > 0 && posAnimation.timeline.keyframes[0].time > 0 || offset > 0)
    {
        var data = { position: FORGE.Utils.clone(this._target.position) };
        kf = new FORGE.Keyframe(0, data);
        posAnimation.timeline.addKeyframe(kf);
    }

    this._animations.push(posAnimation);

    // Third animation - scale
    var scaleAnimation = new FORGE.Animation(this._viewer, this._target);
    scaleAnimation.tween.easing = track.easing;
    scaleAnimation.instruction = this._instructions[2];
    scaleAnimation.instruction.smooth = track.smooth;
    scaleAnimation.onComplete.add(this._onTrackPartialCompleteHandler, this);
    scaleAnimation.onProgress.add(this._onTweenProgressHandler, this);

    var scale;

    for (var i = 0, ii = track.keyframes.length; i < ii; i++)
    {
        time = track.keyframes[i].time + offset;
        scale = track.keyframes[i].data.scale;

        if (typeof scale !== "undefined" && scale !== null)
        {
            x = (typeof scale.x !== "undefined" && scale.x !== null) ? scale.x : this._computeIntermediateValue(time, track.keyframes, "x", scaleAnimation.tween.easing, "scale");
            y = (typeof scale.y !== "undefined" && scale.y !== null) ? scale.y : this._computeIntermediateValue(time, track.keyframes, "y", scaleAnimation.tween.easing, "scale");
            z = (typeof scale.z !== "undefined" && scale.z !== null) ? scale.z : this._computeIntermediateValue(time, track.keyframes, "z", scaleAnimation.tween.easing, "scale");

            kf = new FORGE.Keyframe(time + offset,
            {
                scale:
                {
                    x: x,
                    y: y,
                    z: z
                }
            });

            scaleAnimation.timeline.addKeyframe(kf);
        }
    }

    // If the first keyframe is not at time 0 or there is an offset, add a
    // virtual keyframe
    if (scaleAnimation.timeline.keyframes.length > 0 && scaleAnimation.timeline.keyframes[0].time > 0 || offset > 0)
    {
        var data = { scale: FORGE.Utils.clone(this._target.scale) };
        kf = new FORGE.Keyframe(0, data);
        scaleAnimation.timeline.addKeyframe(kf);
    }

    this._animations.push(scaleAnimation);

    // Play it !
    this._animations[0].play();
    this._animations[1].play();
    this._animations[2].play();
};

/**
 * Destroy sequence.
 * @method FORGE.HotspotAnimation#destroy
 */
FORGE.HotspotAnimation.prototype.destroy = function()
{
    this._tracks = null;

    if (this._onProgress !== null)
    {
        this._onProgress.destroy();
        this._onProgress = null;
    }

    FORGE.MetaAnimation.prototype.destroy.call(this);
};

/**
 * Enabled flag.
 * @name FORGE.HotspotAnimation#enabled
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.HotspotAnimation.prototype, "enabled",
{
    /** @this {FORGE.HotspotAnimation} */
    get: function()
    {
        return this._enabled;
    }
});

/**
 * Does the animation auto play.
 * @name FORGE.HotspotAnimation#autoPlay
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.HotspotAnimation.prototype, "autoPlay",
{
    /** @this {FORGE.HotspotAnimation} */
    get: function()
    {
        return this._autoPlay;
    }
});

/**
 * Get the "onProgress" {@link FORGE.EventDispatcher} of the target.
 * @name FORGE.HotspotAnimation#onProgress
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.HotspotAnimation.prototype, "onProgress",
{
    /** @this {FORGE.HotspotAnimation} */
    get: function()
    {
        if (this._onProgress === null)
        {
            this._onProgress = new FORGE.EventDispatcher(this);
        }

        return this._onProgress;
    }
});

/**
 * A director track, that defines a camera animation.
 *
 * @constructor FORGE.HotspotAnimationTrack
 * @param {HotspotTrackConfig} config - Configuration of the track from the JSON file.
 * @extends {FORGE.Track}
 */
FORGE.HotspotAnimationTrack = function(config)
{
    /**
     * Does the track has a smooth interpolation between keyframes ?
     * @name FORGE.HotspotAnimationTrack#_smooth
     * @type {boolean}
     * @private
     */
    this._smooth = false;

    FORGE.Track.call(this, "HotspotAnimationTrack");

    this._boot(config);
};

FORGE.HotspotAnimationTrack.prototype = Object.create(FORGE.Track.prototype);
FORGE.HotspotAnimationTrack.prototype.constructor = FORGE.HotspotAnimationTrack;

/**
 * Boot sequence
 *
 * @method FORGE.HotspotAnimationTrack#_boot
 * @param  {Object} config - The information on the track
 * @private
 */
FORGE.HotspotAnimationTrack.prototype._boot = function(config)
{
    this._smooth = config.smooth;

    FORGE.Track.prototype._boot.call(this, config);
};
/**
 * Hotspot states
 *
 * @constructor FORGE.HotspotStates
 * @param {FORGE.Viewer} viewer - The viewer reference.
 * @param {string} hotspotUid - The hotspot uid
 * @extends {FORGE.BaseObject}
 */
FORGE.HotspotStates = function(viewer, hotspotUid)
{
    /**
     * Viewer reference.
     * @name  FORGE.HotspotStates#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The hotspot uid
     * @name FORGE.HotspotStates#_hotspotUid
     * @type {string}
     * @private
     */
    this._hotspotUid = hotspotUid;

    /**
     * Hotspot material config
     * @name FORGE.HotspotStates#_config
     * @type {?HotspotStatesConfig}
     * @private
     */
    this._config = null;

    /**
     * The current state name
     * @name FORGE.HotspotStates#_state
     * @type {string}
     * @private
     */
    this._state = "";

    /**
     * Default state
     * @name FORGE.HotspotStates#_default
     * @type {string}
     * @private
     */
    this._default = "default";

    /**
     * Does the states change automatically on interactive 3d objects?
     * @name FORGE.HotspotStates#_auto
     * @type {boolean}
     * @private
     */
    this._auto = true;

    /**
     * Ready flag
     * @name FORGE.HotspotStates#_ready
     * @type {boolean}
     * @private
     */
    this._ready = false;

    /**
     * Loading flags
     * @name FORGE.HotspotStates#_loading
     * @type {Object}
     * @private
     */
    this._loading =
    {
        geometry: false,
        transform: false,
        material: false,
        sound: false,
        animation: false
    };

    /**
     * Load complete event dispatcher for state change.
     * @name  FORGE.HotspotStates#_onLoadComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;

    FORGE.BaseObject.call(this, "HotspotStates");

    this._boot();
};

FORGE.HotspotStates.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.HotspotStates.prototype.constructor = FORGE.HotspotStates;

/**
 * List of reserved keyword for states names.
 * @name FORGE.HotspotStates._RESERVED
 * @type {Array<string>}
 * @const
 * @private
 */
FORGE.HotspotStates._RESERVED = ["options"];

/**
 * Boot method.
 * @method FORGE.HotspotStates#_boot
 * @private
 */
FORGE.HotspotStates.prototype._boot = function()
{
    var hotspot = FORGE.UID.get(this._hotspotUid);

    // If no match, return
    if(typeof hotspot === "undefined")
    {
        throw("No hotspot match with uid: "+this._hotspotUid);
    }

    // Set the default config
    this._config =
    {
        options: {},

        default: hotspot.config
    };
};

/**
 * Parse the states configuration
 * @method FORGE.HotspotStates#_parseConfig
 * @param {?HotspotStatesConfig} config - The configuration to parse
 * @private
 */
FORGE.HotspotStates.prototype._parseConfig = function(config)
{
    this._default = (typeof config.options.default === "string") ? config.options.default : "default";
    this._auto = (typeof config.options.auto === "boolean") ? config.options.auto : true;

    this._config.default = FORGE.Utils.extendSimpleObject(this._config.default, config[this._default]);
};

/**
 * Get the state names (states config keys without reserved keys that are not states)
 * @method FORGE.HotspotStates#_getStatesNames
 * @return {Array<string>} Returns the names of the available states.
 * @private
 */
FORGE.HotspotStates.prototype._getStatesNames = function()
{
    if(this._config === null)
    {
        return [];
    }

    var config = /** @type {!Object} */ (this._config);
    var keys = Object.keys(config);

    // Remove the reserved keywords from state names
    for(var i = 0, ii = FORGE.HotspotStates._RESERVED.length; i < ii; i++)
    {
        var index = keys.indexOf(FORGE.HotspotStates._RESERVED[i]);

        if(index !== -1)
        {
            keys.splice(index, 1);
        }
    }

    // Remove the state named "default" if there is a default state in the options
    if(this._default !== "default" && typeof this._config[this._default] !== "undefined")
    {
        index = keys.indexOf("default");

        if(index !== -1)
        {
            keys.splice(index, 1);
        }
    }

    return keys;
};

/**
 * Update the geometry for the current state
 * @method FORGE.HotspotStates#_updateGeometry
 * @param  {HotspotGeometryConfig} config - The hotspot geometry configuration object.
 * @private
 */
FORGE.HotspotStates.prototype._updateGeometry = function(config)
{
    this.log("update geometry");

    var hotspot = FORGE.UID.get(this._hotspotUid);
    hotspot.geometry.onLoadComplete.addOnce(this._geometryLoadCompleteHandler, this);
    hotspot.geometry.load(config);
};

/**
 * Geometry load complete event handler
 * @method FORGE.HotspotStates#_geometryLoadCompleteHandler
 * @private
 */
FORGE.HotspotStates.prototype._geometryLoadCompleteHandler = function()
{
    this._loading.geometry = false;
    this._checkLoading();
};

/**
 * Update the material for the current state
 * @method FORGE.HotspotStates#_updateMaterial
 * @param  {HotspotMaterialConfig} config - The hotspot material configuration object.
 * @private
 */
FORGE.HotspotStates.prototype._updateMaterial = function(config)
{
    this.log("update material");

    var hotspot = FORGE.UID.get(this._hotspotUid);
    hotspot.material.onReady.addOnce(this._materialReadyHandler, this);
    hotspot.material.load(config);
};

/**
 * Material ready event handler
 * @method FORGE.HotspotStates#_materialReadyHandler
 * @private
 */
FORGE.HotspotStates.prototype._materialReadyHandler = function()
{
    this._loading.material = false;
    this._checkLoading();
};

/**
 * Update the sound for the current state
 * @method FORGE.HotspotStates#_updateSound
 * @param  {SoundConfig} config - The hotspot sound configuration object.
 * @private
 */
FORGE.HotspotStates.prototype._updateSound = function(config)
{
    this.log("update sound");

    var hotspot = FORGE.UID.get(this._hotspotUid);
    hotspot.sound.onReady.addOnce(this._soundReadyHandler, this);
    hotspot.sound.load(config);
};

/**
 * Sound ready event handler
 * @method FORGE.HotspotStates#_soundReadyHandler
 * @private
 */
FORGE.HotspotStates.prototype._soundReadyHandler = function()
{
    this._loading.sound = false;
    this._checkLoading();
};

/**
 * Update the animation for the current state
 * @method FORGE.HotspotStates#_updateAnimation
 * @param  {HotspotTrackConfig} config - The hotspot animation configuration object.
 * @private
 */
FORGE.HotspotStates.prototype._updateAnimation = function(config)
{
    this.log("update animation");

    var hotspot = FORGE.UID.get(this._hotspotUid);
    hotspot.animation.load(config, false);

    this._loading.animation = false;
    this._checkLoading();
};

/**
 * Update the transform for the current state
 * @method FORGE.HotspotStates#_updateTransform
 * @param  {HotspotTransformConfig} config - The hotspot transform configuration object.
 * @private
 */
FORGE.HotspotStates.prototype._updateTransform = function(config)
{
    this.log("update transform");

    var hotspot = FORGE.UID.get(this._hotspotUid);
    hotspot.transform.load(config, false);

    this._loading.transform = false;
    this._checkLoading();
};

/**
 * Check the loading status of the current state.
 * Dispatch the laod complete event if all check are ok.
 * @method FORGE.HotspotStates#_checkLoading
 * @private
 */
FORGE.HotspotStates.prototype._checkLoading = function()
{
    for(var prop in this._loading)
    {
        if(this._loading[prop] === true)
        {
            return true;
        }
    }

    this._ready = true;

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.dispatch();
    }

    return false;
};

/**
 * Add a states configuration object.
 * @method FORGE.HotspotStates#addConfig
 * @param  {HotspotStatesConfig} config - Configuration object with hotspots states.
 */
FORGE.HotspotStates.prototype.addConfig = function(config)
{
    this._config = FORGE.Utils.extendSimpleObject(this._config, config);
    this._parseConfig(this._config);
};

/**
 * Load a state.
 * @method FORGE.HotspotStates#load
 * @param  {string=} name - the name of the state to load.
 */
FORGE.HotspotStates.prototype.load = function(name)
{
    name = (typeof name === "string") ? name : this._default;

    this.log("Hotspot load state: "+name);

    var hotspot = FORGE.UID.get(this._hotspotUid);

    // If no hotspot match OR no state name match OR already on this state THEN return
    if(typeof hotspot === "undefined" || typeof this._config[name] !== "object" || name === this._state)
    {
        return;
    }

    this._ready = false;

    // Set the state name
    this._state = name;

    if(typeof this._config[name].sound === "object")
    {
        this._loading.sound = true;
    }

    if(typeof this._config[name].animation === "object")
    {
        this._loading.animation = true;
    }

    this._loading.material = true;
    this._loading.geometry = true;
    this._loading.transform = true;

    if(this._loading.material === true)
    {
        var materialConfig = /** @type {!HotspotMaterialConfig} */ (FORGE.Utils.extendSimpleObject(hotspot.config.material, this._config[name].material));
        this._updateMaterial(materialConfig);
    }

    if(this._loading.sound === true)
    {
        var soundConfig = /** @type {!SoundConfig} */ (FORGE.Utils.extendSimpleObject(hotspot.config.sound, this._config[name].sound));
        this._updateSound(soundConfig);
    }

    if(this._loading.animation === true)
    {
        var animationConfig = /** @type {HotspotTrackConfig} */ (FORGE.Utils.extendSimpleObject(hotspot.config.animation, this._config[name].animation));
        this._updateAnimation(animationConfig);
    }

    if(this._loading.geometry === true)
    {
        var geometryConfig = /** @type {HotspotGeometryConfig} */ (FORGE.Utils.extendSimpleObject(hotspot.config.geometry, this._config[name].geometry));
        this._updateGeometry(geometryConfig);
    }

    if(this._loading.transform === true)
    {
        var transformConfig = /** @type {HotspotTransformConfig} */ (FORGE.Utils.extendSimpleObject(hotspot.config.transform, this._config[name].transform));
        this._updateTransform(transformConfig);
    }
};

/**
 * Toggle from a state to another.
 * @method FORGE.HotspotStates#toggle
 * @param  {Array<string>} names - the names of the states to loop through.
 */
FORGE.HotspotStates.prototype.toggle = function(names)
{
    if(names === null || typeof names === "undefined" || names.length < 2)
    {
        names = this._getStatesNames();
    }

    var current = names.indexOf(this._state);
    var next = 0;

    if(current < names.length - 1)
    {
        next = current + 1;
    }

    this.load(names[next]);
};

/**
 * Destroy sequence.
 * @method FORGE.HotspotStates#destroy
 */
FORGE.HotspotStates.prototype.destroy = function()
{
    this._viewer = null;

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get and set the current state
 * @name FORGE.HotspotStates#state
 * @type {string}
 */
Object.defineProperty(FORGE.HotspotStates.prototype, "state",
{
    /** @this {FORGE.HotspotStates} */
    get: function()
    {
        return this._state;
    },

    /** @this {FORGE.HotspotStates} */
    set: function(value)
    {
        this.load(value);
    }
});

/**
 * Get the states names.
 * @name FORGE.HotspotStates#names
 * @type {Array<string>}
 * @readonly
 */
Object.defineProperty(FORGE.HotspotStates.prototype, "names",
{
    /** @this {FORGE.HotspotStates} */
    get: function()
    {
        return this._getStatesNames();
    }
});

/**
 * Get the ready flag.
 * @name FORGE.HotspotStates#ready
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.HotspotStates.prototype, "ready",
{
    /** @this {FORGE.HotspotStates} */
    get: function()
    {
        return this._ready;
    }
});

/**
 * Get the auto flag.
 * @name FORGE.HotspotStates#auto
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.HotspotStates.prototype, "auto",
{
    /** @this {FORGE.HotspotStates} */
    get: function()
    {
        return this._auto;
    }
});

/**
 * Get the onConfigLoadComplete {@link FORGE.EventDispatcher}.
 * @name  FORGE.HotspotStates#onLoadComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.HotspotStates.prototype, "onLoadComplete",
{
    /** @this {FORGE.HotspotStates} */
    get: function()
    {
        if (this._onLoadComplete === null)
        {
            this._onLoadComplete = new FORGE.EventDispatcher(this);
        }

        return this._onLoadComplete;
    }
});


/**
 * @namespace {Object} FORGE.HotspotType
 */
FORGE.HotspotType = {};

/**
 * @name FORGE.HotspotType.THREE_DIMENSIONAL
 * @type {string}
 * @const
 */
FORGE.HotspotType.THREE_DIMENSIONAL = "3d";

/**
 * @name FORGE.HotspotType.DOM
 * @type {string}
 * @const
 */
FORGE.HotspotType.DOM = "dom";

/**
 * A FORGE.Camera tells the renderer wich part of the scene to render.
 *
 * @constructor FORGE.Camera
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.Camera = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.Camera#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Camera configuration that has been loaded.
     * @name  FORGE.Camera#_config
     * @type {?CameraConfig}
     * @private
     */
    this._config = null;

    /**
     * The yaw value in radians.
     * @name FORGE.Camera#_yaw
     * @type {number}
     * @private
     */
    this._yaw = 0;

    /**
     * The yaw minimum value in radians.
     * @name FORGE.Camera#_yawMin
     * @type {number}
     * @private
     */
    this._yawMin = -Infinity;

    /**
     * The yaw maximum value in radians.
     * @name FORGE.Camera#_yawMax
     * @type {number}
     * @private
     */
    this._yawMax = Infinity;

    /**
     * The pitch value in radians.
     * @name FORGE.Camera#_pitch
     * @type {number}
     * @private
     */
    this._pitch = 0;

    /**
     * The pitch minimum value in radians.
     * @name FORGE.Camera#_pitchMin
     * @type {number}
     * @private
     */
    this._pitchMin = -Infinity;

    /**
     * The pitch maximum value  in radians.
     * @name FORGE.Camera#_pitchMax
     * @type {number}
     * @private
     */
    this._pitchMax = Infinity;

    /**
     * The roll value in radians.
     * @name FORGE.Camera#_roll
     * @type {number}
     * @private
     */
    this._roll = 0;

    /**
     * The roll minimum value  in radians.
     * @name FORGE.Camera#_rollMin
     * @type {number}
     * @private
     */
    this._rollMin = -Infinity;

    /**
     * The roll maximum value in radians.
     * @name FORGE.Camera#_rollMax
     * @type {number}
     * @private
     */
    this._rollMax = Infinity;

    /**
     * The fov value in radians.
     * @name FORGE.Camera#_fov
     * @type {number}
     * @private
     */
    this._fov = 90;

    /**
     * The fov minimum value in radians.
     * @name FORGE.Camera#_fovMin
     * @type {number}
     * @private
     */
    this._fovMin = 0;

    /**
     * The fov maximum value in radians.
     * @name FORGE.Camera#_fovMax
     * @type {number}
     * @private
     */
    this._fovMax = Infinity;

    /**
     * Parallax setting
     * Value range is between 0 and 1
     * @name FORGE.Camera#_parallax
     * @type {number}
     * @private
     */
    this._parallax = 0;

    /**
     * Does the camera keep its orientation between scenes?
     * @name FORGE.Camera#_keep
     * @type {boolean}
     * @private
     */
    this._keep = false;

    /**
     * The modelview rotation matrix.
     * @name FORGE.Camera#_modelView
     * @type {THREE.Matrix4}
     * @private
     */
    this._modelView = null;

    /**
     * The inverse of the modelview rotation matrix.
     * @name FORGE.Camera#_modelViewInverse
     * @type {THREE.Matrix4}
     * @private
     */
    this._modelViewInverse = null;

    /**
     * Rotation quaternion of the camera
     * @name FORGE.Camera#_quaternion
     * @type {THREE.Quaternion}
     * @private
     */
    this._quaternion = null;

    /**
     * Three Perspective Camera object
     * @name FORGE.Camera#_main
     * @type {THREE.PerspectiveCamera}
     * @private
     */
    this._main = null;

    /**
     * Three Orthographic Camera object
     * @name FORGE.Camera#_flat
     * @type {THREE.OrthographicCamera}
     * @private
     */
    this._flat = null;

    /**
     * Left camera for VR rendering
     * @name  FORGE.Camera._left
     * @type {THREE.PerspectiveCamera}
     * @private
     */
    this._left = null;

    /**
     * Right camera for VR rendering
     * @name  FORGE.Camera._right
     * @type {THREE.PerspectiveCamera}
     * @private
     */
    this._right = null;

    /**
     * Three Perspective Camera radius (depends on parallax)
     * @name FORGE.Camera#_radius
     * @type {number}
     * @private
     */
    this._radius = 0;

    /**
     * Camera animation object
     * @name FORGE.Camera#_cameraAnimation
     * @type {FORGE.CameraAnimation}
     * @private
     */
    this._cameraAnimation = null;

    /**
     * Camera gaze cursor
     * @name FORGE.Camera#_gaze
     * @type {FORGE.CameraGaze}
     * @private
     */
    this._gaze = null;

    /**
     * Is the camera have load its configuration at least one time? For keep feature.
     * @name FORGE.Camera#_initialized
     * @type {boolean}
     * @private
     */
    this._initialized = false;

    /**
     * Log the camera changes between two updates.
     * @name FORGE.Camera#_changelog
     * @type {?CameraChangelog}
     * @private
     */
    this._changelog = null;

    /**
     * On camera change event dispatcher.
     * @name FORGE.Camera#_onChange
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onChange = null;

    /**
     * On camera orientation change event dispatcher.
     * @name FORGE.Camera#_onOrientationChange
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onOrientationChange = null;

    /**
     * On camera fov change event dispatcher.
     * @name FORGE.Camera#_onFovChange
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onFovChange = null;

    FORGE.BaseObject.call(this, "Camera");

    this._boot();
};

FORGE.Camera.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Camera.prototype.constructor = FORGE.Camera;

/**
 * Camera default radius for parallax.
 * @name FORGE.Camera.RADIUS
 * @type {number}
 * @const
 */
FORGE.Camera.RADIUS = 50;

/**
 * Camera default configuration in degrees like in the json configuration.
 * @name FORGE.Camera.DEFAULT_CONFIG
 * @type {CameraConfig}
 * @const
 */
FORGE.Camera.DEFAULT_CONFIG =
{
    keep: false,
    parallax: 0,
    yaw:
    {
        min: -Infinity,
        max: Infinity,
        default: 0
    },
    pitch:
    {
        min: -Infinity,
        max: Infinity,
        default: 0
    },
    roll:
    {
        min: -Infinity,
        max: Infinity,
        default: 0
    },
    fov:
    {
        min: 0,
        max: Infinity,
        default: 90
    },
    gaze:
    {
        delay: 2000,
        cursor:
        {
            innerRadius: 0.02,
            outerRadius: 0.04,
            color: 0xffffff,
            opacity: 0.5
        },
        progress:
        {
            innerRadius: 0.02,
            outerRadius: 0.04,
            color: 0xff0000,
            opacity: 0.5
        }
    }
};

/**
 * Init sequence.
 * @method FORGE.Camera#_boot
 * @private
 */
FORGE.Camera.prototype._boot = function()
{
    this._resetChangelog();

    this._modelView = new THREE.Matrix4();
    this._modelViewInverse = new THREE.Matrix4();
    this._quaternion = new THREE.Quaternion();

    this._gaze = new FORGE.CameraGaze(this._viewer, FORGE.Camera.DEFAULT_CONFIG.gaze);

    this._viewer.renderer.view.onChange.add(this._updateInternals, this);
    this._viewer.renderer.onBackgroundReady.add(this._updateInternals, this);

    this._createMainCamera();
    this._createFlatCamera();
    this._createVRCameras();

    // Check config to allow default to be set if they were depending
    // on some parameter external to the camera. For example: multiresolution fovMin set
    // by the background renderer
    if (this._config !== null)
    {
        this._parseConfig(this._config);
    }
};

/**
 * Parse a camera configuration.
 * @method FORGE.Camera#_parseConfig
 * @param {?CameraConfig} config - The camera configuration to parse.
 * @private
 */
FORGE.Camera.prototype._parseConfig = function(config)
{
    this._parallax = config.parallax;
    this._radius = this._parallax * FORGE.Camera.RADIUS;
    this._keep = config.keep;

    if(this._keep === true && this._initialized === true)
    {
        return;
    }

    if (typeof config.fov.min === "number")
    {
        this._fovMin = FORGE.Math.degToRad(config.fov.min);
    }

    if (typeof config.fov.max === "number")
    {
        this._fovMax = FORGE.Math.degToRad(config.fov.max);
    }

    if (typeof config.fov.default === "number")
    {
        this._setFov(config.fov.default, FORGE.Math.DEGREES);
    }

    if (typeof config.yaw.min === "number")
    {
        this._yawMin = FORGE.Math.degToRad(config.yaw.min);
    }

    if (typeof config.yaw.max === "number")
    {
        this._yawMax = FORGE.Math.degToRad(config.yaw.max);
    }

    if (typeof config.yaw.default === "number")
    {
        this._setYaw(config.yaw.default, FORGE.Math.DEGREES);
    }

    if (typeof config.pitch.min === "number")
    {
        this._pitchMin = FORGE.Math.degToRad(config.pitch.min);
    }

    if (typeof config.pitch.max === "number")
    {
        this._pitchMax = FORGE.Math.degToRad(config.pitch.max);
    }

    if (typeof config.pitch.default === "number")
    {
        this._setPitch(config.pitch.default, FORGE.Math.DEGREES);
    }

    if (typeof config.roll.min === "number")
    {
        this._rollMin = FORGE.Math.degToRad(config.roll.min);
    }

    if (typeof config.roll.max === "number")
    {
        this._rollMax = FORGE.Math.degToRad(config.roll.max);
    }

    if (typeof config.roll.default === "number")
    {
        this._setRoll(config.roll.default, FORGE.Math.DEGREES);
    }

    this._updateFromEuler();

    this._updateMainCamera();
    this._updateFlatCamera();

    this._gaze.load(/** @type {CameraGazeConfig} */ (config.gaze));
};

/**
 * Reset the camera changelog.
 * @method FORGE.Camera#_resetChangelog
 * @private
 */
FORGE.Camera.prototype._resetChangelog = function()
{
    this._changelog =
    {
        yaw: false,
        pitch: false,
        roll: false,
        fov: false
    };
};

/**
 * Init the THREE PerspectiveCamera.
 * @method FORGE.Camera#_createMainCamera
 * @private
 */
FORGE.Camera.prototype._createMainCamera = function()
{
    if (typeof this._viewer.renderer !== "undefined")
    {
        var aspect = this._viewer.renderer.displayResolution.ratio;
        this._main = new THREE.PerspectiveCamera(this._fov, aspect, FORGE.RenderManager.DEPTH_NEAR, 2 * FORGE.RenderManager.DEPTH_FAR);
        this._main.name = "CameraMain";
        this._main.matrixAutoUpdate = false;
    }
};

/**
 * Init the THREE OrthographicCamera.
 * @method FORGE.Camera#_createFlatCamera
 * @private
 */
FORGE.Camera.prototype._createFlatCamera = function()
{
    if (typeof this._viewer.renderer !== "undefined")
    {
        this._flat = new THREE.OrthographicCamera(
            -1000, 1000,
            1000, -1000,
            FORGE.RenderManager.DEPTH_NEAR,
            FORGE.RenderManager.DEPTH_FAR);

        this._flat.name = "CameraFlat";
        this._flat.matrixAutoUpdate = false;
    }
};

/**
 * Create the left and right THREE PerspectiveCamera for VR.
 * @method FORGE.Camera#_createVRCameras
 * @private
 */
FORGE.Camera.prototype._createVRCameras = function()
{
    this._left = this._main.clone();
    this._left.name = "CameraLeft";
    this._left.layers.enable(1);

    this._left.add(this._gaze.object);

    this._right = this._main.clone();
    this._right.name = "CameraRight";
    this._right.layers.enable(2);
};

/**
 * Update VR cameras.
 * @method FORGE.Camera#_updateVRCameras
 * @private
 */
FORGE.Camera.prototype._updateVRCameras = function()
{
    var display = this._viewer.renderer.display;

    // Get frame data before pose to ensure pose values are up to date
    var frameData = display.vrFrameData;
    var quat = display.getQuaternionFromPose();

    if (quat !== null)
    {
        this._quaternion = quat;
        this._updateFromQuaternion();
    }

    var eyeParamsL = display.vrDisplay.getEyeParameters("left");
    var eyeParamsR = display.vrDisplay.getEyeParameters("right");

    this._main.matrixWorld.decompose(this._left.position, this._left.quaternion, this._left.scale);
    this._left.matrixWorld = new THREE.Matrix4().makeRotationFromQuaternion(this._main.quaternion);

    this._main.matrixWorld.decompose(this._right.position, this._right.quaternion, this._right.scale);
    this._right.matrixWorld = new THREE.Matrix4().makeRotationFromQuaternion(this._main.quaternion);

    // Get translation from central camera matrix
    this._left.matrixWorld.elements[12] = this._main.matrixWorld.elements[12] + eyeParamsL.offset[0];
    this._left.matrixWorld.elements[13] = this._main.matrixWorld.elements[13] + eyeParamsL.offset[1];
    this._left.matrixWorld.elements[14] = this._main.matrixWorld.elements[14] + eyeParamsL.offset[2];

    // Get translation from central camera matrix
    this._right.matrixWorld.elements[12] = this._main.matrixWorld.elements[12] + eyeParamsR.offset[0];
    this._right.matrixWorld.elements[13] = this._main.matrixWorld.elements[13] + eyeParamsR.offset[1];
    this._right.matrixWorld.elements[14] = this._main.matrixWorld.elements[14] + eyeParamsR.offset[2];

    // Setup camera projection matrix
    if (frameData !== null)
    {
        this._left.projectionMatrix.elements = frameData.leftProjectionMatrix;
        this._right.projectionMatrix.elements = frameData.rightProjectionMatrix;
    }
    else
    {
        var eyeFOVL = {
            upDegrees: eyeParamsL.fieldOfView.upDegrees,
            downDegrees: eyeParamsL.fieldOfView.downDegrees,
            leftDegrees: eyeParamsL.fieldOfView.leftDegrees,
            rightDegrees: eyeParamsL.fieldOfView.rightDegrees
        };

        this._left.projectionMatrix = this._fovToProjectionMatrix(eyeFOVL, this._main);

        var eyeFOVR = {
            upDegrees: eyeParamsR.fieldOfView.upDegrees,
            downDegrees: eyeParamsR.fieldOfView.downDegrees,
            leftDegrees: eyeParamsR.fieldOfView.leftDegrees,
            rightDegrees: eyeParamsR.fieldOfView.rightDegrees
        };

        this._right.projectionMatrix = this._fovToProjectionMatrix(eyeFOVR, this._main);
    }

    this._updateComplete();
};

/**
 * Clone VR cameras objects.
 * @method FORGE.Camera#_cloneVRCamerasChildren
 * @private
 */
FORGE.Camera.prototype._cloneVRCamerasChildren = function()
{
    //First clear all children from camera right
    for (var i = 0, ii = this._right.children.length; i < ii; i++)
    {
        this._right.remove(this._right.children[i]);
    }

    //Then clone all children of camera left to camera right
    var clone = null;
    for (var j = 0, jj = this._left.children.length; j < jj; j++)
    {
        clone = this._left.children[j].clone();
        this._right.add(clone);
    }
};

/**
 * Get projection matrix from a VRFieldOfView
 * @method FORGE.Camera#_fovToProjectionMatrix
 * @param {VRFieldOfViewObject} fov - VRFieldOfView for an eye
 * @param {THREE.PerspectiveCamera} camera - reference camera
 * @return {THREE.Matrix4} projection matrix
 * @private
 */
FORGE.Camera.prototype._fovToProjectionMatrix = function(fov, camera)
{
    // Get projections of field of views on zn plane
    var fovUpTan = Math.tan(FORGE.Math.degToRad(fov.upDegrees));
    var fovDownTan = Math.tan(FORGE.Math.degToRad(fov.downDegrees));
    var fovLeftTan = Math.tan(FORGE.Math.degToRad(fov.leftDegrees));
    var fovRightTan = Math.tan(FORGE.Math.degToRad(fov.rightDegrees));

    // and with scale/offset info for normalized device coords
    var pxscale = 2.0 / (fovLeftTan + fovRightTan);
    var pxoffset = (fovLeftTan - fovRightTan) * pxscale * 0.5;
    var pyscale = 2.0 / (fovUpTan + fovDownTan);
    var pyoffset = (fovUpTan - fovDownTan) * pyscale * 0.5;

    // start with an identity matrix
    var matrix = new THREE.Matrix4();
    var m = matrix.elements;

    // X result, map clip edges to [-w,+w]
    m[0 * 4 + 0] = pxscale;
    m[0 * 4 + 1] = 0.0;
    m[0 * 4 + 2] = -pxoffset;
    m[0 * 4 + 3] = 0.0;

    // Y result, map clip edges to [-w,+w]
    // Y offset is negated because this proj matrix transforms from world coords with Y=up,
    // but the NDC scaling has Y=down (thanks D3D?)
    m[1 * 4 + 0] = 0.0;
    m[1 * 4 + 1] = pyscale;
    m[1 * 4 + 2] = pyoffset;
    m[1 * 4 + 3] = 0.0;

    // Z result (up to the app)
    m[2 * 4 + 0] = 0.0;
    m[2 * 4 + 1] = 0.0;
    m[2 * 4 + 2] = camera.far / (camera.near - camera.far);
    m[2 * 4 + 3] = (camera.far * camera.near) / (camera.near - camera.far);

    // W result (= Z in)
    m[3 * 4 + 0] = 0.0;
    m[3 * 4 + 1] = 0.0;
    m[3 * 4 + 2] = -1.0;
    m[3 * 4 + 3] = 0.0;

    matrix.transpose();

    return matrix;
};

/**
 * Apply Camera change internally.
 * @method FORGE.Camera#_updateFromEuler
 * @private
 */
FORGE.Camera.prototype._updateFromEuler = function()
{
    this._modelView = FORGE.Math.eulerToRotationMatrix(this._yaw, this._pitch, this._roll, false);

    this._modelViewInverse = this._modelView.clone().transpose();

    this._quaternion = FORGE.Quaternion.fromEuler(this._yaw, this._pitch, this._roll);

    // complete camera update
    this._updateComplete();
};

/**
 * Camera update internals after quaternion has been set
 * @method FORGE.Camera#_updateFromQuaternion
 * @private
 */
FORGE.Camera.prototype._updateFromQuaternion = function()
{
    this._modelView = FORGE.Quaternion.toRotationMatrix(this._quaternion);

    this._modelViewInverse = this._modelView.clone().transpose();

    var euler = FORGE.Quaternion.toEuler(this._quaternion);

    this._setAll(euler.yaw, euler.pitch, euler.roll, null, FORGE.Math.RADIANS);
};

/**
 * Camera update internals after modelview matrix has been set.
 * @method FORGE.Camera#_updateFromMatrix
 * @private
 */
FORGE.Camera.prototype._updateFromMatrix = function()
{
    this._modelViewInverse = this._modelView.clone().transpose();

    var euler = FORGE.Math.rotationMatrixToEuler(this._modelView);

    this._setAll(euler.yaw, euler.pitch, euler.roll, null, FORGE.Math.RADIANS);

    this._quaternion = FORGE.Quaternion.fromRotationMatrix(this._modelView);
};

/**
 * THREE Perspective camera update internals after modelview matrix has been set.
 * @method FORGE.Camera#_updateMainCamera
 * @private
 */
FORGE.Camera.prototype._updateMainCamera = function()
{
    if (this._main === null || this._viewer.renderer.view.current === null)
    {
        return;
    }

    var mat = new THREE.Matrix4().copy(this._modelViewInverse);

    if (this._parallax !== 0)
    {
        mat.multiply(new THREE.Matrix4().makeTranslation(0, 0, -this._radius));
    }

    // Now set the object quaternion (side effect: it will override the world matrix)
    this._main.quaternion.setFromRotationMatrix(mat);

    this._main.matrixWorld = mat;
    this._main.matrixWorldInverse.getInverse(mat);

    this._main.fov = FORGE.Math.radToDeg(this._viewer.renderer.view.current.getProjectionFov());
    this._main.aspect = this._viewer.renderer.displayResolution.ratio;
    this._main.updateProjectionMatrix();
};

/**
 * THREE Orthographic camera update internals.
 * @method FORGE.Camera#_updateFlatCamera
 * @private
 */
FORGE.Camera.prototype._updateFlatCamera = function()
{
    if (this._flat === null)
    {
        return;
    }

    var camW = this._flat.right - this._flat.left;
    var camH = this._flat.top - this._flat.bottom;

    this._flat.left = this._flat.position.x - camW / 2;
    this._flat.right = this._flat.position.x + camW / 2;

    this._flat.top = this._flat.position.y + camH / 2;
    this._flat.bottom = this._flat.position.y - camH / 2;

    var max = this._fovMax;
    var view = this._viewer.renderer.view.current;

    if (view !== null && view.fovMax !== null)
    {
        max = Math.min(view.fovMax, this._fovMax);
        this._flat.zoom = max / this._fov;
    }
    else
    {
        this._flat.zoom = 1;
    }

    this._flat.updateProjectionMatrix();
};

/**
 * Final method call to complete camera update, ensure main camera is up to date.
 * @method FORGE.Camera#_updateComplete
 * @private
 */
FORGE.Camera.prototype._updateComplete = function()
{
    var changed = false;

    if(this._changelog.yaw === true || this._changelog.pitch === true || this._changelog.roll === true)
    {
        changed = true;

        if (this._onOrientationChange !== null)
        {
            this._onOrientationChange.dispatch(null, true);
        }
    }

    if(this._changelog.fov === true)
    {
        changed = true;

        if (this._onFovChange !== null)
        {
            this._onFovChange.dispatch(null, true);
        }
    }


    if (changed === true && this._onChange !== null)
    {
        this._onChange.dispatch(null, true);
    }
};


/**
 * Internal setter for yaw, take a value and a unit. Default unit is radians.
 * @method FORGE.Camera#_setYaw
 * @param {?number=} value - The value you want to set for yaw.
 * @param {string=} [unit="radians"] - The unit you use to set the yaw value.
 * @return {boolean} Returns true if the value has changed.
 * @private
 */
FORGE.Camera.prototype._setYaw = function(value, unit)
{
    if (typeof value !== "number" || isNaN(value) === true)
    {
        return false;
    }

    // If unit is not well defined, default will be radians
    unit = (unit === FORGE.Math.DEGREES || unit === FORGE.Math.RADIANS) ? unit : FORGE.Math.RADIANS;

    // Convert value in radians for clamp if unit is in degrees.
    value = (unit === FORGE.Math.DEGREES) ? FORGE.Math.degToRad(value) : value;

    // Wrap the value between -PI and +PI, except for FLAT view where we apply texture ratio
    if (this._viewer.renderer.backgroundRenderer !== null &&
        this._viewer.renderer.backgroundRenderer.displayObject !== null &&
        this._viewer.renderer.view.type === FORGE.ViewType.FLAT)
    {
        var displayObject = this._viewer.renderer.backgroundRenderer.displayObject;
        var ratio = displayObject.pixelWidth / displayObject.pixelHeight;

        if (displayObject.element instanceof HTMLVideoElement)
        {
            ratio = displayObject.element.videoWidth / displayObject.element.videoHeight;
        }

        value = FORGE.Math.wrap(value, -Math.PI * ratio, Math.PI * ratio);
    }
    else
    {
        value = FORGE.Math.wrap(value, -Math.PI, Math.PI);
    }

    var boundaries = this._getYawBoundaries();

    var yaw = FORGE.Math.clamp(value, boundaries.min, boundaries.max);

    var changed = this._yaw !== yaw;

    this._changelog.yaw = changed;

    this._yaw = yaw;

    return changed;
};

/**
 * Compute the yaw boundaries with yaw min and yaw max.
 * @method FORGE.Camera#_getYawBoundaries
 * @param {boolean=} relative - do we need to get the yaw relative to the current fov (default true)
 * @param {number=} fov - specify a fov if we do not want to use the current one (useful for simulation)
 * @return {CameraBoundaries} Returns the min and max yaw computed from the camera configuration and the view limits.
 * @private
 */
FORGE.Camera.prototype._getYawBoundaries = function(relative, fov)
{
    var min = this._yawMin;
    var max = this._yawMax;

    fov = fov || this._fov;

    if (relative !== false && min !== max)
    {
        var halfHFov = 0.5 * fov * this._viewer.renderer.displayResolution.ratio;
        min += halfHFov;
        max -= halfHFov;
    }

    var view = this._viewer.renderer.view.current;

    if (view !== null)
    {
        min = Math.max(view.yawMin, min);
        max = Math.min(view.yawMax, max);
    }

    return { min: min, max: max };
};

/**
 * Internal setter for pitch, take a value and a unit. Default unit is radians.
 * @method FORGE.Camera#_setPitch
 * @param {?number=} value - The value you want to set for pitch.
 * @param {string=} [unit="radians"] - The unit you use to set the pitch value.
 * @return {boolean} Returns true if the value has changed.
 * @private
 */
FORGE.Camera.prototype._setPitch = function(value, unit)
{
    if (typeof value !== "number" || isNaN(value) === true)
    {
        return false;
    }

    var oldPitch = this._pitch;

    // If unit is not well defined, default will be radians
    unit = (unit === FORGE.Math.DEGREES || unit === FORGE.Math.RADIANS) ? unit : FORGE.Math.RADIANS;

    // Convert value in radians for clamp if unit is in degrees.
    value = (unit === FORGE.Math.DEGREES) ? FORGE.Math.degToRad(value) : value;

    // Wrap the value between -PI and +PI
    value = FORGE.Math.wrap(value, -Math.PI, Math.PI);

    var boundaries = this._getPitchBoundaries();

    var pitch = FORGE.Math.clamp(value, boundaries.min, boundaries.max);

    // If old view accepted pitch out of [-PI/2 , PI/2] and new one does not,
    // check if old pitch value was in authorized range and if not, set to zero
    if (Math.abs(oldPitch) > Math.PI / 2 && Math.abs(pitch) === Math.PI / 2)
    {
        pitch = 0;
    }

    var changed = this._pitch !== pitch;

    this._changelog.pitch = changed;

    this._pitch = pitch;

    return changed;
};

/**
 * Compute the pitch boundaries with pitch min and pitch max.
 * @method FORGE.Camera#_getPitchBoundaries
 * @param {boolean=} relative - do we need to get the pitch relative to the current fov (default true)
 * @param {number=} fov - specify a fov if we do not want to use the current one (useful for simulation)
 * @return {CameraBoundaries} Returns the min and max pitch computed from the camera configuration and the view limits.
 * @private
 */
FORGE.Camera.prototype._getPitchBoundaries = function(relative, fov)
{
    var min = this._pitchMin;
    var max = this._pitchMax;

    fov = fov || this._fov;

    if (relative !== false && min !== max)
    {
        var halfFov = 0.5 * fov;
        min += halfFov;
        max -= halfFov;
    }

    var view = this._viewer.renderer.view.current;

    if (view !== null)
    {
        min = Math.max(view.pitchMin, min);
        max = Math.min(view.pitchMax, max);
    }

    return { min: min, max: max };
};

/**
 * Internal setter for roll, take a value and a unit. Default unit is radians.
 * @method FORGE.Camera#_setRoll
 * @param {?number=} value - The value you want to set for roll.
 * @param {string=} [unit="radians"] - The unit you use to set the roll value.
 * @return {boolean} Returns true if the value has changed.
 * @private
 */
FORGE.Camera.prototype._setRoll = function(value, unit)
{
    if (typeof value !== "number" || isNaN(value) === true)
    {
        return false;
    }

    // If unit is not well defined, default will be radians
    unit = (unit === FORGE.Math.DEGREES || unit === FORGE.Math.RADIANS) ? unit : FORGE.Math.RADIANS;

    // Convert value in radians for clamp if unit is in degrees.
    value = (unit === FORGE.Math.DEGREES) ? FORGE.Math.degToRad(value) : value;

    // Wrap the value between -PI and +PI
    value = FORGE.Math.wrap(value, -Math.PI, Math.PI);

    var boundaries = this._getRollBoundaries();

    var roll = FORGE.Math.clamp(value, boundaries.min, boundaries.max);

    var changed = this._roll !== roll;

    this._changelog.roll = changed;

    this._roll = roll;

    return changed;
};

/**
 * Compute the roll boundaries with yaw min and yaw max.
 * @method FORGE.Camera#_getRollBoundaries
 * @return {CameraBoundaries} Returns the min and max roll computed from the camera configuration and the view limits.
 * @private
 */
FORGE.Camera.prototype._getRollBoundaries = function()
{
    var min = this._rollMin;
    var max = this._rollMax;
    var view = this._viewer.renderer.view.current;

    if (view !== null)
    {
        min = Math.max(view.rollMin, min);
        max = Math.min(view.rollMax, max);
    }

    return { min: min, max: max };
};

/**
 * Internal setter for fov (field of view), take a value and a unit. Default unit is radians.
 * @method FORGE.Camera#_setFov
 * @param {?number=} value - The value you want to set for fov.
 * @param {string=} [unit="radians"] - The unit you use to set the fov value.
 * @return {boolean} Returns true if the value has changed.
 * @private
 */
FORGE.Camera.prototype._setFov = function(value, unit)
{
    if (typeof value !== "number" || isNaN(value) === true)
    {
        return false;
    }

    // If unit is not well defined, default will be radians
    unit = (unit === FORGE.Math.DEGREES || unit === FORGE.Math.RADIANS) ? unit : FORGE.Math.RADIANS;

    // Convert value in radians for clamp if unit is in degrees.
    value = (unit === FORGE.Math.DEGREES) ? FORGE.Math.degToRad(value) : value;

    var boundaries = this._getFovBoundaries();

    var fov = FORGE.Math.clamp(value, boundaries.min, boundaries.max);

    var changed = this._fov !== fov;

    this._changelog.fov = changed;

    this._fov = fov;

    if (changed)
    {
        this._setYaw(this._yaw);
        this._setPitch(this._pitch);
    }

    return changed;
};

/**
 * Compute the fov boundaries with yaw min and yaw max.
 * @method FORGE.Camera#_getFovBoundaries
 * @return {CameraBoundaries} Returns the min and max fov computed from the camera configuration and the view limits.
 * @private
 */
FORGE.Camera.prototype._getFovBoundaries = function()
{
    var min = this._fovMin;
    var max = this._fovMax;
    var view = this._viewer.renderer.view.current;

    // if JSON specifies a fov min (not default 0 value), use it
    // useful for multiresolution where fov limit will be computed depending
    // on max level of resolution available and stored in JSON
    if (this._viewer.renderer.backgroundRenderer !== null && "fovMin" in this._viewer.renderer.backgroundRenderer)
    {
        min = Math.max(this._viewer.renderer.backgroundRenderer.fovMin, min);
    }
    else if (min === 0)
    {
        if (view !== null)
        {
            min = Math.max(view.fovMin, min);
            max = Math.min(view.fovMax, max);
        }
    }

    if (view !== null && view.type !== FORGE.ViewType.FLAT)
    {
        // if there are limits, we may need to limit the maximum fov
        var pitchBoundaries = this._getPitchBoundaries(false);
        var pitchRange = pitchBoundaries.max - pitchBoundaries.min;

        if (pitchRange > 0)
        {
            max = Math.min(pitchRange, max);
        }

        var yawBoundaries = this._getYawBoundaries(false);
        var yawRange = yawBoundaries.max - yawBoundaries.min;
        yawRange /= this._viewer.renderer.displayResolution.ratio;

        if (yawRange > 0)
        {
            max = Math.min(yawRange, max);
        }

        // get the tiniest
        if (max < min)
        {
            min = max;
        }
    }

    return { min: min, max: max };
};

/**
 * Set all camera angles in one call (yaw, pitch, roll, fov)
 * @method FORGE.Camera#_setAll
 * @param {?number=} yaw - The yaw value you want to set.
 * @param {?number=} pitch - The pitch value you want to set.
 * @param {?number=} roll - The roll value you want to set.
 * @param {?number=} fov - The fov value you want to set.
 * @param {string=} unit - The unit you use for all the previous arguments (FORGE.Math.DEGREES or FORGE.Math.RADIANS)
 * @return {boolean} Returns true if any values has changed.
 * @private
 */
FORGE.Camera.prototype._setAll = function(yaw, pitch, roll, fov, unit)
{
    var fovChanged = this._setFov(fov, unit);
    var yawChanged = this._setYaw(yaw, unit);
    var pitchChanged = this._setPitch(pitch, unit);
    var rollChanged = this._setRoll(roll, unit);

    return (yawChanged === true || pitchChanged === true || rollChanged === true || fovChanged === true);
};

/**
 * Update internals after a remote component has changed something
 * @method FORGE.Camera#_updateInternals
 * @private
 */
FORGE.Camera.prototype._updateInternals = function()
{
    // Force camera to update its values to bound it in new boundaries after view change
    var changed = this._setAll(this._yaw, this._pitch, this._roll, this._fov);

    if (changed === true)
    {
        this._updateFromEuler();
    }
};

/**
 * Load a camera configuration.
 * @method FORGE.Camera#load
 * @param {CameraConfig} config - The camera configuration to load.
 */
FORGE.Camera.prototype.load = function(config)
{
    this._config = /** @type {CameraConfig} */ (FORGE.Utils.extendMultipleObjects(FORGE.Camera.DEFAULT_CONFIG, config));

    this._parseConfig(this._config);

    this._initialized = true;
};

/**
 * Set the Camera to look at a specified point into the yaw/pitch/roll space.
 * @method FORGE.Camera#lookAt
 * @param {?number=} yaw Euler yaw angle (deg)
 * @param {?number=} pitch Euler pitch angle (deg)
 * @param {?number=} roll Euler roll angle (deg)
 * @param {?number=} fov Field of view (deg)
 * @param {number=} durationMS - Rotation animation duration ms (undefined or zero means immediat effect)
 * @param {boolean=} [cancelRoll=false] - If set to true, roll will be cancelled (always at 0).<br> If false an auto roll movement will be done by the camera for a more natural movement effect.
 * @param {string=} easing - Easing method name (default to {@link FORGE.EasingType.LINEAR}).
 */
FORGE.Camera.prototype.lookAt = function(yaw, pitch, roll, fov, durationMS, cancelRoll, easing)
{
    if (typeof durationMS !== "number" || durationMS === 0)
    {
        var changed = this._setAll(yaw, pitch, roll, fov, FORGE.Math.DEGREES);

        if (changed === true)
        {
            this._updateFromEuler();
        }
    }
    else
    {
        if (fov !== null && typeof fov !== "undefined")
        {
            var fovBoundaries = this._getFovBoundaries();

            fov = FORGE.Math.clamp(fov, FORGE.Math.radToDeg(fovBoundaries.min), FORGE.Math.radToDeg(fovBoundaries.max));

            if (yaw !== null && typeof yaw !== "undefined")
            {
                var yawBoundaries = this._getYawBoundaries(true, FORGE.Math.degToRad(fov));
                yaw = FORGE.Math.clamp(yaw, FORGE.Math.radToDeg(yawBoundaries.min), FORGE.Math.radToDeg(yawBoundaries.max));
            }

            if (pitch !== null && typeof pitch !== "undefined")
            {
                var pitchBoundaries = this._getPitchBoundaries(true, FORGE.Math.degToRad(fov));
                pitch = FORGE.Math.clamp(pitch, FORGE.Math.radToDeg(pitchBoundaries.min), FORGE.Math.radToDeg(pitchBoundaries.max));
            }
        }

        // before creating a track, set the goto point in future boundaries
        var track = new FORGE.DirectorTrack(
        {
            easing:
            {
                default: easing || "LINEAR",
                start: 0
            },

            cancelRoll: Boolean(cancelRoll),

            keyframes:
            [
                {
                    time: durationMS,
                    data:
                    {
                        yaw: yaw,
                        pitch: pitch,
                        roll: roll,
                        fov: fov
                    }
                }
            ]
        });

        this.animation.play(track.uid);
    }
};

/**
 * Update routine called by render manager before rendering a frame.
 * All internals should be up to date.
 * @method FORGE.Camera#update
 */
FORGE.Camera.prototype.update = function()
{
    if (this._viewer.renderer.display.presentingVR === true)
    {
        this._gaze.update();
        this._updateVRCameras();
        this._cloneVRCamerasChildren();
    }

    this._updateMainCamera();
    this._updateFlatCamera();

    this._resetChangelog();
};

/**
 * Destroy sequence.
 * @method FORGE.Camera#destroy
 */
FORGE.Camera.prototype.destroy = function()
{
    this._modelView = null;
    this._modelViewInverse = null;
    this._quaternion = null;
    this._main = null;
    this._flat = null;

    this._gaze.destroy();
    this._gaze = null;

    this._viewer.renderer.view.onChange.remove(this._updateInternals, this);
    this._viewer.renderer.onBackgroundReady.remove(this._updateInternals, this);

    if (this._onChange !== null)
    {
        this._onChange.destroy();
        this._onChange = null;
    }

    if (this._onOrientationChange !== null)
    {
        this._onOrientationChange.destroy();
        this._onOrientationChange = null;
    }

    if (this._onFovChange !== null)
    {
        this._onFovChange.destroy();
        this._onFovChange = null;
    }

    if (this._cameraAnimation !== null)
    {
        this._cameraAnimation.destroy();
        this._cameraAnimation = null;
    }

    this._viewer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get and set the camera configuration (default min & max for all angles yaw, pitch, roll and fov).
 * @name FORGE.Camera#config
 * @type {CameraConfig}
 */
Object.defineProperty(FORGE.Camera.prototype, "config",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return this._config;
    },

    /** @this {FORGE.Camera} */
    set: function(config)
    {
        this.load(config);
    }
});

/**
 * Get the keep flag
 * @name FORGE.Camera#keep
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.Camera.prototype, "keep",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return this._keep;
    }
});

/**
 * Get and set the yaw value in degree.
 * @name FORGE.Camera#yaw
 * @type {number}
 */
Object.defineProperty(FORGE.Camera.prototype, "yaw",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return FORGE.Math.radToDeg(this._yaw);
    },

    /** @this {FORGE.Camera} */
    set: function(value)
    {
        var yawChanged = this._setYaw(value, FORGE.Math.DEGREES);

        if (yawChanged === true)
        {
            this._updateFromEuler();
        }
    }
});

/**
 * Get the yaw min value.
 * Return the most restrictive value between the camera value and the view value.
 * @name FORGE.Camera#yawMin
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Camera.prototype, "yawMin",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        var boundaries = this._getYawBoundaries();
        return FORGE.Math.radToDeg(boundaries.min);
    }
});

/**
 * Get the yaw max value.
 * Return the most restrictive value between the camera value and the view value.
 * @name FORGE.Camera#yawMax
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Camera.prototype, "yawMax",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        var boundaries = this._getYawBoundaries();
        return FORGE.Math.radToDeg(boundaries.max);
    }
});

/**
 * Get and set the pitch value in degree.
 * @name FORGE.Camera#pitch
 * @type {number}
 */
Object.defineProperty(FORGE.Camera.prototype, "pitch",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return FORGE.Math.radToDeg(this._pitch);
    },

    /** @this {FORGE.Camera} */
    set: function(value)
    {
        var pitchChanged = this._setPitch(value, FORGE.Math.DEGREES);

        if (pitchChanged)
        {
            this._updateFromEuler();
        }
    }
});

/**
 * Get the pitch min value.
 * Return the most restrictive value between the camera value and the view value.
 * @name FORGE.Camera#pitchMin
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Camera.prototype, "pitchMin",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        var boundaries = this._getPitchBoundaries();
        return FORGE.Math.radToDeg(boundaries.min);
    }
});

/**
 * Get the pitch max value.
 * Return the most restrictive value between the camera value and the view value.
 * @name FORGE.Camera#pitchMax
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Camera.prototype, "pitchMax",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        var boundaries = this._getPitchBoundaries();
        return FORGE.Math.radToDeg(boundaries.max);
    }
});

/**
 * Get and set the roll value in degree.
 * @name FORGE.Camera#roll
 * @type {number}
 */
Object.defineProperty(FORGE.Camera.prototype, "roll",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return FORGE.Math.radToDeg(this._roll);
    },

    /** @this {FORGE.Camera} */
    set: function(value)
    {
        var rollChanged = this._setRoll(value, FORGE.Math.DEGREES);

        if (rollChanged === true)
        {
            this._updateFromEuler();
        }
    }
});

/**
 * Get the roll min value.
 * Return the most restrictive value between the camera value and the view value.
 * @name FORGE.Camera#rollMin
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Camera.prototype, "rollMin",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        var boundaries = this._getRollBoundaries();
        return FORGE.Math.radToDeg(boundaries.min);
    }
});

/**
 * Get the roll max value.
 * Return the most restrictive value between the camera value and the view value.
 * @name FORGE.Camera#rollMax
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Camera.prototype, "rollMax",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        var boundaries = this._getRollBoundaries();
        return FORGE.Math.radToDeg(boundaries.max);
    }
});

/**
 * Get and set the fov value in degree.
 * @name FORGE.Camera#fov
 * @type {number}
 */
Object.defineProperty(FORGE.Camera.prototype, "fov",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return FORGE.Math.radToDeg(this._fov);
    },

    /** @this {FORGE.Camera} */
    set: function(value)
    {
        var fovChanged = this._setFov(value, FORGE.Math.DEGREES);

        if (fovChanged === true)
        {
            this._updateFromEuler();
        }
    }
});

/**
 * Get the fov min value.
 * Return the most restrictive value between the camera value and the view value.
 * @name FORGE.Camera#fovMin
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Camera.prototype, "fovMin",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        var boundaries = this._getFovBoundaries();
        return FORGE.Math.radToDeg(boundaries.min);
    }
});

/**
 * Get the fov max value.
 * Return the most restrictive value between the camera value and the view value.
 * @name FORGE.Camera#fovMax
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Camera.prototype, "fovMax",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        var boundaries = this._getFovBoundaries();
        return FORGE.Math.radToDeg(boundaries.max);
    }
});

/**
 * Get/set quaternion rotation object of the camera.
 * Setter will update internal quaternion object
 * @name FORGE.Camera#quaternion
 * @readonly
 * @type {THREE.Quaternion}
 */
Object.defineProperty(FORGE.Camera.prototype, "quaternion",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return this._quaternion;
    },
    /** @this {FORGE.Camera} */
    set: function(value)
    {
        this._quaternion = value;
        this._updateFromQuaternion();
        this._updateComplete();
    }
});

/**
 * Get camera animation manager.
 * @name FORGE.Camera#animation
 * @readonly
 * @type {FORGE.CameraAnimation}
 */
Object.defineProperty(FORGE.Camera.prototype, "animation",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        if (this._cameraAnimation === null)
        {
            this._cameraAnimation = new FORGE.CameraAnimation(this._viewer, this);
        }

        return this._cameraAnimation;
    }
});

/**
 * Get/Set parallax setting.
 * @name FORGE.Camera#parallax
 * @type number
 */
Object.defineProperty(FORGE.Camera.prototype, "parallax",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return this._parallax;
    },
    /** @this {FORGE.Camera} */
    set: function(value)
    {
        this._parallax = FORGE.Math.clamp(value, 0, 1);
        this._radius = this._parallax * FORGE.Camera.RADIUS;
        this._updateComplete();
    }
});

/**
 * Get the modelView of the camera.
 * @name FORGE.Camera#modelView
 * @type {THREE.Matrix4}
 */
Object.defineProperty(FORGE.Camera.prototype, "modelView",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return this._modelView;
    },
    /** @this {FORGE.Camera} */
    set: function(value)
    {
        this._modelView = value;
        this._updateFromMatrix();
        this._updateComplete();
    }
});

/**
 * Get the modelViewInverse of the camera.
 * @name FORGE.Camera#modelViewInverse
 * @readonly
 * @type {THREE.Matrix4}
 */
Object.defineProperty(FORGE.Camera.prototype, "modelViewInverse",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return this._modelViewInverse;
    }
});

/**
 * Get the main THREE.PerspectiveCamera of the camera.
 * @name FORGE.Camera#main
 * @readonly
 * @type {THREE.PerspectiveCamera}
 */
Object.defineProperty(FORGE.Camera.prototype, "main",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        if (this._main === null)
        {
            this._createMainCamera();
        }

        return this._main;
    }
});

/**
 * Get the flat THREE.OrthographicCamera of the camera.
 * @name FORGE.Camera#flat
 * @readonly
 * @type {THREE.OrthographicCamera}
 */
Object.defineProperty(FORGE.Camera.prototype, "flat",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        if (this._flat === null)
        {
            this._createFlatCamera();
        }

        return this._flat;
    }
});

/**
 * Get the THREE.PerspectiveCamera radius.
 * @name FORGE.Camera#perspectiveCameraRadius
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.Camera.prototype, "perspectiveCameraRadius",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return this._radius;
    }
});

/**
 * Get the left camera.
 * @name FORGE.Camera#left
 * @type {THREE.PerspectiveCamera}
 * @readonly
 */
Object.defineProperty(FORGE.Camera.prototype, "left",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return this._left;
    }
});

/**
 * Get the right camera.
 * @name FORGE.Camera#right
 * @type {THREE.PerspectiveCamera}
 * @readonly
 */
Object.defineProperty(FORGE.Camera.prototype, "right",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return this._right;
    }
});

/**
 * Get the camera gaze.
 * @name FORGE.Camera#gaze
 * @readonly
 * @type {FORGE.CameraGaze}
 */
Object.defineProperty(FORGE.Camera.prototype, "gaze",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        return this._gaze;
    }
});

/**
 * Get the "onChange" {@link FORGE.EventDispatcher} of the camera.
 * @name FORGE.Camera#onChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Camera.prototype, "onChange",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        if (this._onChange === null)
        {
            this._onChange = new FORGE.EventDispatcher(this);
        }

        return this._onChange;
    }
});

/**
 * Get the "onOrientationChange" {@link FORGE.EventDispatcher} of the camera.
 * @name FORGE.Camera#onOrientationChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Camera.prototype, "onOrientationChange",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        if (this._onOrientationChange === null)
        {
            this._onOrientationChange = new FORGE.EventDispatcher(this);
        }

        return this._onOrientationChange;
    }
});

/**
 * Get the "onFovChange" {@link FORGE.EventDispatcher} of the camera.
 * @name FORGE.Camera#onFovChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Camera.prototype, "onFovChange",
{
    /** @this {FORGE.Camera} */
    get: function()
    {
        if (this._onFovChange === null)
        {
            this._onFovChange = new FORGE.EventDispatcher(this);
        }

        return this._onFovChange;
    }
});

/**
 * A FORGE.CameraAnimation is used by the camera to animate along keyframes.
 *
 * @constructor FORGE.CameraAnimation
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {FORGE.Camera} camera - {@link FORGE.Camera} reference.
 * @extends {FORGE.MetaAnimation}
 *
 */
FORGE.CameraAnimation = function(viewer, camera)
{
    FORGE.MetaAnimation.call(this, viewer, camera, "CameraAnimation");

    this._boot();
};

FORGE.CameraAnimation.prototype = Object.create(FORGE.MetaAnimation.prototype);
FORGE.CameraAnimation.prototype.constructor = FORGE.CameraAnimation;

/**
 * Init sequence
 * @method FORGE.CameraAnimation#_boot
 * @private
 */
FORGE.CameraAnimation.prototype._boot = function()
{
    this._register();

    // Add the cancel roll effect
    var cameraAt = function()
    {
        if (this._instruction.cancelRoll === true)
        {
            this._target.quaternion = FORGE.Quaternion.cancelRoll(this._target.quaternion);
        }
    };

    this._instructions =
    [
        {
            prop: "quaternion",
            smooth: true,
            fun: cameraAt,
            cancelRoll: true
        },

        {
            prop: "fov",
            smooth: false
        }
    ];
};

/**
 * Load a camera animation keyframes configuration.<br>
 * Convert keyframe into timeline keyframes.
 *
 * @method FORGE.CameraAnimation#_prepareKeyframes
 * @param {Array<FORGE.Keyframe>} tracks - the array containing the keyframes
 * @param {number} offset - the time to take between the current position of the camera to the first keyframe.
 * @param {Function} easing - The easing function for this animation
 * @private
 */
FORGE.CameraAnimation.prototype._prepareKeyframes = function(tracks, offset, easing)
{
    offset = offset || 0;

    var kf, data, yaw, pitch, roll, fov, quat;

    // Add a keyframe for each one in the configuration
    for (var i = 0, ii = tracks.length; i < ii; i++)
    {
        data = tracks[i].data;

        // Quaternion
        yaw = (typeof data.yaw !== "undefined" && data.yaw !== null) ? data.yaw : this._computeIntermediateValue(tracks[i].time + offset, tracks, "yaw", easing);
        pitch = (typeof data.pitch !== "undefined" && data.pitch !== null) ? data.pitch : this._computeIntermediateValue(tracks[i].time + offset, tracks, "pitch", easing);
        roll = (typeof data.roll !== "undefined" && data.roll !== null) ? data.roll : this._computeIntermediateValue(tracks[i].time + offset, tracks, "roll", easing);

        yaw = FORGE.Math.degToRad(yaw);
        pitch = FORGE.Math.degToRad(pitch);
        roll = FORGE.Math.degToRad(roll);

        if (typeof yaw !== "undefined" && yaw !== null && typeof pitch !== "undefined" && pitch !== null && typeof roll !== "undefined" && roll !== null)
        {
            quat = FORGE.Quaternion.fromEuler(yaw, pitch, roll);

            kf = new FORGE.Keyframe(tracks[i].time + offset, { quaternion: quat });
            this._animations[0].timeline.addKeyframe(kf);
        }

        // FOV
        if (typeof data.fov !== "undefined" && data.fov !== null)
        {
            fov = data.fov;
            kf = new FORGE.Keyframe(tracks[i].time + offset, { fov: fov });
            this._animations[1].timeline.addKeyframe(kf);
        }
    }

    // If the first keyframe is not at time 0 or there is an offset, add a
    // virtual keyframe
    if (tracks[0].time > 0 || offset > 0)
    {
        kf = new FORGE.Keyframe(0, { quaternion: FORGE.Utils.clone(this._target.quaternion) });
        this._animations[0].timeline.addKeyframe(kf);

        kf = new FORGE.Keyframe(0, { fov: this._target.fov });
        this._animations[1].timeline.addKeyframe(kf);
    }
};

/**
 * Start to move along the keyframes.
 *
 * @method FORGE.CameraAnimation#play
 * @param {string|FORGE.DirectorTrack} track - Track to play
 * @param {number=} time - Time to start the animation at
 */
FORGE.CameraAnimation.prototype.play = function(track, time)
{
    if (typeof track === "string")
    {
        track = FORGE.UID.get(track);
    }

    this._emptyAnimations();

    // First instruction - quaternion
    var quatAnimation = new FORGE.Animation(this._viewer, this._target);
    quatAnimation.tween.easing = track.easing;
    quatAnimation.instruction = this._instructions[0];
    quatAnimation.instruction.smooth = track.smooth;
    quatAnimation.smooth = track.smooth;
    quatAnimation.instruction.cancelRoll = track.cancelRoll;
    quatAnimation.onComplete.add(this._onTrackPartialCompleteHandler, this);
    this._animations.push(quatAnimation);

    // Second instruction - fov
    var fovAnimation = new FORGE.Animation(this._viewer, this._target);
    fovAnimation.tween.easing = track.easing;
    fovAnimation.instruction = this._instructions[1];
    fovAnimation.instruction.smooth = track.smooth;
    fovAnimation.onComplete.add(this._onTrackPartialCompleteHandler, this);
    this._animations.push(fovAnimation);

    // Prepare the keyframes
    this._prepareKeyframes(track.keyframes, track.offset, quatAnimation.tween.easing);

    // Play !
    quatAnimation.play(time);
    fovAnimation.play(time);
};

/**
 * Destroy sequence.
 * @method FORGE.CameraAnimation#destroy
 */
FORGE.CameraAnimation.prototype.destroy = function()
{
    FORGE.MetaAnimation.prototype.destroy.call(this);
};

/**
 * Gaze Cursor base class. Draw a geometry on the camera space for gaze selection.
 *
 * @constructor FORGE.CameraGaze
 * @param {FORGE.Viewer} viewer - viewer reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.CameraGaze = function(viewer, config)
{
    /**
     * The viewer reference.
     * @name FORGE.CameraGaze#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The gaze configuration object
     * @name  FORGE.CameraGaze#_config
     * @type {CameraGazeConfig}
     * @private
     */
    this._config = config;

    /**
     * THREE object
     * @name FORGE.CameraGaze#_object
     * @type {THREE.Object3D}
     * @private
     */
    this._object = null;

    /**
     * Flag to know if the gaze cursor is hovering an object
     * @name FORGE.CameraGaze#_hovering
     * @type {boolean}
     * @private
     */
    this._hovering = false;

    /**
     * Timer for delayed click by gaze
     * @name FORGE.CameraGaze#_timer
     * @type {FORGE.Timer}
     * @private
     */
    this._timer = null;

    /**
     * Timer event used by a current countdown forn click by gaze.
     * @name FORGE.CameraGaze#_timerEvent
     * @type {FORGE.TimerEvent}
     * @private
     */
    this._timerEvent = null;

    /**
     * The percentage of progress to have a valid gaze interaction.
     * @name  FORGE.CameraGaze#_progress
     * @type {number}
     * @private
     */
    this._progress = 0;

    FORGE.BaseObject.call(this, "CameraGaze");

    this._boot();
};

FORGE.CameraGaze.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.CameraGaze.prototype.constructor = FORGE.CameraGaze;

/**
 * Boot sequence.
 * @method FORGE.CameraGaze#_boot
 * @private
 */
FORGE.CameraGaze.prototype._boot = function()
{
    this._timer = this._viewer.clock.create(false);

    this._object = new THREE.Object3D();
    this._object.name = "CameraGaze";
    this._object.position.z = -2;

    this._createCursor();
};

/**
 * Create ring geometry.
 * @method FORGE.CameraGaze#_createRingGeometry
 * @param {number=} [innerRadius=0.02] Inner radius of the ring.
 * @param {number=} [outerRadius=0.04] OuterRadius of the ring.
 * @param {number=} [thetaSegments=32] Number of theta segments on the ring.
 * @param {number=} [phiSegments=1] Number of phi segments on the ring.
 * @param {number=} [thetaStart=0] Thetha start.
 * @param {number=} [thetaLength=6.28] Thetha length, default is two PI.
 * @return {THREE.BufferGeometry} The ring geometry.
 * @private
 */
FORGE.CameraGaze.prototype._createRingGeometry = function(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength)
{
    innerRadius = innerRadius || 0.02;
    outerRadius = outerRadius || 0.04;
    thetaSegments = thetaSegments || 32;
    phiSegments = phiSegments || 1;
    thetaStart = thetaStart || 0;
    thetaLength = thetaLength || Math.PI * 2;

    var geometry = new THREE.RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength);

    return geometry;
};

/**
 * Create the base cursor based on its configuration
 * @method FORGE.CameraGaze#_createCursor
 * @private
 */
FORGE.CameraGaze.prototype._createCursor = function()
{
    var material = new THREE.MeshBasicMaterial(
    {
        color: this._config.cursor.color,
        opacity: this._config.cursor.opacity,
        transparent: true
    });

    var ring = new THREE.Mesh(this._createRingGeometry(this._config.cursor.innerRadius, this._config.cursor.outerRadius), material);
    ring.name = "cursor";

    this._object.add(ring);
};

/**
 * Update the second ring according to the progress percentage of the timer event.
 * @method FORGE.CameraGaze#_updateProgressRing
 * @param  {number} progress - The progress percentage of the timer.
 * @private
 */
FORGE.CameraGaze.prototype._updateProgressRing = function(progress)
{
    this._progress = progress;

    this._destroyRing("progress");

    this._createProgress();
};

/**
 * Create the progress cursor based on its configuration and the percentage of progress
 * @method FORGE.CameraGaze#_createProgress
 * @private
 */
FORGE.CameraGaze.prototype._createProgress = function()
{
    var material = new THREE.MeshBasicMaterial(
    {
        color: this._config.progress.color,
        opacity: this._config.progress.opacity,
        transparent: true,
        side: THREE.DoubleSide
    });

    var thetaLength = (this._progress / 100) * FORGE.Math.TWOPI;

    var ring = new THREE.Mesh(this._createRingGeometry(this._config.progress.innerRadius, this._config.progress.outerRadius, 32, 1, (Math.PI / 2), thetaLength), material);
    ring.name = "progress";
    ring.rotateY(Math.PI);

    this._object.add(ring);
};

/**
 * Destroy a ring from its name
 * @method FORGE.CameraGaze#_destroyRing
 * @param {string} name - The name of the ring to destroy
 * @private
 */
FORGE.CameraGaze.prototype._destroyRing = function(name)
{
    var ring = null;

    for (var i = 0, ii = this._object.children.length; i < ii; i++)
    {
        if (this._object.children[i].name === name)
        {
            ring = this._object.children[i];
        }
    }

    if (ring !== null)
    {
        this._object.remove(ring);

        ring.geometry.dispose();
        ring.material.dispose();
    }
};

/**
 * Timer complete handler, triggers the click action!
 * @method FORGE.CameraGaze#_timerCompleteHandler
 * @private
 */
FORGE.CameraGaze.prototype._timerCompleteHandler = function()
{
    this.stop();

    this._viewer.renderer.pickingManager.click();
};

/**
 * Loads a configuration for gaze cursors.
 * @method FORGE.CameraGaze#load
 * @param {CameraGazeConfig} config -  The configuration to load.
 */
FORGE.CameraGaze.prototype.load = function(config)
{
    this._config = config;

    this._destroyRing("progress");
    this._destroyRing("cursor");

    this._createCursor();

    if (this._hovering === true && this._progress !== 0)
    {
        this._createProgress();
    }
};

/**
 * Starts the gaze timer, this is called from the raycaster.
 * @method FORGE.CameraGaze#start
 */
FORGE.CameraGaze.prototype.start = function()
{
    this.log("startGazeAnimation");

    this._hovering = true;

    this._updateProgressRing(0);

    if (this._timer !== null)
    {
        var delay = 2000 || this._config.delay;

        this._timer.stop();
        this._timerEvent = this._timer.add( /** @type {number} */ (delay), this._timerCompleteHandler, this);
        this._timer.start();
    }
};

/**
 * Stops the gaze timer, this is called from the raycaster.
 * @method FORGE.CameraGaze#stop
 */
FORGE.CameraGaze.prototype.stop = function()
{
    this.log("stopGazeAnimation");

    this._hovering = false;

    this._timer.stop();
    this._timerEvent = null;

    this._progress = 0;

    var ring = this._object.children[1];

    if (typeof ring !== "undefined" && ring !== null)
    {
        this._object.remove(ring);

        ring.geometry.dispose();
        ring.material.dispose();
    }
};

/**
 * Update loop of the gaze cursor, it updates the graphics according to the progress percentage of the timer.
 * @method FORGE.CameraGaze#update
 */
FORGE.CameraGaze.prototype.update = function()
{
    if (this._hovering === true && this._timerEvent !== null)
    {
        var percent = (this._timerEvent.delay - this._timer.duration) * 100 / this._timerEvent.delay;
        this.log("timer update : " + percent + "%");

        this._updateProgressRing(percent);
    }
};

/**
 * Destroy sequence.
 * @method FORGE.CameraGaze#destroy
 */
FORGE.CameraGaze.prototype.destroy = function()
{
    this.stop();

    if (this._object !== null)
    {
        if (typeof this._object.geometry !== "undefined" && this._object.geometry !== null)
        {
            this._object.geometry.dispose();
        }

        if (typeof this._object.material !== "undefined" && this._object.material !== null)
        {
            this._object.material.dispose();
        }

        this._object = null;
    }

    this._scene = null;
};

/**
 * Visibility flag.
 * @name FORGE.CameraGaze#visible
 * @type {boolean}
 */
Object.defineProperty(FORGE.CameraGaze.prototype, "visible",
{
    /** @this {FORGE.CameraGaze} */
    get: function()
    {
        return this._object.visible;
    },

    /** @this {FORGE.CameraGaze} */
    set: function(value)
    {
        this._object.visible = value;
    }
});

/**
 * 3D object
 * @name FORGE.CameraGaze#object
 * @readonly
 * @type {THREE.Mesh}
 */
Object.defineProperty(FORGE.CameraGaze.prototype, "object",
{
    /** @this {FORGE.CameraGaze} */
    get: function()
    {
        return this._object;
    }
});

/**
 * @namespace {Object} FORGE.ControllerType
 */
FORGE.ControllerType = {};

/**
 * @name FORGE.ControllerType.BASE
 * @type {string}
 * @const
 */
FORGE.ControllerType.BASE = "base";

/**
 * @name FORGE.ControllerType.POINTER
 * @type {string}
 * @const
 */
FORGE.ControllerType.POINTER = "pointer";

/**
 * @name FORGE.ControllerType.KEYBOARD
 * @type {string}
 * @const
 */
FORGE.ControllerType.KEYBOARD = "keyboard";

/**
 * @name FORGE.ControllerType.GYROSCOPE
 * @type {string}
 * @const
 */
FORGE.ControllerType.GYROSCOPE = "gyroscope";

/**
 * @name FORGE.ControllerType.GAMEPAD
 * @type {string}
 * @const
 */
FORGE.ControllerType.GAMEPAD = "gamepad";


/**
 * @constructor FORGE.ControllerManager
 * @param {FORGE.Viewer} viewer - viewer reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.ControllerManager = function(viewer)
{
    /**
     * Viewer reference.
     * @name FORGE.ControllerManager#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Array of controllers.
     * @name FORGE.ControllerManager#_controllers
     * @type {Array<FORGE.ControllerBase>}
     * @private
     */
    this._controllers = [];

    /**
     * Enabled flag.
     * @name  FORGE.ControllerManager#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * Event dispatcher for control start.
     * @name FORGE.ControllerManager#_onControlStart
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onControlStart = null;

    /**
     * Event dispatcher for control end.
     * @name FORGE.ControllerManager#_onControlEnd
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onControlEnd = null;

    FORGE.BaseObject.call(this, "ControllerManager");
};

FORGE.ControllerManager.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.ControllerManager.prototype.constructor = FORGE.ControllerManager;

/**
 * Controllers default configuration
 * @name  FORGE.ControllerManager.DEFAULT_CONFIG
 * @const
 */
FORGE.ControllerManager.DEFAULT_CONFIG =
{
    enabled: true,

    instances:
    [
        {
            type: FORGE.ControllerType.POINTER,
            enabled: true
        },

        {
            type: FORGE.ControllerType.KEYBOARD,
            enabled: true
        },

        {
            type: FORGE.ControllerType.GYROSCOPE,
            enabled: true
        },

        {
            type: FORGE.ControllerType.GAMEPAD,
            enabled: true
        }
    ]
};

/**
 * Parse configuration object
 * @method FORGE.ControllerManager#_parseConfig
 * @param {ControllersConfig} config - The config you want to add.
 * @private
 */
FORGE.ControllerManager.prototype._parseConfig = function(config)
{
    this._enabled = (typeof config.enabled === "boolean") ? config.enabled : true;

    if(typeof config.instances !== "undefined")
    {
        var controllerConfig;
        var controller;

        for(var i = 0, ii = config.instances.length; i < ii; i++)
        {
            controllerConfig = config.instances[i];

            switch(controllerConfig.type)
            {
                case FORGE.ControllerType.POINTER:
                    controller = new FORGE.ControllerPointer(this._viewer, controllerConfig);
                    break;

                case FORGE.ControllerType.KEYBOARD:
                    controller = new FORGE.ControllerKeyboard(this._viewer, controllerConfig);
                    break;

                case FORGE.ControllerType.GYROSCOPE:
                    controller = new FORGE.ControllerGyroscope(this._viewer, controllerConfig);
                    break;

                case FORGE.ControllerType.GAMEPAD:
                    controller = new FORGE.ControllerGamepad(this._viewer, controllerConfig);
                    break;

                default:
                    controller = null;
                    break;
            }

            if(controller !== null)
            {
                this._controllers.push(controller);
            }
        }
    }
};

/**
 * Controllers will call this method to notify the manager that a control start.
 * @method FORGE.ControllerManager#notifyControlStart
 * @param  {FORGE.ControllerBase} controller - The controller that notifies the manager.
 */
FORGE.ControllerManager.prototype.notifyControlStart = function(controller)
{
    if(this._onControlStart !== null)
    {
        this._onControlStart.dispatch({"controller": controller});
    }
};

/**
 * Controllers will call this method to notify the manager that a controller ends.
 * @method FORGE.ControllerManager#notifyControlEnd
 * @param  {FORGE.ControllerBase} controller - The controller that notifies the manager.
 */
FORGE.ControllerManager.prototype.notifyControlEnd = function(controller)
{
    if(this._onControlEnd !== null)
    {
        this._onControlEnd.dispatch({"controller": controller});
    }
};

/**
 * Controllers update routine
 * @method FORGE.ControllerManager#update
 */
FORGE.ControllerManager.prototype.update = function()
{
    if (this._controllers === null)
    {
        return;
    }

    for(var i = 0, ii = this._controllers.length; i < ii; i++)
    {
        if (typeof this._controllers[i].update === "function")
        {
            this._controllers[i].update();
        }
    }
};

/**
 * Add a config to the manager.
 * @method FORGE.ControllerManager#addConfig
 * @param {ControllersConfig} config - The config you want to add.
 */
FORGE.ControllerManager.prototype.addConfig = function(config)
{
    config = (typeof config !== "undefined") ? config : FORGE.ControllerManager.DEFAULT_CONFIG;

    this._parseConfig(config);
};

/**
 * Get a controller by its type.
 * @method FORGE.ControllerManager#getByType
 * @param {string} type - The type of the controller you want to get.
 * @return {?FORGE.ControllerBase} return the desired type controller, null if not found
 */
FORGE.ControllerManager.prototype.getByType = function(type)
{
    var controller;

    for(var i = 0, ii = this._controllers.length; i < ii; i++)
    {
        controller = this._controllers[i];

        if(controller.type === type)
        {
            return controller;
        }
    }

    return null;
};

/**
 * Destroy method.
 */
FORGE.ControllerManager.prototype.destroy = function()
{
    var ctrl;

    while(this._controllers.length)
    {
        ctrl = this._controllers.pop();
        if (ctrl !== null && typeof ctrl !== "undefined")
        {
            ctrl.destroy();
        }
    }

    this._controllers = null;

    if(this._onControlStart !== null)
    {
        this._onControlStart.destroy();
        this._onControlStart = null;
    }

    if(this._onControlEnd !== null)
    {
        this._onControlEnd.destroy();
        this._onControlEnd = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get all controllers.
 * @name FORGE.ControllerManager#all
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.ControllerManager.prototype, "all",
{
    /** @this {FORGE.ControllerManager} */
    get: function()
    {
        return this._controllers;
    }
});

/**
 * Get or set the global enabled flag.
 * @name FORGE.ControllerManager#enabled
 * @type {boolean}
 */
Object.defineProperty(FORGE.ControllerManager.prototype, "enabled",
{
    /** @this {FORGE.ControllerManager} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {FORGE.ControllerManager} */
    set: function(value)
    {
        this._enabled = Boolean(value);
    }
});

/**
 * know if any of the controllers is currently in use
 * @name FORGE.ControllerManager#active
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.ControllerManager.prototype, "active",
{
    /** @this {FORGE.ControllerManager} */
    get: function()
    {
        for(var i = 0, ii = this._controllers.length; i < ii; i++)
        {
            if(this._controllers[i].active === true)
            {
                return true;
            }
        }

        return false;
    }
});

/**
 * Get the "onControlStart" {@link FORGE.EventDispatcher} of the camera controller.
 * @name FORGE.ControllerManager#onControlStart
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.ControllerManager.prototype, "onControlStart",
{
    /** @this {FORGE.ControllerManager} */
    get: function()
    {
        if(this._onControlStart === null)
        {
            this._onControlStart = new FORGE.EventDispatcher(this);
        }

        return this._onControlStart;
    }
});

/**
 * Get the "onControlEnd" {@link FORGE.EventDispatcher} of the camera controller.
 * @name FORGE.ControllerManager#onControlEnd
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.ControllerManager.prototype, "onControlEnd",
{
    /** @this {FORGE.ControllerManager} */
    get: function()
    {
        if(this._onControlEnd === null)
        {
            this._onControlEnd = new FORGE.EventDispatcher(this);
        }

        return this._onControlEnd;
    }
});

/**
 * FORGE.ControllerBase
 * CameraBaseController class.
 *
 * Base controller class
 *
 * @constructor FORGE.ControllerBase
 * @param {FORGE.Viewer} viewer - viewer reference.
 * @param {string=} className - subclass className
 * @extends {FORGE.BaseObject}
 */
FORGE.ControllerBase = function(viewer, className)
{
    /**
     * Viewer reference
     * @type {FORGE.Viewer}
     * @name FORGE.ControllerBase#_viewer
     * @private
     */
    this._viewer = viewer;

    /**
     * Type of the controller
     * @name FORGE.ControllerBase#_type
     * @type {string}
     * @private
     */
    this._type = FORGE.ControllerType.BASE;

    /**
     * Main camera reference.
     * @type {FORGE.Camera}
     * @name FORGE.ControllerBase#_camera
     * @private
     */
    this._camera = null;

    /**
     * Enabled state flag.
     * @type {boolean}
     * @name FORGE.ControllerBase#_enabled
     * @private
     */
    this._enabled = false;

    /**
     * Active state flag.
     * @type {boolean}
     * @name FORGE.ControllerBase#_active
     * @private
     */
    this._active = false;

    /**
     * Control start event handler.
     * @type {FORGE.EventDispatcher}
     * @name FORGE.ControllerBase#_onControlStart
     * @private
     */
    this._onControlStart = null;

    /**
     * Control end event handler.
     * @type {FORGE.EventDispatcher}
     * @name FORGE.ControllerBase#_onControlEnd
     * @private
     */
    this._onControlEnd = null;

    FORGE.BaseObject.call(this, className || "ControllerBase");

    this._boot();
};

FORGE.ControllerBase.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.ControllerBase.prototype.constructor = FORGE.ControllerBase;

/**
 * Boot sequence.
 * @method FORGE.ControllerBase#_boot
 * @private
 */
FORGE.ControllerBase.prototype._boot = function()
{
    this._viewer.canvas.pointer.enabled = true;

    this._camera = this._viewer.renderer.camera;
};

/**
 * Enable control.
 * @method FORGE.ControllerBase#enable
 */
FORGE.ControllerBase.prototype.enable = function()
{
    if(this._enabled === true)
    {
        return;
    }

    this._enabled = true;
};

/**
 * Disable control.
 * @method FORGE.ControllerBase#disable
 */
FORGE.ControllerBase.prototype.disable = function()
{
    if(this._enabled === false)
    {
        return;
    }

    this._enabled = false;
};

/**
 * Destroy sequence.
 * @method FORGE.ControllerBase#destroy
 * @private
 */
FORGE.ControllerBase.prototype.destroy = function()
{
    this._camera = null;
    this._viewer = null;

    if(this._onControlStart !== null)
    {
        this._onControlStart.destroy();
        this._onControlStart = null;
    }

    if(this._onControlEnd !== null)
    {
        this._onControlEnd.destroy();
        this._onControlEnd = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get or set the enabled flag.
 * @name FORGE.ControllerBase#enabled
 * @type {boolean}
 */
Object.defineProperty(FORGE.ControllerBase.prototype, "enabled",
{
    /** @this {FORGE.ControllerBase} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {FORGE.ControllerBase} */
    set: function(value)
    {
        if(Boolean(value) === true)
        {
            this.enable();
        }
        else
        {
            this.disable();
        }
    }
});

/**
 * Get type of the controller.
 * @name FORGE.ControllerBase#type
 * @type {string}
 * @readonly
 */
Object.defineProperty(FORGE.ControllerBase.prototype, "type",
{
    /** @this {FORGE.ControllerBase} */
    get: function()
    {
        return this._type;
    }
});

/**
 * Get the "active" flag of the camera controller. A controller is active when it is currently in use.
 * @name FORGE.ControllerBase#active
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.ControllerBase.prototype, "active",
{
    /** @this {FORGE.ControllerBase} */
    get: function()
    {
        return this._active;
    }
});

/**
 * Get the "onControlStart" {@link FORGE.EventDispatcher} of the camera controller.
 * @name FORGE.ControllerBase#onControlStart
 * @type {FORGE.EventDispatcher}
 * @readonly
 */
Object.defineProperty(FORGE.ControllerBase.prototype, "onControlStart",
{
    /** @this {FORGE.ControllerBase} */
    get: function()
    {
        if(this._onControlStart === null)
        {
            this._onControlStart = new FORGE.EventDispatcher(this);
        }

        return this._onControlStart;
    }
});

/**
 * Get the "onControlEnd" {@link FORGE.EventDispatcher} of the camera controller.
 * @name FORGE.ControllerBase#onControlEnd
 * @type {FORGE.EventDispatcher}
 * @readonly
 */
Object.defineProperty(FORGE.ControllerBase.prototype, "onControlEnd",
{
    /** @this {FORGE.ControllerBase} */
    get: function()
    {
        if(this._onControlEnd === null)
        {
            this._onControlEnd = new FORGE.EventDispatcher(this);
        }

        return this._onControlEnd;
    }
});

/**
 * This controller takes mouse and touch events on screen to animate camera moves.
 *
 * @constructor FORGE.ControllerPointer
 * @param {FORGE.Viewer} viewer - viewer reference.
 * @param {ControllerInstanceConfig} config - the configuration of the controller
 * @extends {FORGE.ControllerBase}
 */
FORGE.ControllerPointer = function(viewer, config)
{
    /**
     * Configuration
     * @name FORGE.ControllerPointer#_config
     * @type {ControllerInstanceConfig}
     * @private
     */
    this._config = config;

    /**
     * Orientation controller configuration.
     * @name FORGE.ControllerPointer#_orientation
     * @type {ControllerOrientationConfig}
     * @private
     */
    this._orientation;

    /**
     * Zoom controller configuration.
     * @name FORGE.ControllerPointer#_zoom
     * @type {ControllerZoomConfig}
     * @private
     */
    this._zoom;

    /**
     * Fullscreen configuration.
     * @name FORGE.ControllerPointer#_fullscreen
     * @type {boolean}
     * @private
     */
    this._fullscreen = true;

    /**
     * Start position vector.
     * @name FORGE.ControllerPointer#_positionStart
     * @type {THREE.Vector2}
     * @private
     */
    this._positionStart = null;

    /**
     * Current position vector.
     * @name FORGE.ControllerPointer#_positionCurrent
     * @type {THREE.Vector2}
     * @private
     */
    this._positionCurrent = null;

    /**
     * Previous position vector.
     * @name FORGE.ControllerPointer#_positionPrevious
     * @type {THREE.Vector2}
     * @private
     */
    this._positionPrevious = null;

    /**
     * The fov value when you start to pinch in/out
     * @name FORGE.ControllerPointer#_pinchStartFov
     * @type {number}
     * @private
     */
    this._pinchStartFov = 0;

    /**
     * This is used when we have reached the minimum or maximum scale,
     * in order not to have a "no-effect" zone when zooming the other way
     * @name FORGE.ControllerPointer#_pinchScaleFactorCorrection
     * @type {number}
     * @private
     */
    this._pinchScaleFactorCorrection = 1;

    /**
     * Current velocity vector.
     * @name FORGE.ControllerPointer#_velocity
     * @type {THREE.Vector2}
     * @private
     */
    this._velocity = null;

    /**
     * Previous velocity vector.
     * @name FORGE.ControllerPointer#_inertia
     * @type {THREE.Vector2}
     * @private
     */
    this._inertia = null;

    /**
     * Panning flag.
     * @name FORGE.ControllerPointer#_panning
     * @type {boolean}
     * @private
     */
    this._panning = false;

    FORGE.ControllerBase.call(this, viewer, "ControllerPointer");
};

FORGE.ControllerPointer.prototype = Object.create(FORGE.ControllerBase.prototype);
FORGE.ControllerPointer.prototype.constructor = FORGE.ControllerPointer;

/**
 * Default configuration
 * @name {FORGE.ControllerPointer.DEFAULT_OPTIONS}
 * @type {ControllerPointerConfig}
 */
FORGE.ControllerPointer.DEFAULT_OPTIONS =
{
    fullscreen: true,

    orientation:
    {
        drag: false,
        hardness: 0.6, //Hardness factor impatcing controller response to some instant force.
        damping: 0.15, //Damping factor controlling inertia.
        velocityMax: 300,
        invert: {
            x: false,
            y: false
        }
    },

    zoom:
    {
        hardness: 5,
        invert: false,
        toPointer: false
    }
};

/**
 * Boot sequence.
 * @method FORGE.ControllerPointer#_boot
 * @private
 */
FORGE.ControllerPointer.prototype._boot = function()
{
    FORGE.ControllerBase.prototype._boot.call(this);

    this._type = FORGE.ControllerType.POINTER;

    this._inertia = new THREE.Vector2();
    this._velocity = new THREE.Vector2();
    this._positionStart = new THREE.Vector2();
    this._positionPrevious = new THREE.Vector2();
    this._positionCurrent = new THREE.Vector2();

    this._parseConfig(this._config);

    if(this._enabled === true)
    {
        this.enable();
    }
};

/**
 * Parse the configuration.
 * @method FORGE.ControllerPointer#_parseConfig
 * @param {ControllerInstanceConfig} config - configuration object to parse
 */
FORGE.ControllerPointer.prototype._parseConfig = function(config)
{
    this._uid = config.uid;
    this._register();

    var options = config.options || {};

    this._orientation = /** @type {ControllerOrientationConfig} */ (FORGE.Utils.extendMultipleObjects(FORGE.ControllerPointer.DEFAULT_OPTIONS.orientation, options.orientation));
    this._zoom = /** @type {ControllerZoomConfig} */ (FORGE.Utils.extendMultipleObjects(FORGE.ControllerPointer.DEFAULT_OPTIONS.zoom, options.zoom));
    this._fullscreen = (typeof options.fullscreen === "boolean") ? options.fullscreen : FORGE.ControllerPointer.DEFAULT_OPTIONS.fullscreen;

    this._enabled = (typeof config.enabled === "boolean") ? config.enabled : true;
};

/**
 * Pan start event handler.
 * @method FORGE.ControllerPointer#_panStartHandler
 * @param {FORGE.Event} event - Event object
 * @private
 */
FORGE.ControllerPointer.prototype._panStartHandler = function(event)
{
    if(this._viewer.controllers.enabled === false)
    {
        return;
    }

    this._viewer.canvas.pointer.onPanMove.add(this._panMoveHandler, this);
    this.log("_panStartHandler (" + event.data.velocityX.toFixed(2) + ", " + event.data.velocityY.toFixed(2) + ")");

    this._active = true;
    this._panning = true;

    var position = FORGE.Pointer.getRelativeMousePosition(event.data);
    this._positionStart = new THREE.Vector2(position.x, position.y);
    this._positionPrevious.copy(this._positionStart);
    this._positionCurrent.copy(this._positionStart);
    this._velocity.set(0, 0);

    if (this._onControlStart !== null)
    {
        this._onControlStart.dispatch();
    }

    this._viewer.controllers.notifyControlStart(this);
};

/**
 * Pan move event handler.
 * @method FORGE.ControllerPointer#_panMoveHandler
 * @param {FORGE.Event} event - Event object
 * @private
 */
FORGE.ControllerPointer.prototype._panMoveHandler = function(event)
{
    var position = FORGE.Pointer.getRelativeMousePosition(event.data);

    if(this._viewer.controllers.enabled === false || position === null)
    {
        return;
    }

    this._positionPrevious.copy(this._positionCurrent);
    this._positionCurrent.set(position.x, position.y);
    // this.log("Current position: " + this._positionCurrent.x + ", " + this._positionCurrent.y);

    if(this._orientation.drag === true && this._panning === true)
    {
        this._updateCameraWithDrag();
    }
};

/**
 * Pan end event handler.
 * @method FORGE.ControllerPointer#_panEndHandler
 * @private
 */
FORGE.ControllerPointer.prototype._panEndHandler = function()
{
    this._viewer.canvas.pointer.onPanMove.remove(this._panMoveHandler, this);
    this.log("_panEndHandler");

    this._active = false;
    this._panning = false;

    this._velocity.set(0, 0);
    this._positionStart.set(0, 0);
    this._positionCurrent.copy(this._positionStart);

    if (this._onControlEnd !== null)
    {
        this._onControlEnd.dispatch();
    }

    this._viewer.controllers.notifyControlEnd(this);
};

/**
 * Update the camera from the mouse position.
 * @method FORGE.ControllerPointer#_updateCameraWithDrag
 * @private
 */
FORGE.ControllerPointer.prototype._updateCameraWithDrag = function()
{
    var stw0 = this._viewer.view.screenToWorld(this._positionPrevious);
    var stw1 = this._viewer.view.screenToWorld(this._positionCurrent);

    // If the screen point do not match any world position, return
    if(stw0 === null || stw1 === null)
    {
        return;
    }

    var spherical0 = FORGE.Math.cartesianToSpherical(stw0.x, stw0.y, stw0.z);
    var quat0 = FORGE.Quaternion.fromEuler(spherical0.theta, spherical0.phi, 0);

    var spherical1 = FORGE.Math.cartesianToSpherical(stw1.x, stw1.y, stw1.z);
    var quat1 = FORGE.Quaternion.fromEuler(spherical1.theta, spherical1.phi, 0);

    this._camera.yaw += FORGE.Math.radToDeg(spherical0.theta - spherical1.theta);
    this._camera.pitch += FORGE.Math.radToDeg(spherical0.phi - spherical1.phi);
    this._camera.roll = 0;
};

/**
 * Update the camera from the velocity that results of the mouse movement.
 * @method FORGE.ControllerPointer#_updateCameraWithVelocity
 * @private
 */
FORGE.ControllerPointer.prototype._updateCameraWithVelocity = function()
{
    var size = this._viewer.renderer.displayResolution;
    var hardness = 1 / (this._orientation.hardness * Math.min(size.width, size.height));

    var logZoomFactor = Math.min(1, this._camera.fov / 90) / Math.LN2;

    this._velocity.subVectors(this._positionCurrent, this._positionStart);

    if (this._velocity.length() > this._orientation.velocityMax)
    {
        this._velocity.setLength(this._orientation.velocityMax);
    }

    this._velocity.multiplyScalar(hardness);
    this._velocity.multiplyScalar(logZoomFactor);

    // this.log("Current velocity: " + this._velocity.x + ", " + this._velocity.y);

    var invert = this._orientation.invert;
    var invertX = (invert === true) ? -1 : (typeof invert === "object" && invert.x === true) ? -1 : 1;
    var invertY = (invert === true) ? -1 : (typeof invert === "object" && invert.y === true) ? -1 : 1;

    var dx = this._velocity.x + this._inertia.x;
    var dy = this._velocity.y + this._inertia.y;

    if (dx === 0 && dy === 0)
    {
        return;
    }

    var yaw = invertX * dx;

    var threshold = logZoomFactor * 0.05;
    //Do not move the camera anymore if the modifier is too low, this prevent the camera onChange event to be fired too much times
    if(Math.abs(yaw) > threshold)
    {
        this._camera.yaw += yaw;
        this._camera.flat.position.x += dx;
    }

    var pitch = invertY * dy;
    //Do not move the camera anymore if the modifier is too low, this prevent the camera onChange to be fired too much times
    if(Math.abs(pitch) > threshold)
    {
        this._camera.pitch -= pitch;
        this._camera.flat.position.y -= dy;
    }

    // Damping 1 -> stops instantly, 0 infinite rebounds
    this._inertia.add(this._velocity).multiplyScalar(FORGE.Math.clamp(1 - this._orientation.damping, 0, 1));
};

/**
 * Pinch start event handler.
 * @method FORGE.ControllerPointer#_pinchStartHandler
 * @param {FORGE.Event} event - Event object
 * @private
 */
FORGE.ControllerPointer.prototype._pinchStartHandler = function(event)
{
    if(this._viewer.controllers.enabled === false)
    {
        return;
    }

    this._pinchStartFov = this._camera.fov;
    this._pinchScaleFactorCorrection = 1;

    this._viewer.canvas.pointer.onPinchMove.add(this._pinchMoveHandler, this);
    this.log("_pinchStartHandler "+event);
};

/**
 * Pinch move event handler.
 * @method FORGE.ControllerPointer#_pinchMoveHandler
 * @param {FORGE.Event} event - Event object
 * @private
 */
FORGE.ControllerPointer.prototype._pinchMoveHandler = function(event)
{
    if(this._viewer.controllers.enabled === false)
    {
        return;
    }

    event.data.preventDefault();

    var scale = this._zoom.invert ? event.data.scale : 1 / event.data.scale;
    var fovMin = this._camera.fovMin;
    var fovMax = this._camera.fovMax;

    var tmpFov = this._pinchStartFov * scale / this._pinchScaleFactorCorrection;

    if (tmpFov < fovMin)
    {
        this._pinchScaleFactorCorrection = this._pinchStartFov * scale / fovMin;
    }
    else if (tmpFov > fovMax)
    {
        this._pinchScaleFactorCorrection = this._pinchStartFov * scale / fovMax;
    }

    tmpFov = this._pinchStartFov * scale / this._pinchScaleFactorCorrection;

    this._camera.fov = tmpFov;
};

/**
 * Pinch end event handler.
 * @method FORGE.ControllerPointer#_pinchEndHandler
 * @param {FORGE.Event} event - Event object
 * @private
 */
FORGE.ControllerPointer.prototype._pinchEndHandler = function(event)
{
    this._viewer.canvas.pointer.onPinchMove.remove(this._pinchMoveHandler, this);
    this.log("_pinchEndHandler "+event);
};

/**
 * Wheel event handler.
 * @method FORGE.ControllerPointer#_wheelHandler
 * @param {FORGE.Event} event - Event object
 * @private
 */
FORGE.ControllerPointer.prototype._wheelHandler = function(event)
{
    if(this._viewer.controllers.enabled === false)
    {
        return;
    }

    event.data.preventDefault();

    var invert = this._zoom.invert ? 1 : -1;
    var delta = invert / this._zoom.hardness;
    var factorDeltaY = 1;

    if (event.data.deltaMode)
    {
        switch(event.data.deltaMode)
        {
            case 1: //DOM_DELTA_LINE (3 lines === 100 pixels)
                factorDeltaY = 33.3;
                break;
            case 2: //DOM_DELTA_PAGE
                factorDeltaY = self.innerHeight;
                break;
            default: //DOM_DELTA_PIXEL
                factorDeltaY = 1;
        }
    }

    if (event.data.deltaY)
    {
        delta *= (event.data.deltaY * factorDeltaY) / 5;
    }

    var logZoomFactor = Math.min(1, this._camera.fov / 90) / Math.LN2;
    this._camera.fov -= delta * logZoomFactor;

    if(this._zoom.toPointer === true)
    {
        var screen = FORGE.Pointer.getRelativeMousePosition(event.data);
        var stw0 = this._viewer.view.screenToWorld(screen);
        var spherical0 = FORGE.Math.cartesianToSpherical(stw0.x, stw0.y, stw0.z);
        var quat0 = FORGE.Quaternion.fromEuler(spherical0.theta, spherical0.phi, 0);

        this._viewer.view.current.updateUniforms();

        var stw1 = this._viewer.view.screenToWorld(screen);
        var spherical1 = FORGE.Math.cartesianToSpherical(stw1.x, stw1.y, stw1.z);
        var quat1 = FORGE.Quaternion.fromEuler(spherical1.theta, spherical1.phi, 0);

        var quat = FORGE.Quaternion.diffBetweenQuaternions(quat1, quat0);
        var euler = FORGE.Quaternion.toEuler(quat);

        this._camera.yaw += FORGE.Math.radToDeg(euler.yaw);
        this._camera.pitch += FORGE.Math.radToDeg(euler.pitch);
    }

    this.log("_wheelHandler (fov:" + this._camera.fov + ")");
};

/**
 * Double tap event handler. Toggle the fullscreen.
 * @method FORGE.ControllerPointer#_doubleTapHandler
 * @private
 */
FORGE.ControllerPointer.prototype._doubleTapHandler = function()
{
    if (this._viewer.controllers.enabled === false || this._fullscreen === false)
    {
        return;
    }

    this._viewer.fullscreen = !this._viewer.fullscreen;
};

/**
 * Enable controller
 * @method FORGE.ControllerPointer#enable
 */
FORGE.ControllerPointer.prototype.enable = function()
{
    FORGE.ControllerBase.prototype.enable.call(this);

    this._viewer.canvas.pointer.onPanStart.add(this._panStartHandler, this);
    this._viewer.canvas.pointer.onPanEnd.add(this._panEndHandler, this);

    this._viewer.canvas.pointer.onPinchStart.add(this._pinchStartHandler, this);
    this._viewer.canvas.pointer.onPinchEnd.add(this._pinchEndHandler, this);
    this._viewer.canvas.pointer.onWheel.add(this._wheelHandler, this);

    this._viewer.canvas.pointer.onDoubleTap.add(this._doubleTapHandler, this);
};

/**
 * Disable controller
 * @method FORGE.ControllerPointer#disable
 */
FORGE.ControllerPointer.prototype.disable = function()
{
    FORGE.ControllerBase.prototype.disable.call(this);

    this._viewer.canvas.pointer.onPanStart.remove(this._panStartHandler, this);
    this._viewer.canvas.pointer.onPanMove.remove(this._panMoveHandler, this);
    this._viewer.canvas.pointer.onPanEnd.remove(this._panEndHandler, this);

    this._viewer.canvas.pointer.onPinchStart.remove(this._pinchStartHandler, this);
    this._viewer.canvas.pointer.onPinchMove.remove(this._pinchEndHandler, this);
    this._viewer.canvas.pointer.onPinchEnd.remove(this._pinchEndHandler, this);
    this._viewer.canvas.pointer.onWheel.remove(this._wheelHandler, this);

    this._viewer.canvas.pointer.onDoubleTap.remove(this._doubleTapHandler, this);
};

/**
 * Update routine.
 * @method FORGE.ControllerPointer#update
 */
FORGE.ControllerPointer.prototype.update = function()
{
    if(this._orientation.drag !== true)
    {
        this._updateCameraWithVelocity();
    }
};

/**
 * Destroy routine
 * @method FORGE.ControllerPointer#destroy
 */
FORGE.ControllerPointer.prototype.destroy = function()
{
    FORGE.ControllerBase.prototype.destroy.call(this);
};

/**
 * Get and set the orientation options
 * @name FORGE.ControllerPointer#orientation
 * @type {boolean}
 */
Object.defineProperty(FORGE.ControllerPointer.prototype, "orientation",
{
    /** @this {FORGE.ControllerPointer} */
    get: function()
    {
        return this._orientation;
    },
    /** @this {FORGE.ControllerPointer} */
    set: function(value)
    {
        this._orientation = value;
    }
});

/**
 * Get and set the zoom options
 * @name FORGE.ControllerPointer#zoom
 * @type {boolean}
 */
Object.defineProperty(FORGE.ControllerPointer.prototype, "zoom",
{
    /** @this {FORGE.ControllerPointer} */
    get: function()
    {
        return this._zoom;
    },
    /** @this {FORGE.ControllerPointer} */
    set: function(value)
    {
        this._zoom = value;
    }
});

/**
 * @constructor FORGE.ControllerKeyboard
 * @param {FORGE.Viewer} viewer - viewer reference.
 * @param {ControllerInstanceConfig} config - the configuration of the controller
 * @extends {FORGE.ControllerBase}
 */
FORGE.ControllerKeyboard = function(viewer, config)
{
    /**
     * Configuration
     * @name FORGE.ControllerKeyboard#_config
     * @type {ControllerInstanceConfig}
     * @private
     */
    this._config = config;

    /**
     * Orientation controller configuration.
     * @name FORGE.ControllerKeyboard#_orientation
     * @type {ControllerOrientationConfig}
     * @private
     */
    this._orientation;

    /**
     * Zoom controller configuration.
     * @name FORGE.ControllerKeyboard#_zoom
     * @type {ControllerZoomConfig}
     * @private
     */
    this._zoom;

    /**
     * Previous position vector.
     * @name FORGE.ControllerKeyboard#_positionStart
     * @type {THREE.Vector2}
     * @private
     */
    this._positionStart = null;

    /**
     * Previous position vector.
     * @name FORGE.ControllerKeyboard#_positionCurrent
     * @type {THREE.Vector2}
     * @private
     */
    this._positionCurrent = null;

    /**
     * Current velocity vector.
     * @name FORGE.ControllerKeyboard#_velocity
     * @type {THREE.Vector2}
     * @private
     */
    this._velocity = null;

    /**
     * Previous velocity vector.
     * @name FORGE.ControllerKeyboard#_inertia
     * @type {THREE.Vector2}
     * @private
     */
    this._inertia = null;

    /**
     * Array of all key bindings
     * @name FORGE.ControllerKeyboard#_keyBindings
     * @type {Array<FORGE.KeyBinding>}
     * @private
     */
    this._keyBindings = null;

    FORGE.ControllerBase.call(this, viewer, "ControllerKeyboard");
};

FORGE.ControllerKeyboard.prototype = Object.create(FORGE.ControllerBase.prototype);
FORGE.ControllerKeyboard.prototype.constructor = FORGE.ControllerKeyboard;

/**
 * Default configuration
 * @name {FORGE.ControllerKeyboard.DEFAULT_OPTIONS}
 * @type {ControllerKeyboardConfig}
 */
FORGE.ControllerKeyboard.DEFAULT_OPTIONS =
{
    orientation:
    {
        hardness: 0.6, //Hardness factor impatcing controller response to some instant force.
        damping: 0.15, //Damping factor controlling inertia.
        velocityMax: 300,
        invert: false
    },

    zoom:
    {
        hardness: 5,
        invert: false
    }
};

/**
 * Boot sequence.
 * @method FORGE.ControllerKeyboard#_boot
 * @private
 */
FORGE.ControllerKeyboard.prototype._boot = function()
{
    FORGE.ControllerBase.prototype._boot.call(this);

    this._type = FORGE.ControllerType.KEYBOARD;

    this._keyBindings = [];

    this._inertia = new THREE.Vector2();
    this._velocity = new THREE.Vector2();
    this._positionStart = new THREE.Vector2();
    this._positionCurrent = new THREE.Vector2();

    this._parseConfig(this._config);

    if(this._enabled === true)
    {
        this.enable();
    }
};

/**
 * Parse the configuration.
 * @method FORGE.ControllerKeyboard#_parseConfig
 * @param {ControllerInstanceConfig} config - configuration object to parse.
 */
FORGE.ControllerKeyboard.prototype._parseConfig = function(config)
{
    this._uid = config.uid;
    this._register();

    var options = config.options || {};

    this._orientation = /** @type {ControllerOrientationConfig} */ (FORGE.Utils.extendMultipleObjects(FORGE.ControllerKeyboard.DEFAULT_OPTIONS.orientation, options.orientation));
    this._zoom = /** @type {ControllerZoomConfig} */ (FORGE.Utils.extendMultipleObjects(FORGE.ControllerKeyboard.DEFAULT_OPTIONS.zoom, options.zoom));

    this._enabled = (typeof config.enabled === "boolean") ? config.enabled : true;

    if(options.default !== false)
    {
        this._addDefaultBindings();
    }

    if(Array.isArray(options.bindings) === true)
    {
        for(var i = 0, ii = options.bindings.length; i < ii; i++)
        {
            this._addBinding(options.bindings[i]);
        }
    }
};

/**
 * Add the default bindings to the controller keyboard : orientation with arrows and zoom with plus (+) and minus (-).
 * @method FORGE.ControllerKeyboard#_addDefaultBinding.
 * @private
 */
FORGE.ControllerKeyboard.prototype._addDefaultBindings = function()
{
    var bindingLeft = new FORGE.KeyBinding(this._viewer,
        [81, 37],
        this._orientationDownHandler,
        this._orientationUpHandler,
        this._orientationHoldHandler,
        [68, 39],
        this,
        "left"
    );
    this._keyBindings.push(bindingLeft);

    var bindingRight = new FORGE.KeyBinding(this._viewer,
        [68, 39],
        this._orientationDownHandler,
        this._orientationUpHandler,
        this._orientationHoldHandler,
        [81, 37],
        this,
        "right"
    );
    this._keyBindings.push(bindingRight);

    var bindingUp = new FORGE.KeyBinding(this._viewer,
        [90, 38],
        this._orientationDownHandler,
        this._orientationUpHandler,
        this._orientationHoldHandler,
        [83, 40],
        this,
        "up"
    );
    this._keyBindings.push(bindingUp);

    var bindingDown = new FORGE.KeyBinding(this._viewer,
        [83, 40],
        this._orientationDownHandler,
        this._orientationUpHandler,
        this._orientationHoldHandler,
        [90, 38],
        this,
        "down"
    );
    this._keyBindings.push(bindingDown);

    var bindingPlus = new FORGE.KeyBinding(this._viewer,
        107,
        this._zoomDownHandler,
        this._zoomUpHandler,
        this._zoomHoldHandler,
        109,
        this,
        "plus"
    );
    this._keyBindings.push(bindingPlus);

    var bindingMinus = new FORGE.KeyBinding(this._viewer,
        109,
        this._zoomDownHandler,
        this._zoomUpHandler,
        this._zoomHoldHandler,
        107,
        this,
        "minus"
    );
    this._keyBindings.push(bindingMinus);
};

/**
 * Add a keyboard binding config to this controller.
 * @method FORGE.ControllerKeyboard#_addBinding
 * @param {ControllerKeyboardBindingConfig} binding - The binding config to add.
 * @private
 */
FORGE.ControllerKeyboard.prototype._addBinding = function(binding)
{
    var keysIn = binding.in;
    var keysOut = binding.out;
    var name = binding.name;
    var events = binding.events;

    if(FORGE.Utils.isTypeOf(keysIn, "number") === false && FORGE.Utils.isArrayOf(keysIn, "number") === false)
    {
        this.warn("Can't add custom keyboard binding, keys in are invalid!");
        return;
    }

    if(typeof events !== "object" && events === null)
    {
        this.warn("Can't add custom keyboard binding, events are invalid!");
        return;
    }

    var keyBinding = new FORGE.KeyBinding(this._viewer, keysIn, events.onDown, events.onUp, events.onHold, keysOut, this, name);

    this._keyBindings.push(keyBinding);
};

/**
 * Event handler for orientation (arrows) down handler.
 * @method FORGE.ControllerKeyboard#_orientationDownHandler
 * @param  {FORGE.KeyBinding} binding - The binding associated to the event.
 * @private
 */
FORGE.ControllerKeyboard.prototype._orientationDownHandler = function(binding)
{
    if(this._viewer.controllers.enabled === false)
    {
        return;
    }

    this._active = true;

    switch(binding.name)
    {
        case "left":
        case "right":
            this._velocity.setX(0);
            break;

        case "up":
        case "down":
            this._velocity.setY(0);
            break;
    }

    if (this._onControlStart !== null)
    {
        this._onControlStart.dispatch();
    }

    this._viewer.controllers.notifyControlStart(this);
};

/**
 * Event handler for orientation (arrows) hold handler.
 * @method FORGE.ControllerKeyboard#_orientationHoldHandler
 * @param  {FORGE.KeyBinding} binding - The binding associated to the event.
 * @private
 */
FORGE.ControllerKeyboard.prototype._orientationHoldHandler = function(binding)
{
    if(this._viewer.controllers.enabled === false)
    {
        return;
    }

    switch(binding.name)
    {
        case "left":
            this._positionCurrent.setX(this._positionCurrent.x - 5);
            break;

        case "right":
            this._positionCurrent.setX(this._positionCurrent.x + 5);
            break;

        case "up":
            this._positionCurrent.setY(this._positionCurrent.y - 5);
            break;

        case "down":
            this._positionCurrent.setY(this._positionCurrent.y + 5);
            break;
    }
};

/**
 * Event handler for orientation (arrows) up handler.
 * @method FORGE.ControllerKeyboard#_orientationUpHandler
 * @param  {FORGE.KeyBinding} binding - The binding associated to the event.
 * @private
 */
FORGE.ControllerKeyboard.prototype._orientationUpHandler = function(binding)
{
    this._active = false;

    switch(binding.name)
    {
        case "left":
        case "right":
            this._velocity.setX(0);
            this._positionCurrent.setX(0);
            break;

        case "up":
        case "down":
            this._velocity.setY(0);
            this._positionCurrent.setY(0);
            break;
    }

    if (this._onControlEnd !== null)
    {
        this._onControlEnd.dispatch();
    }

    this._viewer.controllers.notifyControlEnd(this);
};

/**
 * Event handler for zoom (+ / -) down handler.
 * @method FORGE.ControllerKeyboard#_zoomDownHandler
 * @param  {FORGE.KeyBinding} binding - The binding associated to the event.
 * @private
 */
FORGE.ControllerKeyboard.prototype._zoomDownHandler = function(binding)
{
    if(this._viewer.controllers.enabled === false)
    {
        return;
    }

    this._active = true;

    this._zoomProcessBinding(binding);

    if (this._onControlStart !== null)
    {
        this._onControlStart.dispatch();
    }

    this._viewer.controllers.notifyControlStart(this);
};

/**
 * Event handler for zoom (+ / -) hold handler.
 * @method FORGE.ControllerKeyboard#_zoomHoldHandler
 * @param  {FORGE.KeyBinding} binding - The binding associated to the event.
 * @private
 */
FORGE.ControllerKeyboard.prototype._zoomHoldHandler = function(binding)
{
    this._zoomProcessBinding(binding);
};

/**
 * Event handler for zoom (+ / -) up handler.
 * @method FORGE.ControllerKeyboard#_zoomUpHandler
 * @private
 */
FORGE.ControllerKeyboard.prototype._zoomUpHandler = function()
{
    this._active = false;

    if (this._onControlEnd !== null)
    {
        this._onControlEnd.dispatch();
    }

    this._viewer.controllers.notifyControlEnd(this);
};

/**
 * Process a key binding related to zoom for down and hold zoom handlers.
 * @method FORGE.ControllerKeyboard#_zoomProcessBinding
 * @param  {FORGE.KeyBinding} binding - The key binding related to zoom
 * @private
 */
FORGE.ControllerKeyboard.prototype._zoomProcessBinding = function(binding)
{
    var invert = this._zoom.invert ? 1 : -1;
    var delta = invert / this._zoom.hardness;

    switch(binding.name)
    {
        case "minus":
            delta *= 10;
            break;

        case "plus":
            delta *= -10;
            break;
    }

    this._camera.fov = this._camera.fov - delta;
};

/**
 * Enable controller
 * @method FORGE.ControllerKeyboard#enable
 */
FORGE.ControllerKeyboard.prototype.enable = function()
{
    FORGE.ControllerBase.prototype.enable.call(this);

    var binding;

    for(var i = 0, ii = this._keyBindings.length; i < ii; i++)
    {
        binding = this._keyBindings[i];
        this._viewer.keyboard.addBinding(binding);
    }
};

/**
 * Disable controller
 * @method FORGE.ControllerKeyboard#disable
 */
FORGE.ControllerKeyboard.prototype.disable = function()
{
    FORGE.ControllerBase.prototype.disable.call(this);

    var binding;

    for(var i = 0, ii = this._keyBindings.length; i < ii; i++)
    {
        binding = this._keyBindings[i];
        this._viewer.keyboard.removeBinding(binding);
    }
};

/**
 * Update routine.
 * @method FORGE.ControllerKeyboard#update
 */
FORGE.ControllerKeyboard.prototype.update = function()
{
    var size = this._viewer.renderer.displayResolution;
    var hardness = 1 / (this._orientation.hardness * Math.min(size.width, size.height));

    this._velocity.subVectors(this._positionCurrent, this._positionStart);

    if (this._velocity.length() > this._orientation.velocityMax)
    {
        this._velocity.setLength(this._orientation.velocityMax);
    }

    this._velocity.multiplyScalar(hardness);

    // this.log("Current velocity: " + this._velocity.x + ", " + this._velocity.y);

    var dx = this._velocity.x + this._inertia.x;
    var dy = this._velocity.y + this._inertia.y;

    if (dx === 0 && dy === 0)
    {
        return;
    }

    var invert = this._orientation.invert ? -1 : 1;
    this._camera.yaw += invert * dx;
    this._camera.pitch -= invert * dy;

    // Damping 1 -> stops instantly, 0 infinite rebounds
    this._inertia.add(this._velocity).multiplyScalar(FORGE.Math.clamp(1 - this._orientation.damping, 0, 1));
};

/**
 * Destroy routine
 * @method FORGE.ControllerKeyboard#destroy
 */
FORGE.ControllerKeyboard.prototype.destroy = function()
{
    FORGE.ControllerBase.prototype.destroy.call(this);
};

/**
 * This controller takes gyroscope events on screen to animate camera moves.
 *
 * @constructor FORGE.ControllerGyroscope
 * @param {FORGE.Viewer} viewer - viewer reference
 * @param {ControllerInstanceConfig} config - the configuration of the controller
 * @extends {FORGE.ControllerBase}
 */
FORGE.ControllerGyroscope = function(viewer, config)
{
    /**
     * Configuration
     * @name FORGE.ControllerGyroscope#_config
     * @type {ControllerInstanceConfig}
     * @private
     */
    this._config = config;

    /**
     * Position euler.
     * @name FORGE.ControllerGyroscope#_posEuler
     * @type {THREE.Euler}
     * @private
     */
    this._posEuler = null;

    /**
     * The intermediate quaternion where the position is computed.
     * @name FORGE.ControllerGyroscope#_posQuatIndermediate
     * @type {THREE.Quaternion}
     * @private
     */
    this._posQuatIndermediate = null;

    /**
     * The offset quaternion of the camera.
     * @name FORGE.ControllerGyroscope#_posQuatOffset
     * @type {THREE.Quaternion}
     * @private
     */
    this._posQuatOffset = null;

    /**
     * The quaternion to add given the orientation of the screen
     * @name FORGE.ControllerGyroscope#_posQuatScreenOrientation
     * @type {THREE.Quaternion}
     * @private
     */
    this._posQuatScreenOrientation = null;

    /**
     * Quaternion result of the position.
     * @name FORGE.ControllerGyroscope#_posQuatFinal
     * @type {THREE.Quaternion}
     * @private
     */
    this._posQuatFinal = null;

    /**
     * Orientation of the screen (not the device !)
     * @name FORGE.ControllerGyroscope#_screenOrientation
     * @type {number}
     * @private
     */
    this._screenOrientation = 0;

    /**
     * Is the controller paused ?
     * @name FORGE.ControllerGyroscope#_paused
     * @type {boolean}
     * @private
     */
    this._paused = false;

    FORGE.ControllerBase.call(this, viewer, "ControllerGyroscope");
};

FORGE.ControllerGyroscope.prototype = Object.create(FORGE.ControllerBase.prototype);
FORGE.ControllerGyroscope.prototype.constructor = FORGE.ControllerGyroscope;

/**
 * Boot sequence
 * @method FORGE.ControllerGyroscope#_boot
 * @private
 */
FORGE.ControllerGyroscope.prototype._boot = function()
{
    FORGE.ControllerBase.prototype._boot.call(this);

    this._type = FORGE.ControllerType.GYROSCOPE;

    this._posEuler = new THREE.Euler();
    this._posQuatIndermediate = new THREE.Quaternion();
    this._posQuatOffset = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
    this._posQuatScreenOrientation = new THREE.Quaternion();
    this._posQuatFinal = new THREE.Quaternion();

    this._parseConfig(this._config);

    FORGE.Device.onReady.addOnce(this._deviceReadyHandler, this);
};

/**
 * Device ready handler. Enables the gyro controller if gyro is available on the device.
 * @method FORGE.ControllerGyroscope#_deviceReadyHandler
 * @private
 */
FORGE.ControllerGyroscope.prototype._deviceReadyHandler = function()
{
    this._viewer.renderer.display.onDisplayChange.add(this._displayChangeHandler, this);
    this._viewer.renderer.view.onChange.add(this._viewChangeHandler, this);

    if (this._enabled === true && FORGE.Device.gyroscope === true)
    {
        this.enable();
    }
};

/**
 * Parse the configuration.
 * @method FORGE.ControllerGyroscope#_parseConfig
 * @param {ControllerInstanceConfig} config - configuration object to parse.
 */
FORGE.ControllerGyroscope.prototype._parseConfig = function(config)
{
    this._uid = config.uid;
    this._register();

    this._enabled = (typeof config.enabled === "boolean") ? config.enabled : true;
};

/**
 * Display change handler, pause the gyro in VR (WebVR handles the gyro antoher way)
 * @method FORGE.ControllerGyroscope#_displayChangeHandler
 * @private
 */
FORGE.ControllerGyroscope.prototype._displayChangeHandler = function()
{
    if(this._viewer.renderer.display.presentingVR === true)
    {
        this._paused = true;
    }
    else
    {
        this._paused = false;
    }
};

/**
 * View change handler, pause the gyro if the view is not rectilinear
 * @method FORGE.ControllerGyroscope#_viewChangeHandler
 * @private
 */
FORGE.ControllerGyroscope.prototype._viewChangeHandler = function()
{
    if(this._viewer.renderer.view.type !== FORGE.ViewType.RECTILINEAR)
    {
        this._paused = true;
    }
    else
    {
        this._paused = false;
    }
};

/**
 * Orientation change handler.
 * @method FORGE.ControllerGyroscope#_deviceOrientationChangeHandler
 * @param {FORGE.Event=} event - Event object
 * @private
 */
FORGE.ControllerGyroscope.prototype._deviceOrientationChangeHandler = function(event)
{
    if (this._viewer.controllers.enabled === false)
    {
        return;
    }

    /** @type {DeviceOrientation} */
    var position = {
        beta: 0,
        alpha: 0,
        gamma: 0
    };

    if (typeof event !== "undefined" && event !== null && typeof event.data !== "undefined" && event.data !== null)
    {
        position = /** @type {DeviceOrientation} */ event.data;
    }

    // Set the position in correct Euler coordinates
    this._posEuler.set(FORGE.Math.degToRad(position.beta), FORGE.Math.degToRad(position.alpha), -FORGE.Math.degToRad(position.gamma), "YXZ");
    this._posQuatIndermediate.setFromEuler(this._posEuler);

    // Add the offset provided by the camera
    this._posQuatIndermediate.multiply(this._posQuatOffset);

    // Adjust given the screen orientation
    this._posQuatIndermediate.multiply(this._posQuatScreenOrientation);

    // Final inversion, see FORGE.RenderDisplay#getQuaternionFromPose method
    this._posQuatFinal.set(-this._posQuatIndermediate.y, -this._posQuatIndermediate.x, -this._posQuatIndermediate.z, this._posQuatIndermediate.w);
};

/**
 * Screen orientation change event.
 * @method FORGE.ControllerGyroscope#_screenOrientationChangeHandler
 * @private
 */
FORGE.ControllerGyroscope.prototype._screenOrientationChangeHandler = function()
{
    if (typeof screen.orientation !== "undefined")
    {
        this._screenOrientation = FORGE.Math.degToRad(screen.orientation.angle);
    }
    else if (typeof window.orientation !== "undefined")
    {
        this._screenOrientation = FORGE.Math.degToRad(window.orientation);
    }

    this._posQuatScreenOrientation.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -this._screenOrientation);
};

/**
 * Enable controller
 * @method FORGE.ControllerGyroscope#enable
 */
FORGE.ControllerGyroscope.prototype.enable = function()
{
    if (this._viewer.controllers.enabled === false || this._config.enabled === false)
    {
        return;
    }

    FORGE.ControllerBase.prototype.enable.call(this);

    this._viewer.gyroscope.onDeviceOrientationChange.add(this._deviceOrientationChangeHandler, this);
    this._viewer.gyroscope.onScreenOrientationChange.add(this._screenOrientationChangeHandler, this);

    this._screenOrientationChangeHandler();
    this._deviceOrientationChangeHandler();
};

/**
 * Disable controller
 * @method FORGE.ControllerGyroscope#disable
 */
FORGE.ControllerGyroscope.prototype.disable = function()
{
    if (this._viewer.controllers.enabled === false || this._config.enabled === false)
    {
        return;
    }

    FORGE.ControllerBase.prototype.disable.call(this);

    this._viewer.gyroscope.onDeviceOrientationChange.remove(this._deviceOrientationChangeHandler, this);
    this._viewer.gyroscope.onScreenOrientationChange.remove(this._screenOrientationChangeHandler, this);
};

/**
 * Update routine.
 * @method FORGE.ControllerGyroscope#update
 */
FORGE.ControllerGyroscope.prototype.update = function()
{
    if (this._enabled === true && FORGE.Device.gyroscope === true && this._paused === false)
    {
        this._viewer.camera.quaternion = this._posQuatFinal;
    }
};

/**
 * Destroy squence
 * @method FORGE.ControllerGyroscope#destroy
 * @private
 */
FORGE.ControllerGyroscope.prototype.destroy = function()
{
    this.disable();

    this._viewer.renderer.display.onDisplayChange.remove(this._displayChangeHandler, this);
    this._viewer.renderer.view.onChange.remove(this._viewChangeHandler, this);

    this._posEuler = null;
    this._posQuatIndermediate = null;
    this._posQuatOffset = null;
    this._posQuatScreenOrientation = null;
    this._posQuatFinal = null;

    FORGE.ControllerBase.prototype.destroy.call(this);
};

/**
 * A gamepad controller (type xbox or ps4 for example).
 *
 * @constructor FORGE.ControllerGamepad
 * @param {FORGE.Viewer} viewer - viewer reference
 * @param {ControllerInstanceConfig} config - the configuration of the controller
 * @extends {FORGE.ControllerBase}
 */
FORGE.ControllerGamepad = function(viewer, config)
{
    /**
     * A list of associated gamepad
     * @name FORGE.ControllerGamepad#_gamepads
     * @type {?Array<FORGE.Gamepad>}
     * @private
     */
    this._gamepads = null;

    /**
     * Configuration
     * @name FORGE.ControllerGamepad#_config
     * @type {ControllerInstanceConfig}
     * @private
     */
    this._config = config;

    /**
     * Orientation controller configuration.
     * @name FORGE.ControllerGamepad#_orientation
     * @type {ControllerOrientationConfig}
     * @private
     */
    this._orientation;

    /**
     * Zoom controller configuration.
     * @name FORGE.ControllerGamepad#_zoom
     * @type {ControllerZoomConfig}
     * @private
     */
    this._zoom;

    /**
     * Previous position vector.
     * @name FORGE.ControllerGamepad#_positionCurrent
     * @type {THREE.Vector2}
     * @private
     */
    this._positionCurrent = null;

    /**
     * Current velocity vector.
     * @name FORGE.ControllerGamepad#_velocity
     * @type {THREE.Vector2}
     * @private
     */
    this._velocity = null;

    /**
     * Previous velocity vector.
     * @name FORGE.ControllerGamepad#_inertia
     * @type {THREE.Vector2}
     * @private
     */
    this._inertia = null;

    /**
     * Array of all button bindings
     * @name FORGE.ControllerGamepad#_buttonBindings
     * @type {Array<FORGE.ButtonBinding>}
     * @private
     */
    this._buttonBindings = null;

    /**
     * Array of all axis bindings
     * @name FORGE.ControllerGamepad#_axisBindings
     * @type {Array<FORGE.AxisBinding>}
     * @private
     */
    this._axisBindings = null;

    FORGE.ControllerBase.call(this, viewer, "ControllerGamepad");
};

FORGE.ControllerGamepad.prototype = Object.create(FORGE.ControllerBase.prototype);
FORGE.ControllerGamepad.prototype.constructor = FORGE.ControllerGamepad;

/**
 * Default configuration
 * @name {FORGE.ControllerGamepad.DEFAULT_OPTIONS}
 * @type {ControllerKeyboardConfig}
 */
FORGE.ControllerGamepad.DEFAULT_OPTIONS = {
    orientation:
    {
        hardness: 0.6, //Hardness factor impatcing controller response to some instant force.
        damping: 0.15, //Damping factor controlling inertia.
        velocityMax: 300,
        invert: {
            x: false,
            y: false
        }
    },

    zoom:
    {
        hardness: 5,
        invert: false
    }
};

/**
 * Boot sequence.
 * @method FORGE.ControllerGamepad#_boot
 * @private
 */
FORGE.ControllerGamepad.prototype._boot = function()
{
    FORGE.ControllerBase.prototype._boot.call(this);

    this._type = FORGE.ControllerType.GAMEPAD;

    this._gamepads = [];

    this._buttonBindings = [];
    this._axisBindings = [];

    this._inertia = new THREE.Vector2();
    this._velocity = new THREE.Vector2();
    this._positionStart = new THREE.Vector2();
    this._positionCurrent = new THREE.Vector2();

    this._parseConfig(this._config);

    if (this._enabled === true)
    {
        this.enable();
    }

    this._viewer.gamepad.onGamepadConnected.add(this._onGamepadConnectedHandler, this);
    this._viewer.gamepad.onGamepadDisconnected.add(this._onGamepadDisconnectedHandler, this);
};

/**
 * Parse the configuration.
 * @method FORGE.ControllerGamepad#_parseConfig
 * @param {ControllerInstanceConfig} config - configuration object to parse.
 */
FORGE.ControllerGamepad.prototype._parseConfig = function(config)
{
    this._uid = config.uid;
    this._register();

    var options = config.options || {};

    this._orientation = /** @type {ControllerOrientationConfig} */ (FORGE.Utils.extendMultipleObjects(FORGE.ControllerGamepad.DEFAULT_OPTIONS.orientation, options.orientation));
    this._zoom = /** @type {ControllerZoomConfig} */ (FORGE.Utils.extendMultipleObjects(FORGE.ControllerGamepad.DEFAULT_OPTIONS.zoom, options.zoom));

    this._enabled = (typeof config.enabled === "boolean") ? config.enabled : true;

    if (options.default !== false)
    {
        this._addDefaultBindings();
    }

    if (typeof options.bindings !== "undefined")
    {
        if (typeof options.bindings.buttons !== "undefined" && Array.isArray(options.bindings.buttons) === true)
        {
            for (var i = 0, ii = options.bindings.buttons.length; i < ii; i++)
            {
                this._addButtonBinding(options.bindings.buttons[i]);
            }
        }

        if (typeof options.bindings.axes !== "undefined" && Array.isArray(options.bindings.axes) === true)
        {
            for (var i = 0, ii = options.bindings.axes.length; i < ii; i++)
            {
                this._addAxisBinding(options.bindings.axes[i]);
            }
        }
    }
};

/**
 * Add the default bindings ot the controller gamepad : direction with left stick, zoom with LT and
 * RT buttons (6 and 7 according to standard mapping).
 * @method FORGE.ControllerGamepad#_addDefaultBindings
 * @private
 */
FORGE.ControllerGamepad.prototype._addDefaultBindings = function()
{
    var bindingPlus = new FORGE.ButtonBinding(this._viewer,
        7,
        this._zoomDownHandler,
        this._zoomUpHandler,
        this._zoomHoldHandler,
        6,
        this,
        "plus"
    );
    this._buttonBindings.push(bindingPlus);

    var bindingMinus = new FORGE.ButtonBinding(this._viewer,
        6,
        this._zoomDownHandler,
        this._zoomUpHandler,
        this._zoomHoldHandler,
        7,
        this,
        "minus"
    );
    this._buttonBindings.push(bindingMinus);

    var bindingYaw = new FORGE.AxisBinding(this._viewer,
        0,
        this._yawChangeHandler,
        this,
        "yaw"
    );
    this._axisBindings.push(bindingYaw);

    var bindingPitch = new FORGE.AxisBinding(this._viewer,
        1,
        this._pitchChangeHandler,
        this,
        "pitch"
    );
    this._axisBindings.push(bindingPitch);
};

/**
 * Add a gamepad binding config to this controller.
 * @method FORGE.ControllerGamepad#_addButtonBinding
 * @param {ControllerGamepadButtonBindingConfig} binding - The binding config to add.
 * @private
 */
FORGE.ControllerGamepad.prototype._addButtonBinding = function(binding)
{
    var buttonsIn = binding.in;
    var buttonsOut = binding.out;
    var name = binding.name;
    var events = binding.events;

    if (FORGE.Utils.isTypeOf(buttonsIn, "number") === false && FORGE.Utils.isArrayOf(buttonsIn, "number") === false)
    {
        this.warn("Can't add custom gamepad binding, buttons in are invalid!");
        return;
    }

    if (typeof events !== "object" && events === null)
    {
        this.warn("Can't add custom gamepad binding, events are invalid!");
        return;
    }

    var buttonBinding = new FORGE.ButtonBinding(this._viewer, buttonsIn, events.onDown, events.onUp, events.onHold, buttonsOut, this, name);

    this._buttonBindings.push(buttonBinding);
};

/**
 * Add a gamepad axis binding config to this controller.
 * @method FORGE.ControllerGamepad#_addAxisBinding
 * @param {ControllerGamepadAxisBindingConfig} binding - the binding config to add
 * @private
 */
FORGE.ControllerGamepad.prototype._addAxisBinding = function(binding)
{
    var axis = binding.axis;
    var name = binding.name;
    var events = binding.events;

    if (FORGE.Utils.isTypeOf(axis, "number") === false && FORGE.Utils.isArrayOf(axis, "number") === false)
    {
        this.warn("Can't add custom gamepad binding, axis in is invalid!");
        return;
    }

    if (typeof events !== "object" && events === null)
    {
        this.warn("Can't add custom gamepad binding, events are invalid!");
        return;
    }

    var axisBinding = new FORGE.AxisBinding(this._viewer, axis, events.onChange, this, name);

    this._axisBindings.push(axisBinding);
};

/**
 * Event handler for yaw changement.
 * @method FORGE.ControllerGamepad#_yawChangeHandler
 * @param {FORGE.AxisBinding} binding - the reference to the binding
 * @param {number} value - the value of the change of the yaw
 * @private
 */
FORGE.ControllerGamepad.prototype._yawChangeHandler = function(binding, value)
{
    // Check the delta, as the value isn't exactly 0 at rest
    if (Math.abs(value) < 0.1)
    {
        this._velocity.setX(0);
        this._positionCurrent.setX(0);
        return;
    }

    this._positionCurrent.setX(180 * value);
};

/**
 * Event handler for pitch changement.
 * @method FORGE.ControllerGamepad#_pitchChangeHandler
 * @param {FORGE.AxisBinding} binding - the reference to the binding
 * @param {number} value - the value of the change of the pitch
 * @private
 */
FORGE.ControllerGamepad.prototype._pitchChangeHandler = function(binding, value)
{
    // Check the delta, as the value isn't exactly 0 at rest
    if (Math.abs(value) < 0.1)
    {
        this._velocity.setY(0);
        this._positionCurrent.setY(0);
        return;
    }

    this._positionCurrent.setY(180 * value);
};

/**
 * Event handler for zoom (+ / -) down handler.
 * @method FORGE.ControllerGamepad#_zoomDownHandler
 * @param  {FORGE.ButtonBinding} binding - The binding associated to the event.
 * @private
 */
FORGE.ControllerGamepad.prototype._zoomDownHandler = function(binding)
{
    if (this._viewer.controllers.enabled === false)
    {
        return;
    }

    this._active = true;

    this._zoomProcessBinding(binding);

    if (this._onControlStart !== null)
    {
        this._onControlStart.dispatch();
    }

    this._viewer.controllers.notifyControlStart(this);
};

/**
 * Event handler for zoom (+ / -) hold handler.
 * @method FORGE.ControllerGamepad#_zoomHoldHandler
 * @param  {FORGE.ButtonBinding} binding - The binding associated to the event.
 * @private
 */
FORGE.ControllerGamepad.prototype._zoomHoldHandler = function(binding)
{
    this._zoomProcessBinding(binding);
};

/**
 * Event handler for zoom (+ / -) up handler.
 * @method FORGE.ControllerGamepad#_zoomUpHandler
 * @private
 */
FORGE.ControllerGamepad.prototype._zoomUpHandler = function()
{
    this._active = false;

    if (this._onControlEnd !== null)
    {
        this._onControlEnd.dispatch();
    }

    this._viewer.controllers.notifyControlEnd(this);
};

/**
 * Process a key binding related to zoom for down and hold zoom handlers.
 * @method FORGE.ControllerGamepad#_zoomProcessBinding
 * @param  {FORGE.ButtonBinding} binding - The key binding related to zoom
 * @private
 */
FORGE.ControllerGamepad.prototype._zoomProcessBinding = function(binding)
{
    var invert = this._zoom.invert ? 1 : -1;
    var delta = invert / this._zoom.hardness;

    switch (binding.name)
    {
        case "minus":
            delta *= 5;
            break;

        case "plus":
            delta *= -5;
            break;
    }

    this._camera.fov = this._camera.fov - delta;
};

/**
 * When a gamepad is connected, add bindings to it.
 * @method FORGE.ControllerGamepad#_onGamepadConnectedHandler
 * @param {FORGE.Gamepad} gamepad - the gamepad to add
 */
FORGE.ControllerGamepad.prototype._onGamepadConnectedHandler = function(gamepad)
{
    gamepad = gamepad.data;

    if (this._gamepads.indexOf(gamepad) === -1)
    {
        this._gamepads.push(gamepad);
    }

    var binding;

    for (var i = 0, ii = this._buttonBindings.length; i < ii; i++)
    {
        binding = this._buttonBindings[i];
        gamepad.addBinding(binding);
    }

    for (var i = 0, ii = this._axisBindings.length; i < ii; i++)
    {
        binding = this._axisBindings[i];
        gamepad.addBinding(binding);
    }
};

/**
 * When a gamepad is disconnected, remove bindings to it.
 * @method FORGE.ControllerGamepad#_onGamepadDisconnectedHandler
 * @param {string} name - the name of the gamepad to remove
 */
FORGE.ControllerGamepad.prototype._onGamepadDisconnectedHandler = function(name)
{
    name = name.data;

    var index;

    for (var i = 0, ii = this._gamepads.length; i < ii; i++)
    {
        if (this._gamepads[i].name === name)
        {
            index = i;
            break;
        }
    }

    if (index !== -1)
    {
        this._gamepads.splice(index, 1);
    }
};

/**
 * Enable controller
 * @method FORGE.ControllerGamepad#enable
 */
FORGE.ControllerGamepad.prototype.enable = function()
{
    FORGE.ControllerBase.prototype.enable.call(this);

    var binding;

    for (var i = 0, ii = this._buttonBindings.length; i < ii; i++)
    {
        binding = this._buttonBindings[i];

        for (var j = 0, jj = this._gamepads.length; j < jj; j++)
        {
            this._gamepads[j].addBinding(binding);
        }
    }

    for (var i = 0, ii = this._axisBindings.length; i < ii; i++)
    {
        binding = this._axisBindings[i];

        for (var j = 0, jj = this._gamepads.length; j < jj; j++)
        {
            this._gamepads[j].addBinding(binding);
        }
    }
};

/**
 * Disable controller
 * @method FORGE.ControllerGamepad#disable
 */
FORGE.ControllerGamepad.prototype.disable = function()
{
    FORGE.ControllerBase.prototype.disable.call(this);

    var binding;

    for (var i = 0, ii = this._buttonBindings.length; i < ii; i++)
    {
        binding = this._buttonBindings[i];

        for (var j = 0, jj = this._gamepads.length; j < jj; j++)
        {
            this._gamepads[j].removeBinding(binding);
        }
    }

    for (var i = 0, ii = this._axisBindings.length; i < ii; i++)
    {
        binding = this._axisBindings[i];

        for (var j = 0, jj = this._gamepads.length; j < jj; j++)
        {
            this._gamepads[j].removeBinding(binding);
        }
    }
};

/**
 * Update routine.
 * @method FORGE.ControllerGamepad#update
 */
FORGE.ControllerGamepad.prototype.update = function()
{
    var size = this._viewer.renderer.displayResolution;
    var hardness = 1 / (this._orientation.hardness * Math.min(size.width, size.height));

    this._velocity = this._positionCurrent.clone();

    if (this._velocity.length() > this._orientation.velocityMax)
    {
        this._velocity.setLength(this._orientation.velocityMax);
    }

    this._velocity.multiplyScalar(hardness);

    var dx = this._velocity.x + this._inertia.x;
    var dy = this._velocity.y + this._inertia.y;

    if (dx === 0 && dy === 0)
    {
        return;
    }

    var invert = this._orientation.invert;
    var invertX = (invert === true) ? -1 : (typeof invert === "object" && invert.x === true) ? -1 : 1;
    var invertY = (invert === true) ? -1 : (typeof invert === "object" && invert.y === true) ? -1 : 1;

    this._camera.yaw += invertX * dx;
    this._camera.pitch -= invertY * dy;

    // Damping 1 -> stops instantly, 0 infinite rebounds
    this._inertia.add(this._velocity).multiplyScalar(FORGE.Math.clamp(1 - this._orientation.damping, 0, 1));
};

/**
 * Destroy routine
 * @method FORGE.ControllerGamepad#destroy
 */
FORGE.ControllerGamepad.prototype.destroy = function()
{
    this._viewer.gamepad.onGamepadConnected.remove(this._onGamepadConnectedHandler, this);
    this._viewer.gamepad.onGamepadDisconnected.remove(this._onGamepadDisconnectedHandler, this);

    this._positionStart = null;
    this._positionCurrent = null;
    this._velocity = null;
    this._inertia = null;

    var binding;

    while (this._buttonBindings.length > 0)
    {
        binding = this._buttonBindings.pop();
        binding.destroy();
    }
    this._buttonBindings = null;

    while (this._axisBindings.length > 0)
    {
        binding = this._axisBindings.pop();
        binding.destroy();
    }
    this._axisBindings = null;

    FORGE.ControllerBase.prototype.destroy.call(this);
};


/**
 * A FORGE.SoundManager is an object to manage all sounds.
 *
 * @constructor FORGE.SoundManager
 * @param {FORGE.Viewer} viewer - The {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 *
 * @todo Start/Stop sound to avoid autoplay
 */
FORGE.SoundManager = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.SoundManager#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The global sound config backup.
     * @name FORGE.SoundManager#_config
     * @type {?AudioConfig}
     * @private
     */
    this._config = null;

    /**
     * The global volume for sounds.
     * @name FORGE.SoundManager#_volume
     * @type {number}
     * @private
     */
    this._volume = 1;

    /**
     * The volume has been changed?
     * @name FORGE.SoundManager#_volumeChanged
     * @type {boolean}
     * @private
     */
    this._volumeChanged = false;

    /**
     * The default volume for sounds.
     * Can't be greater than the maximum volume.
     * @name FORGE.SoundManager#_defaultVolume
     * @type {number}
     * @private
     */
    this._defaultVolume = 1;

    /**
     * The maximum volume for sounds.
     * @name  FORGE.SoundManager#_maxVolume
     * @type {number}
     * @private
     */
    this._maxVolume = 1;

    /**
     * The save of the global volume for sounds before a mute.
     * @name FORGE.SoundManager#_mutedVolume
     * @type {number}
     * @private
     */
    this._mutedVolume = 1;

    /**
     * Are all sounds muted?
     * @name FORGE.SoundManager#_muted
     * @type {boolean}
     * @private
     */
    this._muted = false;

    /**
     * Is the sound manager enabled?
     * @name  FORGE.SoundManager#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * Array of {@link FORGE.Sound}.
     * @name FORGE.SoundManager#_sounds
     * @type {?Array<FORGE.Sound>}
     * @private
     */
    this._sounds = null;

    /**
     * Is audio deactivated?
     * @name FORGE.SoundManager#_noAudio
     * @type {boolean}
     * @private
     */
    this._noAudio = false;

    /**
     * Is Audio tag activated?
     * @name FORGE.SoundManager#_useAudioTag
     * @type {boolean}
     * @private
     */
    this._useAudioTag = false;

    /**
     * Is WebAudio API activated?
     * @name FORGE.SoundManager#_useWebAudio
     * @type {boolean}
     * @private
     */
    this._useWebAudio = true;

    /**
     * Number of sound channels.
     * @name FORGE.SoundManager#_channels
     * @type {number}
     * @private
     */
    this._channels = 32;

    /**
     * The AudioContext interface.
     * @name FORGE.SoundManager#_context
     * @type {?(AudioContext|webkitAudioContext)}
     * @private
     */
    this._context = null;

    /**
     * The AudioContext state.
     * @name FORGE.SoundManager#_contextState
     * @type {string}
     * @private
     */
    this._contextState = "running";

    /**
     * AnalyserNode to expose audio time and frequency data and create data visualisations.
     * @name FORGE.SoundManager#_analyser
     * @type {AnalyserNode}
     * @private
     */
    this._analyser = null;

    /**
     * Master GainNode used to control the overall volume of the audio graph.
     * @name FORGE.SoundManager#_masterGain
     * @type {GainNode}
     * @private
     */
    this._masterGain = null;

    /**
     * On sounds muted event dispatcher.
     * @name FORGE.SoundManager#_onMute
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onMute = null;

     /**
     * On sounds unmuted event dispatcher.
     * @name FORGE.SoundManager#_onUnmute
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onUnmute = null;

    /**
     * On sounds volume change event dispatcher.
     * @name FORGE.SoundManager#_onVolumeChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onVolumeChange = null;

    /**
     * On sounds disabled event dispatcher.
     * @name FORGE.SoundManager#_onDisable
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onDisable = null;

    /**
     * On sounds enabled event dispatcher.
     * @name FORGE.SoundManager#_onEnable
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onEnable = null;

    FORGE.BaseObject.call(this, "SoundManager");
};

FORGE.SoundManager.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.SoundManager.prototype.constructor = FORGE.SoundManager;

/**
 * Boot sequence.
 * @method FORGE.SoundManager#_boot
 * @private
 * @suppress {deprecated}
 */
FORGE.SoundManager.prototype.boot = function()
{
    this._sounds = [];

    if (FORGE.Device.iOS && FORGE.Device.webAudio === false)
    {
        this._channels = 1; //only 1 channel in iOS with AudioTag support
    }

    if (FORGE.Device.webAudio === true)
    {
        try
        {
            if (typeof window.AudioContext === "function")
            {
                this._context = new window.AudioContext();
            }
            else
            {
                this._context = new window.webkitAudioContext();
            }
        }
        catch (error)
        {
            this._context = null;
            this._useWebAudio = false;
            this._noAudio = true;
        }
    }

    if (FORGE.Device.audioTag === true && this._context === null)
    {
        this._useWebAudio = false;
        this._useAudioTag = true;
        this._noAudio = false;
    }

    if (this._context !== null)
    {
        if (typeof this._context.createGain === "undefined")
        {
            this._masterGain = this._context.createGainNode();
        }
        else
        {
            this._masterGain = this._context.createGain();
        }

        this._analyser = this._context.createAnalyser();
        this._analyser.connect(this._masterGain);

        this._masterGain.gain.value = this._volume;
        this._masterGain.connect(this._context.destination);

        // The common coordinate system used with WebGL.
        // The listener is always facing down the negative Z axis, the
        // positive Y axis points up, the positive X axis points right.
        this._context.listener.setOrientation(0, 0, -1, 0, 1, 0);
    }

    this._viewer.story.onSceneLoadStart.add(this._sceneLoadStartHandler, this);
};

/**
 * Event handler for scene start.
 * @method FORGE.SoundManager#_sceneLoadStartHandler
 * @private
 */
FORGE.SoundManager.prototype._sceneLoadStartHandler = function()
{
    if(typeof this._viewer.story.scene.config.audio !== "undefined")
    {
        this._parseSceneConfig(this._viewer.story.scene.config.audio);
    }
    else
    {
        //restore global sounds config
        this._applyConfig(this._config);

        //Is the sound manager enabled?
        if(this._enabled === false)
        {
            if(this._onDisable !== null)
            {
                this._onDisable.dispatch();
            }
        }
        else
        {
            if(this._onEnable !== null)
            {
                this._onEnable.dispatch();
            }
        }
    }
};

/**
 * Parse the scene configuration part related to sounds.
 * @method  FORGE.SoundManager#_parseSceneConfig
 * @private
 * @param  {AudioConfig} config - The scene configuration part related to sounds.
 */
FORGE.SoundManager.prototype._parseSceneConfig = function(config)
{
    var extendedConfig = /** @type {AudioConfig} */ FORGE.Utils.extendMultipleObjects(this._config, config);
    this._applyConfig(extendedConfig);

    //Is the sound manager enabled?
    if(this._enabled === false)
    {
        if(this._onDisable !== null)
        {
            this._onDisable.dispatch();
        }
    }
    else
    {
        if(this._onEnable !== null)
        {
            this._onEnable.dispatch();
        }
    }
};

/**
 * Set values from configuration file.
 * @method  FORGE.SoundManager#_applyConfig
 * @param {?AudioConfig} config - The config file.
 * @private
 */
FORGE.SoundManager.prototype._applyConfig = function(config)
{
    if(config !== null)
    {
        this._enabled = typeof config.enabled !== "undefined" ? Boolean(config.enabled) : true;
        this._maxVolume = (typeof config.volume !== "undefined" && typeof config.volume.max === "number") ? FORGE.Math.clamp(config.volume.max, 0, 1) : 1;

        if(this._volumeChanged === false)
        {
            this._defaultVolume = (typeof config.volume !== "undefined" && typeof config.volume.default === "number") ? FORGE.Math.clamp(config.volume.default, 0, this._maxVolume) : 1;
        }
        else
        {
            this._defaultVolume = FORGE.Math.clamp(this._volume, 0, this._maxVolume);
        }
    }
};

/**
 * Add a sound config to the manager.
 * @method FORGE.SoundManager#addConfig
 * @param {AudioConfig} config - The config you want to add.
 */
FORGE.SoundManager.prototype.addConfig = function(config)
{
    this._parseConfig(config);

    this._initSounds();
};

/**
 * Parse a playlist config object.
 * @method FORGE.SoundManager#_parseConfig
 * @private
 * @param {AudioConfig} config - The config you want to parse.
 */
FORGE.SoundManager.prototype._parseConfig = function(config)
{
    this._config = config;

    this._applyConfig(config);
};

/**
 * Initialize the sounds manager.
 * @method FORGE.PlaylistManager#_initSounds
 * @private
 */
FORGE.SoundManager.prototype._initSounds = function()
{
    if(typeof this._defaultVolume === "number" && this._volumeChanged === false)
    {
        this._volume = FORGE.Math.clamp(this._defaultVolume, 0, 1);
    }

    this._updateVolume();
};

/**
 * Update method called by the viewer main loop.
 * @method FORGE.SoundManager#update
 */
FORGE.SoundManager.prototype.update = function ()
{
    for (var i = 0, ii = this._sounds.length; i < ii; i++)
    {
        this._sounds[i].update();
    }

    // update listener position
    this._setContextListenerOrientation();
};

/**
 * Add a {@link FORGE.Sound} into the _sounds Array.
 * @method FORGE.SoundManager#add
 * @param {FORGE.Sound} sound - The {@link FORGE.Sound} to add.
 */
FORGE.SoundManager.prototype.add = function (sound)
{
    var index = this._indexOfSound(sound);

    if(index === -1)
    {
        this._sounds.push(sound);
    }
};

/**
 * Remove a {@link FORGE.Sound} into the _sounds Array.
 * @method FORGE.SoundManager#remove
 * @param {FORGE.Sound} sound - The {@link FORGE.Sound} to remove.
 */
FORGE.SoundManager.prototype.remove = function (sound)
{
    var index = this._indexOfSound(sound);

    if(index > -1)
    {
        this._sounds.splice(index, 1);
    }
};

/**
 * Internal method to find a {@link FORGE.Sound} index in the _sounds Array.
 * @method FORGE.SoundManager#_indexOfSound
 * @private
 * @param {FORGE.Sound} sound - The {@link FORGE.Sound} itself.
 * @return {number} Returns the index of the searched {@link FORGE.Sound} if found, -1 if not.
 *
 * @todo Either the {@link FORGE.Sound} itself or its index or its uid. (FORGE.Sound|Number|String)
 */
FORGE.SoundManager.prototype._indexOfSound = function (sound)
{
    if(this._sounds === null)
    {
        return -1;
    }

    var _sound;

    for (var i = 0, ii = this._sounds.length; i < ii; i++)
    {
        _sound = this._sounds[i];

        if(_sound === sound)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Suspend audio context if no sound are playing.
 * @method FORGE.SoundManager#suspend
 */
FORGE.SoundManager.prototype.suspend = function()
{
    if(this._context !== null && typeof this._context.suspend !== "undefined" && this._useWebAudio === true && FORGE.Device.safari === false)
    {
        if(this._contextState === "running")
        {
            var allStopped = true;
            for (var i = 0, ii = this._sounds.length; i < ii; i++)
            {
                if(this._sounds[i].playing === true || this._sounds[i].paused === true)
                {
                    allStopped = false;
                    break;
                }
            }

            if(allStopped === true)
            {
                this._contextState = "suspended";
                this._context.suspend();
            }
        }
    }
};

/**
 * Resume the audio context if at least one sound is playing.
 * @method FORGE.SoundManager#resume
 */
FORGE.SoundManager.prototype.resume = function()
{
    if(this._context !== null && typeof this._context.resume !== "undefined" && this._useWebAudio === true && FORGE.Device.safari === false)
    {
        if(this._contextState === "suspended")
        {
            for (var i = 0, ii = this._sounds.length; i < ii; i++)
            {
                if(this._sounds[i].playing === true || this._sounds[i].paused === true)
                {
                    this._contextState = "running";
                    this._context.resume();
                    break;
                }
            }
        }
    }
};

/**
 * Pause all playing sounds.
 * @method FORGE.SoundManager#pauseAll
 */
FORGE.SoundManager.prototype.pauseAll = function()
{
    for (var i = 0, ii = this._sounds.length; i < ii; i++)
    {
        if (this._sounds[i].playing === true)
        {
            this._sounds[i].pause();
            this._sounds[i].resumed = true;
        }
    }
};

/**
 * Play all sounds that have been paused with the pauseAll method.
 * @method FORGE.SoundManager#resumeAll
 */
FORGE.SoundManager.prototype.resumeAll = function()
{
    for (var i = 0, ii = this._sounds.length; i < ii; i++)
    {
        if (this._sounds[i].resumed === true)
        {
            this._sounds[i].resume();
            this._sounds[i].resumed = false;
        }
    }
};

/**
 * Mute method of the sounds.
 * @method FORGE.SoundManager#mute
 */
FORGE.SoundManager.prototype.mute = function()
{
    if(this._muted === true)
    {
        return;
    }

    this._muted = true;
    this._mutedVolume = this._volume;
    this._volume = 0;

    if (this._useWebAudio === true)
    {
        this._mutedVolume = this._masterGain.gain.value;
    }

    this._updateVolume();

    if(this._onMute !== null)
    {
        this._onMute.dispatch();
    }
};

/**
 * Unmute method of the sounds.
 * @method FORGE.SoundManager#unmute
 */
FORGE.SoundManager.prototype.unmute = function()
{
    if(this._muted === false)
    {
        return;
    }

    this._muted = false;
    this._volume = this._mutedVolume;

    this._updateVolume();

    if(this._onUnmute !== null)
    {
        this._onUnmute.dispatch();
    }
};

/**
 * Update volume method for the sounds.
 * @method FORGE.SoundManager#unmute
 * @private
 */
FORGE.SoundManager.prototype._updateVolume = function()
{
    if (this._useWebAudio === true)
    {
        this._masterGain.gain.value = this._volume;
    }
    else if (this._useAudioTag === true)
    {
        // Loop through the sound cache and change the volume of all html audio tags
        for (var i = 0; i < this._sounds.length; i++)
        {
            this._sounds[i]._sound.data.volume = FORGE.Math.clamp(this._sounds[i]._volume, 0, 1) * this._volume;
        }
    }
    this._volumeChanged = true;

    if(this._onVolumeChange !== null)
    {
        this._onVolumeChange.dispatch();
    }
};

/**
 * Change the sound manager orientation to follow the THREE perspective camera.
 * @method FORGE.SoundManager#_setContextListenerOrientation
 * @private
 */
FORGE.SoundManager.prototype._setContextListenerOrientation = function()
{
    if (this._useWebAudio === true && this._viewer.renderer.camera.main !== null)
    {
        var cameraDirection = new THREE.Vector3();
        var qCamera = this._viewer.renderer.camera.main.quaternion;

        // front vector indicating where the listener is facing to
        cameraDirection.set(0, 0, -1);
        cameraDirection.applyQuaternion(qCamera);
        var camera = cameraDirection.clone();

        // up vector repesenting the direction of the top of the listener head
        cameraDirection.set(0, 1, 0);
        cameraDirection.applyQuaternion(qCamera);
        var cameraUp = cameraDirection;

        // apply orientation values
        this._context.listener.setOrientation(camera.x, camera.y, camera.z, cameraUp.x, cameraUp.y, cameraUp.z);
    }
};

/**
 * Destroy sequence
 * @method FORGE.SoundManager#destroy
 */
FORGE.SoundManager.prototype.destroy = function()
{
    this._viewer.story.onSceneLoadStart.remove(this._sceneLoadStartHandler, this);

    this._viewer = null;
    this._config = null;

    var i = this._sounds.length;
    while(i--)
    {
        this._sounds[i].destroy();
    }

    this._sounds = null;

    this._context = null;
    this._analyser = null;
    this._masterGain = null;

    if(this._onMute !== null)
    {
        this._onMute.destroy();
        this._onMute = null;
    }

    if(this._onUnmute !== null)
    {
        this._onUnmute.destroy();
        this._onUnmute = null;
    }

    if(this._onVolumeChange !== null)
    {
        this._onVolumeChange.destroy();
        this._onVolumeChange = null;
    }

    if(this._onDisable !== null)
    {
        this._onDisable.destroy();
        this._onDisable = null;
    }

    if(this._onEnable !== null)
    {
        this._onEnable.destroy();
        this._onEnable = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};


/**
 * Get the audio context.
 * @name FORGE.SoundManager#context
 * @type {?AudioContext}
 * @readonly
 */
Object.defineProperty(FORGE.SoundManager.prototype, "context",
{
    /** @this {FORGE.SoundManager} */
    get: function()
    {
        return this._context;
    }
});

/**
 * Get the analyser.
 * @name FORGE.SoundManager#analyser
 * @type {?AnalyserNode}
 * @readonly
 */
Object.defineProperty(FORGE.SoundManager.prototype, "analyser",
{
    /** @this {FORGE.SoundManager} */
    get: function()
    {
        return this._analyser;
    }
});

/**
 * Get the analyser
 * @name  FORGE.SoundManager#inputNode
 * @type {?AudioDestinationNode}
 * @readonly
 */
Object.defineProperty(FORGE.SoundManager.prototype, "inputNode",
{
    /** @this {FORGE.SoundManager} */
    get: function()
    {
        return this._analyser;
    }
});

/**
 * Get the masterGain.
 * @name FORGE.SoundManager#masterGain
 * @type {?GainNode}
 * @readonly
 */
Object.defineProperty(FORGE.SoundManager.prototype, "masterGain",
{
    /** @this {FORGE.SoundManager} */
    get: function()
    {
        return this._masterGain;
    }
});

/**
 * The WebAudio API tag must be used?
 * @name FORGE.SoundManager#useWebAudio
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.SoundManager.prototype, "useWebAudio",
{
    /** @this {FORGE.SoundManager} */
    get: function()
    {
        return this._useWebAudio;
    },

    /** @this {FORGE.SoundManager} */
    set: function(value)
    {
        if(typeof value === "boolean")
        {
            this._useWebAudio = value;
            this._useAudioTag = !value;
        }
    }
});

/**
 * The Audio tag must be used?
 * @name FORGE.SoundManager#useAudioTag
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.SoundManager.prototype, "useAudioTag",
{
    /** @this {FORGE.SoundManager} */
    get: function()
    {
        return this._useAudioTag;
    },

    /** @this {FORGE.SoundManager} */
    set: function(value)
    {
        if(typeof value === "boolean")
        {
            this._useAudioTag = value;
            this._useWebAudio = !value;
        }
    }
});

/**
 * Get the enabled state for sounds.
 * @name FORGE.SoundManager#enabled
 * @type {boolean}
 */
Object.defineProperty(FORGE.SoundManager.prototype, "enabled", {

    /** @this {FORGE.SoundManager} */
    get: function()
    {
        return this._enabled;
    }

});

/**
 * Get or set the muted state for sounds.
 * @name FORGE.SoundManager#muted
 * @type {boolean}
 */
Object.defineProperty(FORGE.SoundManager.prototype, "muted", {

    /** @this {FORGE.SoundManager} */
    get: function()
    {
        return this._muted;
    },

    /** @this {FORGE.SoundManager} */
    set: function(value)
    {
        if(typeof value === "boolean")
        {
            if (value === true)
            {
                this.mute();
            }
            else
            {
                this.unmute();
            }
        }
    }
});

/**
 * Get or set the global volume for sounds.
 * @name FORGE.SoundManager#volume
 * @type {number}
 */
Object.defineProperty(FORGE.SoundManager.prototype, "volume", {

    /** @this {FORGE.SoundManager} */
    get: function()
    {
        if (this._useWebAudio === true)
        {
            return this._masterGain.gain.value;
        }
        else
        {
            return this._volume;
        }
    },

    /** @this {FORGE.SoundManager} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        value = FORGE.Math.clamp(value, 0, 1);
        if(this._maxVolume < value)
        {
            this._volume = this._maxVolume;
        }
        else
        {
            this._volume = value;
        }

        if (this._volume > 0)
        {
            this._muted = false;
        }

        this._updateVolume();
    }
});

/**
 * Get the sounds "onMute" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.SoundManager#onMute
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.SoundManager.prototype, "onMute",
{
    /** @this {FORGE.SoundManager} */
    get: function()
    {
        if(this._onMute === null)
        {
            this._onMute = new FORGE.EventDispatcher(this);
        }

        return this._onMute;
    }
});

/**
 * Get the sounds "onUnmute" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.SoundManager#onUnmute
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.SoundManager.prototype, "onUnmute",
{
    /** @this {FORGE.SoundManager} */
    get: function()
    {
        if(this._onUnmute === null)
        {
            this._onUnmute = new FORGE.EventDispatcher(this);
        }

        return this._onUnmute;
    }
});

/**
 * Get the sounds "onVolumeChange" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.SoundManager#onVolumeChange
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.SoundManager.prototype, "onVolumeChange",
{
    /** @this {FORGE.SoundManager} */
    get: function()
    {
        if(this._onVolumeChange === null)
        {
            this._onVolumeChange = new FORGE.EventDispatcher(this);
        }

        return this._onVolumeChange;
    }
});

/**
 * Get the sounds "onDisable" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.SoundManager#onDisable
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.SoundManager.prototype, "onDisable",
{
    /** @this {FORGE.SoundManager} */
    get: function()
    {
        if(this._onDisable === null)
        {
            this._onDisable = new FORGE.EventDispatcher(this);
        }

        return this._onDisable;
    }
});

/**
 * Get the sounds "onEnable" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.SoundManager#onDisable
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.SoundManager.prototype, "onEnable",
{
    /** @this {FORGE.SoundManager} */
    get: function()
    {
        if(this._onEnable === null)
        {
            this._onEnable = new FORGE.EventDispatcher(this);
        }

        return this._onEnable;
    }
});


/**
 * @namespace {Object} FORGE.SoundType
 */
FORGE.SoundType = {};

/**
 * @name FORGE.SoundType.STEREO
 * @type {string}
 * @const
 */
FORGE.SoundType.STEREO = "stereo";

/**
 * @name FORGE.SoundType.SPATIAL
 * @type {string}
 * @const
 */
FORGE.SoundType.SPATIAL = "3d";

/**
 * @name FORGE.SoundType.AMBISONIC
 * @type {string}
 * @const
 */
FORGE.SoundType.AMBISONIC = "ambisonic";
/**
 * A FORGE.Sound is an object that manages a sound.
 *
 * @constructor FORGE.Sound
 * @param {FORGE.Viewer} viewer - The {@link FORGE.Viewer} reference.
 * @param {string} key - The sound file id reference.
 * @param {string} url - The sound file url.
 * @param {boolean=} ambisonic - Is the sound ambisonic and need binaural rendering?
 * @extends {FORGE.BaseObject}
 *
 * @todo  Ability to force audio type into config
 * @todo  Make a test plugin that creates sound, add sound to the PluginObjectFactory
 * @todo  Loop during x steps (parameter) only if loop is true
 */
FORGE.Sound = function(viewer, key, url, ambisonic)
{
    /**
     * The viewer reference.
     * @name FORGE.Sound#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The sound identifier.
     * @name FORGE.Sound#_key
     * @type {string}
     * @private
     */
    this._key = key;

    /**
     * The sound file url.
     * @name FORGE.Sound#_url
     * @type {string}
     * @private
     */
    this._url = url;

    /**
     * The current volume of the sound.
     * @name FORGE.Sound#_volume
     * @type {number}
     * @private
     */
    this._volume = 1;

    /**
     * The volume level before a mute of the sound.
     * @name FORGE.Sound#_mutedVolume
     * @type {number}
     * @private
     */
    this._mutedVolume = 1;

    /**
     * The muted state of the sound.
     * @name FORGE.Sound#_muted
     * @type {boolean}
     * @private
     */
    this._muted = false;

    /**
     * Is the sound enabled?
     * @name  FORGE.Sound#enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * Is the sound spatialized?
     * @name  FORGE.Sound#_spatialized
     * @type {boolean}
     * @private
     */
    this._spatialized = false;

    /**
     * The duration in seconds of the sound.
     * @name FORGE.Sound#_duration
     * @type {number}
     * @private
     */
    this._duration = 0;

    /**
     * The duration in milliseconds of the sound.
     * @name FORGE.Sound#_durationMS
     * @type {number}
     * @private
     */
    this._durationMS = 0;

    /**
     * The start time in milliseconds of the sound linked to the global clock.
     * @name FORGE.Sound#_startTime
     * @type {number}
     * @private
     */
    this._startTime = 0;

    /**
     * The pause time in milliseconds of the sound linked to the global clock.
     * @name FORGE.Sound#_pauseTime
     * @type {number}
     * @private
     */
    this._pauseTime = 0;

    /**
     * The current time in milliseconds of the sound.<br>
     * The current time value is based on duration minus time on the current clock because the AudioContext currentTime value is global to the audio context.
     * @name FORGE.Sound#_currentTime
     * @type {number}
     * @private
     */
    this._currentTime = 0;

    /**
     * The loop state of the sound.
     * @name FORGE.Sound#_loop
     * @type {boolean}
     * @private
     */
    this._loop = false;

    /**
     * The playing state of the sound.
     * @name FORGE.Sound#_playing
     * @type {boolean}
     * @private
     */
    this._playing = false;

    /**
     * The number of play of the sound.
     * @name FORGE.Sound#_playCount
     * @type {number}
     * @private
     */
    this._playCount = 0;

    /**
     * The paused state of the sound.
     * @name FORGE.Sound#_paused
     * @type {boolean}
     * @private
     */
    this._paused = false;

    /**
     * The resumed state of the sound.
     * @name FORGE.Sound#_resumed
     * @type {boolean}
     * @private
     */
    this._resumed = false;

    /**
     * The sound file with augmented properties.
     * @property {AudioBuffer} data The sound file data contained into an AudioBuffer.
     * @name FORGE.Sound#_soundFile
     * @type {?FORGE.File}
     * @private
     */
    this._soundFile = null;

    /**
     * The AudioBufferSourceNode instance used to play audio data contained within an AudioBuffer object.
     * @name FORGE.Sound#_sound
     * @type {?AudioBufferSourceNode}
     * @private
     */
    this._sound = null;

    /**
     * The sound file data contained into an AudioBuffer.
     * @name FORGE.Sound#_buffer
     * @type {?AudioBuffer}
     * @private
     */
    this._buffer = null;

    /**
     * The sound file position data contained into a PannerNode.
     * @name FORGE.Sound#_panner
     * @type {?AudioPannerNode}
     * @private
     */
    this._panner = null;

    /**
     * The AudioContext interface.
     * @name FORGE.Sound#_context
     * @type {?AudioContext}
     * @private
     */
    this._context = null;

    /**
     * The AudioDestinationNode representing the final destination of all audio in the context.
     * @name FORGE.Sound#_inputNode
     * @type {?AudioDestinationNode}
     * @private
     */
    this._inputNode = null;

    /**
     * The GainNode which can be used to control the overall volume of the audio graph.
     * @type {?GainNode}
     * @private
     */
    this._gainNode = null;

    /**
     * THREE Vector3 x coordinate.
     * @name  FORGE.Sound#_x
     * @type {number}
     * @private
     */
    this._x = 0;

    /**
     * THREE Vector3 y coordinate.
     * @name  FORGE.Sound#_y
     * @type {number}
     * @private
     */
    this._y = 0;

    /**
     * THREE Vector3 z coordinate.
     * @name  FORGE.Sound#_z
     * @type {number}
     * @private
     */
    this._z = 0;

    /**
     * FOADecoder is a ready-made FOA decoder and binaural renderer.
     * @name  FORGE.Sound#_decoder
     * @type {?FOADecoder}
     * @private
     */
    this._decoder = null;

    /**
     * Is it an ambisonical sound?
     * @name  FORGE.Sound#_ambisonic
     * @type {boolean}
     * @private
     */
    this._ambisonic = ambisonic || false;

    /**
     * Default channel map for ambisonic sound.
     * @name  FORGE.Sound#_defaultChannelMap
     * @type {Array<number>}
     * @private
     */
    this._defaultChannelMap = [0, 1, 2, 3]; //AMBIX
    // this._defaultChannelMap = [0, 3, 1, 2]; //FUMA

    /**
     * To save the pending state to be applied after the sound object will be ready.
     * @name FORGE.Sound#_pendingPlay
     * @type {boolean}
     * @private
     */
    this._pendingPlay = false;

    /**
     * Is this sound object is ready?
     * @name FORGE.Sound#_ready
     * @type {boolean}
     * @private
     */
    this._ready = false;

    /**
     * This is a reference to decodeComplete function but with a different this bind reference.
     * @name  FORGE.Sound#_decodeCompleteBind
     * @type {?Function}
     * @private
     */
    this._decodeCompleteBind = null;

    /**
     * This is a reference to decodeError function but with a different this bind reference.
     * @name  FORGE.Sound#_decodeErrorBind
     * @type {?Function}
     * @private
     */
    this._decodeErrorBind = null;

    /**
     * Is the sound decoded?
     * @name  FORGE.Sound#_decoded
     * @type {boolean}
     * @private
     */
    this._decoded = false;

    /**
     * On sound decoded event dispatcher.
     * @name FORGE.Sound#_onSoundDecode
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onSoundDecode = null;

    /**
     * On load start event dispatcher.
     * @name FORGE.Sound#_onLoadStart
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onLoadStart = null;

    /**
     * On loaded data event dispatcher.
     * @name FORGE.Sound#_onLoadedData
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onLoadedData = null;

    /**
     * On can play event dispatcher.
     * @name FORGE.Sound#_onCanPlay
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onCanPlay = null;

    /**
     * On can play through event dispatcher.
     * @name FORGE.Sound#_onCanPlayThrough
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onCanPlayThrough = null;

    /**
     * On sound muted event dispatcher.
     * @name FORGE.Sound#_onMute
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onMute = null;

    /**
     * On sound unmuted event dispatcher.
     * @name FORGE.Sound#_onUnmute
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onUnmute = null;

    /**
     * On sound volume change event dispatcher.
     * @name FORGE.Sound#_onVolumeChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onVolumeChange = null;

    /**
     * On sound play event dispatcher.
     * @name FORGE.Sound#_onPlay
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On sound stop event dispatcher.
     * @name FORGE.Sound#_onStop
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onStop = null;

    /**
     * On sound pause event dispatcher.
     * @name FORGE.Sound#_onPause
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * On sound resume event dispatcher.
     * @name FORGE.Sound#_onResume
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onResume = null;

    /**
     * On sound decoded event dispatcher.
     * @name FORGE.Sound#_onEnded
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onEnded = null;

    FORGE.BaseObject.call(this, "Sound");

    this._boot();
};

FORGE.Sound.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Sound.prototype.constructor = FORGE.Sound;

/**
 * Boot sequence.
 * @method FORGE.Sound#_boot
 * @private
 * @suppress {deprecated}
 */
FORGE.Sound.prototype._boot = function()
{
    if (this._ambisonic === true && this._isAmbisonic() === false)
    {
        this.log("FORGE.Sound: can't manage ambisonic sound without Google Chrome Omnitone library and WebAudio API.");
        this._ambisonic = false;
    }

    //register the uid
    this._uid = this._key;
    this._register();

    if (this._viewer.audio.useWebAudio === true)
    {
        this._context = this._viewer.audio.context;

        this._inputNode = this._viewer.audio.inputNode;

        if (typeof this._context.createGain === "undefined")
        {
            this._gainNode = this._context.createGainNode();
        }
        else
        {
            this._gainNode = this._context.createGain();
        }

        this._gainNode.gain.value = this._volume * this._viewer.audio.volume;
        this._gainNode.connect(this._inputNode);
    }
    if (this._viewer.audio.useAudioTag === true || this._isAmbisonic() === true)
    {
        if (this._viewer.cache.has(FORGE.Cache.types.SOUND, this._key) === true)
        {
            this._loadComplete(this._viewer.cache.get(FORGE.Cache.types.SOUND, this._key));
        }

        //Listen to the main volume change to adapt the sound volume accordingly.
        this._viewer.audio.onVolumeChange.add(this._mainVolumeChangeHandler, this);
    }

    this._viewer.audio.onDisable.add(this._disableSoundHandler, this);

    if (this._url !== "")
    {
        this._viewer.load.sound(this._key, this._url, this._loadComplete, this, this._isAmbisonic());

        if (this._onLoadStart !== null)
        {
            this._onLoadStart.dispatch();
        }
    }

    this._viewer.audio.add(this);
};

/**
 * Event handler for load complete event, it launch the decoding of the sound file.
 * @method FORGE.Sound#_loadComplete
 * @private
 * @param {FORGE.File} file - The sound file.
 */
FORGE.Sound.prototype._loadComplete = function(file)
{
    // In some case, the sound is destroyed before the loading
    if(this._alive === false)
    {
        return;
    }

    this._soundFile = file;

    this._ready = true;

    // loaded events
    if (this._onLoadedData !== null)
    {
        this._onLoadedData.dispatch();
    }

    if (this._viewer.audio.useWebAudio === true)
    {
        this._decode(this._soundFile);
    }
    else
    {
        this._dispatchDecodedEvents();

        this._decodeComplete(null);
    }
};

/**
 * Decoding of the sound file.
 * @method FORGE.Sound#_decode
 * @private
 * @param {Object} file - The sound file
 */
FORGE.Sound.prototype._decode = function(file)
{
    if (file)
    {
        if (this._decoded === false)
        {
            this._decodeCompleteBind = this._decodeComplete.bind(this);
            this._decodeErrorBind = this._decodeError.bind(this);

            if (this._isAmbisonic() === true)
            {
                // FOA decoder and binaural renderer
                this._decoder = Omnitone.createFOADecoder(this._context, file.data,
                {
                    channelMap: this._defaultChannelMap
                    // HRTFSetUrl: 'YOUR_HRTF_SET_URL', //Base URL for the cube HRTF sets.
                    // postGainDB: 0, //Post-decoding gain compensation in dB.
                });

                // Initialize the decoder
                this._decoder.initialize().then(this._decodeCompleteBind, this._decodeErrorBind);
            }
            else
            {
                this._context.decodeAudioData(file.data, this._decodeCompleteBind, this._decodeErrorBind);
            }
        }
    }
};

/**
 * Event handler for decode error event, it stores decoding data into the sound file object.
 * @method FORGE.Sound#_decodeError
 * @private
 */
FORGE.Sound.prototype._decodeError = function()
{
    if (this._soundFile !== null)
    {
        this._soundFile.data = null;
        this._decoded = false;
    }
};

/**
 * Dispatcher for decoded events.
 * @method  FORGE.Sound#_dispatchDecodedEvents
 * @private
 */
FORGE.Sound.prototype._dispatchDecodedEvents = function()
{
    if (this._onSoundDecode !== null)
    {
        this._onSoundDecode.dispatch();
    }

    if (this._onCanPlay !== null)
    {
        this._onCanPlay.dispatch();
    }

    if (this._onCanPlayThrough !== null)
    {
        this._onCanPlayThrough.dispatch();
    }
};

/**
 * Event handler for decode complete event, it stores decoding data into the sound file object.
 * @method FORGE.Sound#_decodeComplete
 * @private
 * @param  {?AudioBuffer} buffer - The raw binary data buffer.
 */
FORGE.Sound.prototype._decodeComplete = function(buffer)
{
    if (this._soundFile === null)
    {
        this.log("FORGE.Sound._decodeComplete error, sound file is null");
        return;
    }

    if (buffer)
    {
        this._soundFile.data = buffer;
    }

    this._decoded = true;

    this._dispatchDecodedEvents();

    if (this._viewer.audio.useAudioTag === true || this._isAmbisonic() === true)
    {
        this._sound = this._viewer.cache.get(FORGE.Cache.types.SOUND, this._key);

        this._updateVolume();

        this._duration = 0;
        if (this._sound.data.duration)
        {
            this._duration = this._sound.data.duration;
            this._durationMS = Math.ceil(this._duration * 1000);
        }
    }

    if (this._pendingPlay === true)
    {
        this.play(this._currentTime, this._loop, true);
    }
};

/**
 * Handles the main volume change, update the volume factor to the sound volume.
 * @method FORGE.Sound#_mainVolumeChangeHandler
 * @private
 */
FORGE.Sound.prototype._mainVolumeChangeHandler = function()
{
    this._updateVolume();
};

/**
 * Apply the main volume factor to the sound volume.
 * @method FORGE.Sound#_updateVolume
 * @private
 */
FORGE.Sound.prototype._updateVolume = function()
{
    if (this._sound !== null && (this._viewer.audio.useAudioTag === true || this._isAmbisonic() === true))
    {
        this._sound.data.volume = FORGE.Math.clamp(this._volume, 0, 1) * this._viewer.audio.volume;
    }
};

/**
 * Disable the sound.
 * @method FORGE.Sound#_disableSoundHandler
 * @private
 */
FORGE.Sound.prototype._disableSoundHandler = function()
{
    if (this._playing === true)
    {
        this.pause();
    }
    else if (this.paused === false)
    {
        this.stop();
    }
};

/**
 * Reset of the sound values.
 * @method FORGE.Sound#_reset
 * @private
 */
FORGE.Sound.prototype._reset = function()
{
    this._currentTime = 0;
    this._pendingPlay = false;
    this._playing = false;
    this._paused = false;
};

/**
 * Setup for sound panner.
 * @method FORGE.Sound#_setupPanner
 * @private
 */
FORGE.Sound.prototype._setupPanner = function()
{
    this._panner = this._context.createPanner();
    this._panner.panningModel = "HRTF";
    this._panner.distanceModel = "inverse";
    this._panner.refDistance = 1;
    this._panner.maxDistance = 10000;
    this._panner.rolloffFactor = 1;
    this._panner.coneInnerAngle = 360;
    this._panner.coneOuterAngle = 0;
    this._panner.coneOuterGain = 0;
    // look to listener position (x, y, z)
    this._panner.setOrientation(0, 0, 0);
    // init the 3D position of the panner (x, y, z)
    this._panner.setPosition(0, 0, 0);
};

/**
 * Apply sound panner orientation.
 * @method  FORGE.Sound#_applyPanner
 * @param {boolean=} connect - Panner must be connected to sound and gainNode?
 * @private
 */
FORGE.Sound.prototype._applyPanner = function(connect)
{
    if (this._panner === null)
    {
        this._setupPanner();
    }

    this._panner.setPosition(this._x, this._y, this._z);

    if (connect === true)
    {
        this._sound.connect(this._panner);
        // Connect the "panner" object to the "destination" object.
        this._panner.connect(this._gainNode);
    }
};

/**
 * Does the audio sound must be considered as ambisonic?
 * @method FORGE.Sound#_isAmbisonic
 * @return {boolean} Is ambisonic?
 * @private
 */
FORGE.Sound.prototype._isAmbisonic = function()
{
    return (this._ambisonic === true && this._viewer.audio.useWebAudio === true && typeof Omnitone !== "undefined");
};

/**
 * Update method called by the viewer main loop.
 * @method FORGE.Sound#update
 */
FORGE.Sound.prototype.update = function()
{
    if (this._playing === true && this._paused === false)
    {
        var time = this._viewer.clock.time - this._startTime;
        if (time >= this._durationMS)
        {
            this._currentTime = this._durationMS;

            if (this._viewer.audio.useWebAudio === true || this._viewer.audio.useAudioTag === true)
            {
                this.stop(true);

                if (this._onEnded !== null)
                {
                    this._onEnded.dispatch();
                }

                if (this._loop === true)
                {
                    this._currentTime = 0;
                    this.resume();
                }
            }
        }
        else
        {
            //also for this case when using streaming for data or bad headers : this._duration === Infinity
            this._currentTime = time;
        }
    }

    if (this._decoder !== null && this._playing === true)
    {
        // Rotate the binaural renderer based on a Three.js camera object.
        var m4 = this._viewer.renderer.camera.modelViewInverse;
        this._decoder.setRotationMatrixFromCamera(m4);
    }
};

/**
 * Play method of the sound.
 * @method FORGE.Sound#play
 * @param {number=} position - The start position to play the sound in milliseconds.
 * @param {?boolean=} loop - The loop state of the sound.
 * @param {?boolean=} forceRestart - If the sound is already playing you can set forceRestart to restart it from the beginning.
 * @suppress {deprecated}
 */
FORGE.Sound.prototype.play = function(position, loop, forceRestart)
{
    if (this._viewer.audio.enabled === false || this._enabled === false)
    {
        this._playing = false;
        this._paused = false;
        return;
    }

    this._loop = loop || this._loop;

    if (this._playing === true)
    {
        if (forceRestart === true)
        {
            this.stop();
        }
        else
        {
            return;
        }
    }

    if (this._ready === false)
    {
        this._pendingPlay = true;
        return;
    }

    if (this._viewer.audio.useWebAudio === true && this._isAmbisonic() === false)
    {
        //  Does the sound need decoding?
        if (this._decoded === true)
        {
            //  Do we need to do this every time we play? How about just if the buffer is empty?
            if (this._buffer === null)
            {
                this._buffer = this._soundFile.data;
            }

            this._sound = this._context.createBufferSource();
            this._sound.buffer = this._buffer;

            if (this._spatialized === true)
            {
                this._applyPanner(true);
            }
            else
            {
                this._sound.connect(this._gainNode);
            }

            this._duration = this._sound.buffer.duration;
            this._durationMS = Math.ceil(this._duration * 1000);

            if (!isNaN(position) && position < this._durationMS)
            {
                this._startTime = this._viewer.clock.time - position;
            }
            else
            {
                position = 0;
                this._startTime = this._viewer.clock.time;
            }

            var time = FORGE.Math.round10(position / 1000);
            //  Useful to cache this somewhere perhaps?
            if (typeof this._sound.start === "undefined")
            {
                this._sound.noteGrainOn(0, time % this._duration, this._duration);
            }
            else
            {
                // Start playback, but make sure we stay in bound of the buffer.
                this._sound.start(0, time % this._duration, this._duration);
            }

            this._playing = true;
            this._currentTime = /** @type {number} */ (position);
            this._playCount++;

            if (this._onPlay !== null)
            {
                this._onPlay.dispatch();
            }
        }
        else
        {
            this.log("Sound is not decoded yet");
            this._pendingPlay = true;
            return;
        }
    }
    else if (this._viewer.audio.useAudioTag === true || this._isAmbisonic() === true)
    {
        if (this._duration === 0)
        {
            this._duration = this._sound.data.duration;
            this._durationMS = Math.ceil(this._duration * 1000);
        }
        else if (this._duration === Infinity)
        {
            this._sound.data.loop = true;
        }

        if (!isNaN(position) && this._durationMS !== 0 && position < this._durationMS)
        {
            this._sound.data.currentTime = FORGE.Math.round10(position / 1000);
            this._startTime = this._viewer.clock.time - position;
        }
        else
        {
            position = 0;
            this._sound.data.currentTime = position;
            this._startTime = this._viewer.clock.time;
        }

        this._sound.data.play();

        this._playing = true;
        this._currentTime = /** @type {number} */ (position);
        this._playCount++;

        if (this._onPlay !== null)
        {
            this._onPlay.dispatch();
        }
    }

    this._viewer.audio.resume();
};

/**
 * Stop method of the sound.
 * @method FORGE.Sound#stop
 * @param  {boolean=} internal - Internal use: true prevents event firing.
 */
FORGE.Sound.prototype.stop = function(internal)
{
    if (this._sound !== null)
    {
        this._stop(true);

        this._pauseTime = this._viewer.clock.time;
        this._startTime = this._viewer.clock.time;
        this._pendingPlay = false;
        this._playing = false;
        this._paused = false;

        if (this._onStop !== null && internal === true)
        {
            this._onStop.dispatch();
        }

        this._viewer.audio.suspend();
    }
    else if (this._ready === false || this._decoded !== true)
    {
        this._reset();
    }
};

/**
 * Stop actions to apply to the sound.
 * @method FORGE.Sound#_stop
 * @private
 * @param {boolean} resetCurrentTime - To force a reset of the current time
 * @suppress {deprecated}
 */
FORGE.Sound.prototype._stop = function(resetCurrentTime)
{
    if (this._viewer.audio.useWebAudio === true && this._isAmbisonic() === false)
    {
        if (typeof this._sound.stop === "undefined")
        {
            this._sound.noteOff(0);
        }
        else
        {
            try
            {
                this._sound.stop(0);
            }
            catch (e)
            {

            }
        }

        // Clean up the buffer source
        this._sound.disconnect(0);

        if (resetCurrentTime === true)
        {
            this._currentTime = 0;
        }
    }
    else if (this._viewer.audio.useAudioTag === true || this._isAmbisonic() === true)
    {
        this._sound.data.pause();
        if (resetCurrentTime === true)
        {
            this._currentTime = 0;
            this._sound.data.currentTime = 0;
        }
    }
};

/**
 * Pause method of the sound.
 * @method FORGE.Sound#pause
 */
FORGE.Sound.prototype.pause = function()
{
    if (this._playing === true && this._sound !== null)
    {
        this._stop(false);

        this._paused = true;
        this._pauseTime = this._viewer.clock.time;
        this._pendingPlay = false;
        this._playing = false;

        if (this._onPause !== null)
        {
            this._onPause.dispatch();
        }

        this._viewer.audio.suspend();
    }
    else if (this._ready === false || this._decoded !== true)
    {
        this._reset();
    }
};

/**
 * Resume method of the sound.
 * @method FORGE.Sound#resume
 * @suppress {deprecated}
 */
FORGE.Sound.prototype.resume = function()
{
    if (this._viewer.audio.enabled === false || this._enabled === false)
    {
        return;
    }

    if (this._paused === true || this._playing === false || this._resumed === true)
    {
        if (this._sound === null)
        {
            this.play(this._currentTime, this._loop, true);
            return;
        }
        else
        {
            this._startTime = this._viewer.clock.time - (this._pauseTime - this._startTime);
            this._currentTime = this._viewer.clock.time - this._startTime; //force current time update
            var time = FORGE.Math.round10(this._currentTime / 1000);

            if (this._viewer.audio.useWebAudio === true && this._isAmbisonic() === false)
            {
                this._sound = this._context.createBufferSource();
                this._sound.buffer = this._buffer;

                if (this._spatialized === true)
                {
                    this._applyPanner(true);
                }
                else
                {
                    this._sound.connect(this._gainNode);
                }

                var duration = Math.ceil((this._durationMS - this._currentTime) / 1000);

                if (typeof this._sound.start === "undefined")
                {
                    this._sound.noteGrainOn(0, time % this._duration, duration);
                }
                else
                {
                    this._sound.start(0, time % this._duration, duration);
                }
            }
            else if (this._viewer.audio.useAudioTag === true || this._isAmbisonic() === true)
            {
                this._sound.data.currentTime = time;
                this._sound.data.play();
            }
        }

        this._playing = true;
        this._paused = false;

        if (this._onResume !== null)
        {
            this._onResume.dispatch();
        }

        this._viewer.audio.resume();
    }
    else if (this._ready === false || this._decoded === false)
    {
        this._reset();
        this._pendingPlay = true;
    }
};

/**
 * Mute method of the sound.
 * @method FORGE.Sound#mute
 */
FORGE.Sound.prototype.mute = function()
{
    if (this._muted === true || this._viewer.audio.enabled === false || this._enabled === false)
    {
        return;
    }

    this._muted = true;
    this._mutedVolume = this._volume;
    this._volume = 0;

    if (this._viewer.audio.useWebAudio === true && this._isAmbisonic() === false)
    {
        this._gainNode.gain.value = this._volume;
    }
    else if ((this._viewer.audio.useAudioTag === true || this._isAmbisonic() === true) && this._sound !== null)
    {
        this._sound.data.volume = this._volume;
    }

    if (this._onMute !== null)
    {
        this._onMute.dispatch();
    }
};

/**
 * Unmute method of the sound.
 * @method FORGE.Sound#unmute
 */
FORGE.Sound.prototype.unmute = function()
{
    if (this._muted === false || this._viewer.audio.enabled === false || this._enabled === false)
    {
        return;
    }

    this._muted = false;
    this._volume = this._mutedVolume;

    if (this._viewer.audio.useWebAudio === true && this._isAmbisonic() === false)
    {
        this._gainNode.gain.value = this._mutedVolume;
    }
    else if ((this._viewer.audio.useAudioTag === true || this._isAmbisonic() === true) && this._sound !== null)
    {
        this._sound.data.volume = this._mutedVolume;
    }

    if (this._onUnmute !== null)
    {
        this._onUnmute.dispatch();
    }
};

/**
 * Augmented destroy method.
 * @method FORGE.Sound#destroy
 */
FORGE.Sound.prototype.destroy = function()
{
    this.stop();

    if (this._viewer.audio.useAudioTag === true || this._isAmbisonic() === true)
    {
        this._viewer.audio.onVolumeChange.remove(this._mainVolumeChangeHandler, this);
    }

    this._viewer.audio.onDisable.remove(this._disableSoundHandler, this);

    this._viewer.audio.remove(this);

    this._viewer = null;

    this._soundFile = null;
    this._sound = null;
    this._buffer = null;
    this._context = null;
    this._inputNode = null;
    this._gainNode = null;
    this._panner = null;

    this._decodeCompleteBind = null;
    this._decodeErrorBind = null;

    if (this._onSoundDecode !== null)
    {
        this._onSoundDecode.destroy();
        this._onSoundDecode = null;
    }

    if (this._onLoadStart !== null)
    {
        this._onLoadStart.destroy();
        this._onLoadStart = null;
    }

    if (this._onLoadedData !== null)
    {
        this._onLoadedData.destroy();
        this._onLoadedData = null;
    }

    if (this._onCanPlay !== null)
    {
        this._onCanPlay.destroy();
        this._onCanPlay = null;
    }

    if (this._onCanPlayThrough !== null)
    {
        this._onCanPlayThrough.destroy();
        this._onCanPlayThrough = null;
    }

    if (this._onMute !== null)
    {
        this._onMute.destroy();
        this._onMute = null;
    }

    if (this._onUnmute !== null)
    {
        this._onUnmute.destroy();
        this._onUnmute = null;
    }

    if (this._onVolumeChange !== null)
    {
        this._onVolumeChange.destroy();
        this._onVolumeChange = null;
    }

    if (this._onPlay !== null)
    {
        this._onPlay.destroy();
        this._onPlay = null;
    }

    if (this._onStop !== null)
    {
        this._onStop.destroy();
        this._onStop = null;
    }

    if (this._onPause !== null)
    {
        this._onPause.destroy();
        this._onPause = null;
    }

    if (this._onResume !== null)
    {
        this._onResume.destroy();
        this._onResume = null;
    }

    if (this._onEnded !== null)
    {
        this._onEnded.destroy();
        this._onEnded = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get and set the sound enabled status.
 * @name FORGE.Sound#enabled
 * @type {boolean}
 */
Object.defineProperty(FORGE.Sound.prototype, "enabled",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {FORGE.Sound} */
    set: function(value)
    {
        if (typeof value === "boolean")
        {
            this._enabled = value;

            if (this._enabled === false && (this._playing === true || this._paused === true))
            {
                this.stop();
            }
        }
    }
});


/**
 * Get or set the current time in milliseconds of the sound.
 * @name FORGE.Sound#currentTime
 * @type {number}
 */
Object.defineProperty(FORGE.Sound.prototype, "currentTime",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._currentTime;
    },

    /** @this {FORGE.Sound} */
    set: function(value)
    {
        if (typeof value !== "number")
        {
            return;
        }

        this.pause();
        this._currentTime = value;
        if (this._playing === true)
        {
            this.resume();
        }
    }
});

/**
 * Get or set the spatialized state of the sound.
 * @name FORGE.Sound#spatialized
 * @type {boolean}
 */
Object.defineProperty(FORGE.Sound.prototype, "spatialized",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._spatialized;
    },

    /** @this {FORGE.Sound} */
    set: function(value)
    {
        if (typeof value === "boolean")
        {
            this._spatialized = value;
        }
    }
});

/**
 * Get the ambisonic state of the sound.
 * @name FORGE.Sound#ambisonic
 * @type {boolean}
 */
Object.defineProperty(FORGE.Sound.prototype, "ambisonic",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._ambisonic;
    }
});

/**
 * Get the duration in seconds of the sound.
 * @name FORGE.Sound#duration
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.Sound.prototype, "duration",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._duration;
    }
});

/**
 * Get or set the muted state of the sound.
 * @name FORGE.Sound#muted
 * @type {boolean}
 */
Object.defineProperty(FORGE.Sound.prototype, "muted",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return (this._muted || this._viewer.audio.mute);
    },

    /** @this {FORGE.Sound} */
    set: function(value)
    {
        if (typeof value === "boolean")
        {
            if (value === true)
            {
                this.mute();
            }
            else
            {
                this.unmute();
            }
        }
    }
});

/**
 * Get or set the volume of the sound.
 * @name FORGE.Sound#volume
 * @type {number}
 */
Object.defineProperty(FORGE.Sound.prototype, "volume",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._volume;
    },

    /** @this {FORGE.Sound} */
    set: function(value)
    {
        if (typeof value !== "number" || isNaN(value) === true)
        {
            return;
        }

        value = FORGE.Math.clamp(value, 0, 1);

        if (value === this._volume || this._viewer.audio.enabled === false || this._enabled === false)
        {
            return;
        }

        this._volume = value;

        if (this._volume > 0)
        {
            this._muted = false;
        }

        if (this._viewer.audio.useWebAudio === true && this._isAmbisonic() === false)
        {
            this._gainNode.gain.value = value;
        }
        else
        {
            this._updateVolume();
        }

        if (this._onVolumeChange !== null)
        {
            this._onVolumeChange.dispatch();
        }
    }
});

/**
 * Get the decoded status of the sound.
 * @name FORGE.Sound#decoded
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Sound.prototype, "decoded",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._soundFile === null)
        {
            return false;
        }

        return this._decoded;
    }
});

/**
 * Get the number of play of the sound.
 * @name FORGE.Sound#playCount
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Sound.prototype, "playCount",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._playCount;
    }
});

/**
 * Get the playing status of the sound.
 * @name FORGE.Sound#playing
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Sound.prototype, "playing",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._playing;
    }
});

/**
 * Get the ready status of the sound.
 * @name FORGE.Sound#ready
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Sound.prototype, "ready",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._ready;
    }
});

/**
 * Get the paused status of the sound.
 * @name FORGE.Sound#paused
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Sound.prototype, "paused",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._paused;
    }
});

/**
 * Get/Set the resumed status of the sound.
 * @name FORGE.Sound#resumed
 * @type {boolean}
 */
Object.defineProperty(FORGE.Sound.prototype, "resumed",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._resumed;
    },

    /** @this {FORGE.Sound} */
    set: function(value)
    {
        if (typeof value === "boolean")
        {
            this._resumed = value;
        }
    }
});

/**
 * Get and set the loop status of the sound.
 * @name FORGE.Sound#loop
 * @type {boolean}
 */
Object.defineProperty(FORGE.Sound.prototype, "loop",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._loop;
    },

    /** @this {FORGE.Sound} */
    set: function(value)
    {
        if (typeof value === "boolean")
        {
            this._loop = value;

            if ((this._viewer.audio.useAudioTag === true || this._isAmbisonic() === true) && this._sound !== null && this._duration === Infinity)
            {
                this._sound.data.loop = this._loop;
            }
        }
    }
});

/**
 * Get and set the x axis position of the sound.
 * @name FORGE.Sound#x
 * @type {number}
 */
Object.defineProperty(FORGE.Sound.prototype, "x",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._x;
    },

    /** @this {FORGE.Sound} */
    set: function(value)
    {
        if (typeof value === "number")
        {
            this._x = value;

            if ((this._viewer.audio.useWebAudio === true && this._isAmbisonic() === false) && this._sound !== null && this._panner !== null && this._spatialized === true)
            {
                this._applyPanner();
            }
        }
    }
});

/**
 * Get and set the y axis position of the sound.
 * @name FORGE.Sound#y
 * @type {number}
 */
Object.defineProperty(FORGE.Sound.prototype, "y",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._y;
    },

    /** @this {FORGE.Sound} */
    set: function(value)
    {
        if (typeof value === "number")
        {
            this._y = value;

            if ((this._viewer.audio.useWebAudio === true && this._isAmbisonic() === false) && this._sound !== null && this._panner !== null && this._spatialized === true)
            {
                this._applyPanner();
            }
        }
    }
});

/**
 * Get and set the z axis position of the sound.
 * @name FORGE.Sound#z
 * @type {number}
 */
Object.defineProperty(FORGE.Sound.prototype, "z",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        return this._y;
    },

    /** @this {FORGE.Sound} */
    set: function(value)
    {
        if (typeof value === "number")
        {
            this._z = value;

            if ((this._viewer.audio.useWebAudio === true && this._isAmbisonic() === false) && this._sound !== null && this._panner !== null && this._spatialized === true)
            {
                this._applyPanner();
            }
        }
    }
});

/**
 * Get the sound "onSoundDecode" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.Sound#onSoundDecode
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Sound.prototype, "onSoundDecode",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._onSoundDecode === null)
        {
            this._onSoundDecode = new FORGE.EventDispatcher(this);
        }

        return this._onSoundDecode;
    }
});

/**
 * Get the sound "onLoadStart" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.Sound#onLoadStart
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Sound.prototype, "onLoadStart",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._onLoadStart === null)
        {
            this._onLoadStart = new FORGE.EventDispatcher(this);
        }

        return this._onLoadStart;
    }
});

/**
 * Get the sound "onLoadedData" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.Sound#onLoadedData
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Sound.prototype, "onLoadedData",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._onLoadedData === null)
        {
            this._onLoadedData = new FORGE.EventDispatcher(this);
        }

        return this._onLoadedData;
    }
});

/**
 * Get the sound "onCanPlay" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.Sound#onCanPlay
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Sound.prototype, "onCanPlay",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._onCanPlay === null)
        {
            this._onCanPlay = new FORGE.EventDispatcher(this);
        }

        return this._onCanPlay;
    }
});

/**
 * Get the sound "onCanPlayThrough" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.Sound#onCanPlayThrough
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Sound.prototype, "onCanPlayThrough",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._onCanPlayThrough === null)
        {
            this._onCanPlayThrough = new FORGE.EventDispatcher(this);
        }

        return this._onCanPlayThrough;
    }
});

/**
 * Get the sound "onMute" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.Sound#onMute
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Sound.prototype, "onMute",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._onMute === null)
        {
            this._onMute = new FORGE.EventDispatcher(this);
        }

        return this._onMute;
    }
});

/**
 * Get the sound "onUnmute" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.Sound#onUnmute
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Sound.prototype, "onUnmute",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._onUnmute === null)
        {
            this._onUnmute = new FORGE.EventDispatcher(this);
        }

        return this._onUnmute;
    }
});

/**
 * Get the sound "onVolumeChange" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.Sound#onVolumeChange
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Sound.prototype, "onVolumeChange",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._onVolumeChange === null)
        {
            this._onVolumeChange = new FORGE.EventDispatcher(this);
        }

        return this._onVolumeChange;
    }
});

/**
 * Get the sound "onPlay" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.Sound#onPlay
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Sound.prototype, "onPlay",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._onPlay === null)
        {
            this._onPlay = new FORGE.EventDispatcher(this);
        }

        return this._onPlay;
    }
});

/**
 * Get the sound "onStop" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.Sound#onStop
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Sound.prototype, "onStop",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._onStop === null)
        {
            this._onStop = new FORGE.EventDispatcher(this);
        }

        return this._onStop;
    }
});

/**
 * Get the sound "onPause" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.Sound#onPause
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Sound.prototype, "onPause",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._onPause === null)
        {
            this._onPause = new FORGE.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
 * Get the sound "onResume" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.Sound#onResume
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Sound.prototype, "onResume",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._onResume === null)
        {
            this._onResume = new FORGE.EventDispatcher(this);
        }

        return this._onResume;
    }
});

/**
 * Get the sound "onEnded" event {@link FORGE.EventDispatcher}.
 * The {@link FORGE.EventDispatcher} is created only if you ask for it.
 * @name FORGE.Sound#onEnded
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Sound.prototype, "onEnded",
{
    /** @this {FORGE.Sound} */
    get: function()
    {
        if (this._onEnded === null)
        {
            this._onEnded = new FORGE.EventDispatcher(this);
        }

        return this._onEnded;
    }
});


/**
 * A FORGE.Playlist is an object that represents a list of media.
 *
 * @constructor FORGE.Playlist
 * @param {FORGE.Viewer} viewer - The {@link FORGE.Viewer} reference.
 * @param {AudioPlaylistConfig} config - The playlist config object.
 * @extends {FORGE.BaseObject}
 */
FORGE.Playlist = function(viewer, config)
{
    /**
     * The viewer reference.
     * @name FORGE.Playlist#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The config object.
     * @name FORGE.Playlist#_config
     * @type {?AudioPlaylistConfig}
     * @private
     */
    this._config = config;

    /**
     * Array of PlaylistTrack uid.
     * @name FORGE.Playlist#_tracks
     * @type {?Array<string>}
     * @private
     */
    this._tracks = null;

    /**
     * The name of the playlist.
     * @name FORGE.Playlist#_name
     * @type {?FORGE.LocaleString}
     * @private
     */
    this._name = null;

    /**
     * The default track uid or index of the playlist.
     * @name FORGE.Playlist#_defaultTrack
     * @type {string}
     * @private
     */
    this._defaultTrack = "";

    /**
     * UID of the current {@link FORGE.PlaylistTrack}.
     * @name FORGE.Playlist#_trackUID
     * @type {string}
     * @private
     */
    this._trackUID = "";

    /**
     * The maximum volume for playlist.
     * @name  FORGE.Playlist#_maxVolume
     * @type {number}
     * @private
     */
    this._maxVolume = 1;

    /**
     * The current volume of the playlist.
     * Can't be greater than the maximum volume.
     * @name FORGE.Playlist#_volume
     * @type {number}
     * @private
     */
    this._volume = 1;

    /**
     * Does the playlist will auto play?
     * @name FORGE.Playlist#_autoPlay
     * @type {boolean}
     * @private
     */
    this._autoPlay = true;

    /**
     * Internal flag to know if the playlist must check the autoPlay property.
     * @name  FORGE.Playlist#_checkAutoPlay
     * @type {boolean}
     * @private
     */
    this._checkAutoPlay = true;

    /**
     * Does the playlist will loop?
     * @name FORGE.Playlist#_loop
     * @type {boolean}
     * @private
     */
    this._loop = true;

    /**
     * Playlist with tracks ready event dispatcher.
     * @name FORGE.Playlist#_onReady
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onReady = null;

    /**
     * On playlist play event dispatcher.
     * @name FORGE.Playlist#_onPlay
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On playlist stop event dispatcher.
     * @name FORGE.Playlist#_onStop
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onStop = null;

    /**
     * On playlist pause event dispatcher.
     * @name FORGE.Playlist#_onPause
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * On playlist resume event dispatcher.
     * @name FORGE.Playlist#_onResume
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onResume = null;

    /**
     * On playlist ended event dispatcher.
     * @name FORGE.Playlist#_onEnded
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onEnded = null;

    FORGE.BaseObject.call(this, "Playlist");

    this._boot();
};

FORGE.Playlist.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Playlist.prototype.constructor = FORGE.Playlist;

/**
 * Boot sequence.
 * @method FORGE.Playlist#_boot
 * @private
 */
FORGE.Playlist.prototype._boot = function()
{
    this._uid = this._config.uid;
    this._register();
    this._name = new FORGE.LocaleString(this._viewer, this._config.name);

    this._tracks = [];

    this._parseConfig(this._config);
    this._parseTracks(this._config);
};

/**
 * Parse playlist config.
 * @method FORGE.Playlist#_parseConfig
 * @private
 * @param {AudioPlaylistConfig} config - The object that describes the playlist config.
 */
FORGE.Playlist.prototype._parseConfig = function(config)
{
    this._autoPlay = typeof config.autoPlay !== "undefined" ? Boolean(config.autoPlay) : true;
    this._loop = typeof config.loop !== "undefined" ? Boolean(config.loop) : true;

    this._maxVolume = (typeof config.volume !== "undefined" && typeof config.volume.max === "number") ? FORGE.Math.clamp(config.volume.max, 0, 1) : 1;
    this._volume = (typeof config.volume !== "undefined" && typeof config.volume.default === "number") ? FORGE.Math.clamp(config.volume.default, 0, this._maxVolume) : FORGE.Math.clamp(1, 0, this._maxVolume);
};

/**
 * Parse playlist tracks.
 * @method FORGE.Playlist#_parseTracks
 * @private
 * @param {AudioPlaylistConfig} config - The object that describes the playlist config.
 */
FORGE.Playlist.prototype._parseTracks = function(config)
{
    if(typeof config.tracks !== "undefined" && FORGE.Utils.isArrayOf(config.tracks, "string") === true)
    {
        this._tracks = config.tracks;
    }
    else
    {
        this.warn("A playlist has no track in its configuration, or configuration is not valid!");
    }

    //Parse the default track of the playlist
    if(typeof config.default === "string" && config.default !== "")
    {
        this._defaultTrack = config.default;
    }
    else if(typeof config.default === "number" && config.default >= 0 && config.default < this._tracks.length)
    {
        this._defaultTrack = this._tracks[config.default].uid;
    }
    else
    {
        this.warn("A playlist has a default track that is not in its tracks array!");
    }

    this._trackUID = this._defaultTrack;

    if(this._onReady !== null)
    {
        this._onReady.dispatch();
    }
};

/**
 * Event handler that triggers when the current track ends, set the next track to play.
 * @method FORGE.Playlist#_trackEndHandler
 * @private
 */
FORGE.Playlist.prototype._trackEndHandler = function()
{
    if(this._tracks.length > 0)
    {
        var index = this._tracks.indexOf(this._trackUID) + 1;

        // loop if playlist loop is activated and track doesn't loop.
        if(index === this._tracks.length && (this._loop === false || this.track.loop === true))
        {
            // reset to the first track of the playlist for next call to play
            this._trackUID = this._tracks[0];
            return;
        }
    }

    this.nextTrack();
};

/**
 * Dispatch play event to the track
 * @method  FORGE.Playlist#_notifyPlay
 * @private
 */
FORGE.Playlist.prototype._notifyPlay = function()
{
    if(this._onPlay !== null)
    {
        this._onPlay.dispatch();
    }
};

/**
 * Dispatch stop event to the track
 * @method  FORGE.Playlist#_notifyStop
 * @private
 */
FORGE.Playlist.prototype._notifyStop = function()
{
    if(this._onStop !== null)
    {
        this._onStop.dispatch();
    }
};

/**
 * Dispatch pause event to the track
 * @method  FORGE.Playlist#_notifyPause
 * @private
 */
FORGE.Playlist.prototype._notifyPause = function()
{
    if(this._onPause !== null)
    {
        this._onPause.dispatch();
    }
};

/**
 * Dispatch resume event to the track
 * @method  FORGE.Playlist#_notifyResume
 * @private
 */
FORGE.Playlist.prototype._notifyResume = function()
{
    if(this._onResume !== null)
    {
        this._onResume.dispatch();
    }
};

/**
 * Dispatch ended event to the track
 * @method  FORGE.Playlist#_notifyEnded
 * @private
 */
FORGE.Playlist.prototype._notifyEnded = function()
{
    if(this._onEnded !== null)
    {
        this._onEnded.dispatch();
    }
};

/**
 * Know if the playlist have any {@link FORGE.PlaylistTrack}.
 * @method FORGE.Playlist#hasTracks
 * @return {boolean} Returns true if the playlist has at least a {@link FORGE.PlaylistTrack}, false if not.
 */
FORGE.Playlist.prototype.hasTracks = function()
{
    return this._tracks.length !== 0;
};

/**
 * Play the current track or set a track to be the current one then play it.
 * @method FORGE.Playlist#play
 * @param {?FORGE.PlaylistTrack|string|number=} track - The track you want to play or its uid or its index, if undefined, play the current track.
 * @param {boolean=} checkAutoPlay - Does the autoPlay status must be checked?
 * @return {FORGE.PlaylistTrack} Returns the playing track.
 */
FORGE.Playlist.prototype.play = function(track, checkAutoPlay)
{
    this._checkAutoPlay = typeof checkAutoPlay !== "undefined" ? checkAutoPlay : false;

    var uid;

    if(typeof track === "string" && FORGE.UID.isTypeOf(track, "PlaylistTrack"))
    {
        uid = track;
    }
    else if(FORGE.Utils.isTypeOf(track, "PlaylistTrack"))
    {
        uid = track.uid;
    }
    else if (typeof track === "number" && track >= 0 && track < this._tracks.length)
    {
        uid = this._tracks[track];
    }
    else if(this._trackUID !== "")
    {
        uid = this._trackUID;
    }
    else if(typeof track === "undefined" || track === "")
    {
        uid = this._tracks[0];
    }

    if(typeof uid !== "undefined")
    {
        this.stop();

        this._trackUID = uid;

        if (this._checkAutoPlay === true && this._autoPlay === false)
        {
            this.warn("FORGE.Playlist.play(); autoPlay is disabled");
            return this.track;
        }

        this.track.play();

        if(this.track.onEnded.has(this._trackEndHandler, this) === false)
        {
            this.track.onEnded.add(this._trackEndHandler, this);
        }

        this.log("FORGE.Playlist.play(); [uid: "+this._trackUID+"]");

        return this.track;
    }

    return null;
};

/**
 * Stop the current track.
 * @method FORGE.Playlist#stop
 */
FORGE.Playlist.prototype.stop = function()
{
    if(this.track !== null)
    {
        this.track.stop();

        if(typeof this.track.onEnded !== "undefined" && this.track.onEnded.has(this._trackEndHandler, this) === false)
        {
            this.track.onEnded.remove(this._trackEndHandler, this);
        }
    }
};

/**
 * Pause the current track.
 * @method FORGE.Playlist#pause
 */
FORGE.Playlist.prototype.pause = function()
{
    if(this.track !== null)
    {
        this.track.pause();
    }
};

/**
 * Resume the current track if it's paused.
 * @method FORGE.Playlist#resume
 */
FORGE.Playlist.prototype.resume = function()
{
    if(this.track !== null)
    {
        this.track.resume();
    }
};

/**
 * Set the next {@link FORGE.PlaylistTrack} to be the current track.
 * If the playlist is paused, keep the pause status of the playlist.
 * @method FORGE.Playlist#nextTrack
 */
FORGE.Playlist.prototype.nextTrack = function()
{
    var index = -1;

    if(this._tracks.length > 0)
    {
        index = this._tracks.indexOf(this._trackUID) + 1;

        if(index === this._tracks.length)
        {
            index = 0;
        }
    }

    this.play(index, this._checkAutoPlay);

    if(this.paused === true)
    {
        this.pause();
    }
};

/**
 * Set the previous {@link FORGE.PlaylistTrack} to be the current track.
 * If the playlist is paused, keep the pause status of the playlist.
 * @method FORGE.Playlist#previousTrack
 */
FORGE.Playlist.prototype.previousTrack = function()
{
    var index = -1;

    if(this._tracks.length > 0)
    {
        index = this._tracks.indexOf(this._trackUID) - 1;

        if(index === -1)
        {
            index = this._tracks.length - 1;
        }
    }

    this.play(index, this._checkAutoPlay);

    if(this.paused === true)
    {
        this.pause();
    }
};

/**
 * Destroy sequence
 * @method FORGE.Playlist#destroy
 */
FORGE.Playlist.prototype.destroy = function()
{
    this.stop();

    this._viewer = null;

    this._name.destroy();
    this._name = null;

    if(this._tracks.length > 0)
    {
        this._tracks.length = 0;
        this._tracks = null;
    }

    this._config = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the list of tracks of this playlist.
 * @name FORGE.Playlist#tracks
 * @readonly
 * @type {Array<string>}
 */
Object.defineProperty(FORGE.Playlist.prototype, "tracks",
{
    /** @this {FORGE.Playlist} */
    get: function ()
    {
        return this._tracks;
    }
});

/**
 * Get the name of this playlist.
 * @name FORGE.Playlist#name
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Playlist.prototype, "name",
{
    /** @this {FORGE.Playlist} */
    get: function ()
    {
        return this._name.value;
    }
});

/**
 * Get the ready status of this playlist current track.
 * @name FORGE.Playlist#ready
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Playlist.prototype, "ready",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        if(this.track !== null)
        {
            return this.track.ready;
        }

        return false;
    }
});

/**
 * Get the decoded status of this playlist current track.
 * @name FORGE.Playlist#decoded
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Playlist.prototype, "decoded",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        if(this.track !== null)
        {
            return this.track.decoded;
        }

        return false;
    }
});

/**
 * Get the playing status of this playlist current track.
 * @name FORGE.Playlist#playing
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Playlist.prototype, "playing",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        if(this.track !== null)
        {
            return this.track.playing;
        }

        return false;
    }
});

/**
 * Get the paused status of this playlist current track.
 * @name FORGE.Playlist#paused
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Playlist.prototype, "paused",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        if(this.track !== null)
        {
            return this.track.paused;
        }

        return false;
    }
});

/**
 * Get the current {@link FORGE.PlaylistTrack} of this playlist.
 * @name FORGE.Playlist#track
 * @readonly
 * @type {FORGE.PlaylistTrack}
 */
Object.defineProperty(FORGE.Playlist.prototype, "track",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        if(FORGE.UID.isTypeOf(this._trackUID, "PlaylistTrack") === true)
        {
            return FORGE.UID.get(this._trackUID, "PlaylistTrack");
        }

        return null;
    }
});

/**
 * Get and set the loop state of the playlist.
 * @name FORGE.Playlist#loop
 * @type {boolean}
 */
Object.defineProperty(FORGE.Playlist.prototype, "loop",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        return this._loop;
    },

    /** @this {FORGE.Playlist} */
    set: function(value)
    {
        this._loop = Boolean(value);
    }
});

/**
 * Get and set the auto play state of the playlist.
 * @name FORGE.Playlist#autoPlay
 * @type {boolean}
 */
Object.defineProperty(FORGE.Playlist.prototype, "autoPlay",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        return this._autoPlay;
    },

    /** @this {FORGE.Playlist} */
    set: function(value)
    {
        this._autoPlay = Boolean(value);
    }
});

/**
 * Get the playlist volume.
 * @name FORGE.Playlist#volume
 * @type {number}
 */
Object.defineProperty(FORGE.Playlist.prototype, "volume",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        return this._volume;
    },

    /** @this {FORGE.Playlist} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        value = FORGE.Math.clamp(value, 0, 1);
        if(this._maxVolume < value)
        {
            this._volume = this._maxVolume;
        }
        else
        {
            this._volume = value;
        }

        if(FORGE.UID.isTypeOf(this._trackUID, "PlaylistTrack") === true)
        {
            var track = FORGE.UID.get(this._trackUID, "PlaylistTrack");

            if(track !== null)
            {
                track.volume = this._volume * this._viewer.playlists.volume;
            }
        }
    }
});

/**
 * Get the "onPlay" event {@link FORGE.EventDispatcher} of the playlist.
 * @name FORGE.Playlist#onPlay
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Playlist.prototype, "onPlay",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        if(this._onPlay === null)
        {
            this._onPlay = new FORGE.EventDispatcher(this);
        }

        return this._onPlay;
    }
});

/**
 * Get the "onStop" event {@link FORGE.EventDispatcher} of the playlist.
 * @name FORGE.Playlist#onStop
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Playlist.prototype, "onStop",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        if(this._onStop === null)
        {
            this._onStop = new FORGE.EventDispatcher(this);
        }

        return this._onStop;
    }
});

/**
 * Get the "onPause" event {@link FORGE.EventDispatcher} of the playlist.
 * @name FORGE.Playlist#onPause
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Playlist.prototype, "onPause",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        if(this._onPause === null)
        {
            this._onPause = new FORGE.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
 * Get the "onResume" event {@link FORGE.EventDispatcher} of the playlist.
 * @name FORGE.Playlist#onResume
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Playlist.prototype, "onResume",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        if(this._onResume === null)
        {
            this._onResume = new FORGE.EventDispatcher(this);
        }

        return this._onResume;
    }
});

/**
 * Get the "onEnded" event {@link FORGE.EventDispatcher} of the playlist.
 * @name FORGE.Playlist#onEnded
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Playlist.prototype, "onEnded",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        if(this._onEnded === null)
        {
            this._onEnded = new FORGE.EventDispatcher(this);
        }

        return this._onEnded;
    }
});

/**
 * Get the "onReady" {@link FORGE.EventDispatcher} of the playlist.
 * @name FORGE.Playlist#onReady
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Playlist.prototype, "onReady",
{
    /** @this {FORGE.Playlist} */
    get: function()
    {
        if(this._onReady === null)
        {
            this._onReady = new FORGE.EventDispatcher(this);
        }

        return this._onReady;
    }
});


/**
 * The FORGE.PlaylistManager is an object that manages playlists of the project.
 *
 * @constructor FORGE.PlaylistManager
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 *
 * @todo  previous/next playlist
 * @todo  real keepAudio to resume a "lost sound"
 * @todo  preload of all sounds
 */
FORGE.PlaylistManager = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.PlaylistManager#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The general config backup.
     * @name FORGE.PalylistManager#_config
     * @type {?AudioPlaylistsConfig}
     * @private
     */
    this._config = null;

    /**
     * Array of {@link FORGE.Playlist}.
     * @name FORGE.PlaylistManager#_playlists
     * @type {?Array<FORGE.Playlist>}
     * @private
     */
    this._playlists = null;

    /**
     * The tracks list object.
     * @name  FORGE.PlaylistManager#_tracks
     * @type {?Array<FORGE.PlaylistTrack>}
     * @private
     */
    this._tracks = null;

    /**
     * Uid of the current {@link FORGE.Playlist}.
     * @name  FORGE.PlaylistManager#_playlistUID
     * @type {string}
     * @private
     */
    this._playlistUID = "";

    /**
     * The default playlist uid.
     * @name FORGE.PlaylistManager#_defaultList
     * @type {string}
     * @private
     */
    this._defaultList = "";

    /**
     * The maximum volume for all playlists.
     * @name  FORGE.PlaylistManager#_maxVolume
     * @type {number}
     * @private
     */
    this._maxVolume = 1;

    /**
     * The current volume for all the playlists.
     * @name FORGE.PlaylistManager#_volume
     * @type {number}
     * @private
     */
    this._volume = 1;

    /**
     * Is the playlist manager enabled?
     * @name  FORGE.PlaylistManager#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * Tracks must be preloaded?
     * @name  FORGE.PlaylistManager#_preload
     * @type {boolean}
     * @private
     */
    this._preload = false;

    /**
     * Is the playlistManager paused?
     * @name  FORGE.PlaylistManager#_paused
     * @type {boolean}
     * @private
     */
    this._paused = false;

    /**
     * On playlist manager ready event dispatcher.
     * @name FORGE.Sound#_onReady
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onReady = null;

    /**
     * On playlist manager play event dispatcher.
     * @name FORGE.PlaylistManager#_onPlay
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On playlist manager stop event dispatcher.
     * @name FORGE.PlaylistManager#_onStop
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onStop = null;

    /**
     * On playlist manager pause event dispatcher.
     * @name FORGE.PlaylistManager#_onPause
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * On playlist manager resume event dispatcher.
     * @name FORGE.PlaylistManager#_onResume
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onResume = null;

    /**
     * On playlist manager ended event dispatcher.
     * @name FORGE.PlaylistManager#_onEnded
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onEnded = null;

    FORGE.BaseObject.call(this, "PlaylistManager");

};

FORGE.PlaylistManager.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.PlaylistManager.prototype.constructor = FORGE.PlaylistManager;

/**
 * Boot sequence.
 * @method FORGE.PlaylistManager#boot
 */
FORGE.PlaylistManager.prototype.boot = function()
{
    this._playlists = [];
    this._tracks = [];

    this._viewer.audio.onEnable.add(this._enableSoundHandler, this);
    this._viewer.story.onSceneLoadStart.add(this._sceneLoadStartHandler, this);
};

/**
 * Enable handler the sound manager.
 * @method FORGE.PlaylistManager#_enableSoundHandler
 * @private
 */
FORGE.PlaylistManager.prototype._enableSoundHandler = function()
{
    if(this._enabled === true && this._playlists.length > 0 && this.ready === true && this.decoded === true && this._paused === false)
    {
        if(this.paused === true)
        {
            this.resume();
        }
        else if(this.playing === false)
        {
            this.play();
        }
    }
};

/**
 * Event handler for scene start.
 * @method FORGE.PlaylistManager#_sceneLoadStartHandler
 * @private
 */
FORGE.PlaylistManager.prototype._sceneLoadStartHandler = function()
{
    if(typeof this._viewer.story.scene.config.playlists !== "undefined")
    {
        this._parseSceneConfig(this._viewer.story.scene.config.playlists);
    }
    else
    {
        //restore global playlists config
        this._applyConfig(this._config);

        if(this._paused === false && this._defaultList !== this._playlistUID)
        {
            if(this._enabled === false || this.ready === false || this.decoded === false || this.playing === true)
            {
                this._stopScenePlaylist();
            }

            //load the default playlist of the global audio if exists
            this._startScenePlaylist(this._defaultList);
        }
    }
};

/**
 * Parse the scene configuration part related to playlist.
 * @method  FORGE.PlaylistManager#_parseSceneConfig
 * @private
 * @param  {AudioPlaylistsConfig} config - The scene configuration part related to playlist.
 */
FORGE.PlaylistManager.prototype._parseSceneConfig = function(config)
{
    var extendedConfig = /** @type {AudioPlaylistsConfig} */ FORGE.Utils.extendMultipleObjects(this._config, config);
    this._applyConfig(extendedConfig);

    if(this._paused === false)
    {
        if(this._enabled === false)
        {
            this._stopScenePlaylist();
        }
        else
        {
            if(!this._startScenePlaylist(this._defaultList))
            {
                if(this.playing === true)
                {
                    this._stopScenePlaylist();
                }
            }
        }
    }
};

/**
 * Set values from configuration file.
 * @method  FORGE.PlaylistManager#_applyConfig
 * @param {?AudioPlaylistsConfig} config - The config file.
 * @private
 */
FORGE.PlaylistManager.prototype._applyConfig = function(config)
{
    if(config !== null)
    {
        this._enabled = typeof config.enabled !== "undefined" ? Boolean(config.enabled) : true;

        if (typeof config.default !== "undefined")
        {
            if (typeof config.default === "string" && config.default !== "")
            {
                this._defaultList = config.default;
            }
            else if (typeof config.default === "number" && config.default >= 0 && config.default < this._playlists.length)
            {
                this._defaultList = this._playlists[config.default].uid;
            }
        }

        this._maxVolume = (typeof config.volume !== "undefined" && typeof config.volume.max === "number") ? FORGE.Math.clamp(config.volume.max, 0, 1) : 1;
        this._volume = (typeof config.volume !== "undefined" && typeof config.volume.default === "number") ? FORGE.Math.clamp(config.volume.default, 0, this._maxVolume) : FORGE.Math.clamp(1, 0, this._maxVolume);
    }
};

/**
 * Add a playlist config to the manager.
 * @method FORGE.PlaylistManager#addConfig
 * @param {AudioPlaylistsConfig} config - The config you want to add.
 */
FORGE.PlaylistManager.prototype.addConfig = function(config)
{
    this._parseConfig(config);

    this._initPlaylist();
};

/**
 * Parse a playlist config object.
 * @method FORGE.PlaylistManager#_parseConfig
 * @private
 * @param {AudioPlaylistsConfig} config - The config you want to parse.
 */
FORGE.PlaylistManager.prototype._parseConfig = function(config)
{
    var playlist, track;

    this._config = config;

    if(typeof config.lists !== "undefined")
    {
        for(var i = 0, ii = config.lists.length; i<ii; i++)
        {
            playlist = new FORGE.Playlist(this._viewer, config.lists[i]);
            this.add(playlist);
        }
    }

    if(typeof config.tracks !== "undefined")
    {
        for(var j = 0, jj = config.tracks.length; j<jj; j++)
        {
            track = new FORGE.PlaylistTrack(this._viewer, config.tracks[j]);
            this.addTrack(track);

            if(this._preload === true)
            {
                // @todo manage preload queue
                this.warn("Preload is not supported yet.");
            }
        }
    }

    this._applyConfig(config);

    if(typeof config.lists !== "undefined" && config.lists.length > 0)
    {
        if (this._defaultList === "")
        {
            this.warn("The playlist manager has a default playlist that is not in its playlists array!");
        }

        this._playlistUID = this._defaultList;
    }
};

/**
 * Initialize the default playlist.
 * @method FORGE.PlaylistManager#_initPlaylist
 * @private
 */
FORGE.PlaylistManager.prototype._initPlaylist = function()
{
    // If the page is not visible at init, report it later
    if (document[FORGE.Device.visibilityState] !== "visible")
    {
        this._viewer.onResume.addOnce(this._initPlaylist, this);
        return;
    }

    if(this._playlists.length <= 0)
    {
        return;
    }

    var uid;
    if(typeof this._defaultList === "string" && this._defaultList !== "")
    {
        uid = this._defaultList;
    }
    else
    {
        uid = this._playlists[0].uid;
    }

    if(FORGE.UID.get(uid) === undefined)
    {
        this.warn("PlaylistManager : uid \""+uid+"\" is not into playlists");
    }

    if(FORGE.UID.isTypeOf(uid, "Playlist") === true)
    {
        this.play(uid, true);
    }
    else
    {
        this.warn("Impossible to play the playlist with uid "+uid+", it doesn't seem to be a playlist!");
    }
};

/**
 * Start or resume a playlist for a specific scene.
 * @method  FORGE.PlaylistManager#_startScenePlaylist
 * @param {string} playlistUID - The default playlist uid.
 * @return {boolean} Returns true if the playlist is found.
 * @private
 */
FORGE.PlaylistManager.prototype._startScenePlaylist = function(playlistUID)
{
    if(playlistUID !== null && FORGE.UID.isTypeOf(playlistUID, "Playlist") === true)
    {
        //Maybe the new scene shares the same playlist so we do not reset the playback
        if(this.playlist !== null && this.playlist.uid === playlistUID)
        {
            if(this.playlist.track !== null && (typeof this.playlist.track.uid !== "undefined" && this.playlist.track.uid !== ""))
            {
                if(this.paused === true)
                {
                    this.resume();
                }
                else if(this.playing === false)
                {
                    this.play(playlistUID, true);
                }
            }
            else
            {
                this.stop();
                this.play(playlistUID, true);
            }
        }
        else
        {
            this.stop();
            this.play(playlistUID, true);
        }

        return true;
    }

    return false;
};

/**
 * Stop or pause a playlist.
 * @method  FORGE.PlaylistManager#_stopScenePlaylist
 * @private
 */
FORGE.PlaylistManager.prototype._stopScenePlaylist = function()
{
    if(this.playing === true)
    {
        this.pause();
    }
    else
    {
        this.stop();
    }
};

/**
 * Dispatch play event and notify it to the playlist
 * @method  FORGE.PlaylistManager#_notifyPlay
 * @private
 */
FORGE.PlaylistManager.prototype._notifyPlay = function()
{
    if(this._onPlay !== null)
    {
        this._onPlay.dispatch();
    }

    if(this.playlist !== null)
    {
        FORGE.Playlist.prototype._notifyPlay.call(this.playlist);
    }
};

/**
 * Dispatch stop event and notify it to the playlist
 * @method  FORGE.PlaylistManager#_notifyStop
 * @private
 */
FORGE.PlaylistManager.prototype._notifyStop = function()
{
    if(this._onStop !== null)
    {
        this._onStop.dispatch();
    }

    if(this.playlist !== null)
    {
        FORGE.Playlist.prototype._notifyStop.call(this.playlist);
    }
};

/**
 * Dispatch pause event and notify it to the playlist
 * @method  FORGE.PlaylistManager#_notifyPause
 * @private
 */
FORGE.PlaylistManager.prototype._notifyPause = function()
{
    if(this._onPause !== null)
    {
        this._onPause.dispatch();
    }

    if(this.playlist !== null)
    {
        FORGE.Playlist.prototype._notifyPause.call(this.playlist);
    }
};

/**
 * Dispatch resume event and notify it to the playlist
 * @method  FORGE.PlaylistManager#_notifyResume
 * @private
 */
FORGE.PlaylistManager.prototype._notifyResume = function()
{
    if(this._onResume !== null)
    {
        this._onResume.dispatch();
    }

    if(this.playlist !== null)
    {
        FORGE.Playlist.prototype._notifyResume.call(this.playlist);
    }
};

/**
 * Dispatch ended event and notify it to the playlist
 * @method  FORGE.PlaylistManager#_notifyEnded
 * @private
 */
FORGE.PlaylistManager.prototype._notifyEnded = function()
{
    if(this._onEnded !== null)
    {
        this._onEnded.dispatch();
    }

    if(this.playlist !== null)
    {
        FORGE.Playlist.prototype._notifyEnded.call(this.playlist);
    }
};

/**
 * Add a {@link FORGE.Playlist} to the playlist manager.
 * @method  FORGE.PlaylistManager#add
 * @param {FORGE.Playlist} playlist - The {@link FORGE.Playlist} you want to add.
 */
FORGE.PlaylistManager.prototype.add = function(playlist)
{
    this._playlists.push(playlist);
};

/**
 * Add a {@link FORGE.PlaylistTrack} to the playlist manager.
 * @method  FORGE.PlaylistManager#addTrack
 * @param {FORGE.PlaylistTrack} track - The {@link FORGE.PlaylistTrack} you want to add.
 */
FORGE.PlaylistManager.prototype.addTrack = function(track)
{
    this._tracks.push(track);
};

/**
 * Know if the project have any {@link FORGE.Playlist}.
 * @method FORGE.PlaylistManager#hasPlaylists
 * @return {boolean} Returns true if the project has at least a {@link FORGE.Playlist}, false if not.
 */
FORGE.PlaylistManager.prototype.hasPlaylists = function()
{
    return this._playlists.length !== 0;
};

/**
 * Know if the project have any {@link FORGE.PlaylistTrack}.
 * @method FORGE.PlaylistManager#hasTracks
 * @return {boolean} Returns true if the project has at least a {@link FORGE.PlaylistTrack}, false if not.
 */
FORGE.PlaylistManager.prototype.hasTracks = function()
{
    return this._tracks.length !== 0;
};

/**
 * Play the current playlist or a specific one at a specific track.
 * @method  FORGE.PlaylistManager#play
 * @param  {FORGE.Playlist|string|number=} playlist - The {@link FORGE.Playlist} you want to play or its uid or its index.
 * @param {boolean=} checkAutoPlay - Set to true if the autoPlay status of the playlist must be checked.
 */
FORGE.PlaylistManager.prototype.play = function(playlist, checkAutoPlay)
{
    var uid;

    if(typeof playlist === "string" && FORGE.UID.isTypeOf(playlist, "Playlist"))
    {
        uid = playlist;
    }
    else if(FORGE.Utils.isTypeOf(playlist, "Playlist"))
    {
        uid = playlist.uid;
    }
    else if (typeof playlist === "number" && playlist >= 0 && playlist < this._playlists.length)
    {
        uid = this._playlists[playlist].uid;
    }
    else if(this._playlistUID !== "")
    {
        uid = this._playlistUID;
    }
    else if(typeof playlist === "undefined" || playlist === "")
    {
        uid = this._playlists[0].uid;
    }

    if(typeof uid !== "undefined")
    {
        if(this.playing === true)
        {
            this.stop();
        }

        this._playlistUID = uid;

        if(this._enabled === true)
        {
            this._paused = false;

            this.playlist.play(null, checkAutoPlay);

            this.log("FORGE.PlaylistManager.play(); [uid: "+this._playlistUID+"]");
        }
    }
};

/**
 * Stop the current {@link FORGE.Playlist}.
 * @method  FORGE.PlaylistManager#play
 */
FORGE.PlaylistManager.prototype.stop = function()
{
    if(this.playlist !== null)
    {
        this.playlist.stop();
    }
};

/**
 * Pause the current {@link FORGE.Playlist}.
 * @method  FORGE.PlaylistManager#pause
 */
FORGE.PlaylistManager.prototype.pause = function()
{
    if(this.playlist !== null && this.playlist.playing === true)
    {
        this._paused = true;
        this.playlist.pause();
    }
};

/**
 * Resume the current {@link FORGE.Playlist}.
 * @method  FORGE.PlaylistManager#resume
 */
FORGE.PlaylistManager.prototype.resume = function()
{
    if(this.playlist !== null && this._enabled === true && this.playlist.paused === true)
    {
        var isPaused = this._paused;
        this._paused = false;
        if (isPaused === true && this._defaultList !== this._playlistUID)
        {
            this._startScenePlaylist(this._defaultList);
        }
        else
        {
            this.playlist.resume();
        }
    }
};

/**
 * Set the next {@link FORGE.PlaylistTrack} of the current {@link FORGE.Playlist} to be the current track.<br>
 * If the playlist is paused, keep the pause status of the playlist.
 * @method FORGE.PlaylistManager#nextTrack
 */
FORGE.PlaylistManager.prototype.nextTrack = function()
{
    if(this.playlist !== null && this._enabled === true)
    {
        this.playlist.nextTrack();
    }
};

/**
 * Set the previous {@link FORGE.PlaylistTrack} of the current {@link FORGE.Playlist} to be the current track.<br>
 * If the playlist is paused, keep the pause status of the playlist.
 * @method FORGE.PlaylistManager#previousTrack
 */
FORGE.PlaylistManager.prototype.previousTrack = function()
{
    if(this.playlist !== null && this._enabled === true)
    {
        this.playlist.previousTrack();
    }
};

/**
 * Destroy sequence
 * @method FORGE.PlaylistManager#destroy
 */
FORGE.PlaylistManager.prototype.destroy = function()
{
    this.stop();

    this._viewer.audio.onEnable.remove(this._enableSoundHandler, this);
    this._viewer.story.onSceneLoadStart.remove(this._sceneLoadStartHandler, this);

    this._viewer = null;
    this._config = null;

    var i = this._playlists.length;
    while(i--)
    {
        this._playlists[i].destroy();
    }
    this._playlists = null;

    var j = this._tracks.length;
    while(j--)
    {
        this._tracks[j].destroy();
    }
    this._tracks = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the playlists Array.
 * @name FORGE.PlaylistManager#playlists
 * @readonly
 * @type {Array<FORGE.Playlist>}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "playlists",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        return this._playlists;
    }
});

/**
 * Get the tracks Array.
 * @name FORGE.PlaylistManager#tracks
 * @readonly
 * @type {Array<FORGE.Playlist>}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "tracks",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        return this._tracks;
    }
});

/**
 * Get the current playlist.
 * @name FORGE.PlaylistManager#playlist
 * @readonly
 * @type {?FORGE.Playlist}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "playlist",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        if(FORGE.UID.isTypeOf(this._playlistUID, "Playlist") === true)
        {
            return FORGE.UID.get(this._playlistUID, "Playlist");
        }

        return null;
    }
});

/**
 * Get the loop status of the current {@link FORGE.Playlist}.
 * @name FORGE.PlaylistManager#loop
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "loop",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        if(this.playlist !== null)
        {
            return this.playlist.loop;
        }

        return true; // default state is true
    }
});

/**
 * Get the auto play status of the current {@link FORGE.Playlist}.
 * @name FORGE.PlaylistManager#autoPlay
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "autoPlay",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        if(this.playlist !== null)
        {
            return this.playlist.autoPlay;
        }

        return true; // default state is true
    }
});

/**
 * Preload status of audio files.
 * @name FORGE.PlaylistManager#preload
 * @type {boolean}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "preload",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        return this._preload;
    },

    /** @this {FORGE.PlaylistManager} */
    set: function(value)
    {
        this._preload = Boolean(value);
    }
});

/**
 * Get the enabled status of the playlists manager.
 * @name FORGE.PlaylistManager#enabled
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "enabled",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        return this._enabled;
    }
});

/**
 * Get the ready status of current {@link FORGE.Playlist}.
 * @name FORGE.PlaylistManager#ready
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "ready",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        if(this.playlist !== null)
        {
            return this.playlist.ready;
        }

        return false;
    }
});

/**
 * Get the decoded status of current {@link FORGE.Playlist}.
 * @name FORGE.PlaylistManager#decoded
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "decoded",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        if(this.playlist !== null)
        {
            return this.playlist.decoded;
        }

        return false;
    }
});

/**
 * Get the playing status of current {@link FORGE.Playlist}.
 * @name FORGE.PlaylistManager#playing
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "playing",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        if(this.playlist !== null)
        {
            return this.playlist.playing;
        }

        return false;
    }
});

/**
 * Get the pause status of current {@link FORGE.Playlist}.
 * @name FORGE.PlaylistManager#paused
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "paused",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        if(this.playlist !== null)
        {
            return this.playlist.paused;
        }

        return false;
    }
});

/**
 * Get the playlist manager main volume.
 * @name FORGE.PlaylistManager#volume
 * @type {number}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "volume",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        return this._volume;
    },

    /** @this {FORGE.PlaylistManager} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        value = FORGE.Math.clamp(value, 0, 1);
        if(this._maxVolume < value)
        {
            this._volume = this._maxVolume;
        }
        else
        {
            this._volume = value;
        }

        if(FORGE.UID.isTypeOf(this._playlistUID, "Playlist") === true)
        {
            var playlist = FORGE.UID.get(this._playlistUID, "Playlist");

            if(playlist !== null)
            {
                var track = playlist.track;

                if(track !== null)
                {
                    track.volume = playlist.volume * this._volume;
                }
            }
        }
    }
});

/**
 * Get the "onReady" event {@link FORGE.EventDispatcher} of the playlist.
 * @name FORGE.PlaylistManager#onReady
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "onReady",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        if(this._onReady === null)
        {
            this._onReady = new FORGE.EventDispatcher(this);
        }

        return this._onReady;
    }
});

/**
 * Get the "onPlay" event {@link FORGE.EventDispatcher} of the track.
 * @name FORGE.PlaylistManager#onPlay
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "onPlay",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        if(this._onPlay === null)
        {
            this._onPlay = new FORGE.EventDispatcher(this);
        }

        return this._onPlay;
    }
});

/**
 * Get the "onStop" event {@link FORGE.EventDispatcher} of the track.
 * @name FORGE.PlaylistManager#onStop
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "onStop",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        if(this._onStop === null)
        {
            this._onStop = new FORGE.EventDispatcher(this);
        }

        return this._onStop;
    }
});

/**
 * Get the "onPause" event {@link FORGE.EventDispatcher} of the track.
 * @name FORGE.PlaylistManager#onPause
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "onPause",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        if(this._onPause === null)
        {
            this._onPause = new FORGE.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
 * Get the "onResume" event {@link FORGE.EventDispatcher} of the track.
 * @name FORGE.PlaylistManager#onResume
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "onResume",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        if(this._onResume === null)
        {
            this._onResume = new FORGE.EventDispatcher(this);
        }

        return this._onResume;
    }
});

/**
 * Get the "onEnded" event {@link FORGE.EventDispatcher} of the track.
 * @name FORGE.PlaylistManager#onEndedd
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.PlaylistManager.prototype, "onEnded",
{
    /** @this {FORGE.PlaylistManager} */
    get: function()
    {
        if(this._onEnded === null)
        {
            this._onEnded = new FORGE.EventDispatcher(this);
        }

        return this._onEnded;
    }
});


/**
 * A FORGE.PlaylistTrack is an object that manages the sound atached to a playlist track.
 *
 * @constructor FORGE.PlaylistTrack
 * @param {FORGE.Viewer} viewer - The {@link FORGE.Viewer} reference.
 * @param {AudioTrackConfig} config - The track config object.
 * @extends {FORGE.BaseObject}
 */
FORGE.PlaylistTrack = function(viewer, config)
{
    /**
     * The viewer reference.
     * @name FORGE.PlaylistTrack#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The config object.
     * @name FORGE.PlaylistTrack#_config
     * @type {?AudioTrackConfig}
     * @private
     */
    this._config = config;

    /**
     * The name of the track.
     * @name  FORGE.PlaylistTrack#_name
     * @type {?FORGE.LocaleString}
     * @private
     */
    this._name = null;

    /**
     * The author of the track.
     * @name  FORGE.PlaylistTrack#_author
     * @type {?FORGE.LocaleString}
     * @private
     */
    this._author = null;

    /**
     * The url of the track.
     * @name  FORGE.PlaylistTrack#_url
     * @type {string}
     * @private
     */
    this._url = "";

    /**
     * Does the track must be looped?
     * @name  FORGE.PlaylistTrack#_loop
     * @type {boolean}
     * @private
     */
    this._loop = false;

    /**
     * The {@link FORGE.Sound} attached to this track.
     * @name  FORGE.PlaylistTrack#_sound
     * @type {?FORGE.Sound}
     * @private
     */
    this._sound = null;

    FORGE.BaseObject.call(this, "PlaylistTrack");

    this._boot();
};

FORGE.PlaylistTrack.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.PlaylistTrack.prototype.constructor = FORGE.PlaylistTrack;

/**
 * Boot sequence.
 * @method FORGE.PlaylistTrack#_boot
 * @private
 */
FORGE.PlaylistTrack.prototype._boot = function()
{
    this._uid = this._config.uid;
    this._register();

    this._parseConfig(this._config);
};

/**
 * Parse the track config.
 * @method FORGE.PlaylistTrack#_parseConfig
 * @param {AudioTrackConfig} config - The config to parse.
 * @private
 */
FORGE.PlaylistTrack.prototype._parseConfig = function(config)
{
    this._unregister();
    this._uid = config.uid;
    this._register();
    this._name = new FORGE.LocaleString(this._viewer, config.name);
    this._author = new FORGE.LocaleString(this._viewer, config.author);
    this._url = config.url;
    this._loop = config.loop || false;
};

/**
 * Bind handlers on the sound
 * @method  FORGE.PlaylistTrack#_bindEvents
 * @private
 */
FORGE.PlaylistTrack.prototype._bindEvents = function()
{
    this._sound.onPlay.add(this._onPlayHandler, this);
    this._sound.onStop.add(this._onStopHandler, this);
    this._sound.onPause.add(this._onPauseHandler, this);
    this._sound.onResume.add(this._onResumeHandler, this);
    this._sound.onEnded.add(this._onEndedHandler, this);
};

/**
 * Unbind handlers on the sound
 * @method  FORGE.PlaylistTrack#_unbindEvents
 * @private
 */
FORGE.PlaylistTrack.prototype._unbindEvents = function()
{
    this._sound.onPlay.remove(this._onPlayHandler, this);
    this._sound.onStop.remove(this._onStopHandler, this);
    this._sound.onPause.remove(this._onPauseHandler, this);
    this._sound.onResume.remove(this._onResumeHandler, this);
    this._sound.onEnded.remove(this._onEndedHandler, this);
};

/**
 * Play handler to notify event to the playlist manager
 * @method  FORGE.PlaylistTrack#_onPlayHandler
 * @private
 */
FORGE.PlaylistTrack.prototype._onPlayHandler = function()
{
    FORGE.PlaylistManager.prototype._notifyPlay.call(this._viewer.playlists);
};

/**
 * Stop handler to notify event to the playlist manager
 * @method  FORGE.PlaylistTrack#_onStopHandler
 * @private
 */
FORGE.PlaylistTrack.prototype._onStopHandler = function()
{
    FORGE.PlaylistManager.prototype._notifyStop.call(this._viewer.playlists);
};

/**
 * Pause handler to notify event to the playlist manager
 * @method  FORGE.PlaylistTrack#_onPauseHandler
 * @private
 */
FORGE.PlaylistTrack.prototype._onPauseHandler = function()
{
    FORGE.PlaylistManager.prototype._notifyPause.call(this._viewer.playlists);
};

/**
 * Resume handler to notify event to the playlist manager
 * @method  FORGE.PlaylistTrack#_onResumeHandler
 * @private
 */
FORGE.PlaylistTrack.prototype._onResumeHandler = function()
{
    FORGE.PlaylistManager.prototype._notifyResume.call(this._viewer.playlists);
};

/**
 * Ended handler to notify event to the playlist manager
 * @method  FORGE.PlaylistTrack#_onEndedHandler
 * @private
 */
FORGE.PlaylistTrack.prototype._onEndedHandler = function()
{
    FORGE.PlaylistManager.prototype._notifyEnded.call(this._viewer.playlists);
};

/**
 * Play the track.
 * @method FORGE.PlaylistTrack#play
 */
FORGE.PlaylistTrack.prototype.play = function()
{
    if(this._sound === null)
    {
        this._sound = new FORGE.Sound(this._viewer, this._uid + "-sound", this._url);
        this._sound.volume = this._viewer.playlists.volume * this._viewer.playlists.playlist.volume;
        if (this._loop === true)
        {
            this._sound.loop = this._loop;
        }

        this._bindEvents();
    }

    this._sound.play();
};

/**
 * Stop the track.
 * @method FORGE.PlaylistTrack#stop
 */
FORGE.PlaylistTrack.prototype.stop = function()
{
    if(this._sound !== null)
    {
        this._sound.stop(true);
    }
};

/**
 * Pause the track.
 * @method FORGE.PlaylistTrack#pause
 */
FORGE.PlaylistTrack.prototype.pause = function()
{
    if(this._sound !== null)
    {
        this._sound.pause();
    }
};

/**
 * Resume the track.
 * @method FORGE.PlaylistTrack#resume
 */
FORGE.PlaylistTrack.prototype.resume = function()
{
    if(this._sound !== null)
    {
        this._sound.resume();
    }
};

/**
 * Destroy sequence
 * @method  FORGE.PlaylistTrack#destroy
 */
FORGE.PlaylistTrack.prototype.destroy = function()
{
    this._viewer = null;

    this._config = null;

    this._name.destroy();
    this._name = null;

    this._author.destroy();
    this._author = null;

    if(this._sound !== null)
    {
        this._unbindEvents();

        this._sound.destroy();
        this._sound = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the name of the track.
 * @name  FORGE.PlaylistTrack#name
 * @type {string}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "name",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        return this._name.value;
    }
});

/**
 * Get the author of the track.
 * @name  FORGE.PlaylistTrack#author
 * @type {string}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "author",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        return this._author.value;
    }
});

/**
 * Get and set the current time of the track.
 * @name  FORGE.PlaylistTrack#currentTime
 * @type {number}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "currentTime",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound.currentTime;
        }

        return 0;
    },

    /** @this {FORGE.PlaylistTrack} */
    set: function(value)
    {
        if(this._sound === null)
        {
            return;
        }

        this._sound.currentTime = value;
    }
});

/**
 * Get and set the volume of the track.
 * @name  FORGE.PlaylistTrack#volume
 * @type {number}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "volume",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound.volume;
        }

        return false;
    },

    /** @this {FORGE.PlaylistTrack} */
    set: function(value)
    {
        if(this._sound === null)
        {
            return false;
        }

        this._sound.volume = value;
    }
});

/**
 * Get the ready status of the track.
 * @name FORGE.PlaylistTrack#ready
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "ready",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound.ready;
        }

        return false;
    }
});

/**
 * Get the decoded status of the track.
 * @name FORGE.PlaylistTrack#decoded
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "decoded",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound.decoded;
        }

        return false;
    }
});

/**
 * Get the playing status of the track.
 * @name FORGE.PlaylistTrack#playing
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "playing",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound.playing;
        }

        return false;
    }
});

/**
 * Get the paused status of the track.
 * @name FORGE.PlaylistTrack#paused
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "paused",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound.paused;
        }

        return false;
    }
});

/**
 * Get ans set the loop state of the track.
 * @name FORGE.PlaylistTrack#loop
 * @type {boolean}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "loop",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        return this._loop;
    },

    /** @this {FORGE.PlaylistTrack} */
    set: function(value)
    {
        this._loop = Boolean(value);
    }
});

/**
 * Get the "onPlay" event {@link FORGE.EventDispatcher} of the track.
 * @name FORGE.PlaylistTrack#onPlay
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "onPlay",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound.onPlay;
        }

        return;
    }
});

/**
 * Get the "onStop" event {@link FORGE.EventDispatcher} of the track.
 * @name FORGE.PlaylistTrack#onStop
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "onStop",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound.onStop;
        }

        return;
    }
});

/**
 * Get the "onPause" event {@link FORGE.EventDispatcher} of the track.
 * @name FORGE.PlaylistTrack#onPause
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "onPause",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound.onPause;
        }

        return;
    }
});

/**
 * Get the "onResume" event {@link FORGE.EventDispatcher} of the track.
 * @name FORGE.PlaylistTrack#onResume
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "onResume",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound.onResume;
        }

        return;
    }
});

/**
 * Get the "onEnded" event {@link FORGE.EventDispatcher} of the track.
 * @name FORGE.PlaylistTrack#onEnded
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.PlaylistTrack.prototype, "onEnded",
{
    /** @this {FORGE.PlaylistTrack} */
    get: function()
    {
        if(this._sound !== null)
        {
            return this._sound.onEnded;
        }

        return;
    }
});
/**
 * A FORGE.Director is used to animate a hotspot.
 *
 * @constructor FORGE.Director
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference
 * @extends {FORGE.Animation}
 */
FORGE.Director = function(viewer)
{
    /**
     * Viewer reference.
     * @name FORGE.Director#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The UID of the selected track.
     * @name FORGE.Director#_track
     * @type {?string}
     * @private
     */
    this._track = null;

    /**
     * The list of the tracks composing the director's cut
     * @name FORGE.Director#_track
     * @type {?Array<string>}
     * @private
     */
    this._tracks = null;

    /**
     * Does the director's cut loop ?
     * @name FORGE.Director#_loop
     * @type {boolean}
     * @private
     */
    this._loop = false;

    /**
     * Does the director's cut randomized ?
     * @name FORGE.Director#_random
     * @type {boolean}
     * @private
     */
    this._random = false;

    /**
     * Can the director's cut be stopped ?
     * @name FORGE.Director#_stoppable
     * @type {boolean}
     * @private
     */
    this._stoppable = false;

    /**
     * The idle time to resume the animation after it was stopped by the user.
     * @name FORGE.Director#_idleTime
     * @type {number}
     * @private
     */
    this._idleTime = -1;

    /**
     * Timer reference used to trigger an animation after idle time
     * @name FORGE.Director#_idleTimer
     * @type {FORGE.Timer}
     * @private
     */
    this._idleTimer = null;

    /**
     * Timer idle event reference
     * @name FORGE.Director#_idleEvent
     * @type {FORGE.TimerEvent}
     * @private
     */
    this._idleEvent = null;

    /**
     * Event handler for the synchronization of the video. Needed for the visibilitychange event.
     * See https://www.w3.org/TR/page-visibility/#sec-visibilitychange-event
     * @name FORGE.Director#_onVisibilityChangeBind
     * @type {Function}
     * @private
     */
    this._onVisibilityChangeBind = null;

    FORGE.BaseObject.call(this, "Director");
    this._boot();
};

FORGE.Director.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Director.prototype.constructor = FORGE.Director;

/**
 * Boot sequence
 *
 * @method FORGE.Director#_boot
 * @private
 */
FORGE.Director.prototype._boot = function()
{
    // Idle timer
    this._idleTimer = this._viewer.clock.create(false);

    // Start the cut once the scene is loaded
    this._viewer.story.onSceneLoadComplete.add(this._sceneLoadCompleteHandler, this);

    // Add controllers after viewer is ready
    this._viewer.onReady.add(this._onViewerReady, this);

    // Bind onVisibilityChange handler
    this._onVisibilityChangeBind = this._onVisibilityChange.bind(this);
};

/**
 * Load director's cut configuration.
 *
 * @method FORGE.Director#load
 * @param {HotspotTrackConfig} config - The animation config to load.
 */
FORGE.Director.prototype.load = function(config)
{
    // Register tracks, no need to store them here
    if (config.tracks !== null && Array.isArray(config.tracks))
    {
        for (var i = 0, ii = config.tracks.length; i < ii; i++)
        {
            new FORGE.DirectorTrack(config.tracks[i]);
        }
    }
};

/**
 * Viewer ready handler
 * @method FORGE.Director#_onViewerReady
 * @private
 */
FORGE.Director.prototype._onViewerReady = function()
{
    this._viewer.controllers.onControlStart.add(this._controlStartHandler, this);
    this._viewer.controllers.onControlEnd.add(this._controlEndHandler, this);
};

/**
 * Event handler for scene load complete.
 * @method  FORGE.Director#_sceneLoadCompleteHandler
 * @private
 */
FORGE.Director.prototype._sceneLoadCompleteHandler = function()
{
    var scene = this._viewer.story.scene;

    // Stop all
    this.stop();
    this._clearEvents();

    // Empty tracks
    this._track = null;
    this._tracks = [];

    if (typeof scene.config.director !== "undefined")
    {
        var animation = scene.config.director.animation;

        if (typeof animation === "undefined" || animation === null || animation.enabled === false)
        {
            return;
        }

        // General properties
        this._loop = (typeof animation.loop === "boolean") ? animation.loop : false;
        this._random = (typeof animation.random === "boolean") ? animation.random : false;
        this._stoppable = (typeof animation.stoppable === "boolean") ? animation.stoppable : false;
        this._idleTime = (typeof animation.idleTime === "number") ? animation.idleTime : 0;

        // Load tracks
        if (animation.tracks !== null && FORGE.Utils.isArrayOf(animation.tracks, "string"))
        {
            this._tracks = (this._random === true) ? FORGE.Utils.randomize(animation.tracks) : animation.tracks;
        }

        // Add on complete handler
        this._viewer.camera.animation.onComplete.add(this._onTrackCompleteHandler, this);

        // Add specific behavior if the current media is a video
        if (this._viewer.story.scene.media.type === FORGE.MediaType.VIDEO)
        {
            this._viewer.story.scene.media.displayObject.onPause.add(this._pauseHandler, this);

            // React on loading/buffering event
            this._viewer.story.scene.media.displayObject.onWaiting.add(this._waitingHandler, this);
            this._viewer.story.scene.media.displayObject.onStalled.add(this._waitingHandler, this);
            this._viewer.story.scene.media.displayObject.onSeeking.add(this._waitingHandler, this);

            // The director's cut begin again if video is looping
            this._viewer.story.scene.media.displayObject.onEnded.add(this._endedHandler, this);

            // Synchronization !
            this._viewer.story.scene.media.displayObject.onCurrentTimeChange.add(this._synchronizeWithVideo, this);

            // Double synchronization when the window lose visibility
            // Needed because we rely on RAF which is only working on visibility
            document.addEventListener(FORGE.Device.visibilityChange, this._onVisibilityChangeBind);
        }

        // Start given the idle time
        if (typeof animation.delay === "number")
        {
            this._idleEvent = this._idleTimer.add(animation.delay, this._idleTimerCompleteHandler, this);
            this._idleTimer.start();
        }
    }
};

/**
 * Event handler when the video is paused. Not trigger only after the "pause" event.
 * @method FORGE.Director#_pauseHandler
 * @private
 */
FORGE.Director.prototype._pauseHandler = function()
{
    // Stopping the animation
    this.stop();

    // Event handling
    // for animation
    if (this._viewer.story.scene.media.type === FORGE.MediaType.VIDEO)
    {
        this._viewer.story.scene.media.displayObject.onPause.remove(this._pauseHandler, this);
        this._viewer.story.scene.media.displayObject.onPlay.add(this._playHandler, this);
    }

    // for controllers
    this._viewer.controllers.onControlStart.remove(this._controlStartHandler, this);
    this._viewer.controllers.onControlEnd.remove(this._controlEndHandler, this);
};

/**
 * Event handler when the video start playing again. Not trigger only after the "play" event.
 * @method FORGE.Director#_playHandler
 * @private
 */
FORGE.Director.prototype._playHandler = function()
{
    // Starting the animation
    if (this._track !== null)
    {
        this.play(this._track);

        if (this._viewer.story.scene.media.type === FORGE.MediaType.VIDEO)
        {
            this._synchronizeWithVideo();
        }
    }

    // Event handling
    // for animation
    if (this._viewer.story.scene.media.type === FORGE.MediaType.VIDEO)
    {
        this._viewer.story.scene.media.displayObject.onPause.add(this._pauseHandler, this);
        this._viewer.story.scene.media.displayObject.onPlay.remove(this._playHandler, this);
    }
    // for controllers
    this._viewer.controllers.onControlStart.add(this._controlStartHandler, this);
    this._viewer.controllers.onControlEnd.add(this._controlEndHandler, this);
};

/**
 * Waiting and stalled handler
 * @method FORGE.Director#_waitingHandler
 * @private
 */
FORGE.Director.prototype._waitingHandler = function()
{
    // Stopping the animation
    this.stop();

    // Event handling
    // for waiting
    if (this._viewer.story.scene.media.type === FORGE.MediaType.VIDEO)
    {
        this._viewer.story.scene.media.displayObject.onWaiting.remove(this._waitingHandler, this);
        this._viewer.story.scene.media.displayObject.onStalled.remove(this._waitingHandler, this);
        this._viewer.story.scene.media.displayObject.onSeeking.remove(this._waitingHandler, this);
        this._viewer.story.scene.media.displayObject.onPlaying.add(this._playingHandler, this);
        this._viewer.story.scene.media.displayObject.onSeeked.add(this._playingHandler, this);
    }
    // for controllers
    this._viewer.controllers.onControlStart.remove(this._controlStartHandler, this);
    this._viewer.controllers.onControlEnd.remove(this._controlEndHandler, this);
};

/**
 * Playing handler
 * @method FORGE.Director#_playingHandler
 * @private
 */
FORGE.Director.prototype._playingHandler = function()
{
    // Starting the animation
    if (this._track !== null)
    {
        this.play(this._track);

        if (this._viewer.story.scene.media.type === FORGE.MediaType.VIDEO)
        {
            this._synchronizeWithVideo();
        }
    }

    // Event handling
    // for waiting
    if (this._viewer.story.scene.media.type === FORGE.MediaType.VIDEO)
    {
        this._viewer.story.scene.media.displayObject.onPlaying.remove(this._playingHandler, this);
        this._viewer.story.scene.media.displayObject.onSeeked.remove(this._playingHandler, this);
        this._viewer.story.scene.media.displayObject.onWaiting.add(this._waitingHandler, this);
        this._viewer.story.scene.media.displayObject.onStalled.add(this._waitingHandler, this);
        this._viewer.story.scene.media.displayObject.onSeeking.add(this._waitingHandler, this);
    }
    // for controllers
    this._viewer.controllers.onControlStart.add(this._controlStartHandler, this);
    this._viewer.controllers.onControlEnd.add(this._controlEndHandler, this);
};

/**
 * If the video is looping, this handler will start the director's cut all over again.
 * @method FORGE.Director#_endedHandler
 * @private
 */
FORGE.Director.prototype._endedHandler = function()
{
    if (this._viewer.story.scene.media.type === FORGE.MediaType.VIDEO && this._viewer.story.scene.media.displayObject.loop === true)
    {
        // Starting the animation by considering it is a new scene
        this._sceneLoadCompleteHandler();
    }
};

/**
 * Event handler for control start.
 * @method FORGE.Director#_controlStartHandler
 * @private
 */
FORGE.Director.prototype._controlStartHandler = function()
{
    if (this._track !== null && this._stoppable === true)
    {
        this.stop();
    }

    this._idleTimer.stop(true);
};

/**
 * Event handler for control end.
 * @method FORGE.Director#_controlEndHandler
 * @private
 */
FORGE.Director.prototype._controlEndHandler = function()
{
    if (this._idleEvent !== null)
    {
        this._idleTimer.remove(this._idleEvent);
    }

    if (this._track !== null && this._stoppable === true)
    {
        // If the track is null, we haven't began yet the director's cut
        if (this._track === null && typeof this._viewer.story.scene.config.director.animation.delay === "number")
        {
            this._idleEvent = this._idleTimer.add(this._viewer.story.scene.config.director.animation.delay, this._idleTimerCompleteHandler, this);
            this._idleTimer.start();
        }
        else if (typeof this._idleTime === "number" && this._idleTime > -1)
        {
            this._idleEvent = this._idleTimer.add(this._idleTime, this._idleTimerCompleteHandler, this);
            this._idleTimer.start();
        }
    }
};

/**
 * Event handler when a track is completed. Play the next track in the list if
 * any, or a random one.
 * @method FORGE.Director#_onTrackCompleteHandler
 * @private
 */
FORGE.Director.prototype._onTrackCompleteHandler = function()
{
    if (this._tracks.length > 1)
    {
        // Go to the next track if any
        var idx = this._tracks.indexOf( /** @type {string} */ (this._track)) + 1;

        // If the index is too high, play the track
        if (idx < this._tracks.length)
        {
            this.play(idx);
            return;
        }
    }

    // Loop only if it is the end of the last track
    if (this._loop === true)
    {
        // If it is random, change the entire order
        if (this._random === true)
        {
            this._tracks = FORGE.Utils.randomize(this._tracks);
        }

        this.play(0);
        return;
    }
};

/**
 * Event handler for idle timer complete.
 *
 * @method FORGE.Director#_idleTimerCompleteHandler
 * @private
 */
FORGE.Director.prototype._idleTimerCompleteHandler = function()
{
    // Resume the current track
    this.play(this._track);

    this._idleTimer.stop(true);
};

/**
 * Event handler for visibility change on the window.
 * @method FORGE.Director#_onVisibilityChange
 * @private
 */
FORGE.Director.prototype._onVisibilityChange = function()
{
    if (document[FORGE.Device.visibilityState] !== "hidden" && this._viewer.story.scene.media.type === FORGE.MediaType.VIDEO)
    {
        this._viewer.story.scene.media.displayObject.onCurrentTimeChange.dispatch(this._viewer.story.scene.media.displayObject.currentTime);
    }
};

/**
 * When the currentTime property of the video change, synchronize the director's cut on it.
 * @method FORGE.Director#_synchronizeWithVideo
 * @param  {(number|FORGE.Event)=} time - the emitted event, containing the time to synchronize to, or the time to synchronize to (in seconds).
 * @private
 */
FORGE.Director.prototype._synchronizeWithVideo = function(time)
{
    this.stop();

    // Remove the current track
    this._track = null;

    // Get the correct time to sync
    if (typeof time === "number")
    {
        time = time * 1000;
    }
    else if (typeof time === "object" && typeof time.data === "number")
    {
        time = time.data * 1000;
    }
    else if (this._viewer.story.scene.media.type === FORGE.MediaType.VIDEO)
    {
        time = this._viewer.story.scene.media.displayObject.currentTimeMS;
    }
    else
    {
        time = 0;
    }

    var offset = 0;
    var trackA, trackB;
    trackB = FORGE.UID.get(this._tracks[0]);

    // If the time is lower than the duration of the first track, it is this one
    if (trackB.duration > time)
    {
        this._track = trackB.uid;
    }
    else
    {
        // Else check for each track and its following one if the time is between this two.
        for (var i = 1, ii = this._tracks.length - 1; i < ii; i++)
        {
            trackA = trackB;
            trackB = FORGE.UID.get(this._tracks[i]);

            if (trackA.duration + offset < time && trackB.duration + trackA.duration + offset > time)
            {
                this._track = trackB.uid;
                offset += trackA.duration;
                break;
            }

            offset += trackA.duration;
        }
    }

    // If no track found, it is after the last track, so change the camera
    if (this._track === null)
    {
        // Look the same as the last point of our last track
        var point = trackB.keyframes[trackB.keyframes.length - 1].data;
        this._viewer.camera.lookAt(point.yaw, point.pitch, point.roll, point.fov);
    }
    else
    {
        this._viewer.camera.animation.play(this._track, time);
    }
};

/**
 * Play a set of tracks if specified, else the current one, from the start.
 *
 * @method FORGE.Director#play
 * @param {?(string|number)=} track - A track
 */
FORGE.Director.prototype.play = function(track)
{
    this.stop();
    this._track = null;

    if (typeof track === "number")
    {
        this._track = this._tracks[track];
    }
    else if (typeof track === "string")
    {
        this._track = track;
    }
    else
    {
        this._track = this._tracks[0];
    }

    this._viewer.camera.animation.play(this._track);
};

/**
 * Stops the current animation.
 * @method FORGE.Director#stop
 */
FORGE.Director.prototype.stop = function()
{
    this.log("stopping");
    this._viewer.camera.animation.stop();
};

FORGE.Director.prototype._clearEvents = function()
{
    this._viewer.camera.animation.onComplete.remove(this._onTrackCompleteHandler, this);

    if (this._viewer.story.scene !== null && this._viewer.story.scene.media.type === FORGE.MediaType.VIDEO)
    {
        this._viewer.story.scene.media.displayObject.onPlay.remove(this._playHandler, this);
        this._viewer.story.scene.media.displayObject.onPause.remove(this._pauseHandler, this);
        this._viewer.story.scene.media.displayObject.onWaiting.remove(this._waitingHandler, this);
        this._viewer.story.scene.media.displayObject.onStalled.remove(this._waitingHandler, this);
        this._viewer.story.scene.media.displayObject.onPlaying.remove(this._playingHandler, this);
        this._viewer.story.scene.media.displayObject.onEnded.remove(this._endedHandler, this);
        this._viewer.story.scene.media.displayObject.onCurrentTimeChange.remove(this._synchronizeWithVideo, this);

        document.removeEventListener(FORGE.Device.visibilityChange, this._onVisibilityChangeBind);
    }
};

/**
 * Destroy method.
 * @method  FORGE.Director#destroy
 */
FORGE.Director.prototype.destroy = function()
{
    this._clearEvents();

    this._viewer.onReady.remove(this._onViewerReady, this);
    this._viewer = null;

    this._tracks = null;

    this._track = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * A director track, that defines a camera animation.
 *
 * @constructor FORGE.DirectorTrack
 * @param {DirectorTrackConfig} config - Configuration of the track from the JSON file.
 * @extends {FORGE.Track}
 */
FORGE.DirectorTrack = function(config)
{
    /**
     * Does the track has a smooth interpolation between keyframes ?
     * @name FORGE.DirectorTrack#_smooth
     * @type {boolean}
     * @private
     */
    this._smooth = false;

    /**
     * Is the roll cancelled ?
     * @name FORGE.DirectorTrack#_cancelRoll
     * @type {boolean}
     * @private
     */
    this._cancelRoll = false;

    FORGE.Track.call(this, "DirectorTrack");

    this._boot(config);
};

FORGE.DirectorTrack.prototype = Object.create(FORGE.Track.prototype);
FORGE.DirectorTrack.prototype.constructor = FORGE.DirectorTrack;

/**
 * Boot sequence
 *
 * @method FORGE.DirectorTrack#_boot
 * @param  {Object} config - The information on the track
 * @private
 */
FORGE.DirectorTrack.prototype._boot = function(config)
{
    this._smooth = config.smooth;
    this._cancelRoll = config.cancelRoll;

    FORGE.Track.prototype._boot.call(this, config);
};

/**
 * Accessors to smooth
 * @name FORGE.DirectorTrack#smooth
 * @readonly
 * @type {FORGE.DirectorTrack}
 */
Object.defineProperty(FORGE.DirectorTrack.prototype, "smooth",
{
    /** @this {FORGE.DirectorTrack} */
    get: function()
    {
        return this._smooth;
    }
});

/**
 * Accessors to cancelRoll
 * @name FORGE.DirectorTrack#cancelRoll
 * @readonly
 * @type {FORGE.DirectorTrack}
 */
Object.defineProperty(FORGE.DirectorTrack.prototype, "cancelRoll",
{
    /** @this {FORGE.DirectorTrack} */
    get: function()
    {
        return this._cancelRoll;
    }
});

/**
 * A action set event dispatcher is in charge to triggers actions binded on an event.
 *
 * @constructor FORGE.ActionEventDispatcher
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {string} name - The name of the event.
 * @extends {FORGE.BaseObject}
 */
FORGE.ActionEventDispatcher = function(viewer, name)
{
    /**
     * The viewer reference.
     * @name FORGE.ActionEventDispatcher#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Event name
     * @name FORGE.ActionEventDispatcher#_name
     * @type {string}
     * @private
     */
    this._name = name;

    /**
     * The actions uid list of the set.
     * @name  FORGE.ActionEventDispatcher#_actions
     * @type {Array<string>}
     * @private
     */
    this._actions = [];

    /**
     * Flag to know if the dispatcher is currently dispatching the events.
     * It happen that the dispatcher destroy method is called during the dispatching the events.
     * This allows us to re schedule the destroy call after all events have been executed.
     * @name  FORGE.ActionEventDispatcher#_dispatching
     * @type {boolean}
     * @private
     */
    this._dispatching = false;

    /**
     * Is the destroy method have been called during the dispatching?
     * @name  FORGE.ActionEventDispatcher#_pendingDestroy
     * @type {boolean}
     * @private
     */
    this._pendingDestroy = false;

    FORGE.BaseObject.call(this, "ActionEventDispatcher");
};

FORGE.ActionEventDispatcher.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.ActionEventDispatcher.prototype.constructor = FORGE.ActionEventDispatcher;

/**
 * Boot sequence.
 * @method FORGE.ActionEventDispatcher#addActions
 * @param {(string|Array<string>)} actions - The actions uids you want to add
 */
FORGE.ActionEventDispatcher.prototype.addActions = function(actions)
{
    if(FORGE.Utils.isArrayOf(actions, "string") === true || FORGE.Utils.isTypeOf(actions, "string"))
    {
        this._actions = this._actions.concat(actions);
    }
};

/**
 * This method execute every actions binded on this event dispatcher.
 * @method FORGE.ActionEventDispatcher#dispatch
 */
FORGE.ActionEventDispatcher.prototype.dispatch = function()
{
    this._dispatching = true;

    for(var i = 0, ii = this._actions.length; i < ii; i++)
    {
        var action = this._viewer.actions.get(this._actions[i]);

        if(typeof action !== "undefined" && action !== null)
        {
            action.execute();
        }
    }

    this._dispatching = false;

    if(this._pendingDestroy === true)
    {
        this.destroy();
    }
};

/**
 * Destroy sequence.
 * @method  FORGE.ActionEventDispatcher#destroy
 */
FORGE.ActionEventDispatcher.prototype.destroy = function()
{
    //If dispatching, wait for the dispatch is complete to execute the destroy
    if(this._dispatching === true)
    {
        this._pendingDestroy = true;
        return;
    }

    this._viewer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * An action is a description of a method to execute in reaction to an event.<br>
 * The method will be executed from a target.
 *
 * @constructor FORGE.Action
 * @param {FORGE.Viewer} viewer - The {@link FORGE.Viewer} reference.
 * @param {ActionConfig} config - The config of the action.
 * @extends {FORGE.BaseObject}
 */
FORGE.Action = function(viewer, config)
{
    /**
     * The viewer reference.
     * @name FORGE.Action#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The config of the action.
     * @name FORGE.Action#_config
     * @type {ActionConfig}
     * @private
     */
    this._config = config;

    /**
     * The object related to this action.
     * @name FORGE.Action#_object
     * @type {(string|ActionTargetConfig)}
     * @private
     */
    this._target = "";

    /**
     * The method name with args who will be executed.
     * @name FORGE.Action#_method
     * @type {?ActionMethodConfig}
     * @private
     */
    this._method = null;

    /**
     * The property name who will be changed with the value.
     * @name FORGE.Action#_property
     * @type {?ActionPropertyConfig}
     * @private
     */
    this._property = null;

    /**
     * The number of time this action has been executed
     * @name FORGE.Action._count
     * @type {number}
     * @private
     */
    this._count = 0;

    FORGE.BaseObject.call(this, "Action");

    this._boot();
};

FORGE.Action.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Action.prototype.constructor = FORGE.Action;

/**
 * List of possible operation when you affect a property.
 * @name  FORGE.Action.operation
 * @type {Object}
 * @const
 */
FORGE.Action.operation = {};

/**
 * Operation set is the default one, it will just set the value.
 * @name  FORGE.Action.operation.SET
 * @type {string}
 * @const
 */
FORGE.Action.operation.SET = "set";

/**
 * Operation addition.
 * @name  FORGE.Action.operation.ADD
 * @type {string}
 * @const
 */
FORGE.Action.operation.ADD = "add";

/**
 * Operation substract.
 * @name  FORGE.Action.operation.SUBSTRACT
 * @type {string}
 * @const
 */
FORGE.Action.operation.SUBSTRACT = "substract";

/**
 * Operation multiply.
 * @name  FORGE.Action.operation.MULTIPLY
 * @type {string}
 * @const
 */
FORGE.Action.operation.MULTIPLY = "multiply";

/**
 * Operation divide.
 * @name  FORGE.Action.operation.DIVIDE
 * @type {string}
 * @const
 */
FORGE.Action.operation.DIVIDE = "divide";

/**
 * Operation boolean toggle.
 * @name  FORGE.Action.operation.TOGGLE
 * @type {string}
 * @const
 */
FORGE.Action.operation.TOGGLE = "toggle";

/**
 * Boot sequence.
 * @method FORGE.Action#_boot
 * @private
 */
FORGE.Action.prototype._boot = function()
{
    this._parseConfig(this._config);
    this._register();
};

/**
 * Parse the action configuration object from the json
 * @method FORGE.Action#_parseConfig
 * @param  {ActionConfig} config - Action configuration to parse
 * @private
 */
FORGE.Action.prototype._parseConfig = function(config)
{
    this._uid = config.uid;

    this._target = config.target;

    this._method = (typeof config.method !== "undefined") ? config.method : null;

    this._property = (typeof config.property !== "undefined") ? config.property : null;
};

/**
 * Parse the target.<br>
 * If undefined action will be executed on "window".<br>
 * If target start by "this" keyword, method will be searched on the action set instance.<br>
 * Target can also be the id of a plugin.
 * @method FORGE.Action#_parseTarget
 * @private
 * @param  {(string|ActionTargetConfig)} target - The target to parse.
 * @return {*} The target object.
 */
FORGE.Action.prototype._parseTarget = function(target)
{
    var result = null;

    if (typeof target === "undefined")
    {
        result = window;
    }
    else
    {
        var targetUid = target;
        var path = target;

        if (typeof target === "object")
        {
            if (typeof target.identifier === "string")
            {
                targetUid = target.identifier;
            }
            if (typeof target.accessor === "string")
            {
                path = target.accessor;
            }
        }

        // Root target
        var targetByUid = FORGE.UID.get(targetUid);

        if (typeof targetByUid !== "undefined" && targetByUid !== null)
        {
            if (FORGE.Utils.isTypeOf(targetByUid, "Plugin"))
            {
                result = targetByUid.instance;
            }
            else
            {
                result = targetByUid;
            }
        }

        // Path
        path = path.split(".");

        var i = 0;
        // If it is the viewer, reset the result to it
        if (path[0].toLowerCase() === "viewer" && result === null)
        {
            result = this._viewer;
            i = 1;
        }
        else if (result === null)
        {
            result = window;
        }

        for (var ii = path.length; i < ii; i++)
        {
            if (typeof result[path[i]] === "object")
            {
                result = result[path[i]];
            }
        }
    }

    if (result === null)
    {
        this.warn("The target of the action " + this._uid + " is invalid.");
    }

    return result;
};

/**
 * Apply the property configuration to the target.
 * @method FORGE.Action#_applyProperty
 * @param  {*} target - The target that own the desired method.
 * @param  {ActionPropertyConfig} property - The property configuration with its name and its arguments array
 * @private
 */
FORGE.Action.prototype._applyProperty = function(target, property)
{
    if (typeof target[property.name] !== "undefined")
    {
        if (typeof property.operation === "undefined")
        {
            property.operation = FORGE.Action.operation.SET;
        }

        switch (property.operation)
        {
            case FORGE.Action.operation.SET:
                target[property.name] = property.value;
                break;

            case FORGE.Action.operation.ADD:
                target[property.name] += property.value;
                break;

            case FORGE.Action.operation.SUBSTRACT:
                target[property.name] -= /** @type {number} */ (property.value);
                break;

            case FORGE.Action.operation.MULTIPLY:
                target[property.name] *= /** @type {number} */ (property.value);
                break;

            case FORGE.Action.operation.DIVIDE:
                target[property.name] /= /** @type {number} */ (property.value);
                break;

            case FORGE.Action.operation.TOGGLE:
                target[property.name] = !target[property.name];
                break;
        }
    }
};

/**
 * Apply the method configuration to the target.
 * @method FORGE.Action#_applyMethod
 * @param  {*} target - The target that own the desired method.
 * @param  {ActionMethodConfig} method - The method configuration with its name and its arguments array
 * @private
 */
FORGE.Action.prototype._applyMethod = function(target, method)
{
    if (typeof target[method.name] === "function")
    {
        var args = (typeof method.args !== "undefined") ? method.args : null;

        if (!Array.isArray(args))
        {
            args = [args];
        }

        target[method.name].apply(target, args);
    }
};

/**
 * The execute method will trigger the action, parse the target if necessary.
 * @method FORGE.Action#execute
 */
FORGE.Action.prototype.execute = function()
{
    //Get the target at the last time and do NOT keep a reference !
    var target = this._parseTarget(this._target);

    if (target !== null)
    {
        if (this._property !== null)
        {
            this._applyProperty(target, this._property);
        }

        if (this._method !== null)
        {
            this._applyMethod(target, this._method);
        }
    }
};

/**
 * Destroy sequence.
 * @method  FORGE.Action#destroy
 */
FORGE.Action.prototype.destroy = function()
{
    this._viewer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};


/**
 * Get the target of the action.
 * @name FORGE.Action#target
 * @readonly
 * @type {*}
 */
Object.defineProperty(FORGE.Action.prototype, "target",
{
    /** @this {FORGE.Action} */
    get: function()
    {
        return this._parseTarget(this._target);
    }
});

/**
 * Get the number of time this action has been executed.
 * @name FORGE.Action#count
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.Action.prototype, "count",
{
    /** @this {FORGE.Action} */
    get: function()
    {
        return this._count;
    }
});
/**
 * Action manager
 * @constructor FORGE.ActionManager
 * @param {FORGE.Viewer} viewer - viewer reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.ActionManager = function(viewer)
{
    /**
     * Viewer reference.
     * @name FORGE.ActionManager#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Configuration of actions from the JSON
     * @name  FORGE.ActionManager#_config
     * @type {Array<ActionConfig>}
     * @private
     */
    this._config = null;

    /**
     * Camera reference.
     * @name FORGE.ActionManager#_actions
     * @type {Array}
     * @private
     */
    this._actions = [];

    /**
     * Event dispatcher for ready status.
     * @name FORGE.ActionManager#_onReady
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onReady = null;

    FORGE.BaseObject.call(this, "ActionManager");
};

FORGE.ActionManager.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.ActionManager.prototype.constructor = FORGE.ActionManager;

/**
 * Parse an array of configuration
 * @param {(Array<ActionConfig>|ActionConfig)} config - Array of action configurations or a single action configuration.
 * @private
 */
FORGE.ActionManager.prototype._parseConfig = function(config)
{
    var action;

    // If it is an array of actions
    if (Array.isArray(config) === true)
    {
        for (var i = 0, ii = config.length; i < ii; i++)
        {
            action = new FORGE.Action(this._viewer, config[i]);
            this._actions.push(action);
        }
    }
    // If it is a single action
    else
    {
        action = new FORGE.Action(this._viewer, /** @type {ActionConfig} */ (config));
        this._actions.push(action);
    }
};

/**
 * Get an action by id.
 * @method FORGE.ActionManager#get
 */
FORGE.ActionManager.prototype.get = function(uid)
{
    return FORGE.UID.get(uid, "Action");
};

/**
 * Add actions configuration
 * @method FORGE.ActionManager#addConfig
 * @param {(Array<ActionConfig>|ActionConfig)} config - Array of action configurations or a single action configuration.
 */
FORGE.ActionManager.prototype.addConfig = function(config)
{
    this._parseConfig(config);
};

/**
 * Destroy routine
 * @method FORGE.ActionManager#destroy
 */
FORGE.ActionManager.prototype.destroy = function()
{
    if (FORGE.Utils.isArrayOf(this._actions, "Action"))
    {
        while (this._actions.length > 0)
        {
            var a = this._actions.pop();
            a.destroy();
            a = null;
        }
    }
};

/**
 * A plugin object is an instance of a {@link FORGE.PluginEngine} on top of the viewer.<br>
 * It can be visual (display a logo) or not (gyroscope, stats ...).
 *
 * @constructor FORGE.Plugin
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {FORGE.PluginEngine} engine - The engine used to instantiate tis plugin.
 * @param {PluginInstanceConfig} config - The config of the plugin instance.
 * @param {number} index - The index of the plugin, use for display order.
 * @extends {FORGE.BaseObject}
 *
 * @todo  Scene array upgrade : Have a scene array with inclusive and exclusive uids
 * @todo  Same filter array for groups ?
 */
FORGE.Plugin = function(viewer, engine, config, index)
{
    /**
     * The viewer reference.
     * @name FORGE.Plugin#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The engine this plugin is based on.
     * @name  FORGE.Plugin#_engine
     * @type {FORGE.PluginEngine}
     * @private
     */
    this._engine = engine;

    /**
     * The instance config of the plugin.
     * @name  FORGE.Plugin#_instanceConfig
     * @type {?PluginInstanceConfig}
     * @private
     */
    this._instanceConfig = config;

    /**
     * The contextual config is the plugin configuration specific to a scene or a group.<br/>
     * It doesn't last at scene change.
     * @name FORGE.Plugin#_contextualConfig
     * @type {?PluginConfigurationConfig}
     * @private
     */
    this._contextualConfig = null;

    /**
     * This config will be the final config object that merges the default engine config, the instance config and the contextual config.
     * @name  FORGE.Plugin#_config
     * @type {?PluginInstanceConfig}
     * @private
     */
    this._config = null;

    /**
     * The index of the plugin, used if the plugin is a visual one.
     * @name FORGE.Plugin#_index
     * @type {number}
     * @private
     */
    this._index = index;

    /**
     * The options of this Plugin.
     * @name FORGE.Plugin#_options
     * @type {Object}
     * @private
     */
    this._options = null;

    /**
     * The actions of this Plugin.
     * @name FORGE.Plugin#_actions
     * @type {Object}
     * @private
     */
    this._actions = null;

    /**
     * Object that stores {@link FORGE.ActionEventDispatcher}.
     * @name FORGE.Plugin#_events
     * @type {Object<FORGE.ActionEventDispatcher>}
     * @private
     */
    this._events = null;

    /**
     * Instance of the plugin engine constructor.
     * @name  FORGE.Plugin#_instance
     * @type {?PluginStructure}
     * @private
     */
    this._instance = null;

    /**
     * Flag to tell if the instance is ready.<br>
     * It is the plugin developper that set the ready flag by calling the notifyInstanceReady method from its instance.
     * @name  FORGE.Plugin#_instanceReady
     * @type {boolean}
     * @private
     */
    this._instanceReady = false;

    /**
     * A DOM id or a DOM element.<br>
     * Used to inject graphical plugins anywhere in the document (outside the viewer container).
     * @name  FORGE.Plugin#_parent
     * @type {Element|HTMLElement|string}
     * @private
     */
    this._parent = null;

    /**
     * The display object container for this plugin if it is a graphical one.
     * @name FORGE.Plugin#_container
     * @type {?FORGE.DisplayObjectContainer}
     * @private
     */
    this._container = null;

    /**
     * Reference to the plugin object factory, every plugin have its own factory.
     * @name FORGE.Plugin#_create
     * @type {FORGE.PluginObjectFactory}
     * @private
     */
    this._create = null;

    /**
     * Scenes UID array, this plugin is allow to instantiate only on these scene if not null.
     * @name  FORGE.Plugin#_scenes
     * @type {Array<string>}
     * @private
     */
    this._scenes = null;

    /**
     * Object to handle persistent data.
     * @name  FORGE.Plugin#_persistentData
     * @type {Object}
     * @private
     */
    this._persistentData = null;

    /**
     * Is this plugin stay at the scene change event?
     * @name  FORGE.Plugin#_keep
     * @type {boolean}
     * @private
     */
    this._keep = true;

    /**
     * Is this plugin have to reset between each scene?
     * @name  FORGE.Plugin#_reset
     * @type {boolean}
     * @private
     */
    this._reset = true;

    /**
     * Event dispatcher for instance creation
     * @name  FORGE.Plugin#_onInstanceCreate
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onInstanceCreate = null;

     /**
     * Event dispatcher for instance ready
     * @name  FORGE.Plugin#_onInstanceReady
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onInstanceReady = null;

    FORGE.BaseObject.call(this, "Plugin");

    this._boot();
};

FORGE.Plugin.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Plugin.prototype.constructor = FORGE.Plugin;

/**
 * Boot sequence
 * @method  FORGE.Plugin#_boot
 * @private
 */
FORGE.Plugin.prototype._boot = function()
{
    //First thing, very important is to register the plugin object!
    //We can't parse the rest of the config here, maybe the engine is not loaded yet.
    this._uid = this._instanceConfig.uid;
    this._tags = this._instanceConfig.tags;
    this._register();

    this._persistentData = {};
};

/**
 * Internal method to parse the config.
 * @method FORGE.Plugin#_parseConfig
 * @private
 * @param {Object} config - The config object to parse.
 */
FORGE.Plugin.prototype._parseConfig = function(config)
{
    //If there is a parent string in config, this should be an dom element id where to inject the plugin.
    if(typeof config.parent === "string")
    {
        this._parent = config.parent;
    }

    this._keep = (typeof config.keep === "boolean") ? config.keep : true;
    this._reset = (typeof config.reset === "boolean") ? config.reset : true;

    //If there is no scenes array alerady set and if there is a scene array in the instance config.
    if(this._scenes === null && FORGE.Utils.isArrayOf(config.scenes, "string") === true)
    {
        this._scenes = config.scenes;
    }

    this._mergeConfigurations();
};

/**
 * Merge the plugin configurations
 * @method FORGE.Plugin#_mergeConfigurations
 * @private
 */
FORGE.Plugin.prototype._mergeConfigurations = function()
{
    this._config = /** @type {PluginInstanceConfig} */ (FORGE.Utils.extendMultipleObjects(this._engine.defaultConfig, this._instanceConfig, this._contextualConfig));
    this._options = this._config.options || {};
    this._data = this._config.data || {};
    this._actions = this._config.actions || {};

    this._clearEvents();
    this._createEvents(this._config.events);
};

/**
 * Create events dispatchers that the engine needs.
 * @method FORGE.Plugin#_createEvents
 * @private
 * @param {Object=} events - The events config of the plugin engine.
 */
FORGE.Plugin.prototype._createEvents = function(events)
{
    this._events = {};

    var event;
    for(var e in events)
    {
        event = new FORGE.ActionEventDispatcher(this._viewer, e);
        event.addActions(events[e]);
        this._events[e] = event;
    }
};

/**
 * Clear all plugin events.
 * @method FORGE.Plugin#_clearEvents
 * @private
 */
FORGE.Plugin.prototype._clearEvents = function()
{
    for(var e in this._events)
    {
        this._events[e].destroy();
        this._events[e] = null;
    }
};

/**
 * Instantiate the plugin engine if it is loaded, if not listen to the engine load complete to retry to instantiate.
 * @method FORGE.Plugin#instantiate
 */
FORGE.Plugin.prototype.instantiate = function()
{
    if(this._engine.loaded === true)
    {
        this._instantiatePlugin();
    }
    else
    {
        this._engine.onLoadComplete.addOnce(this._engineLoadComplete, this);
    }
};

/**
 * Handler for engine load complete.
 * @method FORGE.Plugin#_engineLoadComplete
 * @private
 */
FORGE.Plugin.prototype._engineLoadComplete = function()
{
    this._instantiatePlugin();
};

/**
 * Parse the config then instantiate the plugin.
 * @method FORGE.Plugin#_instantiatePlugin
 * @private
 */
FORGE.Plugin.prototype._instantiatePlugin = function()
{
    this.log("Plugin._instantiatePlugin(); "+this._uid);

    this._parseConfig(this._instanceConfig);

    this._instance = this._engine.getNewInstance(this._viewer, this);

    this._instance.boot.call(this._instance);

    if(this._onInstanceCreate !== null)
    {
        this._onInstanceCreate.dispatch();
    }
};

/**
 * Instance can notify with this method that the instance is ready
 * @method FORGE.Plugin.notifyInstanceReady
 */
FORGE.Plugin.prototype.notifyInstanceReady = function()
{
    this._instanceReady = true;

    if(this._onInstanceReady !== null)
    {
        this._onInstanceReady.dispatch();
    }
};

/**
 * Update method called by the plugin manager.
 * @method FORGE.Plugin#update
 */
FORGE.Plugin.prototype.update = function()
{
    if(this._instance !== null && typeof this._instance.update === "function")
    {
        this._instance.update.call(this._instance);
    }
};

/**
 * Reset the plugin to a specified configuration.
 * @method FORGE.Plugin#reset
 */
FORGE.Plugin.prototype.resetInstance = function()
{
    this._mergeConfigurations();

    if(this._instance !== null)
    {
        if(typeof this._instance.reset === "function")
        {
            this._instance.reset.call(this._instance);
        }
        else
        {
            this.log("There is no reset function on plugin "+this._engine.uid);
        }
    }
};

/**
 * Destroy method.
 * @method FORGE.Plugin#destroy
 */
FORGE.Plugin.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    if(this._instance !== null)
    {
        this._instance.viewer = null;
        this._instance.plugin = null;

        this._instance.destroy();
        this._instance = null;
    }

    if(this._create !== null)
    {
        this._create.destroy();
        this._create = null;
    }

    if(this._container !== null)
    {
        this._container.destroy();
        this._container = null;
    }

    if(this._onInstanceCreate !== null)
    {
        this._onInstanceCreate.destroy();
        this._onInstanceCreate = null;
    }

    if(this._onInstanceReady !== null)
    {
        this._onInstanceReady.destroy();
        this._onInstanceReady = null;
    }

    this._clearEvents();
    this._events = null;

    this._viewer = null;

    this._persistentData = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the plugin full url.
 * @name FORGE.Plugin#fullUrl
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.Plugin.prototype, "fullUrl",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        return this._engine.fullUrl;
    }
});

/**
 * Get the plugin options.
 * @name FORGE.Plugin#options
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.Plugin.prototype, "options",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        return this._options;
    }
});

/**
 * Get the plugin actions.
 * @name FORGE.Plugin#actions
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.Plugin.prototype, "actions",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        return this._actions;
    }
});

/**
 * Get the plugin events.
 * @name FORGE.Plugin#events
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.Plugin.prototype, "events",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        return this._events;
    }
});

/**
 * Get the scenes array. This plugin will be alive only on these scenes.
 * @name FORGE.Plugin#scenes
 * @readonly
 * @type {Array}
 */
Object.defineProperty(FORGE.Plugin.prototype, "scenes",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        return this._scenes;
    }
});

/**
 * Get and set pesistent data.
 * @name FORGE.Plugin#persistentData
 * @type {Object}
 */
Object.defineProperty(FORGE.Plugin.prototype, "persistentData",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        return this._persistentData;
    },

    /** @this {FORGE.Plugin} */
    set: function(value)
    {
        this._persistentData = value;
    }
});

/**
 * Get the plugin instance.
 * @name FORGE.Plugin#instance
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.Plugin.prototype, "instance",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        return this._instance;
    }
});

/**
 * Get the plugin instance ready flag.
 * @name FORGE.Plugin#instanceReady
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Plugin.prototype, "instanceReady",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        return this._instanceReady;
    }
});

/**
 * Get the plugin container.
 * @name FORGE.Plugin#container
 * @readonly
 * @type {FORGE.DisplayObjectContainer}
 */
Object.defineProperty(FORGE.Plugin.prototype, "container",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        if(this._container === null)
        {
            if(typeof this._parent === "string" && this._parent !== "")
            {
                this._parent = document.getElementById(this._parent);

                if(typeof this._parent === "undefined" || this._parent === null || FORGE.Dom.isHtmlElement(this._parent) === false)
                {
                    throw "FORGE.Plugin.boot : Plugin parent is invalid";
                }

                this._container = new FORGE.DisplayObjectContainer(this._viewer, null, null, this._parent);
            }
            else
            {
                this._container = new FORGE.DisplayObjectContainer(this._viewer);
                this._viewer.pluginContainer.addChild(this._container);
                this._container.maximize(true);
            }

            this._container.id = this._uid;
            this._container.index = this._index;
        }

        return this._container;
    }
});

/**
 * Get the plugin object factory.
 * @name FORGE.Plugin#create
 * @readonly
 * @type {FORGE.PluginObjectFactory}
 */
Object.defineProperty(FORGE.Plugin.prototype, "create",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        if(this._create === null)
        {
            this._create = new FORGE.PluginObjectFactory(this._viewer, this);
        }

        return this._create;
    }
});

/**
 * Get the plugin keep flag.
 * @name FORGE.Plugin#keep
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Plugin.prototype, "keep",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        return this._keep;
    }
});

/**
 * Get the plugin reset flag.
 * @name FORGE.Plugin#reset
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Plugin.prototype, "reset",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        return this._reset;
    }
});

/**
 * Get the contextual config.
 * @name FORGE.Plugin#contextualConfig
 * @type {Object}
 */
Object.defineProperty(FORGE.Plugin.prototype, "contextualConfig",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        return this._contextualConfig;
    },

    /** @this {FORGE.Plugin} */
    set: function(value)
    {
        this._contextualConfig = value;
    }
});

/**
 * Get the instance config.
 * @name FORGE.Plugin#instanceConfig.
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.Plugin.prototype, "instanceConfig",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        return this._instanceConfig;
    }
});

/**
 * Get the final merged config.
 * @name FORGE.Plugin#config
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.Plugin.prototype, "config",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        return this._config;
    }
});


/**
 * Get the "onInstanceCreate" {@link FORGE.EventDispatcher} of the Plugin.
 * @name FORGE.Plugin#onInstanceCreate
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Plugin.prototype, "onInstanceCreate",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        if(this._onInstanceCreate === null)
        {
            this._onInstanceCreate = new FORGE.EventDispatcher(this, true);
        }

        return this._onInstanceCreate;
    }
});

/**
 * Get the "onInstanceReady" {@link FORGE.EventDispatcher} of the Plugin.
 * @name FORGE.Plugin#onInstanceReady
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Plugin.prototype, "onInstanceReady",
{
    /** @this {FORGE.Plugin} */
    get: function()
    {
        if(this._onInstanceReady === null)
        {
            this._onInstanceReady = new FORGE.EventDispatcher(this, true);
        }

        return this._onInstanceReady;
    }
});

/**
 * A plugin Engine handle the javascript files to load, and the constructor.
 *
 * @constructor FORGE.PluginEngine
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 *
 * @todo  In the sources list (in plugin manifest), add possibility to specify type (script or css) for special cases.
 */
FORGE.PluginEngine = function(viewer)
{
    FORGE.BaseObject.call(this, "PluginEngine");

    /**
     * The viewer reference.
     * @name FORGE.PluginEngine#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The config of the plugin engine.
     * @name  FORGE.PluginEngine#_config
     * @type {?PluginEngineConfig}
     * @private
     */
    this._config = null;

    /**
     * The URL prefix for the engine, if not specified, will be the global URL prefix.
     * @name FORGE.PluginEngine#_prefix
     * @type {string}
     * @private
     */
    this._prefix = "";

    /**
     * The url of the plugin engine relative to the prefix location.
     * @name  FORGE.PluginEngine#_url
     * @type {?string}
     * @private
     */
    this._url = "";

    /**
     * The manifest json file name.
     * @name  FORGE.PluginEngine#_manifest
     * @type {string}
     * @private
     */
    this._manifest = "";

    /**
     * The full url of the plugin folder (prefix + url)
     * @name FORGE.PluginEngine#_fullUrl
     * @type {string}
     * @private
     */
    this._fullUrl = "";

    /**
     * The manifest is a json data that describes the plugin engine.
     * @name FORGE.PluginEngine#_manifestData
     * @type {?PluginManifest}
     * @private
     */
    this._manifestData = null;

    /**
     * The name of the plugin engine.
     * @name FORGE.PluginEngine#_name
     * @type {?string}
     * @private
     */
    this._name = "";

    /**
     * The version of the plugin engine.
     * @name FORGE.PluginEngine#_version
     * @type {?string}
     * @private
     */
    this._version = "";

    /**
     * The sources of the plugin engine.
     * @name FORGE.PluginEngine#_sources
     * @type {Array<string>}
     * @private
     */
    this._sources = null;

    /**
     * The name of the constructor of the plugin engine.
     * @name FORGE.PluginEngine#_constructorName
     * @type {string}
     * @private
     */
    this._constructorName = "";

    /**
     * The constructor function reference of the plugin engine.
     * @name  FORGE.PluginEngine#_constructorFunction
     * @type {Function}
     * @private
     */
    this._constructorFunction = null;

    /**
     * i18n configuration.
     * @name FORGE.PluginEngine#_i18n
     * @type {Object}
     * @private
     */
    this._i18n = null;

    /**
     * Object that handles customization options.
     * @name FORGE.PluginEngine#_options
     * @type {Object}
     * @private
     */
    this._options = null;

    /**
     * The events of the engine on which you can bind an action.
     * @name FORGE.PluginEngine#_events
     * @type {Object}
     * @private
     */
    this._events = null;

    /**
     * On a plugin engine, actions is an array of exposed method names.
     * @name FORGE.PluginEngine#_actions
     * @type {Array<Object>}
     * @private
     */
    this._actions = null;

    /**
     * Internal counter for loaded source files.
     * @name FORGE.PluginEngine#_sourcesLoadedCount
     * @type {number}
     * @private
     */
    this._sourcesLoadedCount = 0;

    /**
     * Number of instances that are created from this engine.
     * @name FORGE.PluginEngine#_instanceCount
     * @type {number}
     * @private
     */
    this._instancesCount = 0;

    /**
     * Is this plugin engine is considered as loaded.
     * @name FORGE.PluginEngine#_loaded
     * @type {boolean}
     * @private
     */
    this._loaded = false;

    /**
     * Event dipatcher for load complete.
     * @name FORGE.PluginEngine#_onLoadComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;
};

FORGE.PluginEngine.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.PluginEngine.prototype.constructor = FORGE.PluginEngine;

/**
 * List of required method on a plugn engine.
 * @name FORGE.PluginEngine._REQUIRED
 * @type {Array<string>}
 * @const
 * @private
 */
FORGE.PluginEngine._REQUIRED = ["boot", "destroy"];

/**
 * List of reserved keyword on a plugn engine.
 * @name FORGE.PluginEngine._RESERVED
 * @type {Array<string>}
 * @const
 * @private
 */
FORGE.PluginEngine._RESERVED = ["viewer", "plugin"];

/**
 * Load a configuration for the plugin engine,<br>
 * the config describes the manifest url and the engine identification.
 * @method FORGE.PluginEngine#load
 * @param {PluginEngineConfig} config - The config of the plugin engine.
 * @return {boolean} Returns true if the engine is loaded.
 */
FORGE.PluginEngine.prototype.load = function(config)
{
    if(typeof config !== "undefined")
    {
        this._config = config;

        this._parseConfig(this._config);

        var manifestUrl = this._fullUrl + this._manifest;

        this._loadManifest(manifestUrl);

        return true;
    }

    return false;
};

/**
 * Get a new instance of the engine and associate it to a {@link FORGE.Plugin} Object.
 * @method FORGE.PluginEngine#getNewInstance
 * @param  {FORGE.Viewer} viewer - The viewer attached to this instance.
 * @param  {FORGE.Plugin} plugin - The plugin who will represent this instance.
 * @return {?PluginStructure} Returns the instance of the engine.
 */
FORGE.PluginEngine.prototype.getNewInstance = function(viewer, plugin)
{
    var instance = /** @type {PluginStructure} */ (new this._constructorFunction());

    if(this._validateInstance(instance))
    {
        instance._viewer = viewer;
        instance._plugin = plugin;

        this._instancesCount++;

        return instance;
    }

    return null;
};

/**
 * Parse a plugin engine configuration.
 * @method FORGE.PluginEngine#_parseConfig
 * @param  {PluginEngineConfig} config - The configuration to parse.
 * @private
 */
FORGE.PluginEngine.prototype._parseConfig = function(config)
{
    if(typeof config.uid === "undefined")
    {
        throw "Can't load a plugin engine, missing id in config";
    }

    this._uid = config.uid;
    this._register();

    this._prefix = (typeof config.prefix === "string") ? config.prefix : this._viewer.plugins.prefix;

    if(typeof config.url === "undefined")
    {
        throw "Can't load a plugin engine, missing url in config";
    }
    this._url = config.url;

    this._fullUrl = this._prefix + this._url;

    this._manifest = (typeof config.manifest === "string") ? config.manifest : "manifest.json";
};

/**
 * Internal method to load the engine manifest.
 * @method FORGE.PluginEngine#_loadManifest
 * @param  {string} url - The url of the manifest to load.
 * @private
 */
FORGE.PluginEngine.prototype._loadManifest = function(url)
{
    this._viewer.load.json(this._uid, url, this._manifestLoadComplete, this);
};

/**
 * Handler for the manifest load complete.
 * @method FORGE.PluginEngine#_manifestLoadComplete
 * @private
 * @param  {FORGE.File} file - The  manifest {@link FORGE.File}.
 */
FORGE.PluginEngine.prototype._manifestLoadComplete = function(file)
{
    var json = this._viewer.cache.get(FORGE.Cache.types.JSON, file.key);

    this._manifestData = /** @type {PluginManifest} */ (json.data);
    this._parseManifest(this._manifestData);

    this.log("FORGE.Plugin._manifestLoadComplete();");
};

/**
 * Handler for the manifest load error.
 * @method FORGE.PluginEngine#_manifestLoadError
 * @private
 * @param  {FORGE.File} file - The  manifest {@link FORGE.File}.
 */
FORGE.PluginEngine.prototype._manifestLoadError = function(file)
{
    throw "Can't load the plugin engine manifest "+file.url;
};

/**
 * Internal method to parse the loaded manifest file.
 * @method FORGE.PluginEngine#_parseManifest
 * @private
 * @param  {PluginManifest} manifest - Manifest object to parse.
 * @suppress {checkTypes}
 * @todo  need to change manifest.constructor to another keyword (not reserved)
 */
FORGE.PluginEngine.prototype._parseManifest = function(manifest)
{
    if(this._uid !== manifest.uid)
    {
        throw "Plugin Engine UID doesn't match with manifest UID";
    }

    if(this._versionCheck(manifest.viewer) === false)
    {
        this.warn("Version compatibility check for plugin "+manifest.uid+" failed!");
        this.warn(manifest.viewer);
        return;
    }

    if(FORGE.Device.check(manifest.device) === false)
    {
        this.warn("Device compatibility check for plugin "+manifest.uid+" failed!");
        this.warn(manifest.device);
        return;
    }

    if(typeof manifest.options !== "undefined")
    {
        this._options = manifest.options;
    }

    if(typeof manifest.data !== "undefined")
    {
        this._data = manifest.data;
    }

    if(typeof manifest.actions !== "undefined")
    {
        this._actions = manifest.actions;
    }

    if(typeof manifest.events !== "undefined")
    {
        this._events = manifest.events;
    }

    this._name = manifest.name;
    this._version = manifest.version;
    this._sources = manifest.sources;
    this._constructorName = manifest.constructor;
    this._i18n = this._parseLocales(manifest);

    this._loadSources(this._sources);
};

/**
 * Compare FORGE.VERSION with a minimal and maximal compatibility version.
 * @method FORGE.PluginEngine#_versionCheck
 * @private
 * @param  {Object} config - The viewer version configuration object that contain min and max compatible version of the viewer for the plugin.
 * @return {boolean} Returns true if the plugin is compatible with the current FORGE.VERSION, false if not.
 */
FORGE.PluginEngine.prototype._versionCheck = function(config)
{
    var min = "0.0.0";
    var max = "9.9.9";

    if(typeof config !== "undefined")
    {
        if(typeof config.min !== "undefined")
        {
            min = config.min;
        }

        if(typeof config.max !== "undefined")
        {
            max = config.max;
        }
    }

    var viewerVersion = FORGE.VERSION.split(".");
    var minVersion = min.split(".");
    var maxVersion = max.split(".");
    var maxLength = Math.max(viewerVersion.length, minVersion.length, maxVersion.length);

    var viewerN = 0;
    var minN = 0;
    var maxN = 0;
    var inc = 1;
    for(var i = maxLength - 1; i >= 0; i--)
    {
        if(typeof viewerVersion[i] !== "undefined")
        {
            viewerN += parseInt(viewerVersion[i], 10) * inc;
        }
        if(typeof minVersion[i] !== "undefined")
        {
            minN += parseInt(minVersion[i], 10) * inc;
        }
        if(typeof maxVersion[i] !== "undefined")
        {
            maxN += parseInt(maxVersion[i], 10) * inc;
        }

        inc *= 10;
    }

    if(viewerN < minN || viewerN > maxN)
    {
        return false;
    }

    return true;
};

/**
 * Internal method to load a list of sources files of the engine.
 * @method FORGE.PluginEngine#_loadSources
 * @private
 * @param  {Array<string>} sources - Array of urls of files to load relative sto the base url of the engine.
 */
FORGE.PluginEngine.prototype._loadSources = function(sources)
{
    var sourceUrl;
    for(var i = 0, ii = sources.length; i < ii; i++)
    {
        //If source is an absolute URL
        if(String(sources[i]).substring(0, 7) === "http://" || String(sources[i]).substring(0, 8) === "https://")
        {
            sourceUrl = sources[i];
        }
        // Else it is relative to the plugin folder
        else
        {
            sourceUrl = this._fullUrl + sources[i];
        }

        this._loadSource(sourceUrl);
    }
};

/**
 * Load a single source file file.
 * @method  FORGE.PluginEngine#_loadSource
 * @private
 * @param {string} url - Url of the file to load.
 */
FORGE.PluginEngine.prototype._loadSource = function(url)
{
    var parsedURL = FORGE.URL.parse(url);

    if( parsedURL.extension === "css")
    {
        this._viewer.load.css(url, this._loadSourceComplete, this);
    }
    else
    {
        this._viewer.load.script(url, this._loadSourceComplete, this);
    }
};

/**
 * Handler for the load source complete.
 * @method FORGE.PluginEngine#_loadSourceComplete
 * @private
 */
FORGE.PluginEngine.prototype._loadSourceComplete = function()
{
    this._sourcesLoadedCount++;

    if(this._sourcesLoadedCount === this._sources.length)
    {
        this._constructorFunction = this._parseConstructor(this._constructorName);

        if(this._validateEngine() === true)
        {
            this._addLocales(this._i18n);

            this._loaded = true;

            if(this._onLoadComplete !== null)
            {
                this._onLoadComplete.dispatch();
            }
        }
    }
};

/**
 * Add the locale configuration to the i18n global manager.
 * @method FORGE.PluginEngine#_addlocales
 * @private
 * @param {Object} i18n - The i18n config to add.
 */
FORGE.PluginEngine.prototype._addLocales = function(i18n)
{
    if(i18n !== null)
    {
        this._viewer.i18n.addConfig(i18n);
    }
};

/**
 * For i18n, we check nodes for files and redefine the url for the loading of files<br>
 * with a path relative to the root of the project.
 * @method  FORGE.PluginEngine#_parseLocales
 * @private
 * @param  {Object} manifest - The manifest passed by the main parser.
 * @return {Object} The updated i18n object with paths relative to the project.
 */
FORGE.PluginEngine.prototype._parseLocales = function(manifest)
{
    var i18n = null;

    if(typeof manifest.i18n !== "undefined")
    {
        i18n = manifest.i18n;
        if(typeof i18n.locales !== "undefined")
        {
            var locale;
            for(var i = 0, ii = i18n.locales.length; i < ii; i++)
            {
                locale = i18n.locales[i];
                if(typeof locale.files !== "undefined")
                {
                    var file;
                    for(var j = 0, jj = locale.files.length; j < jj; j++)
                    {
                        file = locale.files[j];
                        file.key = this._uid + "-" + file.key;
                        file.url = this._fullUrl + file.url;
                    }
                }
            }
        }
    }

    return i18n;
};

/**
 * Parse the constructor string.
 * @method FORGE.PluginEngine#_parseConstructor
 * @param {string} constructorName - The constructor name to parse. (ex: "Namespace.PluginConstructor")
 * @return {Function} Return the found constructor function, null if not found
 * @private
 */
FORGE.PluginEngine.prototype._parseConstructor = function(constructorName)
{
    if(typeof constructorName === "string" && constructorName !== "")
    {
        var pathArray = constructorName.split(".");
        var currentObject = window;
        for(var i = 0, ii = pathArray.length; i < ii; i++)
        {
            if(i === pathArray.length - 1 && typeof currentObject[pathArray[i]] === "function")
            {
                return currentObject[pathArray[i]];
            }
            else if(typeof currentObject[pathArray[i]] === "object")
            {
                currentObject = currentObject[pathArray[i]];
            }
            else
            {
                return null;
            }
        }
    }

    return null;
};

/**
 * Internal method to validate the instance.
 * @method FORGE.PluginEngine#_validateEngine
 * @private
 * @return {boolean} Returns true if the engine instance is valid.
 */
FORGE.PluginEngine.prototype._validateEngine = function()
{
    if(this._constructorFunction === null || typeof this._constructorFunction !== "function")
    {
        throw "Plugin engine "+this._uid+" can't find it's constructor";
    }

    for(var i = 0, ii = FORGE.PluginEngine._REQUIRED.length; i < ii; i++)
    {
        if(typeof this._constructorFunction.prototype[FORGE.PluginEngine._REQUIRED[i]] !== "function")
        {
            throw "FORGE.PluginEngine engine validation failed, missing required method "+FORGE.PluginEngine._REQUIRED[i]+" on plugin engine "+this._name;
        }
    }

    //Add a readonly reference of the viewer to the plugin engine instance.
    Object.defineProperty(this._constructorFunction.prototype, "viewer",
    {
        /** @this {FORGE.PluginEngine} */
        get: function()
        {
            return this._viewer;
        }
    });

    //Add a readonly reference of the plugin to the plugin engine instance.
    Object.defineProperty(this._constructorFunction.prototype, "plugin",
    {
        // This annotation is not really true
        /** @this {FORGE.PluginObjectFactory} */
        get: function()
        {
            return this._plugin;
        }
    });

    return true;
};

/**
 * Internal method to validate that the instance do not use one of the reserved keywords.
 * @method FORGE.PluginEngine#_validateReserved
 * @private
 * @param  {Object} instance - The instance to validate.
 * @return {boolean} Returns true if no reserved keywords are in use on the instance.
 */
FORGE.PluginEngine.prototype._validateReserved = function(instance)
{
    for(var i = 0, ii = FORGE.PluginEngine._RESERVED.length; i < ii; i++)
    {
        if(typeof instance[FORGE.PluginEngine._RESERVED[i]] !== "undefined")
        {
            throw "FORGE.PluginEngine instance validation failed, "+FORGE.PluginEngine._RESERVED[i]+" is reserved";
        }
    }

    return true;
};

/**
 * Internal method to validate that the actions listed on the manifest are part of the instance.
 * @method FORGE.PluginEngine#_validateActions
 * @private
 * @param  {Object} instance - The instance to validate.
 * @return {boolean} Returns true if actions are valid on the instance.
 */
FORGE.PluginEngine.prototype._validateActions = function(instance)
{
    if(this._actions === null)
    {
        return true;
    }

    for(var i = 0, ii = this._actions.length; i < ii; i++)
    {
        if(typeof instance[this._actions[i]] !== "function")
        {
            throw "FORGE.PluginEngine instance validation failed, action "+this._actions[i]+" is undefined on plugin "+this._constructorName;
        }
    }

    return true;
};

/**
 * This method validate the instace by testing both reserved keywords and actions.
 * @method FORGE.PluginEngine#_validateEngine
 * @private
 * @param  {Object} instance - The instance to validate.
 * @return {boolean} Returns true if the instance is valid.
 */
FORGE.PluginEngine.prototype._validateInstance = function(instance)
{
    return (this._validateReserved(instance) === true && this._validateActions(instance) === true);
};

/**
 * Destroy method.
 * @method FORGE.PluginEngine#destroy
 */
FORGE.PluginEngine.prototype.destroy = function()
{
    this._viewer = null;
    this._config = null;
    this._manifestData = null;
    this._name = null;
    this._version = null;
    this._sources = null;
    this._constructorFunction = null;
    this._i18n = null;

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the name of this plugin engine.
 * @name FORGE.PluginEngine#name
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.PluginEngine.prototype, "name",
{
    /** @this {FORGE.PluginEngine} */
    get: function()
    {
        return this._name;
    }
});

/**
 * Get the loaded status of this plugin engine.
 * True if the plugin is considered as loaded.
 * @name FORGE.PluginEngine#loaded
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.PluginEngine.prototype, "loaded",
{
    /** @this {FORGE.PluginEngine} */
    get: function()
    {
        return this._loaded;
    }
});

/**
 * Get the base url of the plugin engine.
 * @name FORGE.PluginEngine#url
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.PluginEngine.prototype, "url",
{
    /** @this {FORGE.PluginEngine} */
    get: function()
    {
        return this._url;
    }
});

/**
 * Get the base url of the plugin engine.
 * @name FORGE.PluginEngine#fullUrl
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.PluginEngine.prototype, "fullUrl",
{
    /** @this {FORGE.PluginEngine} */
    get: function()
    {
        return this._fullUrl;
    }
});

/**
 * Get the options of the plugin engine.
 * @name FORGE.PluginEngine#options
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.PluginEngine.prototype, "options",
{
    /** @this {FORGE.PluginEngine} */
    get: function()
    {
        return this._options;
    }
});

/**
 * Get the available actions of the plugin engine.
 * @name FORGE.PluginEngine#actions
 * @readonly
 * @type {Array<String>}
 */
Object.defineProperty(FORGE.PluginEngine.prototype, "actions",
{
    /** @this {FORGE.PluginEngine} */
    get: function()
    {
        return this._actions;
    }
});

/**
 * Get the available events of the plugin engine.
 * @name FORGE.PluginEngine#events
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.PluginEngine.prototype, "events",
{
    /** @this {FORGE.PluginEngine} */
    get: function()
    {
        return this._events;
    }
});

/**
 * Get the default plugin configuration that contains (data + options + actions + events).
 * @name FORGE.PluginEngine#defaultConfig
 * @readonly
 * @type {PluginConfiguration}
 */
Object.defineProperty(FORGE.PluginEngine.prototype, "defaultConfig",
{
    /** @this {FORGE.PluginEngine} */
    get: function()
    {
        /** @type {PluginConfiguration} */
        var config =
        {
            data: /** @type {Object} */ (this._data),
            options: this._options,
            actions: this._actions,
            events: this._events
        };

        return config;
    }
});

/**
 * Get the on load complete {@link FORGE.EventDispatcher} of the plugin engine.
 * @name FORGE.PluginEngine#onLoadComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.PluginEngine.prototype, "onLoadComplete",
{
    /** @this {FORGE.PluginEngine} */
    get: function()
    {
        if(this._onLoadComplete === null)
        {
            this._onLoadComplete = new FORGE.EventDispatcher(this);
        }

        return this._onLoadComplete;
    }
});


/**
 * The FORGE.PluginManager manages {@link FORGE.PluginEngine} and {@link FORGE.Plugin}.
 *
 * @constructor FORGE.PluginManager
 * @param {FORGE.Viewer} viewer - The {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.PluginManager = function(viewer)
{
    FORGE.BaseObject.call(this, "PluginManager");

    /**
     * The viewer reference.
     * @name FORGE.PluginManager#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Config of the plugins
     * @name  FORGE.PluginManager#_config
     * @type {PluginsConfig}
     * @private
     */
    this._config;

    /**
     * Does the plugin manager is enabled ?
     * @name  FORGE.PluginManager#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * Prefix url for the global plugins folder.
     * @name FORGE.PluginManager#_prefix
     * @type {string}
     * @private
     */
    this._prefix = "";

    /**
     * The engines list.
     * @name FORGE.PluginManager#_engines
     * @type {FORGE.Collection<FORGE.PluginEngine>}
     * @private
     */
    this._engines = null;

    /**
     * The plugins list.
     * @name FORGE.PluginManager#_plugins
     * @type {FORGE.Collection<FORGE.Plugin>}
     * @private
     */
    this._plugins = null;

    /**
     * Event dispatcher for instance creation
     * @name  FORGE.PluginManager#_onInstanceCreate
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onInstanceCreate = null;
};

FORGE.PluginManager.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.PluginManager.prototype.constructor = FORGE.PluginManager;

/**
 * Parse the main plugin config.
 * @method FORGE.PluginManager#_parseMainConfig
 * @param {PluginsConfig} config - The configuration of the main plugins node to parse.
 * @private
 */
FORGE.PluginManager.prototype._parseMainConfig = function(config)
{
    this._config = config;

    this._enabled = (typeof config.enabled === "boolean") ? config.enabled : true;
    this._prefix = (typeof config.prefix === "string") ? config.prefix : "./plugins/";
};

/**
 * Parse a plugin config.
 * @method FORGE.PluginManager#_parseConfig
 * @param {PluginsConfig} config - The configuration of the main plugins node to parse.
 * @private
 */
FORGE.PluginManager.prototype._parseConfig = function(config)
{
    this._parseEngines(config.engines);
    this._parseInstances(config.instances);
    this._parseConfigurations(config.configurations);
};


/**
 * Event handler for scene load start.
 * @method FORGE.PluginManager#_sceneLoadStartHandler
 * @private
 */
FORGE.PluginManager.prototype._sceneLoadStartHandler = function()
{
    //Remove plugin that have keep = false and plugin that have scene restrictions.

    this._removeUnkeptPlugins(this._viewer.story.sceneUid);

    //Add plugins =============================================

    if(this._enabled === true && typeof this._config !== "undefined")
    {
        this._parseConfig(this._config);
    }

    if(this._enabled === true && typeof this._viewer.story.scene.config.plugins !== "undefined")
    {
        this._parseConfig(this._viewer.story.scene.config.plugins);
    }

    //Reset plugins ============================================

    this._resetPlugins();
};

/**
 * Remove plugins that have a keep value @ false OR if the plugin have a scene restriction.
 * @method FORGE.PluginManager#_removeUnkeptPlugins
 * @param {string} [sceneUid] The scene uid received on scene load start.
 * @private
 */
FORGE.PluginManager.prototype._removeUnkeptPlugins = function(sceneUid)
{
    var plugin;
    var count = this._plugins.size;

    while(count--)
    {
        plugin = this._plugins.get(count);

        if(plugin.keep === false || (plugin.scenes !== null && plugin.scenes.indexOf(sceneUid) === -1))
        {
            this.remove(plugin.uid);
        }
    }
};

/**
 * This method will reset plugins that have a reset value @ true between each scene.
 * @method  FORGE.PluginManager#_resetPlugins
 * @private
 */
FORGE.PluginManager.prototype._resetPlugins = function()
{
    var plugin;
    var count = this._plugins.size;

    while(count--)
    {
        plugin = this._plugins.get(count);

        if(plugin.reset === true)
        {
            plugin.resetInstance();
        }
    }
};

/**
 * Parse plugins engines in main config.
 * @method FORGE.PluginManager#_parseEngines
 * @param  {Array<PluginEngineConfig>} engines - The engines object to parse.
 * @private
 */
FORGE.PluginManager.prototype._parseEngines = function(engines)
{
    if(typeof engines !== "undefined")
    {
        for(var i = 0, ii = engines.length; i < ii; i++)
        {
            this._addEngine(engines[i]);
        }
    }
};

/**
 * Parse plugins instances in main config.
 * @method FORGE.PluginManager#_parseInstances
 * @param  {Array<PluginInstanceConfig>} instances - The instances object to parse.
 * @private
 */
FORGE.PluginManager.prototype._parseInstances = function(instances)
{
    if(typeof instances !== "undefined")
    {
        for(var i = 0, ii = instances.length; i < ii; i++)
        {
            var instanceUid = instances[i].uid;
            var enabled = (instances[i].enabled !== false) ? true : false;
            var plugin = this.getById(instanceUid);

            var sceneUid = this._viewer.story.sceneUid;
            var scenes = (FORGE.Utils.isArrayOf(instances[i].scenes, "string")) ? instances[i].scenes : [];

            //Scene valid is true if there is no current scene AND there are no scene restriction for the instance,
            //OR if there is a scene restriction and the current scene UID is in the restriction array!
            var sceneValid = Boolean( scenes.length === 0 || (sceneUid === "" && scenes.length === 0) || scenes.indexOf(sceneUid) !== -1 );

            if(enabled === true && plugin === null && sceneValid === true)
            {
                this._addInstance(instances[i]);
            }
        }
    }
};

/**
 * Parse plugins configurations in main config.
 * @method FORGE.PluginManager#_parseConfigurations
 * @param  {Array<PluginConfigurationConfig>} configurations - The configurations object to parse.
 * @private
 */
FORGE.PluginManager.prototype._parseConfigurations = function(configurations)
{
    if(typeof configurations !== "undefined")
    {
        for(var i = 0, ii = configurations.length; i < ii; i++)
        {
            var uid = configurations[i].instance;
            var enabled = (configurations[i].enabled !== false) ? true : false;
            var plugin = this.getById(uid);
            var config = null;

            if(enabled === true)
            {
                config = configurations[i];
            }

            if(plugin !== null)
            {
                plugin.contextualConfig = config;
            }
        }
    }
};

/**
 * Add an engine.
 * @method FORGE.PluginManager#_addEngine
 * @param {PluginEngineConfig} config - The config to parse.
 * @private
 */
FORGE.PluginManager.prototype._addEngine = function(config)
{
    if(typeof config.uid === "string")
    {
        if(this._getEngine(config.uid) !== null)
        {
            return;
        }

        if(FORGE.UID.exists(config.uid) === false)
        {
            var engine = new FORGE.PluginEngine(this._viewer);
            this._engines.add(engine);

            engine.load(config);
        }
        else
        {
            // In some multiple viewer instance case the engine already exists, just get it from the UID
            this._engines.add(FORGE.UID.get(config.uid));
        }
    }
};

/**
 * Get an engine.
 * @method FORGE.PluginManager#_getEngine
 * @param {string} uid - The uid to search for.
 * @return {?FORGE.PluginEngine} Returns the engine.
 * @private
 */
FORGE.PluginManager.prototype._getEngine = function(uid)
{
    var engine = null;
    for(var i = 0, ii = this._engines.size; i < ii; i++)
    {
        engine = /** @type {FORGE.PluginEngine} */ (this._engines.get(i));

        if(engine.uid === uid)
        {
            return engine;
        }
    }

    return null;
};

/**
 * Add a plugin instance.
 * @method FORGE.PluginManager#_addInstance
 * @param {PluginInstanceConfig} config - The config to parse.
 * @private
 * @return {FORGE.Plugin} The created plugin object.
 */
FORGE.PluginManager.prototype._addInstance = function(config)
{
    if(typeof config.engine === "undefined")
    {
        throw "Can't create plugin instance, engineUid is undefined";
    }

    var engine = this._getEngine(config.engine);

    if(engine === null)
    {
        throw "Plugin Engine "+config.engine+" doesn't exist";
    }

    var index = typeof config.index === "number" ? config.index : this._plugins.size;

    var plugin = new FORGE.Plugin(this._viewer, engine, config, index);
    plugin.onInstanceCreate.addOnce(this._onInstanceCreateHandler, this);
    this._plugins.add(plugin);

    plugin.instantiate();

    return plugin;
};

/**
 * Instance create handler, wil lredispatch from the plugin manager
 * @method FORGE.PluginManager#_onInstanceCreateHandler
 * @param {FORGE.Event} event
 * @private
 */
FORGE.PluginManager.prototype._onInstanceCreateHandler = function(event)
{
    var plugin = event.emitter;

    if(this._onInstanceCreate !== null)
    {
        this._onInstanceCreate.dispatch(plugin);
    }
};

/**
 * Boot sequence.
 * @method FORGE.PluginManager#_boot
 * @private
 */
FORGE.PluginManager.prototype.boot = function()
{
    this._engines = new FORGE.Collection();

    this._plugins = new FORGE.Collection();

    this._viewer.story.onSceneLoadStart.add(this._sceneLoadStartHandler, this);
};

/**
 * Add plugins configuration.
 * @method FORGE.PluginManager#addConfig
 * @param {PluginsConfig} config - The config to add
 */
FORGE.PluginManager.prototype.addConfig = function(config)
{
    this._parseMainConfig(config);
};

/**
 * Get a plugin instance by uid.
 * @method FORGE.PluginManager#getById
 * @param {string} uid - The uid to search for.
 * @return {FORGE.Plugin} Returns the plugin.
 */
FORGE.PluginManager.prototype.getById = function(uid)
{
    var plugin;
    for(var i = 0, ii = this._plugins.size; i < ii; i++)
    {
        plugin = /** @type {FORGE.Plugin} */ (this._plugins.get(i));

        if(plugin.uid === uid)
        {
            return plugin;
        }
    }

    return null;
};

/**
 * Get a plugin instance by index.
 * @method FORGE.PluginManager#getByIndex
 * @param {number} index - The index to search for.
 * @return {FORGE.Plugin} Returns the plugin.
 */
FORGE.PluginManager.prototype.getByIndex = function(index)
{
    var plugin = /** @type {FORGE.Plugin} */ (this._plugins.get(index));

    if(typeof plugin !== "undefined")
    {
        return plugin;
    }
    else
    {
        return null;
    }
};

/**
 * Get a plugin instance by value.
 * @method FORGE.PluginManager#get
 * @param {number|string} value - The index or uid to search for.
 * @return {FORGE.Plugin} Returns the plugin.
 */
FORGE.PluginManager.prototype.get = function(value)
{
    var plugin = null;

    if(typeof value === "string")
    {
        plugin = this.getById(value);
    }
    else if(typeof value === "number")
    {
        plugin = this.getByIndex(value);
    }

    return plugin;
};

/**
 * Remove a plugin instance.
 * @method FORGE.PluginManager#remove
 * @param {string} uid - The uid to search for.
 */
FORGE.PluginManager.prototype.remove = function(uid)
{
    var plugin = this.get(uid);

    plugin.destroy();

    this._plugins.remove(plugin);
};

/**
 * Update main loop for plugins.
 * @method FORGE.PluginManager#update
 */
FORGE.PluginManager.prototype.update = function()
{
    var plugin;
    for(var i = 0, ii = this._plugins.size; i < ii; i++)
    {
        plugin = this._plugins.get(i);
        plugin.update();
    }
};

/**
 * Render main loop for plugins.
 * @method FORGE.PluginManager#render
 */
FORGE.PluginManager.prototype.render = function()
{

};

/**
 * Destroy method.
 * @method FORGE.PluginManager#destroy
 */
FORGE.PluginManager.prototype.destroy = function()
{

    this._viewer = null;

    if(this._onInstanceCreate !== null)
    {
        this._onInstanceCreate.destroy();
        this._onInstanceCreate = null;
    }

    for(var i = 0, ii = this._engines.size; i < ii; i++)
    {
        this._engines.get(i).destroy();
    }
    this._engines = null;

    for(var j = 0, jj = this._plugins.size; j < jj; j++)
    {
        this._plugins.get(j).destroy();
    }
    this._plugins = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
* Get the all plugins.
* @name FORGE.PluginManager#all
* @type {Array<FORGE.Plugin>}
* @readonly
*/
Object.defineProperty(FORGE.PluginManager.prototype, "all",
{
    /** @this {FORGE.PluginManager} */
    get: function()
    {
        return this._plugins;
    }
});

/**
* Get the enabled flag of plugins.
* @name FORGE.PluginManager#enabled
* @type {boolean}
* @readonly
*/
Object.defineProperty(FORGE.PluginManager.prototype, "enabled",
{
    /** @this {FORGE.PluginManager} */
    get: function()
    {
        return this._enabled;
    }
});

/**
* Get the global prefix of plugins engines.
* @name FORGE.PluginManager#prefix
* @type {string}
* @readonly
*/
Object.defineProperty(FORGE.PluginManager.prototype, "prefix",
{
    /** @this {FORGE.PluginManager} */
    get: function()
    {
        return this._prefix;
    }
});

/**
 * Get the "onInstanceCreate" {@link FORGE.EventDispatcher} of the PluginManager.
 * @name FORGE.PluginManager#onInstanceCreate
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.PluginManager.prototype, "onInstanceCreate",
{
    /** @this {FORGE.PluginManager} */
    get: function()
    {
        if(this._onInstanceCreate === null)
        {
            this._onInstanceCreate = new FORGE.EventDispatcher(this, true);
        }

        return this._onInstanceCreate;
    }
});




/**
 * Factory helper to create object inside plugins.<br>
 * The factory knows what objects are created for a plugin, so it can destroy all object of the plugin at plugin destroy.
 *
 * @constructor FORGE.PluginObjectFactory
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {FORGE.Plugin} plugin - The {@link FORGE.Plugin} that will use this factory.
 * @extends {FORGE.BaseObject}
 *
 * @todo add the file key restriction for i18n stuff
 */
FORGE.PluginObjectFactory = function(viewer, plugin)
{
    /**
     * The viewer reference.
     * @name FORGE.PluginEngine#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The plugin reference.
     * @name FORGE.PluginEngine#_plugin
     * @type {FORGE.Plugin}
     * @private
     */
    this._plugin = plugin;

    /**
     * The type of object list.
     * @name FORGE.PluginEngine#_objects
     * @type {Array<Object>}
     * @private
     */
    this._objects = [];

    FORGE.BaseObject.call(this, "PluginObjectFactory");
};

FORGE.PluginObjectFactory.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.PluginObjectFactory.prototype.constructor = FORGE.PluginObjectFactory;

/**
 * Search for an object into the list.
 * @method FORGE.PluginObjectFactory#_indexOfObject
 * @param  {Object} obj - The object to look for.
 * @return {number} Returns the index of the object found, if not, returns -1.
 * @private
 */
FORGE.PluginObjectFactory.prototype._indexOfObject = function(obj)
{
    var n = this._objects.length;
    var o;

    while(n--)
    {
        o = this._objects[n];

        if(o === obj)
        {
            return n;
        }
    }

    return -1;
};

/**
 * Internal handler on object destroy.
 * @method FORGE.PluginObjectFactory#_destroyObjectHandler
 * @param  {FORGE.Event} event - The event.
 * @private
 */
FORGE.PluginObjectFactory.prototype._destroyObjectHandler = function(event)
{
    var o = event.emitter;
    var i = this._indexOfObject(o);
    this._objects.splice(i, 1);
};

/**
 * Add a {@link FORGE.LocaleString}.
 * @method FORGE.PluginObjectFactory#string
 * @param  {string} key - Object key.
 * @return {FORGE.LocaleString} Returns the created FORGE.LocaleString.
 */
FORGE.PluginObjectFactory.prototype.string = function(key)
{
    var str = new FORGE.LocaleString(this._viewer, key);
    str.onDestroy.addOnce(this._destroyObjectHandler, this);

    this._objects.push(str);
    return str;
};

/**
 * Add a {@link FORGE.Textfield}.
 * @method FORGE.PluginObjectFactory#textField
 * @param  {(string|TextFieldConfig)} config - Object configuration.
 * @return {FORGE.TextField} Returns the created FORGE.Textfield.
 */
FORGE.PluginObjectFactory.prototype.textField = function(config)
{
    var textField = new FORGE.TextField(this._viewer, config);
    textField.onDestroy.addOnce(this._destroyObjectHandler, this);

    this._objects.push(textField);
    return textField;
};

/**
 * Add a {@link FORGE.Sound}.
 * @method FORGE.PluginObjectFactory#sound
 * @param {string} key - Object key.
 * @param {string} url - The sound url.
 * @return {FORGE.Sound} Returns the created FORGE.Sound.
 */
FORGE.PluginObjectFactory.prototype.sound = function(key, url)
{
    var sound = new FORGE.Sound(this._viewer, key, url);
    sound.onDestroy.addOnce(this._destroyObjectHandler, this);

    this._objects.push(sound);
    return sound;
};

/**
 * Add a {@link FORGE.DisplayObjectContainer}.
 * @method FORGE.PluginObjectFactory#displayObjectContainer
 * @param  {Element|HTMLElement} dom - Dom object.
 * @return {FORGE.DisplayObjectContainer} Returns the created FORGE.DisplayObjectContainer.
 */
FORGE.PluginObjectFactory.prototype.displayObjectContainer = function(dom)
{
    var displayObjectContainer = new FORGE.DisplayObjectContainer(this._viewer, dom);
    displayObjectContainer.onDestroy.addOnce(this._destroyObjectHandler, this);

    this._objects.push(displayObjectContainer);
    return displayObjectContainer;
};

/**
 * Add a {@link FORGE.DisplayObject}.
 * @method FORGE.PluginObjectFactory#displayObject
 * @param  {Element|HTMLElement} dom - Dom object.
 * @return {FORGE.DisplayObject} Returns the created FORGE.DisplayObject.
 */
FORGE.PluginObjectFactory.prototype.displayObject = function(dom)
{
    var displayObject = new FORGE.DisplayObject(this._viewer, dom);
    displayObject.onDestroy.addOnce(this._destroyObjectHandler, this);

    this._objects.push(displayObject);
    return displayObject;
};

/**
 * Add a {@link FORGE.Image}.
 * @method FORGE.PluginObjectFactory#image
 * @param  {string|Object} config - URL of the image or an image configuration object.
 * @param  {boolean} relativeToPluginPath
 * @return {FORGE.Image} Returns the created FORGE.Image.
 */
FORGE.PluginObjectFactory.prototype.image = function(config, relativeToPluginPath)
{
    var c = config;

    if(typeof config === "string")
    {
        c = {"key": null, "url": config};
    }

    c.key = this._plugin.uid + "-" + c.key;

    if(relativeToPluginPath !== false)
    {
        c.url = this._plugin.fullUrl + c.url;
    }

    var img = new FORGE.Image(this._viewer, c);
    img.onDestroy.addOnce(this._destroyObjectHandler, this);

    this._objects.push(img);
    return img;
};

/**
 * Add a {@link FORGE.Sprite}.
 * @method FORGE.PluginObjectFactory#sprite
 * @param  {Object} config - Sprite configuration object.
 * @param  {boolean} relativeToPluginPath
 * @return {FORGE.Image} Returns the created FORGE.Sprite.
 */
FORGE.PluginObjectFactory.prototype.sprite = function(config, relativeToPluginPath)
{
    var c = config;

    c.key = this._plugin.uid + "-" + c.key;

    if(relativeToPluginPath !== false)
    {
        c.url = this._plugin.fullUrl + c.url;
        c.frames = this._plugin.fullUrl + c.frames;
    }

    var sprite = new FORGE.Sprite(this._viewer, c);
    sprite.onDestroy.addOnce(this._destroyObjectHandler, this);

    this._objects.push(sprite);
    return sprite;
};

/**
 * Add a {@link FORGE.Button}.
 * @method FORGE.PluginObjectFactory#button
 * @param  {ButtonConfig} config - The button configuration object.
 * @return {FORGE.Button} Returns the created FORGE.Button.
 */
FORGE.PluginObjectFactory.prototype.button = function(config)
{
    var button = new FORGE.Button(this._viewer, config);
    button.onDestroy.addOnce(this._destroyObjectHandler, this);

    this._objects.push(button);
    return button;
};

/**
 * Add a {@link FORGE.Video}.
 * @method FORGE.PluginObjectFactory#video
 * @param {string} key - The video Id reference.
 * @param {?(string|FORGE.VideoQuality|Array<(FORGE.VideoQuality|string)>)=} config - The video configuration object
 * @param {string=} streaming - The video streaming format. Can be "HTML5" or "DASH".
 * @param {string=} qualityMode - The video quality mode. Can be "auto" or "manual".
 * @param {boolean=} ambisonic - 3D sound including ambisonics. For "HTML5" video only.
 * @return {(FORGE.VideoHTML5|FORGE.VideoDash)} Returns the created FORGE.Video object.
 */
FORGE.PluginObjectFactory.prototype.video = function(key, config, streaming, qualityMode, ambisonic)
{
    var video;

    if(typeof streaming !== "undefined" && streaming.toLowerCase() === FORGE.VideoFormat.DASH)
    {
        video = new FORGE.VideoDash(this._viewer, key, config, qualityMode);
    }
    else
    {
        video = new FORGE.VideoHTML5(this._viewer, key, config, qualityMode, ambisonic);
    }

    video.onDestroy.addOnce(this._destroyObjectHandler, this);

    this._objects.push(video);
    return video;
};

/**
 * Add a {@link FORGE.Canvas}.
 * @method FORGE.PluginObjectFactory#canvas
 * @return {FORGE.Canvas} Returns the created FORGE.Canvas.
 */
FORGE.PluginObjectFactory.prototype.canvas = function()
{
    var canvas = new FORGE.Canvas(this._viewer);
    canvas.onDestroy.addOnce(this._destroyObjectHandler, this);

    this._objects.push(canvas);
    return canvas;
};

/**
 * Add a {@link FORGE.Tween}.
 * @method FORGE.PluginObjectFactory#tween
 * @param {Object} object
 * @return {FORGE.Tween} Returns the created FORGE.Tween.
 */
FORGE.PluginObjectFactory.prototype.tween = function(object)
{
    var tween = new FORGE.Tween(this._viewer, object);
    tween.onDestroy.addOnce(this._destroyObjectHandler, this);
    this._viewer.tween.add(tween);

    this._objects.push(tween);
    return tween;
};

/**
 * Destroy all objects.
 * @method FORGE.PluginObjectFactory#destroyAllObjects
 */
FORGE.PluginObjectFactory.prototype.destroyAllObjects = function()
{
    this.log("destroyAllObjects();");

    var n = this._objects.length;

    while(n--)
    {
        this._objects[n].destroy();
    }
};

/**
 * Destroy method.
 * @method FORGE.PluginObjectFactory#destroy
 */
FORGE.PluginObjectFactory.prototype.destroy = function()
{
    this.destroyAllObjects();

    this._viewer = null;
    this._plugin = null;
    this._objects = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Manage Devices inside FORGE.<br>
 * Device is singleton, so if you have multiple instances in the same page you MUST avoid UID conflict.
 * @constructor
 * @extends {FORGE.BaseObject}
 */
FORGE.Device = (function(c)
 {
    var Tmp = c();
    Tmp.prototype = Object.create(FORGE.BaseObject.prototype);
    Tmp.prototype.constructor = Tmp;

    /**
     * Check which OS is running.
     * @method FORGE.Device#_checkOS
     * @suppress {checkRegExp}
     * @private
     */
    Tmp.prototype._checkOS = function()
    {
        if (/Playstation Vita/.test(this._ua))
        {
            this._os = "playstationvita";
            this._vita = true;
        }
        else if (/Xbox/.test(this._ua))
        {
            this._os = "xbox";
            this._xbox = true;
        }
        else if (/Kindle/.test(this._ua) || /\bKF[A-Z][A-Z]+/.test(this._ua) || /Silk.*Mobile Safari/.test(this._ua))
        {
            this._os = "kindle";
            this._kindle = true;
        }
        else if ((/Windows Phone/i).test(this._ua) || (/IEMobile/i).test(this._ua))
        {
            this._os = "windowsphone";
            this._windowsPhone = true;
            if (/Windows Phone (\d+)/.test(this._ua))
            {
                this._osVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (/Android/.test(this._ua))
        {
            this._os = "android";
            this._android = true;
            if (/Android ([\.\_\d]+)/.test(this._ua))
            {
                this._osVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (/CrOS/.test(this._ua))
        {
            this._os = "chromeos";
            this._chromeOS = true;
        }
        else if (/iP[ao]d|iPhone/i.test(this._ua))
        {
            this._os = "ios";
            this._iOS = true;
            if (/OS (\d+)/.test(navigator.appVersion))
            {
                this._osVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (/(Linux|X11)/.test(this._ua))
        {
            this._os = "linux";
            this._linux = true;
        }
        else if (/Mac OS X/.test(this._ua))
        {
            this._os = "macosx";
            this._macOS = true;
            if (/Mac OS X (10[\.\_\d]+)/.test(this._ua))
            {
                this._osVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (/Windows/.test(this._ua) || (/WPDesktop/i).test(this._ua))
        {
            if ((/WPDesktop/i).test(this._ua))
            {
                this._os = "windowsphone";
                this._windowsPhone = true;
            }
            else
            {
                this._os = "windows";
                this._windows = true;
            }
            if (/(Windows 10.0|Windows NT 10.0)/.test(this._ua))
            {
                this._osVersion = 10;
            }
            else if (/(Windows 8.1|Windows NT 6.3)/.test(this._ua) || /(Windows 8|Windows NT 6.2)/.test(this._ua))
            {
                this._osVersion = 8;
            }
            else if (/(Windows 7|Windows NT 6.1)/.test(this._ua))
            {
                this._osVersion = 7;
            }
        }
    };

    /**
     * Check which browser is running.
     * @method FORGE.Device#_checkBrowsers
     * @suppress {checkRegExp}
     * @private
     */
    Tmp.prototype._checkBrowsers = function()
    {
        this._ie = /** @type {boolean} */ (/*@cc_on!@*/ false || typeof document["documentMode"] !== "undefined");
        this._edge = this._ie === false && Boolean(window["StyleMedia"]) === true;
        this._firefox = typeof window["InstallTrigger"] !== "undefined";
        this._opera = Boolean(window["opr"]) === true || this._ua.indexOf(" OPR/") >= 0 || this._ua.indexOf("Opera") >= 0;
        this._safari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        this._chrome = this._ie === false && this._edge === false && this._opera === false && (Boolean(window["chrome"]) === true || this._ua.indexOf("CriOS") >= 0);

        if (this._edge)
        {
            this._browser = "edge";
            if (/Edge\/(\d+)/.test(this._ua))
            {
                this._browserVersion = this._edgeVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (this._chrome)
        {
            this._browser = "chrome";
            if (/CriOS\/(\d+)/.test(this._ua))
            {
                this._browserVersion = this._chromeVersion = parseInt(RegExp.$1, 10);
            }
            else if (/Chrome\/(\d+)/.test(this._ua))
            {
                this._browserVersion = this._chromeVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (this._firefox)
        {
            this._browser = "firefox";
            if (/Firefox\D+(\d+)/.test(this._ua))
            {
                this._browserVersion = this._firefoxVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (this._kindle)
        {
            // Silk gets its own if clause because its ua also contains 'Safari'
            if (/Silk/.test(this._ua))
            {
                this._browser = "silk";
                this._silk = true;
            }
        }
        else if (this._ie)
        {
            this._browser = "internetexplorer";
            if (/MSIE (\d+\.\d+);/.test(this._ua))
            {
                this._browserVersion = this._ieVersion = parseInt(RegExp.$1, 10);
            }
            else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(this._ua))
            {
                this._browserVersion = this._ieVersion = parseInt(RegExp.$3, 10);
            }
        }
        else if (this._opera)
        {
            this._browser = "opera";
            if (/OPR\/(\d+)/.test(this._ua))
            {
                this._browserVersion = this._operaVersion = parseInt(RegExp.$1, 10);
            }
            else if (this._ua.indexOf("Opera/") >= 0)
            {
                if (/Version\/(\d+)/.test(this._ua))
                {
                    this._browserVersion = this._operaVersion = parseInt(RegExp.$1, 10);
                }
            }
            else if (/Opera (\d+)/.test(this._ua))
            {
                this._browserVersion = this._operaVersion = parseInt(RegExp.$1, 10);
            }
        }
        else if (this._safari)
        {
            this._browser = "safari";
            if ((/version\/(\d+(\.\d+)?)/i).test(this._ua))
            {
                this._browserVersion = this._safariVersion = parseInt(RegExp.$1, 10);
            }
        }
        else
        {
            var matches = this._ua.match(/Android.*AppleWebKit\/([\d.]+)/);
            if (matches && matches[1] < 537)
            {
                this._browser = "androidstock";
                this._isAndroidStockBrowser = true;
                this._browserVersion = this._androidStockBrowserVersion = parseFloat(this._ua.slice(this._ua.indexOf("Android") + 8));
            }
        }
        //  WebApp mode
        if (navigator.standalone)
        {
            this._webApp = true;
        }

        this._quirksMode = (document.compatMode === "CSS1Compat") ? false : true;
    };

    /**
     * Check the device informations.
     * @method FORGE.Device#_checkDevice
     * @private
     */
    Tmp.prototype._checkDevice = function()
    {
        this._pixelRatio = window.devicePixelRatio || 1;

        this._iPhone = this._iOS === true && this._ua.toLowerCase().indexOf("iphone") !== -1;
        this._iPod = this._iOS === true && this._ua.toLowerCase().indexOf("ipod") !== -1;
        this._iPad = this._iOS === true && this._ua.toLowerCase().indexOf("ipad") !== -1;
        this._retina = this._pixelRatio >= 2 && this._iOS === true;

        if ((this._windows && !this._windowsPhone) || this._macOS || (this._linux && !this._silk) || this._chromeOS)
        {
            this._desktop = true;
        }
        else if (/Mobi/i.test(this._ua) && this._iPad === false)
        {
            this._mobile = true;
        }
        else
        {
            this._tablet = true;
        }

        //smart TV, Playstation, Table Windows
        if (/TV/i.test(this._ua) || this._vita === true || this._xbox === true || (this._desktop && /Windows NT/i.test(this._ua) && /Touch/i.test(this._ua)))
        {
            this._other = true;
            this._mobile = false;
            this._tablet = false;
            this._desktop = false;
        }
    };

    /**
     * Check video support.
     * @method FORGE.Device#_checkVideo
     * @private
     */
    Tmp.prototype._checkVideo = function()
    {
        var videoElement = document.createElement("video");

        try
        {
            if (typeof videoElement.canPlayType === "function")
            {
                if (videoElement.canPlayType("video/ogg; codecs=\"theora\"").replace(/^no$/, ""))
                {
                    this._oggVideo = true;
                }

                if (videoElement.canPlayType("video/mp4; codecs=\"avc1.42E01E\"").replace(/^no$/, ""))
                {
                    // without QuickTime, this value will be "undefined"
                    this._h264Video = true;
                    this._mp4Video = true;
                }

                if (videoElement.canPlayType("video/webm; codecs=\"vp8, vorbis\"").replace(/^no$/, ""))
                {
                    this._webmVideo = true;
                }

                if (videoElement.canPlayType("video/webm; codecs=\"vp9\"").replace(/^no$/, ""))
                {
                    this._vp9Video = true;
                }

                if (videoElement.canPlayType("application/x-mpegURL; codecs=\"avc1.42E01E\"").replace(/^no$/, ""))
                {
                    this._hlsVideo = true;
                }
            }
        }
        catch (e)
        {}
    };

    /**
     * Check audio support.
     * @method FORGE.Device#_checkAudio
     * @private
     */
    Tmp.prototype._checkAudio = function()
    {
        this._audioTag = (typeof window.Audio !== "undefined");
        this._webAudio = (typeof window.AudioContext !== "undefined" || typeof window.webkitAudioContext !== "undefined");

        var audioElement = document.createElement("audio");

        try
        {
            if (typeof audioElement.canPlayType === "function")
            {
                if (audioElement.canPlayType("audio/ogg; codecs=\"vorbis\"").replace(/^no$/, ""))
                {
                    this._ogg = true;
                }

                if (audioElement.canPlayType("audio/mpeg;").replace(/^no$/, ""))
                {
                    this._mp3 = true;
                }

                if (audioElement.canPlayType("audio/ogg; codecs=\"opus\"").replace(/^no$/, "") || audioElement.canPlayType("audio/opus;").replace(/^no$/, ""))
                {
                    this._opus = true;
                }

                if (audioElement.canPlayType("audio/wav; codecs=\"1\"").replace(/^no$/, ""))
                {
                    this._wav = true;
                }

                if (audioElement.canPlayType("audio/aac;").replace(/^no$/, ""))
                {
                    this._aac = true;
                }

                if (audioElement.canPlayType("audio/x-m4a;") || audioElement.canPlayType("audio/m4a;") || audioElement.canPlayType("audio/aac;").replace(/^no$/, ""))
                {
                    this._m4a = true;
                }

                if (audioElement.canPlayType("audio/x-mp4;") || audioElement.canPlayType("audio/mp4;") || audioElement.canPlayType("audio/aac;").replace(/^no$/, ""))
                {
                    this._mp4 = true;
                }

                if (audioElement.canPlayType("audio/webm; codecs=\"vorbis\"").replace(/^no$/, ""))
                {
                    this._webm = true;
                    this._weba = true;
                }

            }
        }
        catch (e)
        {}
    };

    /**
     * Check the device features.
     * @method FORGE.Device#_checkDeviceFeatures
     * @private
     */
    Tmp.prototype._checkDeviceFeatures = function()
    {
        this._vibrate = (typeof navigator.vibrate !== "undefined" || typeof navigator.webkitVibrate !== "undefined" || typeof navigator.mozVibrate !== "undefined" || typeof navigator.msVibrate !== "undefined");

        this._battery = (typeof navigator.getBattery === "function");
    };

    /**
     * Check HTML5 features.
     * @method FORGE.Device#_checkFeatures
     * @private
     */
    Tmp.prototype._checkFeatures = function()
    {
        this._canvas = (typeof window.CanvasRenderingContext2D !== "undefined");
        if (this._canvas === true)
        {
            this._canvasText = (typeof document.createElement("canvas").getContext("2d").fillText === "function");
            var canvasCtx = document.createElement("canvas").getContext("2d");
            canvasCtx.rect(0, 0, 10, 10);
            canvasCtx.rect(2, 2, 6, 6);
            this._canvasWinding = (canvasCtx.isPointInPath(5, 5, "evenodd") === false);
        }

        try
        {
            this._localStorage = (typeof window.localStorage === "object" && typeof window.localStorage.getItem === "function");
        }
        catch (error)
        {
            this._localStorage = false;
        }

        this._mediaSource = (typeof window.MediaSource === "function");

        this._encryptedMedia = (typeof window.HTMLMediaElement === "function" && typeof window.MediaKeys === "function" && typeof window.MediaKeySystemAccess === "function" && typeof navigator.requestMediaKeySystemAccess === "function");

        this._applicationCache = (typeof window.applicationCache === "object");

        this._addEventListener = (typeof window.addEventListener === "function");

        this.__raf = (typeof window.requestAnimationFrame === "function" || typeof window.webkitRequestAnimationFrame === "function" || typeof window.mozRequestAnimationFrame === "function");

        try
        {
            var canvas = document.createElement("canvas");
            /* Force screencanvas to false */
            canvas.screencanvas = false;
            this._webGL = (typeof canvas.getContext === "function" && typeof window.WebGLRenderingContext !== "undefined" && Boolean(canvas.getContext("webgl") || canvas.getContext("experimental-webgl")));
        }
        catch (e)
        {
            this._webGL = false;
        }

        if (typeof navigator.getVRDisplays === "function")
        {
            this._webVR = true;
        }
        else
        {
            this._webVR = false;
        }

        this._JSON = (typeof window.JSON === "object" && typeof window.JSON.parse === "function" && typeof window.JSON.stringify === "function");

        this._geolocation = (typeof navigator.geolocation === "object");

        this._history = (typeof window.history === "object" && typeof window.history.pushState === "function");

        this._svg = (typeof document.createElementNS === "function" && typeof document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect === "function");

        this._contextMenu = (typeof document.documentElement.contextMenu !== "undefined" && typeof window.HTMLMenuItemElement === "function");
    };

    /**
     * Check the URL environment.
     * @method FORGE.Device#_checkEnvironment
     * @private
     */
    Tmp.prototype._checkEnvironment = function()
    {
        this._isSecure = /^https/i.test(window.location.protocol);

        try
        {
            this._isIframe = (window.self !== window.top);
        }
        catch (e)
        {
            this._isIframe = true;
        }
    };

    /**
     * Check the various inputs.
     * @method FORGE.Device#_checkInput
     * @private
     */
    Tmp.prototype._checkInput = function()
    {
        this._touch = (typeof window.ontouchstart !== "undefined" || typeof window.DocumentTouch !== "undefined" && document instanceof window.DocumentTouch || (typeof navigator.maxTouchPoints === "number" && navigator.maxTouchPoints > 0) || (typeof navigator.msMaxTouchPoints === "number" && navigator.msMaxTouchPoints > 0));

        // Test for Safari iOS touch force feature
        if (typeof window.onmouseforcewillbegin !== "undefined" || typeof window.onwebkitmouseforcewillbegin !== "undefined")
        {
            // Test if the browser provides thresholds defining a "force touch" from a normal touch/click event
            this._touchForce = Boolean(MouseEvent.WEBKIT_FORCE_AT_MOUSE_DOWN && MouseEvent.WEBKIT_FORCE_AT_FORCE_MOUSE_DOWN);
        }

        this._gamepad = (typeof navigator.getGamepads === "function" || typeof navigator.webkitGetGamepads === "function");
    };

    /**
     * Check the support of the full screen API.
     * @method FORGE.Device#_checkFullscreenSupport
     * @private
     */
    Tmp.prototype._checkFullscreenSupport = function()
    {
        var requestFullscreen =
            [
                "requestFullscreen",
                "requestFullScreen",
                "webkitRequestFullscreen",
                "webkitRequestFullScreen",
                "mozRequestFullScreen",
                "mozRequestFullscreen",
                "msRequestFullscreen",
                "msRequestFullScreen"
            ];
        var exitFullscreen =
            [
                "cancelFullscreen",
                "cancelFullScreen",
                "exitFullscreen",
                "exitFullScreen",
                "webkitCancelFullscreen",
                "webkitCancelFullScreen",
                "webkitExitFullscreen",
                "webkitExitFullScreen",
                "mozCancelFullscreen",
                "mozCancelFullScreen",
                "mozExitFullscreen",
                "mozExitFullScreen",
                "msCancelFullscreen",
                "msCancelFullScreen",
                "msExitFullscreen",
                "msExitFullScreen"
            ];

        var element = document.createElement("div");

        for (var i = 0, ii = requestFullscreen.length; i < ii; i++)
        {
            if (element[requestFullscreen[i]])
            {
                this._requestFullscreen = requestFullscreen[i];
                break;
            }
        }
        for (var j = 0, jj = exitFullscreen.length; j < jj; j++)
        {
            if (document[exitFullscreen[j]])
            {
                this._exitFullscreen = exitFullscreen[j];
                break;
            }
        }

        // Keyboard Input on full screen mode?
        if (typeof window.Element === "function" && Element.ALLOW_KEYBOARD_INPUT)
        {
            this._fullscreenKeyboard = true;
        }

        var fullscreenElement =
            [
                "fullscreenElement",
                "mozFullScreenElement",
                "webkitFullscreenElement",
                "msFullscreenElement"
            ];

        for (var k = 0, kk = fullscreenElement.length; k < kk; k++)
        {
            if (typeof document[fullscreenElement[k]] !== "undefined")
            {
                this._fullscreenElement = fullscreenElement[k];
                break;
            }
        }

        var fullscreenEnabled =
            [
                "fullscreenEnabled",
                "mozFullScreenEnabled",
                "webkitFullscreenEnabled",
                "msFullscreenEnabled"
            ];

        for (var l = 0, ll = fullscreenEnabled.length; l < ll; l++)
        {
            if (typeof document[fullscreenEnabled[l]] !== "undefined")
            {
                this._fullscreenEnabled = fullscreenEnabled[l];
                break;
            }
        }
    };

    /**
     * Check browser APIs.
     * @method FORGE.Device#_checkBrowserApi
     * @private
     */
    Tmp.prototype._checkBrowserApi = function()
    {
        //Page Visibility API
        this._visibilityState = "visibilityState" in document ? "visibilityState" :
            "webkitVisibilityState" in document ? "webkitVisibilityState" :
            "mozVisibilityState" in document ? "mozVisibilityState" :
            null;

        this._visibilityChange = this._visibilityState.slice(0, -5) + "change";

        //Screen orientation API
        var orientation =
            [
                "orientation",
                "mozOrientation",
                "msOrientation"
            ];
        for (var i = 0, ii = orientation.length; i < ii; i++)
        {
            if (typeof screen[orientation[i]] === "string")
            {
                this._orientation = orientation[i];
                break;
            }
        }

        this._screenOrientation = (typeof screen.orientation === "object" && typeof screen.orientation.type === "string" && typeof screen.orientation.lock === "function");

        var lockOrientation =
            [
                "lockOrientation",
                "mozLockOrientation",
                "msLockOrientation"
            ];
        var unlockOrientation =
            [
                "unlockOrientation",
                "mozUnlockOrientation",
                "msUnlockOrientation"
            ];
        for (var j = 0, jj = lockOrientation.length; j < jj; j++)
        {
            if (typeof screen[lockOrientation[j]] === "function")
            {
                this._lockOrientation = lockOrientation[j];
                this._unlockOrientation = unlockOrientation[j];
                break;
            }
        }

        //File API
        this._file = (typeof window.File !== "undefined" && typeof window.FileReader !== "undefined" && typeof window.FileList !== "undefined" && typeof window.Blob !== "undefined");
        this._fileSystem = (typeof window.requestFileSystem !== "undefined" || typeof window.webkitRequestFileSystem !== "undefined");

        //Pointer Lock API
        this._pointerLock = (typeof document.pointerLockElement !== "undefined" || typeof document.mozPointerLockElement !== "undefined" || typeof document.webkitPointerLockElement !== "undefined");
    };

    /**
     * Check CSS rules.
     * @method FORGE.Device#_checkCss
     * @private
     */
    Tmp.prototype._checkCss = function()
    {
        // pointer events
        var cssStyle = document.createElement("a").style;
        cssStyle.cssText = "pointer-events:auto";
        this._cssPointerEvents = (cssStyle.pointerEvents === "auto");

        // rgba
        cssStyle.cssText = "background-color:rgba(150,255,150,.5)";
        this._cssRgba = (("" + cssStyle.backgroundColor).indexOf("rgba") > -1);

        this._cssAnimation = (typeof cssStyle.animationName !== "undefined" || typeof cssStyle.webkitAnimationName !== "undefined" || typeof cssStyle.mozAnimationName !== "undefined" || typeof cssStyle.msAnimationName !== "undefined");

        // css transform and css3D check
        var el = document.createElement("p");
        var has3d;
        var transforms = {
            "webkitTransform": "-webkit-transform",
            "OTransform": "-o-transform",
            "msTransform": "-ms-transform",
            "MozTransform": "-moz-transform",
            "transform": "transform"
        };

        // Add it to the body to get the computed style.
        document.body.insertBefore(el, null);
        for (var t in transforms)
        {
            if (typeof el.style[t] !== "undefined")
            {
                el.style[t] = "translate3d(1px,1px,1px)";
                has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);
            }
        }
        document.body.removeChild(el);
        this._css3D = (typeof has3d !== "undefined" && has3d.length > 0 && has3d !== "none");
    };

    /**
     * Internal handler for Device Motion.
     * @method FORGE.Device#_deviceMotionHandler
     * @param {Event} event DeviceMotionEvent
     * @private
     */
    Tmp.prototype._deviceMotionHandler = function(event)
    {

        if (event.rotationRate !== null && typeof event.rotationRate.alpha !== "undefined" && typeof event.rotationRate.beta !== "undefined" && typeof event.rotationRate.gamma !== "undefined")
        {
            this._deviceMotionRotationRate = true;
        }
        if (typeof event.acceleration !== "undefined" && typeof event.acceleration.x !== "undefined" && typeof event.acceleration.y !== "undefined" && typeof event.acceleration.z !== "undefined")
        {
            this._deviceMotionAcceleration = true;
        }

        this._removeDeviceMotionHandler();

        if (typeof this._deviceOrientationBind !== "function")
        {
            this._checkComplete();
        }
    };

    /**
     * Internal handler for Device Orientation.
     * @method FORGE.Device#_deviceOrientationHandler
     * @param {Event} event DeviceOrientationEvent
     * @private
     */
    Tmp.prototype._deviceOrientationHandler = function(event)
    {
        if (typeof event.alpha !== "undefined" && event.alpha !== null
            && typeof event.beta !== "undefined" && event.beta !== null
            && typeof event.gamma !== "undefined" && event.gamma !== null)
        {
            this._deviceOrientationMagnetometer = true;
        }

        this._removeDeviceOrientationHandler();

        if (typeof this._deviceMotionBind !== "function")
        {
            this._checkComplete();
        }
    };

    /**
     * Remove the device motion handler.
     * @method FORGE.Device#_removeDeviceMotionHandler
     * @private
     */
    Tmp.prototype._removeDeviceMotionHandler = function()
    {
        window.removeEventListener("devicemotion", this._deviceMotionBind, false);
        this._deviceMotionBind = null;
    };

    /**
     * Remove the device orientation handler.
     * @method FORGE.Device#_removeDeviceOrientationHandler
     * @private
     */
    Tmp.prototype._removeDeviceOrientationHandler = function()
    {
        window.removeEventListener("deviceorientation", this._deviceOrientationBind, false);
        this._deviceOrientationBind = null;
    };

    /**
     * Check the gyroscope support.
     * @method FORGE.Device#_checkGyroscope
     * @private
     */
    Tmp.prototype._checkGyroscope = function()
    {
        this._deviceMotion = (typeof window.DeviceMotionEvent !== "undefined");
        this._deviceOrientation = (typeof window.DeviceOrientationEvent !== "undefined");

        window.addEventListener("deviceorientation", this._deviceOrientationBind, false);
        window.addEventListener("devicemotion", this._deviceMotionBind, false);
    };

    /**
     * Check the screen properties
     * @method FORGE.Device#_checkScreen
     * @private
     */
    Tmp.prototype._checkScreen = function()
    {
        var div = document.createElement("div");
        div.style.width = "1in";
        div.style.height = "1in";
        document.body.appendChild(div);

        this._dpi = div.offsetWidth;

        document.body.removeChild(div);
        div = null;

        if (this._mobile)
        {
            this._screenWidth = Math.floor(Math.min(window.screen.width, window.screen.height) * this._pixelRatio);
            this._screenHeight = Math.floor(Math.max(window.screen.width, window.screen.height) * this._pixelRatio);
        }
        else
        {
            this._screenWidth = Math.floor(Math.max(window.screen.width, window.screen.height) * this._pixelRatio);
            this._screenHeight = Math.floor(Math.min(window.screen.width, window.screen.height) * this._pixelRatio);
        }
    };

    /**
     * Run the checks.
     * @method FORGE.Device#_check
     * @private
     */
    Tmp.prototype._check = function()
    {
        this._ua = navigator["userAgent"];

        this._language = ((navigator.languages && navigator.languages[0]) || navigator.language || navigator.userLanguage || "");

        this._checkOS();
        this._checkBrowsers();
        this._checkDevice();
        this._checkAudio();
        this._checkVideo();
        this._checkDeviceFeatures();
        this._checkFeatures();
        this._checkEnvironment();
        this._checkBrowserApi();
        this._checkFullscreenSupport();
        this._checkInput();
        this._checkCss();

        // bind device motion and device orientation events
        this._deviceMotionBind = this._deviceMotionHandler.bind(this);
        this._deviceOrientationBind = this._deviceOrientationHandler.bind(this);
        this._checkGyroscope();
        this._checkScreen();

        // _checkComplete is initially called by either _deviceMotionHandler or
        // _deviceOrientationHandler, but if both _deviceMotion and _deviceOrientation are set to
        // false, we need to force the call of _checkComplete
        if (this._deviceMotion === false && this._deviceOrientation === false)
        {
            this._checkComplete();
        }
    };

    /**
     * Finalize and set as singleton the Device object.
     * @method FORGE.Device#_checkComplete
     * @private
     */
    Tmp.prototype._checkComplete = function()
    {
        if (typeof this._deviceMotionBind === "function")
        {
            this._removeDeviceMotionHandler();
        }
        if (typeof this._deviceOrientationBind === "function")
        {
            this._removeDeviceOrientationHandler();
        }

        this._gyroscope = (this._deviceMotionRotationRate === true
                            && this._deviceMotionAcceleration === true
                            && this._deviceOrientationMagnetometer === true);

        this._ready = true;

        this._onReady.dispatch();

        Object.freeze(FORGE.Device);
    };

    /**
     * Check if the device can play audio.
     * @method FORGE.Device#canPlayAudio
     * @param {string} type - One of 'mp3, 'ogg', 'm4a', 'wav', 'webm'.
     * @return {boolean}
     */
    Tmp.prototype.canPlayAudio = function(type)
    {
        if (type === "mp3" && this._mp3 === true)
        {
            return true;
        }
        else if (type === "ogg" && (this._ogg === true || this._opus === true))
        {
            return true;
        }
        else if (type === "m4a" && this._m4a === true)
        {
            return true;
        }
        else if (type === "mp4" && this._mp4 === true)
        {
            return true;
        }
        else if (type === "opus" && this._opus === true)
        {
            return true;
        }
        else if (type === "wav" && this._wav === true)
        {
            return true;
        }
        else if (type === "aac" && this._aac === true)
        {
            return true;
        }
        else if (type === "webm" && this._webm === true)
        {
            return true;
        }
        else if (type === "weba" && this._weba === true)
        {
            return true;
        }

        return false;
    };

    /**
     * Check If the device can play video files.
     * @method FORGE.Device#canPlayVideo
     * @param {string} type - One of 'mp4, 'ogg', 'webm' or 'mpeg'.
     * @return {boolean}
     */
    Tmp.prototype.canPlayVideo = function(type)
    {
        if (type === "webm" && (this._webmVideo === true || this._vp9Video === true))
        {
            return true;
        }
        else if (type === "mp4" && (this._mp4Video === true || this._h264Video === true))
        {
            return true;
        }
        else if ((type === "ogg" || type === "ogv") && this._oggVideo === true)
        {
            return true;
        }
        else if (type === "mpeg" && this._hlsVideo === true)
        {
            return true;
        }

        return false;
    };

    /**
     * Check If the battery is low.<br>
     * Note "low" is defined as less than 20%.
     * @method FORGE.Device#isLowBattery
     * @return {Promise<boolean>}
     */
    Tmp.prototype.isLowBattery = function()
    {
        var minLevel = 0.20;

        return navigator.getBattery()
            .then(function(battery)
            {
                return this._battery && !battery.charging && battery.level <= minLevel;
            }.bind(this), function()
            {
                return false;
            });
    };

    /**
     * Check device requirement for an object from configuration/manifest.
     * @method FORGE.Device.check
     * @static
     * @param {Object} config - The device requirement configuration of the configuration/manifest.
     * @param {Object} [device=FORGE.Device] - The device environment to test. The default is FORGE.Device detection, but we need to modify it in test suites.
     * @param {string} [condition="and"] [description]
     * @return {boolean} Returns true if the object is compatible with the device environment, false if not.
     */
    Tmp.prototype.check = function(config, device, condition)
    {
        condition = condition || "and";
        device = device || FORGE.Device;

        var result = true;

        for(var i in config)
        {
            if(i === "and")
            {
                result = FORGE.Device.check(config[i], device, "and");
            }
            else if(i === "or")
            {
                result = FORGE.Device.check(config[i], device, "or");
            }
            else
            {
                result = FORGE.Device.checkValue(config[i], device[i]);
            }

            if(condition === "and" && result === false)
            {
                break;
            }
            else if(condition === "or" && result === true)
            {
                break;
            }
        }

        return result;
    };

    /**
     * Check a single device config for the main check method
     * @method FORGE.Device.checkValue
     * @static
     * @param  {(Object|boolean|number|string)} config - The configuration to check
     * @param  {(boolean|number|string)} device - The device value
     * @return {boolean}
     */
    Tmp.prototype.checkValue = function(config, device)
    {
        var operation = "===";
        var value;

        if(typeof config === "object")
        {
            if(typeof config.operation === "string")
            {
                operation = config.operation;
            }

            value = config.value;
        }
        else
        {
            value = config;
        }

        var result = false;

        switch(operation)
        {
            case "==":
            case "===":
                result = device === value;
                break;

            case "!=":
            case "!==":
                result = device !== value;
                break;

            case "<":
                result = device < value;
                break;

            case "<=":
                result = device <= value;
                break;

            case ">":
                result = device > value;
                break;

            case ">=":
                result = device >= value;
                break;
        }

        return result;
    };

    /**
     * Is device detection done?
     * @name FORGE.Device#ready
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "ready",
    {
        get: function()
        {
            return this._ready;
        }
    });

    /**
     * The user agent string.
     * @name FORGE.Device#ua
     * @type {string}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "ua",
    {
        get: function()
        {
            return this._ua;
        }
    });

    /**
     * The browser language.
     * @name FORGE.Device#language
     * @type {string}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "language",
    {
        get: function()
        {
            return this._language;
        }
    });

    //OS

    /**
     * The OS name
     * @name FORGE.Device#os
     * @type {string}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "os",
    {
        get: function()
        {
            return this._os;
        }
    });

    /**
     * The OS major version number.
     * @name FORGE.Device#osVersion
     * @type {number}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "osVersion",
    {
        get: function()
        {
            return this._osVersion;
        }
    });

    /**
     * Is running on PS Vita?
     * @name FORGE.Device#vita
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "vita",
    {
        get: function()
        {
            return this._vita;
        }
    });

    /**
     * Is running on XBox?
     * @name FORGE.Device#xbox
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "xbox",
    {
        get: function()
        {
            return this._xbox;
        }
    });

    /**
     * Is running on Kindle?
     * @name FORGE.Device#kindle
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "kindle",
    {
        get: function()
        {
            return this._kindle;
        }
    });

    /**
     * Is running on android?
     * @name FORGE.Device#android
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "android",
    {
        get: function()
        {
            return this._android;
        }
    });

    /**
     * Is running on chromeOS?
     * @name FORGE.Device#chromeOS
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "chromeOS",
    {
        get: function()
        {
            return this._chromeOS;
        }
    });

    /**
     * Is running on iOS?
     * @name FORGE.Device#iOS
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "iOS",
    {
        get: function()
        {
            return this._iOS;
        }
    });

    /**
     * Is running on Linux?
     * @name FORGE.Device#linux
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "linux",
    {
        get: function()
        {
            return this._linux;
        }
    });

    /**
     * Is running on MacOS?
     * @name FORGE.Device#macOS
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "macOS",
    {
        get: function()
        {
            return this._macOS;
        }
    });

    /**
     * Is running on Windows?
     * @name FORGE.Device#windows
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "windows",
    {
        get: function()
        {
            return this._windows;
        }
    });

    /**
     * Is running on Windows Phone?
     * @name FORGE.Device#windowsPhone
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "windowsPhone",
    {
        get: function()
        {
            return this._windowsPhone;
        }
    });

    // Browsers

    /**
     * Is running in Firefox?
     * @name FORGE.Device#firefox
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "firefox",
    {
        get: function()
        {
            return this._firefox;
        }
    });

    /**
     * Firefox major version number.
     * @name FORGE.Device#firefoxVersion
     * @type {number}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "firefoxVersion",
    {
        get: function()
        {
            return this._firefoxVersion;
        }
    });

    /**
     * Is running in Chrome?
     * @name FORGE.Device#chrome
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "chrome",
    {
        get: function()
        {
            return this._chrome;
        }
    });

    /**
     * Chrome major version number.
     * @name FORGE.Device#chromeVersion
     * @type {number}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "chromeVersion",
    {
        get: function()
        {
            return this._chromeVersion;
        }
    });

    /**
     * Is running in Internet Explorer?
     * @name FORGE.Device#ie
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "ie",
    {
        get: function()
        {
            return this._ie;
        }
    });

    /**
     * Internet Explorer major version number.
     * @name FORGE.Device#ieVersion
     * @type {number}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "ieVersion",
    {
        get: function()
        {
            return this._ieVersion;
        }
    });

    /**
     * Is running in Opera?
     * @name FORGE.Device#opera
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "opera",
    {
        get: function()
        {
            return this._opera;
        }
    });

    /**
     * Opera major version number.
     * @name FORGE.Device#operaVersion
     * @type {number}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "operaVersion",
    {
        get: function()
        {
            return this._operaVersion;
        }
    });

    /**
     * Is running in Edge?
     * @name FORGE.Device#edge
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "edge",
    {
        get: function()
        {
            return this._edge;
        }
    });

    /**
     * Edge major version number.
     * @name FORGE.Device#edgeVersion
     * @type {number}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "edgeVersion",
    {
        get: function()
        {
            return this._edgeVersion;
        }
    });

    /**
     * Is running in Safari?
     * @name FORGE.Device#safari
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "safari",
    {
        get: function()
        {
            return this._safari;
        }
    });

    /**
     * Safari (or Mobile Safari) major version number.
     * @name FORGE.Device#safariVersion
     * @type {number}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "safariVersion",
    {
        get: function()
        {
            return this._safariVersion;
        }
    });

    /**
     * Is running in Silk (Kindle)?
     * @name FORGE.Device#silk
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "silk",
    {
        get: function()
        {
            return this._silk;
        }
    });

    /**
     * The nick name of the browser.
     * @name FORGE.Device#browser
     * @type {string}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "browser",
    {
        get: function()
        {
            return this._browser;
        }
    });

    /**
     * The browser major version.
     * @name FORGE.Device#browserVersion
     * @type {number}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "browserVersion",
    {
        get: function()
        {
            return this._browserVersion;
        }
    });

    /**
     * Is running in a standalone app?
     * @name FORGE.Device#webApp
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "webApp",
    {
        get: function()
        {
            return this._webApp;
        }
    });

    /**
     * Detect if it's an Android Stock browser.
     * @name FORGE.Device#isAndroidStockBrowser
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "isAndroidStockBrowser",
    {
        get: function()
        {
            return this._isAndroidStockBrowser;
        }
    });

    /**
     * The Android version linked to the stock browser.
     * @name FORGE.Device#androidStockBrowserVersion
     * @type {number}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "androidStockBrowserVersion",
    {
        get: function()
        {
            return this._androidStockBrowserVersion;
        }
    });

    /**
     * Is the browser running in strict mode or quirks mode?
     * @name FORGE.Device#quirksMode
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "quirksMode",
    {
        get: function()
        {
            return this._quirksMode;
        }
    });

    // Capabilities

    /**
     * Does the browser support full screen API?
     * @name FORGE.Device#fullscreenEnabled
     * @type {string}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "fullscreenEnabled",
    {
        get: function()
        {
            return this._fullscreenEnabled;
        }
    });

    /**
     * Request full screen method name.
     * @name FORGE.Device#requestFullscreen
     * @type {string}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "requestFullscreen",
    {
        get: function()
        {
            return this._requestFullscreen;
        }
    });

    /**
     * Exit full screen method name.
     * @name FORGE.Device#exitFullscreen
     * @type {string}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "exitFullscreen",
    {
        get: function()
        {
            return this._exitFullscreen;
        }
    });

    /**
     * fullscreenElement accessor name.
     * @name  FORGE.Device#fullscreenElement
     * @type {string}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "fullscreenElement",
    {
        get: function()
        {
            return this._fullscreenElement;
        }
    });

    /**
     * Does the browser support keyboard during full screen mode?
     * @name FORGE.Device#fullscreenKeyboard
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "fullscreenKeyboard",
    {
        get: function()
        {
            return this._fullscreenKeyboard;
        }
    });

    // Device

    /**
     * Is running on iPhone?
     * @name FORGE.Device#iPhone
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "iPhone",
    {
        get: function()
        {
            return this._iPhone;
        }
    });

    /**
     * Is running on Apple Retina display?
     * @name FORGE.Device#retina
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "retina",
    {
        get: function()
        {
            return this._retina;
        }
    });

    /**
     * Is running on iPod?
     * @name FORGE.Device#iPod
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "iPod",
    {
        get: function()
        {
            return this._iPod;
        }
    });

    /**
     * Is running on iPad?
     * @name FORGE.Device#iPad
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "iPad",
    {
        get: function()
        {
            return this._iPad;
        }
    });

    /**
     * Pixel ratio of the device.
     * @name FORGE.Device#pixelRatio
     * @type {number}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "pixelRatio",
    {
        get: function()
        {
            return this._pixelRatio;
        }
    });

    /**
     * Does the device support the Vibration API?
     * @name FORGE.Device#vibrate
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "vibrate",
    {
        get: function()
        {
            return this._vibrate;
        }
    });

    /**
     * Is the Battery API available?
     * @name FORGE.Device#battery
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "battery",
    {
        get: function()
        {
            return this._battery;
        }
    });

    /**
     * Is running on a desktop?
     * @name FORGE.Device#desktop
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "desktop",
    {
        get: function()
        {
            return this._desktop;
        }
    });

    /**
     * Is running on a tablet?
     * @name FORGE.Device#tablet
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "tablet",
    {
        get: function()
        {
            return this._tablet;
        }
    });

    /**
     * Is running on a mobile?
     * @name FORGE.Device#mobile
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "mobile",
    {
        get: function()
        {
            return this._mobile;
        }
    });

    /**
     * Is running on a other device as smartTv...?
     * @name FORGE.Device#other
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "other",
    {
        get: function()
        {
            return this._other;
        }
    });

    // Inputs

    /**
     * Is Touch API available?
     * @name FORGE.Device#touch
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "touch",
    {
        get: function()
        {
            return this._touch;
        }
    });

    /**
     * Is Gamepad API available?
     * @name FORGE.Device#gamepad
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "gamepad",
    {
        get: function()
        {
            return this._gamepad;
        }
    });

    /**
     * Are Force Touch Events supported?
     * Force Touch events are available in OS X 10.11 and later on devices equipped with Force Touch trackpads.
     * @name FORGE.Device#touchForce
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "touchForce",
    {
        get: function()
        {
            return this._touchForce;
        }
    });

    // Audio

    /**
     * Are Audio tags available?
     * @name FORGE.Device#audioTag
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "audioTag",
    {
        get: function()
        {
            return this._audioTag;
        }
    });

    /**
     * Is the WebAudio API available?
     * @name FORGE.Device#webAudio
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "webAudio",
    {
        get: function()
        {
            return this._webAudio;
        }
    });

    /**
     * Can play ogg files?
     * @name FORGE.Device#ogg
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "ogg",
    {
        get: function()
        {
            return this._ogg;
        }
    });

    /**
     * Can play mp3 files?
     * @name FORGE.Device#mp3
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "mp3",
    {
        get: function()
        {
            return this._mp3;
        }
    });

    /**
     * Can play opus files?
     * @name FORGE.Device#opus
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "opus",
    {
        get: function()
        {
            return this._opus;
        }
    });

    /**
     * Can play wav files?
     * @name FORGE.Device#wav
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "wav",
    {
        get: function()
        {
            return this._wav;
        }
    });

    /**
     * Can play m4a files?
     * @name FORGE.Device#m4a
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "m4a",
    {
        get: function()
        {
            return this._m4a;
        }
    });

    /**
     * Can play mp4 files?
     * @name FORGE.Device#mp4
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "mp4",
    {
        get: function()
        {
            return this._mp4;
        }
    });

    /**
     * Can play aac files?
     * @name FORGE.Device#aac
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "aac",
    {
        get: function()
        {
            return this._aac;
        }
    });

    /**
     * Can play webm files?
     * @name FORGE.Device#webm
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "webm",
    {
        get: function()
        {
            return this._webm;
        }
    });

    /**
     * Can play weba files?
     * @name FORGE.Device#weba
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "weba",
    {
        get: function()
        {
            return this._weba;
        }
    });

    // Video

    /**
     * Can play ogg video files?
     * @name FORGE.Device#oggVideo
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "oggVideo",
    {
        get: function()
        {
            return this._oggVideo;
        }
    });

    /**
     * Can play h264 video files?
     * @name FORGE.Device#h264Video
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "h264Video",
    {
        get: function()
        {
            return this._h264Video;
        }
    });

    /**
     * Can play mp4 video files?
     * @name FORGE.Device#mp4Video
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "mp4Video",
    {
        get: function()
        {
            return this._mp4Video;
        }
    });

    /**
     * Can play webm video files?
     * @name FORGE.Device#webmVideo
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "webmVideo",
    {
        get: function()
        {
            return this._webmVideo;
        }
    });

    /**
     * Can play vp9 video files?
     * @name FORGE.Device#vp9Video
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "vp9Video",
    {
        get: function()
        {
            return this._vp9Video;
        }
    });

    /**
     * Can play hls video files?
     * @name FORGE.Device#hlsVideo
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "hlsVideo",
    {
        get: function()
        {
            return this._hlsVideo;
        }
    });

    // Features

    /**
     * Is canvas available?
     * @name FORGE.Device#canvas
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "canvas",
    {
        get: function()
        {
            return this._canvas;
        }
    });

    /**
     * Are winding rules for '<canvas>' (go clockwise or counterclockwise) available?
     * @name FORGE.Device#canvasWinding
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "canvasWinding",
    {
        get: function()
        {
            return this._canvasWinding;
        }
    });

    /**
     * Is text API for canvas available?
     * @name FORGE.Device#canvasText
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "canvasText",
    {
        get: function()
        {
            return this._canvasText;
        }
    });

    /**
     * Is native support of addEventListener available?
     * @name FORGE.Device#addEventListener
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "addEventListener",
    {
        get: function()
        {
            return this._addEventListener;
        }
    });

    /**
     * Is requestAnimationFrame API supported?
     * @name FORGE.Device#raf
     * @type {boolean}
     * @private
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "raf",
    {
        get: function()
        {
            return this._raf;
        }
    });

    /**
     * Is webGL available?
     * @name FORGE.Device#webGL
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "webGL",
    {
        get: function()
        {
            return this._webGL;
        }
    });

    /**
     * Is WebVR available?
     * @name FORGE.Device#webVR
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "webVR",
    {
        get: function()
        {
            return this._webVR;
        }
    });

    /**
     * Is file available?
     * @name FORGE.Device#file
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "file",
    {
        get: function()
        {
            return this._file;
        }
    });

    /**
     * Is fileSystem available?
     * @name FORGE.Device#fileSystem
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "fileSystem",
    {
        get: function()
        {
            return this._fileSystem;
        }
    });

    /**
     * Is localStorage available?
     * @name FORGE.Device#localStorage
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "localStorage",
    {
        get: function()
        {
            return this._localStorage;
        }
    });

    /**
     * Is Application Cache supported to enable web-based applications run offline?
     * @name FORGE.Device#applicationCache
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "applicationCache",
    {
        get: function()
        {
            return this._applicationCache;
        }
    });

    /**
     * Is Geolocation API available?
     * @name FORGE.Device#geolocation
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "geolocation",
    {
        get: function()
        {
            return this._geolocation;
        }
    });

    /**
     * Is pointerLock available?
     * @name FORGE.Device#pointerLock
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "pointerLock",
    {
        get: function()
        {
            return this._pointerLock;
        }
    });

    /**
     * Is context menu available?
     * @name FORGE.Device#contextMenu
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "contextMenu",
    {
        get: function()
        {
            return this._contextMenu;
        }
    });

    /**
     * Is Media Source Extensions API available?
     * @name  FORGE.Device#mediaSource
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "mediaSource",
    {
        get: function()
        {
            return this._mediaSource;
        }
    });

    /**
     * Is Encrypted Media Extensions API available?
     * @name  FORGE.Device#encryptedMedia
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "encryptedMedia",
    {
        get: function()
        {
            return this._encryptedMedia;
        }
    });

    /**
     * Is JSON native support available?
     * @name FORGE.Device#JSON
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "JSON",
    {
        get: function()
        {
            return this._JSON;
        }
    });

    /**
     * Is History API available?
     * @name FORGE.Device#history
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "history",
    {
        get: function()
        {
            return this._history;
        }
    });

    /**
     * Is SVG in '<embed>' or '<object>' supported?
     * @name FORGE.Device#svg
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "svg",
    {
        get: function()
        {
            return this._svg;
        }
    });

    /**
     * Is the current page in secure mode?
     * @name FORGE.Device#isSecure
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "isSecure",
    {
        get: function()
        {
            return this._isSecure;
        }
    });

    /**
     * Is the current page is into an Iframe ?
     * @name FORGE.Device#isIframe
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "isIframe",
    {
        get: function()
        {
            return this._isIframe;
        }
    });

    /**
     * Hidden state name for the PageVisibility API.
     * @name FORGE.Device#visibilityState
     * @type {string}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "visibilityState",
    {
        get: function()
        {
            return this._visibilityState;
        }
    });

    /**
     * Visibility change event name for the PageVisibility API.
     * @name FORGE.Device#visibilityChange
     * @type {string}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "visibilityChange",
    {
        get: function()
        {
            return this._visibilityChange;
        }
    });

    // CSS

    /**
     * Is css3D available?
     * @name FORGE.Device#css3D
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "css3D",
    {
        get: function()
        {
            return this._css3D;
        }
    });

    /**
     * Is rgba (alpha) available?
     * @name FORGE.Device#cssRgba
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "cssRgba",
    {
        get: function()
        {
            return this._cssRgba;
        }
    });

    /**
     * Is pointer-events available?
     * @name FORGE.Device#cssPointerEvents
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "cssPointerEvents",
    {
        get: function()
        {
            return this._cssPointerEvents;
        }
    });

    /**
     * Are css animations (keyframes) supported?
     * @name FORGE.Device#cssAnimation
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "cssAnimation",
    {
        get: function()
        {
            return this._cssAnimation;
        }
    });

    // Gyroscope

    /**
     * Device has a real gyroscope?
     * @name FORGE.Device#gyroscope
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "gyroscope",
    {
        get: function()
        {
            return this._gyroscope;
        }
    });

    /**
     * Is Device Motion Event supported? (Accelerometer)
     * @name FORGE.Device#deviceMotion
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "deviceMotion",
    {
        get: function()
        {
            return this._deviceMotion;
        }
    });

    /**
     * Is Device Orientation Event supported? (Magnetometer)
     * @name FORGE.Device#deviceOrientation
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "deviceOrientation",
    {
        get: function()
        {
            return this._deviceOrientation;
        }
    });

    /**
     * Is Device Motion acceleration supported?
     * @name FORGE.Device#deviceMotionAcceleration
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "deviceMotionAcceleration",
    {
        get: function()
        {
            return this._deviceMotionAcceleration;
        }
    });

    /**
     * Is Device Motion rotation supported?
     * @name FORGE.Device#deviceMotionRotationRate
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "deviceMotionRotationRate",
    {
        get: function()
        {
            return this._deviceMotionRotationRate;
        }
    });

    /**
     * Is Device Orientation motion supported?
     * @name FORGE.Device#deviceOrientationMagnetometer
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "deviceOrientationMagnetometer",
    {
        get: function()
        {
            return this._deviceOrientationMagnetometer;
        }
    });

    /**
     * Pixel density of the screen.
     * @name  FORGE.Device#dpi
     * @type {number}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "dpi",
    {
        get: function()
        {
            return this._dpi;
        }
    });

    /**
     * Device screen width in pixels.
     * @name  FORGE.Device#screenWidth
     * @type {number}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "screenWidth",
    {
        get: function()
        {
            return this._screenWidth;
        }
    });

    /**
     * Device screen height in pixels.
     * @name  FORGE.Device#screenHeight
     * @type {number}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "screenHeight",
    {
        get: function()
        {
            return this._screenHeight;
        }
    });

    /**
     * Is screen orienation API available?
     * @name  FORGE.Device#screenOrientation
     * @type {boolean}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "screenOrientation",
    {
        get: function()
        {
            return this._screenOrientation;
        }
    });

    /**
     * Screen orientation object name.
     * @name FORGE.Device#orientation
     * @type {string}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "orientation",
    {
        get: function()
        {
            return this._orientation;
        }
    });

    /**
     * Lock screen orientation method name.
     * @name FORGE.Device#lockOrientation
     * @type {string}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "lockOrientation",
    {
        get: function()
        {
            return this._lockOrientation;
        }
    });

    /**
     * Unlock screen orientation method name.
     * @name FORGE.Device#unlockOrientation
     * @type {string}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "unlockOrientation",
    {
        get: function()
        {
            return this._unlockOrientation;
        }
    });

    /**
     * Get the onReady EventDispatcher.
     * @name FORGE.Device#onReady
     * @type {FORGE.EventDispatcher}
     * @readonly
     */
    Object.defineProperty(Tmp.prototype, "onReady",
    {
        get: function()
        {
            return this._onReady;
        }
    });

    return new Tmp();

})(function()
{
    return function()
    {
        /**
         * Is device detection done?
         * @name FORGE.Device#_ready
         * @type {boolean}
         * @private
         */
        this._ready = false;

        /**
         * The user agent string.
         * @name FORGE.Device#_ua
         * @type {string}
         * @private
         */
        this._ua = "";

        /**
         * The browser language.
         * @name FORGE.Device#_language
         * @type {string}
         * @private
         */
        this._language = "";

        //OS

        /**
         * The OS name
         * @name FORGE.Device#_os
         * @type {string}
         * @private
         */
        this._os = "";

        /**
         * The OS major version number.
         * @name FORGE.Device#_osVersion
         * @type {number}
         * @private
         */
        this._osVersion = 0;

        /**
         * Is running on PS Vita?
         * @name FORGE.Device#_vita
         * @type {boolean}
         * @private
         */
        this._vita = false;

        /**
         * Is running on XBox?
         * @name FORGE.Device#_xbox
         * @type {boolean}
         * @private
         */
        this._xbox = false;

        /**
         * Is running on Kindle?
         * @name FORGE.Device#_kindle
         * @type {boolean}
         * @private
         */
        this._kindle = false;

        /**
         * Is running on android?
         * @name FORGE.Device#_android
         * @type {boolean}
         * @private
         */
        this._android = false;

        /**
         * Is running on chromeOS?
         * @name FORGE.Device#_chromeOS
         * @type {boolean}
         * @private
         */
        this._chromeOS = false;

        /**
         * Is running on iOS?
         * @name FORGE.Device#_iOS
         * @type {boolean}
         * @private
         */
        this._iOS = false;

        /**
         * Is running on Linux?
         * @name FORGE.Device#_linux
         * @type {boolean}
         * @private
         */
        this._linux = false;

        /**
         * Is running on MacOS?
         * @name FORGE.Device#_macOS
         * @type {boolean}
         * @private
         */
        this._macOS = false;

        /**
         * Is running on Windows?
         * @name FORGE.Device#_windows
         * @type {boolean}
         * @private
         */
        this._windows = false;

        /**
         * Is running on Windows Phone?
         * @name FORGE.Device#_windowsPhone
         * @type {boolean}
         * @private
         */
        this._windowsPhone = false;

        // Browsers

        /**
         * Is running in Firefox?
         * @name FORGE.Device#_firefox
         * @type {boolean}
         * @private
         */
        this._firefox = false;

        /**
         * Firefox major version number.
         * @name FORGE.Device#_firefoxVersion
         * @type {number}
         * @private
         */
        this._firefoxVersion = 0;

        /**
         * Is running in Chrome?
         * @name FORGE.Device#_chrome
         * @type {boolean}
         * @private
         */
        this._chrome = false;

        /**
         * Chrome major version number.
         * @name FORGE.Device#_chromeVersion
         * @type {number}
         * @private
         */
        this._chromeVersion = 0;

        /**
         * Is running in Internet Explorer?
         * @name FORGE.Device#_ie
         * @type {boolean}
         * @private
         */
        this._ie = false;

        /**
         * Internet Explorer major version number.
         * @name FORGE.Device#_ieVersion
         * @type {number}
         * @private
         */
        this._ieVersion = 0;

        /**
         * Is running in Opera?
         * @name FORGE.Device#_opera
         * @type {boolean}
         * @private
         */
        this._opera = false;

        /**
         * Opera major version number.
         * @name FORGE.Device#_operaVersion
         * @type {number}
         * @private
         */
        this._operaVersion = 0;

        /**
         * Is running in Edge?
         * @name FORGE.Device#_edge
         * @type {boolean}
         * @private
         */
        this._edge = false;

        /**
         * Edge major version number.
         * @name FORGE.Device#_edgeVersion
         * @type {number}
         * @private
         */
        this._edgeVersion = 0;

        /**
         * Is running in Safari?
         * @name FORGE.Device#_safari
         * @type {boolean}
         * @private
         */
        this._safari = false;

        /**
         * Safari (or Mobile Safari) major version number.
         * @name FORGE.Device#_safariVersion
         * @type {number}
         * @private
         */
        this._safariVersion = 0;

        /**
         * Is running in Silk (Kindle)?
         * @name FORGE.Device#_silk
         * @type {boolean}
         * @private
         */
        this._silk = false;

        /**
         * The nick name of the browser.
         * @name FORGE.Device#_browser
         * @type {string}
         * @private
         */
        this._browser = "";

        /**
         * The browser major version.
         * @name FORGE.Device#_browserVersion
         * @type {number}
         * @private
         */
        this._browserVersion = 0;

        /**
         * Is running in a standalone app?
         * @name FORGE.Device#_webApp
         * @type {boolean}
         * @private
         */
        this._webApp = false;

        /**
         * Detect if it's an Android Stock browser.
         * @name FORGE.Device#_isAndroidStockBrowser
         * @type {boolean}
         * @private
         */
        this._isAndroidStockBrowser = false;

        /**
         * The Android version linked to the stock browser.
         * @name FORGE.Device#_androidStockBrowserVersion
         * @type {number}
         * @private
         */
        this._androidStockBrowserVersion = 0;

        /**
         * Is the browser running in strict mode or quirks mode?
         * @name FORGE.Device#_quirksMode
         * @type {boolean}
         * @private
         */
        this._quirksMode = false;

        // Capabilities

        /**
         * Does the browser support full screen API?
         * @name FORGE.Device#_fullscreenEnabled
         * @type {string}
         * @private
         */
        this._fullscreenEnabled = "";

        /**
         * Request full screen method name.
         * @name FORGE.Device#_requestFullscreen
         * @type {string}
         * @private
         */
        this._requestFullscreen = "";

        /**
         * Exit full screen method name.
         * @name FORGE.Device#_exitFullscreen
         * @type {string}
         * @private
         */
        this._exitFullscreen = "";

        /**
         * fullscreenElement accessor name.
         * @name  FORGE.Device#_fullscreenElement
         * @type {string}
         * @private
         */
        this._fullscreenElement = "";

        /**
         * Does the browser support keyboard during full screen mode?
         * @name FORGE.Device#_fullscreenKeyboard
         * @type {boolean}
         * @private
         */
        this._fullscreenKeyboard = false;

        // Device

        /**
         * Is running on iPhone?
         * @name FORGE.Device#_iPhone
         * @type {boolean}
         * @private
         */
        this._iPhone = false;

        /**
         * Is running on Apple Retina display?
         * @name FORGE.Device#_retina
         * @type {boolean}
         * @private
         */
        this._retina = false;

        /**
         * Is running on iPod?
         * @name FORGE.Device#_iPod
         * @type {boolean}
         * @private
         */
        this._iPod = false;

        /**
         * Is running on iPad?
         * @name FORGE.Device#_iPad
         * @type {boolean}
         * @private
         */
        this._iPad = false;

        /**
         * Pixel ratio of the device.
         * @name FORGE.Device#_pixelRatio
         * @type {number}
         * @private
         */
        this._pixelRatio = 1;

        /**
         * Does the device support the Vibration API?
         * @name FORGE.Device#_vibrate
         * @type {boolean}
         * @private
         */
        this._vibrate = false;

        /**
         * Is the Battery API available?
         * @name FORGE.Device#_battery
         * @type {boolean}
         * @private
         */
        this._battery = false;

        /**
         * Is running on a desktop?
         * @name FORGE.Device#_desktop
         * @type {boolean}
         * @private
         */
        this._desktop = false;

        /**
         * Is running on a tablet?
         * @name FORGE.Device#_tablet
         * @type {boolean}
         * @private
         */
        this._tablet = false;

        /**
         * Is running on a mobile?
         * @name FORGE.Device#_mobile
         * @type {boolean}
         * @private
         */
        this._mobile = false;

        /**
         * Is running on a other device as smartTv...?
         * @name FORGE.Device#_other
         * @type {boolean}
         * @private
         */
        this._other = false;

        // Inputs

        /**
         * Is Touch API available?
         * @name FORGE.Device#_touch
         * @type {boolean}
         * @private
         */
        this._touch = false;

        /**
         * Is Gamepad API available?
         * @name FORGE.Device#_gamepad
         * @type {boolean}
         * @private
         */
        this._gamepad = false;

        /**
         * Are Force Touch Events supported?
         * Force Touch events are available in OS X 10.11 and later on devices equipped with Force Touch trackpads.
         * @name FORGE.Device#_touchForce
         * @type {boolean}
         * @private
         */
        this._touchForce = false;

        // Audio

        /**
         * Are Audio tags available?
         * @name FORGE.Device#_audioTag
         * @type {boolean}
         * @private
         */
        this._audioTag = false;

        /**
         * Is the WebAudio API available?
         * @name FORGE.Device#_webAudio
         * @type {boolean}
         * @private
         */
        this._webAudio = false;

        /**
         * Can play ogg files?
         * @name FORGE.Device#_ogg
         * @type {boolean}
         * @private
         */
        this._ogg = false;

        /**
         * Can play mp3 files?
         * @name FORGE.Device#_mp3
         * @type {boolean}
         * @private
         */
        this._mp3 = false;

        /**
         * Can play opus files?
         * @name FORGE.Device#_opus
         * @type {boolean}
         * @private
         */
        this._opus = false;

        /**
         * Can play wav files?
         * @name FORGE.Device#_wav
         * @type {boolean}
         * @private
         */
        this._wav = false;

        /**
         * Can play m4a files?
         * @name FORGE.Device#_m4a
         * @type {boolean}
         * @private
         */
        this._m4a = false;

        /**
         * Can play mp4 files?
         * @name FORGE.Device#_mp4
         * @type {boolean}
         * @private
         */
        this._mp4 = false;

        /**
         * Can play aac files?
         * @name FORGE.Device#_aac
         * @type {boolean}
         * @private
         */
        this._aac = false;

        /**
         * Can play webm files?
         * @name FORGE.Device#_webm
         * @type {boolean}
         * @private
         */
        this._webm = false;

        /**
         * Can play weba files?
         * @name FORGE.Device#_weba
         * @type {boolean}
         * @private
         */
        this._weba = false;

        // Video

        /**
         * Can play ogg video files?
         * @name FORGE.Device#_oggVideo
         * @type {boolean}
         * @private
         */
        this._oggVideo = false;

        /**
         * Can play h264 video files?
         * @name FORGE.Device#_h264Video
         * @type {boolean}
         * @private
         */
        this._h264Video = false;

        /**
         * Can play mp4 video files?
         * @name FORGE.Device#_mp4Video
         * @type {boolean}
         * @private
         */
        this._mp4Video = false;

        /**
         * Can play webm video files?
         * @name FORGE.Device#_webmVideo
         * @type {boolean}
         * @private
         */
        this._webmVideo = false;

        /**
         * Can play vp9 video files?
         * @name FORGE.Device#_vp9Video
         * @type {boolean}
         * @private
         */
        this._vp9Video = false;

        /**
         * Can play hls video files?
         * @name FORGE.Device#_hlsVideo
         * @type {boolean}
         * @private
         */
        this._hlsVideo = false;

        // Features

        /**
         * Is canvas available?
         * @name FORGE.Device#_canvas
         * @type {boolean}
         * @private
         */
        this._canvas = false;

        /**
         * Are winding rules for '<canvas>' (go clockwise or counterclockwise) available?
         * @name FORGE.Device#_canvasWinding
         * @type {boolean}
         * @private
         */
        this._canvasWinding = false;

        /**
         * Is text API for canvas available?
         * @name FORGE.Device#_canvasText
         * @type {boolean}
         * @private
         */
        this._canvasText = false;

        /**
         * Is native support of addEventListener available?
         * @name FORGE.Device#_addEventListener
         * @type {boolean}
         * @private
         */
        this._addEventListener = false;

        /**
         * Is requestAnimationFrame API supported?
         * @name FORGE.Device#_raf
         * @type {boolean}
         * @private
         */
        this._raf = false;

        /**
         * Is webGL available?
         * @name FORGE.Device#_webGL
         * @type {boolean}
         * @private
         */
        this._webGL = false;

        /**
         * Is WebVR available?
         * @name FORGE.Device#_webVR
         * @type {boolean}
         * @private
         */
        this._webVR = false;

        /**
         * Is file available?
         * @name FORGE.Device#_file
         * @type {boolean}
         * @private
         */
        this._file = false;

        /**
         * Is fileSystem available?
         * @name FORGE.Device#_fileSystem
         * @type {boolean}
         * @private
         */
        this._fileSystem = false;

        /**
         * Is localStorage available?
         * @name FORGE.Device#_localStorage
         * @type {boolean}
         * @private
         */
        this._localStorage = false;

        /**
         * Is Application Cache supported to enable web-based applications run offline?
         * @name FORGE.Device#_applicationCache
         * @type {boolean}
         * @private
         */
        this._applicationCache = false;

        /**
         * Is Geolocation API available?
         * @name FORGE.Device#_geolocation
         * @type {boolean}
         * @private
         */
        this._geolocation = false;

        /**
         * Is pointerLock available?
         * @name FORGE.Device#_pointerLock
         * @type {boolean}
         * @private
         */
        this._pointerLock = false;

        /**
         * Is context menu available?
         * @name FORGE.Device#_contextMenu
         * @type {boolean}
         * @private
         */
        this._contextMenu = false;

        /**
         * Is Media Source Extensions API available?
         * @name  FORGE.Device#_mediaSource
         * @type {boolean}
         * @private
         */
        this._mediaSource = false;

        /**
         * Is Encrypted Media Extensions API available?
         * @name  FORGE.Device#_encryptedMedia
         * @type {boolean}
         * @private
         */
        this._encryptedMedia = false;

        /**
         * Is JSON native support available?
         * @name FORGE.Device#_JSON
         * @type {boolean}
         * @private
         */
        this._JSON = false;

        /**
         * Is History API available?
         * @name FORGE.Device#_history
         * @type {boolean}
         * @private
         */
        this._history = false;

        /**
         * Is SVG in '<embed>' or '<object>' supported?
         * @name FORGE.Device#_svg
         * @type {boolean}
         * @private
         */
        this._svg = false;

        /**
         * Is the current page in secure mode?
         * @name FORGE.Device#_isSecure
         * @type {boolean}
         * @private
         */
        this._isSecure = false;

        /**
         * Is the current page is into an Iframe ?
         * @name FORGE.Device#_isIframe
         * @type {boolean}
         * @private
         */
        this._isIframe = false;

        /**
         * Hidden state name for the PageVisibility API.
         * @name FORGE.Device#_visibilityState
         * @type {string}
         * @private
         */
        this._visibilityState = "";

        /**
         * Visibility change event name for the PageVisibility API.
         * @name FORGE.Device#_visibilityChange
         * @type {string}
         * @private
         */
        this._visibilityChange = "";

        // CSS

        /**
         * Is css3D available?
         * @name FORGE.Device#_css3D
         * @type {boolean}
         * @private
         */
        this._css3D = false;

        /**
         * Is rgba (alpha) available?
         * @name FORGE.Device#_cssRgba
         * @type {boolean}
         * @private
         */
        this._cssRgba = false;

        /**
         * Is pointer-events available?
         * @name FORGE.Device#_cssPointerEvents
         * @type {boolean}
         * @private
         */
        this._cssPointerEvents = false;

        /**
         * Are css animations (keyframes) supported?
         * @name FORGE.Device#_cssAnimation
         * @type {boolean}
         * @private
         */
        this._cssAnimation = false;

        // Gyroscope

        /**
         * Device has a real gyroscope?
         * @name FORGE.Device#_gyroscope
         * @type {boolean}
         * @private
         */
        this._gyroscope = false;

        /**
         * Is Device Motion Event supported? (Accelerometer)
         * @name FORGE.Device#_deviceMotion
         * @type {boolean}
         * @private
         */
        this._deviceMotion = false;

        /**
         * Is Device Orientation Event supported? (Magnetometer)
         * @name FORGE.Device#_deviceOrientation
         * @type {boolean}
         * @private
         */
        this._deviceOrientation = false;

        /**
         * Is Device Motion acceleration supported?
         * @name FORGE.Device#_deviceMotionAcceleration
         * @type {boolean}
         * @private
         */
        this._deviceMotionAcceleration = false;

        /**
         * Is Device Motion rotation supported?
         * @name FORGE.Device#_deviceMotionRotationRate
         * @type {boolean}
         * @private
         */
        this._deviceMotionRotationRate = false;

        /**
         * Is Device Orientation motion supported?
         * @name FORGE.Device#_deviceOrientationMagnetometer
         * @type {boolean}
         * @private
         */
        this._deviceOrientationMagnetometer = false;

        /**
         * This is a copy of device motion handler with this as this reference (bind).
         * @name  FORGE.Device#_deviceMotionBind
         * @type {Function}
         * @default  null
         * @private
         */
        this._deviceMotionBind = null;

        /**
         * This is a copy of device orientation handler with this as this reference (bind).
         * @name  FORGE.Device#_deviceOrientationBind
         * @type {Function}
         * @default  null
         * @private
         */
        this._deviceOrientationBind = null;

        /**
         * Pixel density of the screen.
         * @name  FORGE.Device#_dpi
         * @type {number}
         * @private
         */
        this._dpi = 0;

        /**
         * Device screen width in pixels.
         * @name  FORGE.Device#_screenWidth
         * @type {number}
         * @private
         */
        this._screenWidth = 0;

        /**
         * Device screen height in pixels.
         * @name  FORGE.Device#_screenHeight
         * @type {number}
         * @private
         */
        this._screenHeight = 0;

        /**
         * Is screen orienation API available?
         * @name  FORGE.Device#_screenOrientation
         * @type {boolean}
         * @private
         */
        this._screenOrientation = false;

        /**
         * Screen orientation object name.
         * @name FORGE.Device#_orientation
         * @type {string}
         * @private
         */
        this._orientation = "";

        /**
         * Lock screen orientation method name.
         * @name FORGE.Device#_lockOrientation
         * @type {string}
         * @private
         */
        this._lockOrientation = "";

        /**
         * Unlock screen orientation method name.
         * @name FORGE.Device#_unlockOrientation
         * @type {string}
         * @private
         */
        this._unlockOrientation = "";

        /**
         * Event dispatcher for the ready event
         * @name FORGE.Device#_onReady
         * @type {FORGE.EventDispatcher}
         * @private
         */
        this._onReady = new FORGE.EventDispatcher(this, true);

        FORGE.BaseObject.call(this, "Device");

        this._check();
    };
});


/**
 * System management.
 *
 * @constructor FORGE.System
 * @param {FORGE.Viewer} viewer - The viewer reference.
 *
 * @todo  Rework wakelock with FORGE.Timer and find another place to code it.
 * @todo Update the wakelock to be sure that the window.stop() doesn't stop the load of current elements when invoked otherwise it can result issues.
 * In this case the elements must known the wakelock status to be able to resume/restart the load.
 *
 * @todo  activate/deactivate the "focus" (commented) and "Pagevisibility API"
 *
 */
FORGE.System = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.Loader#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * This is a copy of visibility change handler with this as this reference (bind).
     * @name  FORGE.System#_visibilityChangeBind
     * @type {Function}
     * @default  null
     * @private
     */
    this._visibilityChangeBind = null;
};

FORGE.System.prototype.constructor = FORGE.System;

/**
 * Boot sequence.
 * @method FORGE.System#boot
 */
FORGE.System.prototype.boot = function()
{
    // bind visibility change event
    this._visibilityChangeBind = this._visibilityChangeHandler.bind(this);
    this._setPageVisibilityEvent();
};

/**
 * Define the window focus and visible change event to use for the tab.
 * @method  FORGE.System#_setPageVisibilityEvent
 * @private
 */
FORGE.System.prototype._setPageVisibilityEvent = function()
{
    // add event listener for visible change event
    document.addEventListener(FORGE.Device.visibilityChange, this._visibilityChangeBind, false);

    // force current tab state
    this._visibilityChangeHandler();
};

/**
 * Check if the current tab is visible or not.
 * @method  FORGE.System#_visibilityChangeHandler
 * @private
 */
FORGE.System.prototype._visibilityChangeHandler = function()
{
    var state = document[FORGE.Device.visibilityState];

    if (typeof state === "string" && state === "visible")
    {
        this._viewer.resume(true);
    }
    else
    {
        this._viewer.pause(true);
    }
};

/**
 * Destroy sequence.
 * @method FORGE.System#destroy
 */
FORGE.System.prototype.destroy = function()
{
    document.removeEventListener(FORGE.Device.visibilityChange, this._visibilityChangeBind, false);
    this._visibilityChangeBind = null;

    this._viewer = null;
};


/**
 * Handle the main loop, choose between a requestAnimationFrame (RAF) or a setTimeout method.
 * @constructor FORGE.RequestAnimationFrame
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 */
FORGE.RequestAnimationFrame = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.RequestAnimationFrame#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The timer reference.
     * @name FORGE.RequestAnimationFrame#_timeOutId
     * @type {Object}
     * @private
     */
    this._timeOutId = null;

    /**
     * Is the current timer out?
     * @name FORGE.RequestAnimationFrame#_isSetTimeOut
     * @type {boolean}
     * @private
     */
    this._isSetTimeOut = false;

    /**
     * The function to call on each loop.
     * @name FORGE.RequestAnimationFrame#_onLoop
     * @type {?function(?number)}
     * @private
     */
    this._onLoop = null;

    /**
     * Is RAF running?
     * @name FORGE.RequestAnimationFrame#_running
     * @type {boolean}
     * @private
     */
    this._running = false;

    /**
     * The number of loops.
     * @name FORGE.RequestAnimationFrame#_called
     * @type {number}
     * @private
     */
    this._called = 0;

    /**
     * Request animation frame owner
     * @type {Object}
     * @private
     */
    this._owner = null;
};

FORGE.RequestAnimationFrame.prototype.constructor = FORGE.RequestAnimationFrame;

/**
 * Boot sequence.
 * @method FORGE.RequestAnimationFrame#boot
 */
FORGE.RequestAnimationFrame.prototype.boot = function()
{
    var vendors =
    [
        "ms",
        "moz",
        "webkit",
        "o"
    ];

    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++)
    {
        window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"];
    }

    this._owner = window;
};

/**
 * Start the RAF.
 * @method FORGE.RequestAnimationFrame#start
 * @param {(Window|VRDisplay)=} owner request animation frame owner: window (default) or VRDisplay instance
 * @suppress {checkTypes}
 */
FORGE.RequestAnimationFrame.prototype.start = function(owner)
{
    this._owner = (typeof owner !== "undefined" && (owner === window || owner instanceof VRDisplay)) ? owner : window;

    this._running = true;

    if (typeof this._owner.requestAnimationFrame === "undefined" || this._viewer.config.update === "timeout")
    {
        this._isSetTimeOut = true;

        this._onLoop = function ()
        {
            if(this._running === true)
            {
                return this._updateSetTimeout();
            }
            return;
        };

        this._timeOutID = window.setTimeout(this._onLoop.bind(this), 0);
    }
    else
    {
        this._isSetTimeOut = false;

        this._onLoop = function (time)
        {
            if(this._running === true)
            {
                return this._updateRAF(time);
            }
            return;
        };

        this._timeOutID = this._owner.requestAnimationFrame(this._onLoop.bind(this));
    }
};

/**
 * Stop the RAF.
 * @method FORGE.RequestAnimationFrame#stop
 */
FORGE.RequestAnimationFrame.prototype.stop = function()
{
    if (this._isSetTimeOut)
    {
        clearTimeout(this._timeOutID);
    }
    else
    {
        this._owner.cancelAnimationFrame(this._timeOutID);
        this._timeOutID = null;
    }

    this._running = false;
};

/**
 * Update the RAF.
 * @method FORGE.RequestAnimationFrame#_updateRAF
 * @param {number} time - The current time.
 * @suppress {checkTypes}
 * @private
 */
FORGE.RequestAnimationFrame.prototype._updateRAF = function(time)
{
    this._called++;
    this._viewer.update(Math.floor(time));
    this._timeOutID = this._owner.requestAnimationFrame(this._onLoop.bind(this));
};

/**
 * Update the timer.<br>
 * Timer is based on 30ms.
 * @method FORGE.RequestAnimationFrame#_updateSetTimeout
 * @private
 */
FORGE.RequestAnimationFrame.prototype._updateSetTimeout = function()
{
    this._called++;
    this._viewer.update(0); //fake time
    this._timeOutID = window.setTimeout(this._onLoop.bind(this), 1000/30);
};

/**
 * Destroy sequence.
 * @method FORGE.RequestAnimationFrame#destroy
 * @suppress {checkTypes}
 */
FORGE.RequestAnimationFrame.prototype.destroy = function()
{
    this.stop();
    this._viewer = null;
    this._timeOutId = null;
    this._onLoop = null;
    this._owner = null;
};

/**
 * Get the running flag of the request animation frame module.
 * @name  FORGE.RequestAnimationFrame#running
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.RequestAnimationFrame.prototype, "running",
{
    /** @this {FORGE.RequestAnimationFrame} */
    get: function ()
    {
        return this._running;
    }
});


/**
 * Browser history managment, add slug name of scenes in URL.
 *
 * @constructor FORGE.History
 * @param {FORGE.Viewer} viewer - The viewer reference.
 * @extends FORGE.BaseObject
 */
FORGE.History = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.History#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * History configuration
     * @name FORGE.History#_config
     * @type {HistoryConfig}
     * @private
     */
    this._config;

    /**
     * The history module enabled flag.
     * @name  FORGE.History#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = false;

    FORGE.BaseObject.call(this, "History");
};

FORGE.History.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.History.prototype.constructor = FORGE.History;

/**
 * Default configuration of the History
 * @name FORGE.History.DEFAULT_CONFIG
 * @type {HistoryConfig}
 * @const
 */
FORGE.History.DEFAULT_CONFIG =
{
    enabled: true
};

/**
 * Boot sequence.
 * @method FORGE.History#_parseConfig
 * @param {HistoryConfig} config - History configuration to parse
 * @private
 */
FORGE.History.prototype._parseConfig = function(config)
{
    this._config = /** @type {HistoryConfig} */ (FORGE.Utils.extendSimpleObject(FORGE.History.DEFAULT_CONFIG, config));

    this._enabled = (typeof this._config.enabled === "boolean") ? this._config.enabled : true;

    if (this._enabled === true)
    {
        this._enable();
    }
};

/**
 * Enable the handler needed for History
 * @method FORGE.History#_enable
 * @private
 */
FORGE.History.prototype._enable = function()
{
    this._viewer.story.onSceneLoadStart.add(this._sceneLoadStartHandler, this);
    this._viewer.i18n.onLocaleChangeComplete.add(this._localeChangeCompleteHandler, this);
    window.addEventListener("popstate", this._onPopStateHandler, false);
};

/**
 * Disable the handler needed for History
 * @method FORGE.History#_disable
 * @private
 */
FORGE.History.prototype._disable = function()
{
    this._viewer.story.onSceneLoadStart.remove(this._sceneLoadStartHandler, this);
    this._viewer.i18n.onLocaleChangeComplete.remove(this._localeChangeCompleteHandler, this);
    window.removeEventListener("popstate", this._onPopStateHandler, false);
};

/**
 * Internal handler for scene load start.
 * @method FORGE.History#_sceneLoadStartHandler
 * @private
 */
FORGE.History.prototype._sceneLoadStartHandler = function()
{
    this._addState();
};

/**
 * Internal handler for locale change complete.
 * @method FORGE.History#_localeChangeCompleteHandler
 * @private
 */
FORGE.History.prototype._localeChangeCompleteHandler = function()
{
    this._updateState();
};

/**
 * Add a state into the history.
 * @method  FORGE.History#_addState
 * @private
 */
FORGE.History.prototype._addState = function()
{
    this.log("_addState");

    var scene = this._viewer.story.scene;

    var newState = {
        "viewer":
        {
            uid: this._viewer.uid
        },

        "scene":
        {
            uid: scene.uid
        },

        "locale": this._viewer.i18n.locale
    };

    var currentState = window.history.state;

    if (currentState === null)
    {
        window.history.replaceState(newState, scene.name, this.generateHash(scene));
    }
    else if (currentState.scene.uid !== newState.scene.uid)
    {
        window.history.pushState(newState, scene.name, this.generateHash(scene));
    }
};

/**
 * Update the current state with the correct slug name.
 * @method FORGE.History#_updateState
 * @private
 */
FORGE.History.prototype._updateState = function()
{
    this.log("_updateState");

    var currentState = /** @type {Object} */ (window.history.state);

    if (this._isStateValid(currentState))
    {
        var scene = FORGE.UID.get(currentState.scene.uid);
        currentState.locale = this._viewer.i18n.locale;
        window.history.replaceState(currentState, scene.name, this.generateHash( /** @type {FORGE.Scene} */ (scene)));
    }
};

/**
 * Internal handler for browser pop state event.<br>
 * This event occur when user click on back or next browser buttons.
 * @param  {Event} event - The pop state event.
 * @private
 */
FORGE.History.prototype._onPopStateHandler = function(event)
{
    if (event.state === null)
    {
        return;
    }

    var viewer = FORGE.UID.get(event.state.viewer.uid);

    viewer.history.log("_onPopStateHandler");

    viewer.story.scene = event.state.scene.uid;
};

/**
 * Method to check if a state is valid for the history module.
 * @param  {Object}  state - The state to check.
 * @return {boolean} Returns true if the state is valid, false if not.
 * @private
 */
FORGE.History.prototype._isStateValid = function(state)
{
    if (state === null)
    {
        return false;
    }

    var viewerValid = (typeof state.viewer !== "undefined" && typeof state.viewer.uid === "string");
    var sceneValid = (typeof state.scene !== "undefined" && typeof state.scene.uid === "string");

    return (viewerValid === true && sceneValid === true);
};

/**
 * Generate a hash for the current scene with the i18n slug name and the scene uid.
 * @method FORGE.History#generateHash
 * @param  {FORGE.Scene|Object} scene - The scene for which you want to generate a hash.
 * @param {boolean} [keep=true] - Do we have to keep the existing URL parameters.
 * @return {string} The generated hash.
 */
FORGE.History.prototype.generateHash = function(scene, keep)
{
    // Search for other parameters in URL, beside the UID
    var result = "";

    // Keep others parameters
    if(keep !== false)
    {
        var hash = window.location.hash;

        // get all slugs
        var slugs = this._viewer.story.scenes.map(function(s)
        {
            return s.slug;
        });

        // result for normal URL querystring
        var re = /[&#]([^&]+)/g;
        var rr;
        while ((rr = re.exec(hash)) !== null)
        {
            if (rr[1].substr(0, 3) !== "uid" && !slugs.includes(rr[1]))
            {
                result += "&" + rr[1];
            }
        }
    }

    return "#" + scene.slug + "&uid=" + scene.uid + result;
};

/**
 * Add the history configuration.
 * @method FORGE.History#addConfig
 * @param {HistoryConfig} config - The configuration to add
 */
FORGE.History.prototype.addConfig = function(config)
{
    this._parseConfig(config);
};

/**
 * Destroy sequence.
 * @method FORGE.History#destroy
 */
FORGE.History.prototype.destroy = function()
{
    this._disable();

    this._viewer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the enbled flag value of the history.
 * @name FORGE.History#enabled
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.History.prototype, "enabled",
{
    /** @this {FORGE.History} */
    get: function()
    {
        return this._enabled;
    }
});

/**
 * Manager for the locales.
 *
 * @constructor  FORGE.LocaleManager
 * @param {FORGE.Viewer} viewer - Reference to the FORGE.Viewer.
 * @extends {FORGE.BaseObject}
 *
 * @todo Take into account that several configs could be loaded over time
 * @todo Find a behavior for default btw viewer config & story config & plugins config ... into parse config method
 * @todo Separate load events from request and complete
 * @todo Test to embed HTML with special characters like "" and ''
 */
FORGE.LocaleManager = function(viewer)
{
    /**
     * Viewer reference.
     * @name FORGE.LocaleManager#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The configuration data for locales.
     * @name FORGE.LocaleManager#_config
     * @type {?I18nConfig}
     * @private
     */
    this._config = null;

    /**
     * List of locales.
     * @name FORGE.LocaleManager#_locales
     * @type {FORGE.Collection}
     * @private
     */
    this._locales = null;

    /**
     * The current locale index.
     * @name FORGE.LocaleManager#_localeIndex
     * @type {number}
     * @private
     */
    this._localeIndex = -1;

    /**
     * The default locale index.
     * Set once for all viewer data.
     * @name FORGE.LocaleManager#_defaultLocale
     * @type {string}
     * @private
     */
    this._defaultLocale = "";

    /**
     * Is i18n enabled?
     * Set once for all viewer data.
     * @name FORGE.LocaleManager#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * On local change event dispatcher.
     * @name  FORGE.LocaleManager#_onLocaleChangeRequest
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLocaleChangeRequest = null;

    /**
     * On local change completed event dispatcher.
     * @name  FORGE.LocaleManager#_onLocaleChangeComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLocaleChangeComplete = null;

    FORGE.BaseObject.call(this, "LocaleManager");

    this._boot();
};

FORGE.LocaleManager.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.LocaleManager.prototype.constructor = FORGE.LocaleManager;

/**
 * Boot sequence for viewer only.
 * @method FORGE.LocaleManager#_boot
 * @private
 */
FORGE.LocaleManager.prototype._boot = function()
{
    this.log("FORGE.LocaleManager._boot();");

    this._locales = new FORGE.Collection();
};

/**
 * Add i18n configuration data.
 * @method FORGE.LocaleManager#addConfig
 * @param {I18nConfig} config - The configuration data.
 */
FORGE.LocaleManager.prototype.addConfig = function(config)
{
    this._parseConfig(config);
};

/**
 * Parse the configuration data of a i18n node.
 * @method FORGE.LocaleManager#_parseConfig
 * @param {I18nConfig} config - The configuration data.
 * @private
 */
FORGE.LocaleManager.prototype._parseConfig = function(config)
{
    this._config = config;

    this._enabled = (typeof config.enabled === "boolean") ? config.enabled : true;

    if (typeof config.auto !== "undefined" && config.auto === true && FORGE.Device.language !== "")
    {
        this._defaultLocale = FORGE.Device.language; //change the default config option
    }
    else if (typeof config.default === "string")
    {
        this._defaultLocale = config.default;
    }

    if (this._enabled === false)
    {
        this.warn("FORGE.LocaleManager: locale management is deactivated");
        return;
    }

    if (typeof config.locales !== "undefined")
    {
        var configLength = config.locales.length;
        var currentLocaleLoaded = false;

        for (var i = 0, ii = configLength; i < ii; i++)
        {
            if (this._addLocale(config.locales[i]) === true)
            {
                currentLocaleLoaded = true;
            }
        }

        // if nothing is loaded, load the first locale found
        if (currentLocaleLoaded === false)
        {
            // set the default locale for the manager only once
            if (this._indexOfLocale(this._defaultLocale) === -1)
            {
                this._defaultLocale = config.locales[0].uid;
            }
            this._setLocaleIndex(this._indexOfLocale(config.locales[0].uid));
        }
    }
};

/**
 * Search index position for a locale.
 * @method FORGE.LocaleManager#_indexOfLocale
 * @param {string} uid - The locale UID.
 * @private
 */
FORGE.LocaleManager.prototype._indexOfLocale = function(uid)
{
    var locale;

    for (var i = 0, ii = this._locales.size; i < ii; i++)
    {
        locale = this._locales.get(i);

        if (locale.uid.toLowerCase() === uid.toLowerCase())
        {
            return i;
        }
    }

    return -1;
};

/**
 * Set the index position for the locale.
 * @method FORGE.LocaleManager#_setLocaleIndex
 * @param {number} index - The locale index.
 * @private
 */
FORGE.LocaleManager.prototype._setLocaleIndex = function(index)
{
    if (index < 0 || index >= this._locales.size)
    {
        throw "The locale you are trying to set doesn't exist";
    }

    if (this._localeIndex === index)
    {
        this.warn("FORGE.LocaleManager: You're trying to set a locale that is already the actual locale");
        return;
    }

    this._localeIndex = index;

    if (this._onLocaleChangeRequest !== null)
    {
        this._onLocaleChangeRequest.dispatch();
    }

    this._locales.get(this._localeIndex).loadFiles();
};

/**
 * Add a locale.
 * @method FORGE.LocaleManager#_addLocale
 * @param {I18nLocaleConfig} config - The configuration data.
 * @return {boolean} The current locale files have been loaded?
 * @private
 */
FORGE.LocaleManager.prototype._addLocale = function(config)
{
    var locale;
    var i = this._indexOfLocale(config.uid);

    if (i === -1)
    {
        locale = new FORGE.Locale(this._viewer);
        locale.onLocaleAllFilesLoaded.add(this._localeAllFilesLoaded, this);

        i = this._locales.add(locale) - 1;
    }
    else
    {
        locale = this._locales.get(i);
    }

    locale.addConfig(config);

    // If this is the current locale in use, load the files
    if (i === this._localeIndex || this._defaultLocale.toLowerCase() === config.uid.toLowerCase())
    {
        locale.loadFiles();

        if (this._localeIndex === -1)
        {
            this._setLocaleIndex(i);
        }

        return true;
    }

    return false;
};

/**
 * Verify if all local files are loaded.
 * @method FORGE.LocaleManager#_localeAllFilesLoaded
 * @private
 */
FORGE.LocaleManager.prototype._localeAllFilesLoaded = function()
{
    this.log("FORGE.LocaleManager._localeAllFilesLoaded();");

    if (this._onLocaleChangeComplete !== null)
    {
        this._onLocaleChangeComplete.dispatch();
    }
};

/**
 * Get value of for a selected locale.
 * @method FORGE.LocaleManager#getValue
 * @param {string} key - The key to get locale data.
 * @param {?string=} jsonKey - The json key to search into a specific file.
 * @return {string} Returns the locale value.
 */
FORGE.LocaleManager.prototype.getValue = function(key, jsonKey)
{
    if (this._localeIndex === -1)
    {
        this.warn("FORGE.LocaleManager: You trying to get a value with no locale selected!");
        return key;
    }

    var value = this._locales.get(this._localeIndex).getValue(key, jsonKey);
    var defaultLocalIndex = this._indexOfLocale(this._defaultLocale);
    if (this._localeIndex !== defaultLocalIndex && defaultLocalIndex !== -1 && value === key)
    {
        //if not found, get the default locale value
        value = this._locales.get(defaultLocalIndex).getValue(key, jsonKey);
    }
    return value;
};

/**
 * Is the selected locale has a value?
 * @method FORGE.LocaleManager#hasValue
 * @param {string} key - The key to get locale data.
 * @param {?string=} jsonKey - The json key to search into a specific file.
 * @return {boolean} Returns true if the locale has a value.
 */
FORGE.LocaleManager.prototype.hasValue = function(key, jsonKey)
{
    if (this._localeIndex === -1)
    {
        return false;
    }

    var available = this._locales.get(this._localeIndex).hasValue(key, jsonKey);
    var defaultLocalIndex = this._indexOfLocale(this._defaultLocale);
    if (this._localeIndex !== defaultLocalIndex && defaultLocalIndex !== -1 && available === false)
    {
        //if not found, return result from the default locale
        available = this._locales.get(defaultLocalIndex).hasValue(key, jsonKey);
    }
    return available;
};

/**
 * Destroy method.
 * @method FORGE.LocaleManager#destroy
 */
FORGE.LocaleManager.prototype.destroy = function()
{
    this._viewer = null;

    if (this._locales !== null)
    {
        for (var i = 0, ii = this._locales.size; i < ii; i++)
        {
            this._locales.get(i).destroy();
        }
        this._locales = null;
    }

    if (this._onLocaleChangeRequest !== null)
    {
        this._onLocaleChangeRequest.destroy();
        this._onLocaleChangeRequest = null;
    }

    if (this._onLocaleChangeComplete !== null)
    {
        this._onLocaleChangeComplete.destroy();
        this._onLocaleChangeComplete = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get and set the locale UID.
 * @name FORGE.LocaleManager#locale
 * @type {string}
 */
Object.defineProperty(FORGE.LocaleManager.prototype, "locale",
{
    /** @this {FORGE.LocaleManager} */
    get: function()
    {
        if (this._localeIndex !== -1)
        {
            return this._locales.get(this._localeIndex).uid;
        }
        else
        {
            return "";
        }
    },

    /** @this {FORGE.LocaleManager} */
    set: function(value)
    {
        var index;

        if (typeof value === "number" && value < this._locales.size)
        {
            index = value;
        }
        else if (typeof value === "string")
        {
            index = this._indexOfLocale(value);
        }

        this._setLocaleIndex(index);
    }

});

/**
 * Get and set the locale index.
 * @name FORGE.LocaleManager#localeIndex
 * @type {number}
 */
Object.defineProperty(FORGE.LocaleManager.prototype, "localeIndex",
{
    /** @this {FORGE.LocaleManager} */
    get: function()
    {
        return this._localeIndex;
    },

    /** @this {FORGE.LocaleManager} */
    set: function(value)
    {
        if (typeof value === "number" && value < this._locales.size)
        {
            this._setLocaleIndex(value);
        }

    }

});

/**
 * Get the current locale object.
 * @name FORGE.LocaleManager#localeObject
 * @readonly
 * @type {FORGE.Locale}
 */
Object.defineProperty(FORGE.LocaleManager.prototype, "localeObject",
{
    /** @this {FORGE.LocaleManager} */
    get: function()
    {
        if (this._localeIndex !== -1)
        {
            return this._locales.get(this._localeIndex);
        }
        else
        {
            return null;
        }
    }
});

/**
 * Get and set the locales UID list.
 * @name FORGE.LocaleManager#locales
 * @type {Array}
 */
Object.defineProperty(FORGE.LocaleManager.prototype, "locales",
{
    /** @this {FORGE.LocaleManager} */
    get: function()
    {
        var locales = [];

        for (var i = 0, ii = this._locales.size; i < ii; i++)
        {
            locales.push(this._locales.get(i).uid);
        }

        return locales;
    }

});

/**
 * Get the "onLocaleChangeRequest" {@link FORGE.EventDispatcher} of the LocaleManager.
 * @name FORGE.LocaleManager#onLocaleChangeRequest
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.LocaleManager.prototype, "onLocaleChangeRequest",
{
    /** @this {FORGE.LocaleManager} */
    get: function()
    {
        if (this._onLocaleChangeRequest === null)
        {
            this._onLocaleChangeRequest = new FORGE.EventDispatcher(this);
        }

        return this._onLocaleChangeRequest;
    }
});

/**
 * Get the "onLocaleChangeComplete" {@link FORGE.EventDispatcher} of the LocaleManager.
 * @name FORGE.LocaleManager#onLocaleChangeComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.LocaleManager.prototype, "onLocaleChangeComplete",
{
    /** @this {FORGE.LocaleManager} */
    get: function()
    {
        if (this._onLocaleChangeComplete === null)
        {
            this._onLocaleChangeComplete = new FORGE.EventDispatcher(this);
        }

        return this._onLocaleChangeComplete;
    }
});

/**
 * Locale string class.
 *
 * @constructor FORGE.LocaleString
 * @param {FORGE.Viewer} viewer {@link FORGE.Viewer} reference.
 * @param {string=} key the i18n key of the locale.
 * @param {string=} jsonKey - The JSON key to search for.
 * @param {string=} defaultStr - The default text to use.
 * @extends {FORGE.BaseObject}
 *
 * @todo Try to make strings that works with a specific key for the cache
 * @todo For example a plugin can declare an exclusive key to work with
 */
FORGE.LocaleString = function(viewer, key, jsonKey, defaultStr)
{
    /**
     * Viewer reference.
     * @name FORGE.LocaleString#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Key of the locale.
     * @name FORGE.LocaleString#_key
     * @type {(string|undefined)}
     * @private
     */
    this._key = key;

    /**
     * JSON file key where to look for the locale.
     * @name FORGE.LocaleString#_jsonKey
     * @type {(string|undefined)}
     * @private
     */
    this._jsonKey = jsonKey;

    /**
     * Default value for the locale string.
     * @name FORGE.LocaleString#_defaultValue
     * @type {(string|undefined)}
     * @private
     */
    this._defaultValue = defaultStr;

    /**
     * Value of the locale.
     * @name FORGE.LocaleString#_value
     * @type {?string}
     * @private
     */
    this._value = null;

    // The current locale
    //this._locale = 0;

    FORGE.BaseObject.call(this, "LocaleString");
};

FORGE.LocaleString.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.LocaleString.prototype.constructor = FORGE.LocaleString;

/**
 * Destroy method.
 * @method FORGE.LocaleString#destroy
 */
FORGE.LocaleString.prototype.destroy = function()
{
    this._viewer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
* Get and set the key of the locale.
* @name FORGE.LocaleString#key
* @type {string}
*/
Object.defineProperty(FORGE.LocaleString.prototype, "key", {

    /** @this {FORGE.LocaleString} */
    get: function ()
    {
        return this._key;
    },

    /** @this {FORGE.LocaleString} */
    set: function (value)
    {
        this._key = value;
    }

});

/**
* Get and set the JSON key of the locale.
* @name FORGE.LocaleString#jsonKey
* @type {string}
*/
Object.defineProperty(FORGE.LocaleString.prototype, "jsonKey", {

    /** @this {FORGE.LocaleString} */
    get: function ()
    {
        return this._jsonKey;
    },

    /** @this {FORGE.LocaleString} */
    set: function (value)
    {
        this._jsonKey = value;
    }

});

/**
* Get the value of the locale.
* @name FORGE.LocaleString#value
* @readonly
* @type {string}
*/
Object.defineProperty(FORGE.LocaleString.prototype, "value", {

    /** @this {FORGE.LocaleString} */
    get: function ()
    {
        // Check if the string is already populated.
        // Check if the locale is ok
        // Populate the string value
        // Return the string value
        // If the string is not found return the key or an empty string ?

        // Is the current locale value is the same than the manager one ?
        /*
        if(this._locale == this._viewer.i18n.locale)
        {

        }
        */

        var locale = this._viewer.i18n.locale;

        // if no locale is selected in the locale manager then return the default value or return the key!
        if(locale === "")
        {
            if(typeof this._defaultValue !== "undefined")
            {
                return this._defaultValue;
            }
            return this._key;
        }

        this._value = this._viewer.i18n.getValue(/** @type {string} */ (this._key), this._jsonKey);

        // if no value are found for the key and a default value exists, return it.
        if (this._value === this._key && typeof this._defaultValue !== "undefined")
        {
            this._value = this._defaultValue;
        }

        return this._value;
    }

});

/**
* Get the loaded status of this locale string for the current locale.
* @name FORGE.LocaleString#loaded
* @readonly
* @type {boolean}
*/
Object.defineProperty(FORGE.LocaleString.prototype, "loaded",
{
    /** @this {FORGE.LocaleString} */
    get: function()
    {
        var value = this._viewer.i18n.getValue(/** @type {string} */ (this._key), this._jsonKey);
        return (typeof value !== "undefined" && value !== this._key);
    }
});

/**
 * Locale.
 * @constructor FORGE.Locale
 * @param {FORGE.Viewer} viewer - The {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 *
 * @todo If you duplicate a plugin, locale file loaded count is superior than file count
 */
FORGE.Locale = function(viewer)
{
    /**
     * Viewer reference.
     * @name FORGE.Locale#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Name of the locale.
     * @name FORGE.Locale#_name
     * @type {string}
     * @private
     */
    this._name = "";

    /**
     * List of the files.
     * @name FORGE.Locale#_files
     * @type {FORGE.Collection}
     * @private
     */
    this._files = null;

    /**
     * On file loaded event dispatcher.
     * @name  FORGE.Locale#onLocaleFileLoaded
     * @type {FORGE.EventDispatcher}
     */
    this.onLocaleFileLoaded = null;

    /**
     * On all files loaded event dispatcher.
     * @name  FORGE.Locale#onLocaleAllFilesLoaded
     * @type {FORGE.EventDispatcher}
     */
    this.onLocaleAllFilesLoaded = null;

    FORGE.BaseObject.call(this, "Locale");

    this._boot();
};

FORGE.Locale.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Locale.prototype.constructor = FORGE.Locale;

/**
 * Boot sequence.
 * @method FORGE.Locale#_boot
 * @private
 */
FORGE.Locale.prototype._boot = function()
{
    this._files = new FORGE.Collection();

    this.onLocaleFileLoaded = new FORGE.EventDispatcher(this);

    this.onLocaleAllFilesLoaded = new FORGE.EventDispatcher(this);
};

/**
 * Add configuration files.
 * @method FORGE.Locale#addConfig
 * @param {I18nLocaleConfig} config - The configuration data.
 */
FORGE.Locale.prototype.addConfig = function(config)
{
    if(typeof config.uid === "string")
    {
        this._uid = config.uid;
    }

    if(this._name === "" && typeof config.name === "string")
    {
        this._name = config.name;
    }

    if(typeof config.files !== "undefined")
    {
        var file;

        for(var i = 0, ii = config.files.length; i < ii; i++)
        {
            file = /** @type I18nLocaleFileConfig */ (config.files[i]);
            if(this._getFileByKey(file.key) === null)
            {
                file.loading = false;
                file.loaded = false;
                this._files.add(file);
            }
        }
    }

    this.log("Locale.addConfig(); number of files : "+this._files.size);
};

/**
 * Load configuration files.
 * @method FORGE.Locale#loadFiles
 */
FORGE.Locale.prototype.loadFiles = function()
{
    if(this._isAllFilesLoaded() === true)
    {
        this.onLocaleAllFilesLoaded.dispatch();
        return true;
    }

    var file;
    for(var i = 0, ii = this._files.size; i < ii; i++)
    {
        file = /** @type {FORGE.File} */ (this._files.get(i));

        if(file.loading === false && file.loaded === false)
        {
            this._loadFile(file);
        }
    }
};

/**
 * Get a file by key.
 * @method FORGE.Locale#_getFileByKey
 * @param {string} key - The key to search for a file.
 * @private
 */
FORGE.Locale.prototype._getFileByKey = function(key)
{
    var file;

    for(var i = 0, ii = this._files.size; i < ii; i++)
    {
        file = this._files.get(i);

        if(file.key === key)
        {
            return file;
        }
    }

    return null;
};

/**
 * Load a file.
 * @method FORGE.Locale#_loadFile
 * @param {FORGE.File} file - The file to load.
 * @private
 */
FORGE.Locale.prototype._loadFile = function(file)
{
    if(file.loading === false && file.loaded === false)
    {
        file.loading = true;
        this._viewer.load.json(file.key, file.url, this._loadFileComplete, this);
    }
};

/**
 * Load of a file is completed.
 * @method FORGE.Locale#_loadFileComplete
 * @param {FORGE.File} file - The file loaded.
 * @private
 */
FORGE.Locale.prototype._loadFileComplete = function(file)
{
    var _file = this._getFileByKey(file.key);
    _file.loading = false; //Loading is ended
    _file.loaded = true; //Load is complete

    this.log("loadFileComplete(); "+_file.key);

    this.onLocaleFileLoaded.dispatch();

    if(this._isAllFilesLoaded() === true)
    {
        this.onLocaleAllFilesLoaded.dispatch();
    }
};

/**
 * Verify if all files are loaded.
 * @method FORGE.Locale#_isAllFilesLoaded
 * @return {boolean} Returns true if all files are loaded.
 * @private
 */
FORGE.Locale.prototype._isAllFilesLoaded = function()
{
    var file;

    for(var i = 0, ii = this._files.size; i < ii; i++)
    {
        file = this._files.get(i);

        if(file.loaded === false)
        {
            return false;
        }
    }

    return true;
};

/**
 * Get the locale value.
 * @method FORGE.Locale#getValue
 * @param {string} key - The key to search for a locale.
 * @param {?string=} jsonKey - The json key to search into a specific file.
 * @return {string} The key to search for a locale.
 */
FORGE.Locale.prototype.getValue = function(key, jsonKey)
{
    var file, json;
    for(var i = 0, ii = this._files.size; i < ii; i++)
    {
        file = this._files.get(i);

        if(this._viewer.cache.has(FORGE.Cache.types.JSON, file.key) === true && (typeof jsonKey === "undefined" || jsonKey === file.key))
        {
            json = this._viewer.cache.get(FORGE.Cache.types.JSON, file.key);

            if(typeof json.data[key] !== "undefined")
            {
                return json.data[key];
            }
        }
    }

    if (typeof jsonKey !== "undefined")
    {
        this.warn("FORGE.Locale: value not found into the specified JSON file, try to find it in all files.");
        this.getValue(key);
    }

    return key;
};

/**
 * Locale has a value?
 * @method FORGE.Locale#hasValue
 * @param {string} key - The key to search for a locale.
 * @param {?string=} jsonKey - The json key to search into a specific file.
 * @return {boolean} Returns true if the locale has a value stored.
 */
FORGE.Locale.prototype.hasValue = function(key, jsonKey)
{
    var file, json;
    for(var i = 0, ii = this._files.size; i < ii; i++)
    {
        file = this._files.get(i);

        if(this._viewer.cache.has(FORGE.Cache.types.JSON, file.key) === true && (typeof jsonKey === "undefined" || jsonKey === file.key))
        {
            json = this._viewer.cache.get(FORGE.Cache.types.JSON, file.key);

            if(typeof json.data[key] !== "undefined")
            {
                return true;
            }
        }
    }

    if (typeof jsonKey !== "undefined")
    {
        this.warn("FORGE.Locale: key not found into the specified JSON file, try to find it in all files.");
        this.hasValue(key);
    }

    return false;
};

/**
 * Get the key of an i18n value.
 * @method  FORGE.Locale#getKey
 * @param  {string} value - The value associated to the key you want.
 * @param  {?string=} jsonKey - The json key to search into a specific file.
 * @return {string|undefined} Returns the key associated to the value if found, undefined if not.
 */
FORGE.Locale.prototype.getKey = function(value, jsonKey)
{
    var file, json;
    for(var i = 0, ii = this._files.size; i < ii; i++)
    {
        file = /** @type {FORGE.File} */ (this._files.get(i));

        if(this._viewer.cache.has(FORGE.Cache.types.JSON, file.key) === true && (typeof jsonKey === "undefined" || jsonKey === file.key))
        {
            json = this._viewer.cache.get(FORGE.Cache.types.JSON, file.key);

            for(var key in json.data)
            {
                if(json.data[key] === value)
                {
                    return key;
                }
            }
        }
    }

    if (typeof jsonKey !== "undefined")
    {
        this.warn("FORGE.Locale: value not found into the specified JSON file, try to find it in all files.");
        this.getKey(value);
    }

    return undefined;
};

/**
 * Destroy method.
 * @method FORGE.Locale#destroy
 */
FORGE.Locale.prototype.destroy = function()
{
    this._viewer = null;
    this._files = null;

    this.onLocaleFileLoaded.destroy();
    this.onLocaleFileLoaded = null;

    this.onLocaleAllFilesLoaded.destroy();
    this.onLocaleAllFilesLoaded = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
* Get the name of the locale.
* @name FORGE.Local#name
* @readonly
* @type {string}
*/
Object.defineProperty(FORGE.Locale.prototype, "name",
{
    /** @this {FORGE.Locale} */
    get: function()
    {
        return this._name;
    }
});

/**
 * Base class for input bindings
 *
 * @constructor FORGE.BaseBinding
 * @param {FORGE.Viewer} viewer - The viewer reference.
 * @param {string} className - The name of the class binding.
 * @param {Object=} context - The context in which you want your callbacks to be executed.
 * @param {string=} name - The name of the binding, can be use as an identifier.
 * @extends {FORGE.BaseObject}
 */
FORGE.BaseBinding = function(viewer, className, context, name)
{
    /**
     * Viewer reference
     * @name  FORGE.BaseBinding#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The context in which we execute down, up and hold callback.
     * @name  FORGE.BaseBinding#_context
     * @type {Object}
     * @private
     */
    this._context = context || this;

    /**
     * The name of the binding, can be usefull if multiple keycodes react for this binding.
     * @name FORGE.BaseBinding#_name
     * @type {string}
     * @private
     */
    this._name = name || "";

    FORGE.BaseObject.call(this, className);
};

FORGE.BaseBinding.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.BaseBinding.prototype.constructor = FORGE.BaseBinding;

/**
 * Destroy sequence.
 * @method FORGE.BaseBinding#destroy
 */
FORGE.BaseBinding.prototype.destroy = function()
{
    this._context = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Gets the name of this BaseBinding.
 * @name FORGE.BaseBinding#name
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.BaseBinding.prototype, "name",
{
    /** @this {FORGE.BaseBinding} */
    get: function()
    {
        return this._name;
    }
});

/**
 * Gets the type of this BaseBinding.
 * @name FORGE.BaseBinding#type
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.BaseBinding.prototype, "type",
{
    /** @this {FORGE.BaseBinding} */
    get: function()
    {
        return this._className;
    }
});

/**
 * Key Binding object that handles keyboard event handlers for a list of keycodes.
 * To use a Key Binding you have to add it to the {@link FORGE.Keyboard}.
 *
 * @constructor FORGE.KeyBinding
 * @param {FORGE.Viewer} viewer - The viewer reference.
 * @param {(Array<number>|number)} keysIn - The key code or array of key codes associated to this KeyBinding.
 * @param {?(Function|string|Array<string>)=} down - The callback function that will be called on a keydown event.
 * @param {?(Function|string|Array<string>)=} up - The callback function that will be called on a keyup event.
 * @param {?(Function|string|Array<string>)=} hold - The callback function that will be called if a key down is hold.
 * @param {?(Array<number>|number)=} keysOut - The key code or array of key codes that will be rejected if this KeyBinding is pressed.
 * @param {Object=} context - The context in which you want your "down", "hold" & up callbacks to execute
 * @param {string=} name - The name of the binding, can be use as an identifier.
 * @extends {FORGE.BaseBinding}
 */
FORGE.KeyBinding = function(viewer, keysIn, down, up, hold, keysOut, context, name)
{
    /**
     * The key code or array of key codes associated to this KeyBinding.
     * @name FORGE.KeyBinding#_keysIn
     * @type {?(Array<number>|number)}
     * @private
     */
    this._keysIn = keysIn;

    /**
     * The callback function that will be called on a keydown event.
     * @name FORGE.KeyBinding#_down
     * @type {?(Function|string|Array<string>)}
     * @private
     */
    this._down = down || null;

    /**
     * The callback function that will be called on a keyup event.
     * @name FORGE.KeyBinding#_up
     * @type {?(Function|string|Array<string>)}
     * @private
     */
    this._up = up || null;

    /**
     * The callback function that will be called if a key down is holded.
     * @name FORGE.KeyBinding#_hold
     * @type {?(Function|string|Array<string>)}
     * @private
     */
    this._hold = hold || null;

    /**
     * The key code or array of key codes that will be rejected if this KeyBinding is pressed.
     * @name FORGE.KeyBinding#_keysOut
     * @type {?(Array<number>|number|undefined)}
     * @private
     */
    this._keysOut = keysOut;

    /**
     * Flag to know if we have to wait to consider a down event as a holded one.
     * @name FORGE.KeyBinding#_waitToHold
     * @type {boolean}
     * @private
     */
    this._waitToHold = false;

    /**
     * Flag to know if we have this key binding is considered as pressed.<br>
     * It should be pressed if any of keysIn are pressed.
     * @name FORGE.KeyBinding#_pressed
     * @type {boolean}
     * @private
     */
    this._pressed = false;

    /**
     * When a key binding have to wait to be considered as holded this flag is check to know if down action is complete.
     * @name FORGE.KeyBinding#_downComplete
     * @type {boolean}
     * @private
     */
    this._downComplete = false;

    /**
     * Count of down.
     * @name FORGE.KeyBinding#_downCount
     * @type {number}
     * @private
     */
    this._downCount = 0;

    /**
     * Count of hold.
     * @name FORGE.KeyBinding#_holdCount
     * @type {number}
     * @private
     */
    this._holdCount = 0;

    /**
     * Count of up.
     * @name FORGE.KeyBinding#_upCount
     * @type {number}
     * @private
     */
    this._upCount = 0;

    /**
     * Action event dispatcher for down action
     * @name FORGE.KeyBinding#_downActionEventDispatcher
     * @type {?FORGE.ActionEventDispatcher}
     * @private
     */
    this._downActionEventDispatcher = null;

    /**
     * Action event dispatcher for hold action
     * @name FORGE.KeyBinding#_holdActionEventDispatcher
     * @type {?FORGE.ActionEventDispatcher}
     * @private
     */
    this._holdActionEventDispatcher = null;

    /**
     * Action event dispatcher for up action
     * @name FORGE.KeyBinding#_upActionEventDispatcher
     * @type {?FORGE.ActionEventDispatcher}
     * @private
     */
    this._upActionEventDispatcher = null;

    FORGE.BaseBinding.call(this, viewer, "KeyBinding", context, name);

    this._boot();
};

FORGE.KeyBinding.prototype = Object.create(FORGE.BaseBinding.prototype);
FORGE.KeyBinding.prototype.constructor = FORGE.KeyBinding;

/**
 * Boot sequence
 * @method FORGE.KeyBinding#_boot
 */
FORGE.KeyBinding.prototype._boot = function()
{
    if (typeof this._keysIn === "undefined" || this._keysIn === null)
    {
        this._keysIn = [];
    }

    if (typeof this._keysOut === "undefined")
    {
        this._keysOut = null;
    }

    if (FORGE.Utils.isTypeOf(this._down, "string") === true || FORGE.Utils.isArrayOf(this._down, "string"))
    {
        this._downActionEventDispatcher = new FORGE.ActionEventDispatcher(this._viewer, "onDown");
        this._downActionEventDispatcher.addActions( /** @type {(string|Array<string>)} */ (this._down));
    }

    if (FORGE.Utils.isTypeOf(this._hold, "string") === true || FORGE.Utils.isArrayOf(this._hold, "string"))
    {
        this._holdActionEventDispatcher = new FORGE.ActionEventDispatcher(this._viewer, "onHold");
        this._holdActionEventDispatcher.addActions( /** @type {(string|Array<string>)} */ (this._hold));
    }

    if (FORGE.Utils.isTypeOf(this._up, "string") === true || FORGE.Utils.isArrayOf(this._up, "string"))
    {
        this._upActionEventDispatcher = new FORGE.ActionEventDispatcher(this._viewer, "onUp");
        this._upActionEventDispatcher.addActions( /** @type {(string|Array<string>)} */ (this._up));
    }
};

/**
 * Know if a key code is associated to this KeyBinding.
 * @method FORGE.KeyBinding#hasKeyIn
 * @param  {number}  keyCode The key code you want to know if it is associated to this KeyBinding.
 * @return {boolean} Returns true if the keycode is associated as a key in to this KeyBinding.
 */
FORGE.KeyBinding.prototype.hasKeyIn = function(keyCode)
{
    if (typeof this._keysIn === "number" && this._keysIn === keyCode)
    {
        return true;
    }
    else if (typeof this._keysIn.indexOf === "function")
    {
        return this._keysIn.indexOf(keyCode) !== -1;
    }

    return false;
};

/**
 * Know if a key code is considered as a key out for this KeyBinding.
 * @method FORGE.KeyBinding#hasKeyOut
 * @param  {number}  keyCode The key code you want to know if it is considered as a key out for this KeyBinding.
 * @return {boolean} Returns true if the key code is considered as a key out for this KeyBinding.
 */
FORGE.KeyBinding.prototype.hasKeyOut = function(keyCode)
{
    if (this._keysOut === null)
    {
        return false;
    }
    else if (typeof this._keysOut === "number" && this._keysOut === keyCode)
    {
        return true;
    }
    else if (typeof this._keysOut.indexOf === "function")
    {
        return this._keysOut.indexOf(keyCode) !== -1;
    }

    return false;
};

/**
 * This method is called by the {@link FORGE.Keyboard} when a key down event is applied.<br>
 * This triggers the down callback associated to this KeyBinding and increase the downCount value.
 * @param {KeyboardEvent} event - The keyboardEvent from the keydown user action.
 * @method FORGE.KeyBinding#down
 */
FORGE.KeyBinding.prototype.down = function(event)
{
    this.log("down");

    this._downCount++;
    this._pressed = true;

    if (typeof this._down === "function")
    {
        //Call the callback with a reference to this binding + the original event.
        this._down.call(this._context, this, event);
    }
    else if (this._downActionEventDispatcher !== null)
    {
        this._downActionEventDispatcher.dispatch();
    }
};

/**
 * This method has to be called by the user down callback to specify that the key down have to wait to be considered as holded.<br>
 * This gives in return a callback to set the down as complete.
 * @method FORGE.KeyBinding#waitToHold
 * @return {Function} Returns a callback function that the user have to call to set the down as complete to allow hold.
 */
FORGE.KeyBinding.prototype.waitToHold = function()
{
    this._waitToHold = true;

    var _downCount = this._downCount;

    var downCompleteCallback = function()
    {
        this.log("downCompleteCallback " + _downCount + " " + this._downCount);

        if (_downCount === this._downCount)
        {
            this._downComplete = true;
        }
    };

    return downCompleteCallback.bind(this);
};

/**
 * This method is called by the {@link FORGE.Keyboard} when a key up event is applied.<br>
 * This triggers the up callback associated to this KeyBinding and increase the upCount value.
 * @param {KeyboardEvent} event - The keyboardEvent from the keyup user action.
 * @method FORGE.KeyBinding#up
 */
FORGE.KeyBinding.prototype.up = function(event)
{
    this.log("up");

    this._upCount++;
    this._pressed = false;
    this._downComplete = false;

    if (typeof this._up === "function")
    {
        //Call the callback with a reference to this binding + the original event.
        this._up.call(this._context, this, event);
    }
    else if (this._upActionEventDispatcher !== null)
    {
        this._upActionEventDispatcher.dispatch();
    }
};

/**
 * This method is called by the {@link FORGE.Keyboard} when a key hold event is applied.<br>
 * This triggers the hold callback associated to this KeyBinding and increase the holdCount value.
 * @method FORGE.KeyBinding#hold
 */
FORGE.KeyBinding.prototype.hold = function()
{
    this.log("hold");

    this._holdCount++;

    if (typeof this._hold === "function")
    {
        this._hold.call(this._context, this);
    }
    else if (this._holdActionEventDispatcher !== null)
    {
        this._holdActionEventDispatcher.dispatch();
    }
};

/**
 * Destroy sequence.
 * @method  FORGE.KeyBinding#destroy
 */
FORGE.KeyBinding.prototype.destroy = function()
{
    this._keysIn = null;
    this._down = null;
    this._up = null;
    this._hold = null;
    this._keysOut = null;

    if (this._downActionEventDispatcher !== null)
    {
        this._downActionEventDispatcher.destroy();
        this._downActionEventDispatcher = null;
    }

    if (this._holdActionEventDispatcher !== null)
    {
        this._holdActionEventDispatcher.destroy();
        this._holdActionEventDispatcher = null;
    }

    if (this._upActionEventDispatcher !== null)
    {
        this._upActionEventDispatcher.destroy();
        this._upActionEventDispatcher = null;
    }

    FORGE.BaseBinding.prototype.destroy.call(this);
};

/**
 * Gets the pressed status of this KeyBinding.
 * @name FORGE.KeyBinding#pressed
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.KeyBinding.prototype, "pressed",
{
    /** @this {FORGE.KeyBinding} */
    get: function()
    {
        return this._pressed;
    }
});

/**
 * Gets the down count value.
 * @name FORGE.KeyBinding#downCount
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.KeyBinding.prototype, "downCount",
{
    /** @this {FORGE.KeyBinding} */
    get: function()
    {
        return this._downCount;
    }
});

/**
 * Gets the up count value.
 * @name FORGE.KeyBinding#upCount
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.KeyBinding.prototype, "upCount",
{
    /** @this {FORGE.KeyBinding} */
    get: function()
    {
        return this._upCount;
    }
});

/**
 * Gets the hold count value.
 * @name FORGE.KeyBinding#holdCount
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.KeyBinding.prototype, "holdCount",
{
    /** @this {FORGE.KeyBinding} */
    get: function()
    {
        return this._holdCount;
    }
});

/**
 * Gets the hasToWaitToHold value.
 * @name FORGE.KeyBinding#hasToWaitToHold
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.KeyBinding.prototype, "hasToWaitToHold",
{
    /** @this {FORGE.KeyBinding} */
    get: function()
    {
        return this._waitToHold;
    }
});

/**
 * Gets the downComplete value.
 * @name FORGE.KeyBinding#downComplete
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.KeyBinding.prototype, "downComplete",
{
    /** @this {FORGE.KeyBinding} */
    get: function()
    {
        return this._downComplete;
    }
});

/**
 * Button binding object that handles buttons event for a list of buttons.
 * To use a button binding, you have to add it to a {@link FORGE.Gamepad}.
 *
 * @constructor FORGE.ButtonBinding
 * @param {FORGE.Viewer} viewer - the viewer referemce.
 * @param {(Array<number>|number)} buttonsIn - The button code (or array) associated to this binding.
 * @param {?(Function|string|Array<string>)=} down - The callback function that will be called on a button down event.
 * @param {?(Function|string|Array<string>)=} up - The callback function that will be called on a button release event.
 * @param {?(Function|string|Array<string>)=} hold - The callback function that will be called if a button is hold.
 * @param {?(Array<number>|number)=} buttonsOut - The button code (or array) that will be rejected if the button is down.
 * @param {Object=} context - The context in which you want your "down", "hold" & up callbacks to execute.
 * @param {string=} name - The name of the binding, can be use as an identifier.
 * @extends {FORGE.BaseBinding}
 */
FORGE.ButtonBinding = function(viewer, buttonsIn, down, up, hold, buttonsOut, context, name)
{
    /**
     * The button code or array of button codes associated to this ButtonBinding.
     * @name FORGE.ButtonBinding#_buttonsIn
     * @type {?(Array<number>|number)}
     * @private
     */
    this._buttonsIn = buttonsIn;

    /**
     * The callback function that will be called on a button down event.
     * @name FORGE.ButtonBinding#_down
     * @type {?(Function|string|Array<string>)}
     * @private
     */
    this._down = down || null;

    /**
     * The callback function that will be called on a button up event.
     * @name FORGE.ButtonBinding#_up
     * @type {?(Function|string|Array<string>)}
     * @private
     */
    this._up = up || null;

    /**
     * The callback function that will be called if a button is hold.
     * @name FORGE.ButtonBinding#_hold
     * @type {?(Function|string|Array<string>)}
     * @private
     */
    this._hold = hold || null;

    /**
     * The button code or array of button codes that will be rejected if this ButtonBinding is down.
     * @name FORGE.ButtonBinding#_buttonsOut
     * @type {?(Array<number>|number|undefined)}
     * @private
     */
    this._buttonsOut = buttonsOut;

    /**
     * Flag to know if we have to wait to consider a down event as a hold one.
     * @name FORGE.ButtonBinding#_waitToHold
     * @type {boolean}
     * @private
     */
    this._waitToHold = false;

    /**
     * Flag to know if we have this button binding is considered as pressed.<br>
     * It should be pressed if any of buttonsIn are pressed.
     * @name FORGE.ButtonBinding#_pressed
     * @type {boolean}
     * @private
     */
    this._pressed = false;

    /**
     * When a button binding have to wait to be considered as holded this flag is check to know if down action is complete.
     * @name FORGE.ButtonBinding#_downComplete
     * @type {boolean}
     * @private
     */
    this._downComplete = false;

    /**
     * Count of down.
     * @name FORGE.ButtonBinding#_downCount
     * @type {number}
     * @private
     */
    this._downCount = 0;

    /**
     * Count of hold.
     * @name FORGE.ButtonBinding#_holdCount
     * @type {number}
     * @private
     */
    this._holdCount = 0;

    /**
     * Count of up.
     * @name FORGE.ButtonBinding#_upCount
     * @type {number}
     * @private
     */
    this._upCount = 0;

    /**
     * Action event dispatcher for down action
     * @name FORGE.ButtonBinding#_downActionEventDispatcher
     * @type {?FORGE.ActionEventDispatcher}
     * @private
     */
    this._downActionEventDispatcher = null;

    /**
     * Action event dispatcher for hold action
     * @name FORGE.ButtonBinding#_holdActionEventDispatcher
     * @type {?FORGE.ActionEventDispatcher}
     * @private
     */
    this._holdActionEventDispatcher = null;

    /**
     * Action event dispatcher for up action
     * @name FORGE.ButtonBinding#_upActionEventDispatcher
     * @type {?FORGE.ActionEventDispatcher}
     * @private
     */
    this._upActionEventDispatcher = null;

    FORGE.BaseBinding.call(this, viewer, "ButtonBinding", context, name);

    this._boot();
};

FORGE.ButtonBinding.prototype = Object.create(FORGE.BaseBinding.prototype);
FORGE.ButtonBinding.prototype.constructor = FORGE.ButtonBinding;

/**
 * Boot sequence
 * @method FORGE.ButtonBinding#_boot
 */
FORGE.ButtonBinding.prototype._boot = function()
{
    if (typeof this._buttonsIn === "undefined" || this._buttonsIn === null)
    {
        this._buttonsIn = [];
    }

    if (typeof this._buttonsOut === "undefined")
    {
        this._buttonsOut = null;
    }

    if (FORGE.Utils.isTypeOf(this._down, "string") === true || FORGE.Utils.isArrayOf(this._down, "string"))
    {
        this._downActionEventDispatcher = new FORGE.ActionEventDispatcher(this._viewer, "onPressed");
        this._downActionEventDispatcher.addActions( /** @type {(string|Array<string>)} */ (this._down));
    }

    if (FORGE.Utils.isTypeOf(this._hold, "string") === true || FORGE.Utils.isArrayOf(this._hold, "string"))
    {
        this._holdActionEventDispatcher = new FORGE.ActionEventDispatcher(this._viewer, "onHold");
        this._holdActionEventDispatcher.addActions( /** @type {(string|Array<string>)} */ (this._hold));
    }

    if (FORGE.Utils.isTypeOf(this._up, "string") === true || FORGE.Utils.isArrayOf(this._up, "string"))
    {
        this._upActionEventDispatcher = new FORGE.ActionEventDispatcher(this._viewer, "onReleased");
        this._upActionEventDispatcher.addActions( /** @type {(string|Array<string>)} */ (this._up));
    }
};

/**
 * Know if a button is associated to this binding by being in.
 * @method FORGE.ButtonBinding#hasButtonIn
 * @param {number} button - the code of the button to check
 * @return {boolean} true if associated, else false
 */
FORGE.ButtonBinding.prototype.hasButtonIn = function(button)
{
    return this._buttonsIn === button ||
        (typeof this._buttonsIn.indexOf === "function" && this._buttonsIn.indexOf(button) !== -1);
};

/**
 * Know if a button is associated to this binding by being out.
 * @method FORGE.ButtonBinding#hasButtonOut
 * @param {number} button - the code of the button to check
 * @return {boolean} true if associated, else false
 */
FORGE.ButtonBinding.prototype.hasButtonOut = function(button)
{
    return this._buttonsOut !== null &&
        (this._buttonsOut === button ||
            (typeof this._buttonsOut.indexOf === "function" && this._buttonsOut.indexOf(button) !== -1));
};

/**
 * This method is called by the input associated when a button is down. This triggers the
 * down callback associated to this binding and increases the downCount value.
 * @method FORGE.ButtonBinding#down
 * @param {number} value - the value of the button
 */
FORGE.ButtonBinding.prototype.down = function(value)
{
    this.log("down");

    this._pressed = true;
    this._downCount++;

    if (typeof this._down === "function")
    {
        // Call the callback with a reference to this binding + the original event.
        this._down.call(this._context, this, value);
    }
    else if (this._downActionEventDispatcher !== null)
    {
        this._downActionEventDispatcher.dispatch();
    }
};

/**
 * This method is called by the input associated when a button is hold. This triggers the
 * hold callback associated to this binding and increases the holdCount value.
 * @method FORGE.ButtonBinding#hold
 */
FORGE.ButtonBinding.prototype.hold = function()
{
    this.log("hold");

    this._holdCount++;

    if (typeof this._hold === "function")
    {
        // Call the callback with a reference to this binding + the original event.
        this._hold.call(this._context, this);
    }
    else if (this._holdActionEventDispatcher !== null)
    {
        this._holdActionEventDispatcher.dispatch();
    }
};

/**
 * This method is called by the input associated when a button is up. This triggers the
 * up callback associated to this binding and increases the upCount value.
 * @method FORGE.ButtonBinding#up
 * @param {number} value - the value of the button
 */
FORGE.ButtonBinding.prototype.up = function(value)
{
    this.log("up");

    this._pressed = false;
    this._downComplete = false;
    this._upCount++;

    if (typeof this._up === "function")
    {
        // Call the callback with a reference to this binding + the original event.
        this._up.call(this._context, this, value);
    }
    else if (this._upActionEventDispatcher !== null)
    {
        this._upActionEventDispatcher.dispatch();
    }
};

/**
 * This method has to be called by the user down callback to specify that the button down have to
 * wait to be considered as holded.<br>
 * This gives in return a callback to set the down as complete.
 * @method FORGE.ButtonBinding#waitToHold
 * @return {Function} Returns a callback function that the user have to call to set the down as complete to allow hold.
 */
FORGE.ButtonBinding.prototype.waitToHold = function()
{
    this._waitToHold = true;

    var _downCount = this._downCount;

    var downCompleteCallback = function()
    {
        this.log("downCompleteCallback " + _downCount + " " + this._downCount);

        if (_downCount === this._downCount)
        {
            this._downComplete = true;
        }
    };

    return downCompleteCallback.bind(this);
};

/**
 * Destroy sequence.
 * @method  FORGE.ButtonBinding#destroy
 */
FORGE.ButtonBinding.prototype.destroy = function()
{
    this._buttonsIn = null;
    this._down = null;
    this._up = null;
    this._hold = null;
    this._buttonsOut = null;

    if (this._downActionEventDispatcher !== null)
    {
        this._downActionEventDispatcher.destroy();
        this._downActionEventDispatcher = null;
    }

    if (this._holdActionEventDispatcher !== null)
    {
        this._holdActionEventDispatcher.destroy();
        this._holdActionEventDispatcher = null;
    }

    if (this._upActionEventDispatcher !== null)
    {
        this._upActionEventDispatcher.destroy();
        this._upActionEventDispatcher = null;
    }

    FORGE.BaseBinding.prototype.destroy.call(this);
};

/**
 * Gets the pressed status of this ButtonBinding.
 * @name FORGE.ButtonBinding#pressed
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.ButtonBinding.prototype, "pressed",
{
    /** @this {FORGE.ButtonBinding} */
    get: function()
    {
        return this._pressed;
    }
});

/**
 * Gets the down count value.
 * @name FORGE.ButtonBinding#downCount
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.ButtonBinding.prototype, "downCount",
{
    /** @this {FORGE.ButtonBinding} */
    get: function()
    {
        return this._downCount;
    }
});

/**
 * Gets the up count value.
 * @name FORGE.ButtonBinding#upCount
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.ButtonBinding.prototype, "upCount",
{
    /** @this {FORGE.ButtonBinding} */
    get: function()
    {
        return this._upCount;
    }
});

/**
 * Gets the hold count value.
 * @name FORGE.ButtonBinding#holdCount
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.ButtonBinding.prototype, "holdCount",
{
    /** @this {FORGE.ButtonBinding} */
    get: function()
    {
        return this._holdCount;
    }
});

/**
 * Gets the hasToWaitToHold value.
 * @name FORGE.ButtonBinding#hasToWaitToHold
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.ButtonBinding.prototype, "hasToWaitToHold",
{
    /** @this {FORGE.ButtonBinding} */
    get: function()
    {
        return this._waitToHold;
    }
});

/**
 * Gets the downComplete value.
 * @name FORGE.ButtonBinding#downComplete
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.ButtonBinding.prototype, "downComplete",
{
    /** @this {FORGE.ButtonBinding} */
    get: function()
    {
        return this._downComplete;
    }
});

/**
 * Axis binding object that handles axis event for a list of axes.
 * To use an axis binding, you have to add ti to a {@link FORGE.Gamepad}.
 *
 * @constructor FORGE.AxisBinding
 * @param {FORGE.Viewer} viewer - the viewer reference
 * @param {number} axis - the axis code associated to this binding
 * @param {?(Function|string|Array<string>)=} change - the callback function that will be called on an axis changement
 * @param {Object=} context - the context in which you want the callbacks to be executed
 * @param {string=} name - the name of the binding
 * @extends {FORGE.BaseBinding}
 */
FORGE.AxisBinding = function(viewer, axis, change, context, name)
{
    /**
     * The axis code associated to this AxisBinding
     * @name FORGE.AxisBinding#_axis
     * @type {number}
     * @private
     */
    this._axis = axis;

    /**
     * The callback function that will be called on an axis changement
     * @name FORGE.AxisBinding#_change
     * @type {?(Function|string|Array<string>)}
     * @private
     */
    this._change = change || null;

    /**
     * Action event dispatcher for change action
     * @name FORGE.AxisBinding#_changeActionEventDispatcher
     * @type {?FORGE.ActionEventDispatcher}
     * @private
     */
    this._changeActionEventDispatcher = null;

    FORGE.BaseBinding.call(this, viewer, "AxisBinding", context, name);

    this._boot();
};

FORGE.AxisBinding.prototype = Object.create(FORGE.BaseBinding.prototype);
FORGE.AxisBinding.prototype.constructor = FORGE.AxisBinding;

/**
 * Boot sequence
 * @method FORGE.AxisBinding#_boot
 */
FORGE.AxisBinding.prototype._boot = function()
{
    if (FORGE.Utils.isTypeOf(this._change, "string") === true || FORGE.Utils.isArrayOf(this._change, "string"))
    {
        this._changeActionEventDispatcher = new FORGE.ActionEventDispatcher(this._viewer, "onChange");
        this._changeActionEventDispatcher.addActions( /** @type {(string|Array<string>)} */ (this._change));
    }
};

/**
 * This method is called by the input associated when an axis is changed. This triggers the change
 * callbacks associated to this binding.
 * @method FORGE.AxisBinding#change
 * @param {number} value - the value of the axis
 */
FORGE.AxisBinding.prototype.change = function(value)
{
    this.log("change");

    this._pressed = true;

    if (typeof this._change === "function")
    {
        // Call the callback with a reference to this binding + the original event.
        this._change.call(this._context, this, value);
    }
    else if (this._changeActionEventDispatcher !== null)
    {
        this._changeActionEventDispatcher.dispatch();
    }
};

/**
 * Destroy sequence.
 * @method  FORGE.AxisBinding#destroy
 */
FORGE.AxisBinding.prototype.destroy = function()
{
    this._change = null;

    if (this._changeActionEventDispatcher !== null)
    {
        this._changeActionEventDispatcher.destroy();
        this._changeActionEventDispatcher = null;
    }

    FORGE.BaseBinding.prototype.destroy.call(this);
};


/**
 * Gets the axis associated to this binding.
 * @name FORGE.AxisBinding#axis
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.AxisBinding.prototype, "axis",
{
    /** @this {FORGE.AxisBinding} **/
    get: function()
    {
        return this._axis;
    }
});


/**
 * Keyboard Manager that handles keyboard events and manage {@link FORGE.KeyBinding}s.
 *
 * @constructor FORGE.Keyboard
 * @param {FORGE.Viewer} viewer {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 *
 * @todo  fix keyout for several keybinding on a same keycode but different keysout configuration ?
 */
FORGE.Keyboard = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.Keyboard#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Is the keyboard is enabled?
     * @name FORGE.Keyboard#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * The array that handles the {@link FORGE.KeyBinding} objects.
     * @name FORGE.Keyboard#_keyBindings
     * @type {?Array<FORGE.KeyBinding>}
     * @private
     */
    this._keyBindings = null;

    /**
     * The array that handles the key codes that are considered as pressed.
     * @name FORGE.Keyboard#_keyPressed
     * @type {?Array<number>}
     * @private
     */
    this._keyPressed = null;

    /**
     * This is a copy of key down handler with this as this reference (bind).
     * @name  FORGE.Keyboard#_keyDownBind
     * @type {Function}
     * @private
     */
    this._keyDownBind = null;

    /**
     * This is a copy of key up handler with this as this reference (bind).
     * @name  FORGE.Keyboard#_keyUpBind
     * @type {Function}
     * @private
     */
    this._keyUpBind = null;

    FORGE.BaseObject.call(this, "Keyboard");

    this._boot();
};

FORGE.Keyboard.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Keyboard.prototype.constructor = FORGE.Keyboard;

/**
 * Boot sequence.
 * @method FORGE.Keyboard#_boot
 * @suppress {checkTypes}
 * @private
 */
FORGE.Keyboard.prototype._boot = function()
{
    this._keyBindings = [];
    this._keyPressed = [];

    this._keyDownBind = this._keyDownHandler.bind(this);
    this._keyUpBind = this._keyUpHandler.bind(this);

    window.addEventListener("keydown", this._keyDownBind, false);
    window.addEventListener("keyup", this._keyUpBind, false);
};

/**
 * Event handler for key down, listening on window.<br>
 * This handler is copied in _keyDownBind, for custom this reference.
 * @method FORGE.Keyboard#_keyDownHandler
 * @private
 * @param  {KeyboardEvent} event - the native HTML KeyboardEvent
 */
FORGE.Keyboard.prototype._keyDownHandler = function(event)
{
    this._processKeyDown(event);
};

/**
 * Event handler for key up, listening on window.<br>
 * This handler is copied in _keyUpBind, for custom this reference.
 * @method FORGE.Keyboard#_keyUpHandler
 * @private
 * @param  {KeyboardEvent} event - the native HTML KeyboardEvent
 */
FORGE.Keyboard.prototype._keyUpHandler = function(event)
{
    this._processKeyUp(event);
};

/**
 * Get the index of a KeyBinding.
 * @method FORGE.Keyboard#_indexOfBinding
 * @private
 * @param  {FORGE.KeyBinding|number} value - The KeyBinding or a keyCode (Number).
 * @return {number} Returns the searched index if found, if not, returns -1.
 */
FORGE.Keyboard.prototype._indexOfBinding = function(value)
{
    if(this._keyBindings === null || this._keyBindings.length === 0)
    {
        return -1;
    }

    if(typeof value === "object" && value.type === "KeyBinding")
    {
        return this._keyBindings.indexOf(value);
    }

    if(typeof value === "number")
    {
        for(var i = 0, ii = this._keyBindings.length; i < ii; i++)
        {
            if(this._keyBindings[i].hasKeyIn(value) === true)
            {
                return i;
            }
        }
    }

    return -1;
};

/**
 * Add a keyCode to the keyPressed array if it's not already in.
 * @method FORGE.Keyboard#_addKeyPressed
 * @private
 * @param {number} keyCode - The keyCode you want to add.
 * @return {boolean} Returns true if it's correctly added, false if it's already in.
 */
FORGE.Keyboard.prototype._addKeyPressed = function(keyCode)
{
    if(this._keyPressed.indexOf(keyCode) === -1)
    {
        this._keyPressed.push(keyCode);
        return true;
    }

    return false;
};

/**
 * Remove a keyCode from the keyPressed array.
 * @method FORGE.Keyboard#_removeKeyPressed
 * @private
 * @param  {number} keyCode - The keyCode you want to remove.
 * @return {boolean} Return true if it's succesfuly removed, false if not found.
 */
FORGE.Keyboard.prototype._removeKeyPressed = function(keyCode)
{
    var index = this._keyPressed.indexOf(keyCode);

    if(index !== -1)
    {
        this._keyPressed.splice(index, 1);
        return true;
    }

    return false;
};

/**
 * Event handler for keydown event.
 * @method FORGE.Keyboard#_processKeyDown
 * @param  {KeyboardEvent} event - The native KeyboardEvent from the down action.
 * @private
 */
FORGE.Keyboard.prototype._processKeyDown = function(event)
{
    if(this._enabled === false)
    {
        return;
    }

    var keyCode = event.keyCode;

    this.log("keyDown "+keyCode);

    if(this._addKeyPressed(keyCode) === true)
    {
        this._applyKeyDown(event);
    }
};

/**
 * If the processed keydown event is valid it's applied by this method.
 * @method FORGE.Keyboard#_applyKeyDown
 * @param  {KeyboardEvent} event - The keyboard event code that has been validated as a pressed key.
 * @private
 */
FORGE.Keyboard.prototype._applyKeyDown = function(event)
{
    var keyCode = event.keyCode;

    if(this.isKeyOut(keyCode) === true)
    {
        return;
    }

    var keyBindings = this.getBindings(keyCode);
    var keyBinding;

    for(var i = 0, ii = keyBindings.length; i < ii; i++)
    {
        keyBinding = keyBindings[i];

        if(keyBinding.pressed === false)
        {
            keyBinding.down(event);
        }
    }
};

/**
 * Event handler for keyup event.
 * @method FORGE.Keyboard#_processKeyUp
 * @param  {KeyboardEvent} event - The native KeyboardEvent from the up action.
 * @private
 */
FORGE.Keyboard.prototype._processKeyUp = function(event)
{
    if(this._enabled === false)
    {
        return;
    }

    var keyCode = event.keyCode;

    this.log("keyUp "+keyCode);

    if(this._removeKeyPressed(keyCode) === true)
    {
        this._applyKeyUp(event);
    }
};

/**
 * If the processed keyup event is valid it's applied by this method.
 * @method FORGE.Keyboard#_applyKeyUp
 * @param  {KeyboardEvent} event - The keyboard event code that has been validated as a released key.
 * @private
 */
FORGE.Keyboard.prototype._applyKeyUp = function(event)
{
    var keyCode = event.keyCode;

    if(this.isKeyOut(keyCode) === true)
    {
        return;
    }

    var keyBindings = this.getBindings(keyCode);
    var keyBinding;

    for(var i = 0, ii = keyBindings.length; i < ii; i++)
    {
        keyBinding = keyBindings[i];

        //Is there any valid keycode down for this keyBinding ?
        //If so, just return and consider this binding still down
        for(var j = 0, jj = this._keyPressed.length; j < jj; j++)
        {
            if(keyBinding.hasKeyIn(this._keyPressed[j]))
            {
                return;
            }
        }

        //If not, execute the up callback for the keybinding
        keyBinding.up(event);

        //When a key is up, activate the down effect for keycodes
        //that were considered as "out" before the key up.
        for(var k = 0, kk = this._keyPressed.length; k < kk; k++)
        {
            if(keyBinding.hasKeyOut(this._keyPressed[k]))
            {
                var keyboardEventInit = {keycode: this._keyPressed[k], ctrlKey: event.ctrlKey, shiftKey: event.shiftKey, altKey: event.altKey};
                var keyboardEvent = new KeyboardEvent("keydown", keyboardEventInit);
                this._applyKeyDown(keyboardEvent);
            }
        }
    }
};

/**
 * Update method called by the viewer main loop.
 * @method FORGE.Keyboard#update
 */
FORGE.Keyboard.prototype.update = function()
{
    var keyBinding;

    for(var i = 0, ii = this._keyBindings.length; i < ii; i++)
    {
        keyBinding = this._keyBindings[i];

        if(keyBinding.pressed === true)
        {
            if(keyBinding.hasToWaitToHold === true && keyBinding.downComplete === false)
            {
                continue;
            }

            keyBinding.hold();
        }
    }
};

/**
 * Ask if a keyCode is in the keyPressed array.
 * @method FORGE.Keyboard#isKeyPressed
 * @param  {number} keyCode - The keyCode you want to know if it's in the keyPressed array.
 * @return {boolean} Returns true if the keyCode is considered as a keyPressed, false if not.
 */
FORGE.Keyboard.prototype.isKeyPressed = function(keyCode)
{
    return this._keyPressed.indexOf(keyCode) !== -1;
};

/**
 * Ask if a keyCode is considered as a keyOut at this time.
 * @method FORGE.Keyboard#isKeyOut
 * @param  {number}  keyCode - The keyCode you want to know if it's a key out.
 * @return {boolean} Returns true if keyCode is considered as a keyOut, false if not.
 */
FORGE.Keyboard.prototype.isKeyOut = function(keyCode)
{
    var keyBinding;

    for(var i = 0, ii = this._keyBindings.length; i < ii; i++)
    {
        keyBinding = this._keyBindings[i];

        if(keyBinding.pressed === true && keyBinding.hasKeyOut(keyCode) === true)
        {
            return true;
        }
    }

    return false;
};

/**
 * Add a KeyBinding to the Keyboard's keyBinding array.
 * @method FORGE.Keyboard#addBinding
 * @param {FORGE.KeyBinding} keyBinding - The FORGE.KeyBinding you want to add.
 * @return {boolean} Returns true if it's correctly added, false if it's already in or if wrong type.
 */
FORGE.Keyboard.prototype.addBinding = function(keyBinding)
{
    if(typeof keyBinding !== "object" && keyBinding.type !== "KeyBinding")
    {
        return false;
    }

    var index = this._indexOfBinding(keyBinding);

    if(index === -1)
    {
        this._keyBindings.push(keyBinding);
        return true;
    }
    else
    {
        this.warn("Trying to add a duplicate key binding on keyboard!");
    }

    return false;
};

/**
 * Remove a {@link FORGE.KeyBinding} from the {@link FORGE.Keyboard} object.
 * @method FORGE.Keyboard#removeBinding
 * @param  {FORGE.KeyBinding|number} keyBinding - A {@link FORGE.KeyBinding} or a Number that represent a key code.
 * @return {boolean} Returns true if it's removed, false if not found.
 */
FORGE.Keyboard.prototype.removeBinding = function(keyBinding)
{
    var index = this._indexOfBinding(keyBinding);

    if(index !== -1)
    {
        this._keyBindings[index].destroy();
        this._keyBindings.splice(index, 1);
        return true;
    }

    return false;
};

/**
 * Know if the keyboard has a KeyBinding Object or if there already one for a key code.
 * @method FORGE.KeyBoard#hasBinding
 * @param  {FORGE.KeyBinding}  value - A FORGE.KeyBinding Object or a key code.
 * @return {boolean} Returns true if a KeyBinding is found, false if not.
 */
FORGE.Keyboard.prototype.hasBinding = function(value)
{
    return this._indexOfBinding(value) !== -1;
};

/**
 * Get a {@link FORGE.KeyBinding} associated to a key code.
 * @method  FORGE.Keyboard#getBindings
 * @param  {number} keyCode - The key code for which you search a {@link FORGE.KeyBinding}.
 * @return {Array<FORGE.KeyBinding>} Returns a {@link FORGE.KeyBinding} object if found, null if not.
 */
FORGE.Keyboard.prototype.getBindings = function(keyCode)
{
    var bindings = [];

    for(var i = 0, ii = this._keyBindings.length; i < ii; i++)
    {
        if(this._keyBindings[i].hasKeyIn(keyCode) === true)
        {
            bindings.push(this._keyBindings[i]);
        }
    }

    return bindings;
};

/**
 * Destroy sequence.
 * @method FORGE.Keyboard#destroy
 */
FORGE.Keyboard.prototype.destroy = function()
{
    this._viewer = null;

    window.removeEventListener("keydown", this._keyDownBind, false);
    window.removeEventListener("keyup", this._keyUpBind, false);

    var i = this._keyBindings.length;
    while(i--)
    {
        this.removeBinding(this._keyBindings[i]);
    }
    this._keyBindings = null;

    this._keyDownBind = null;
    this._keyUpBind = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Gets or sets the enabled status of the keyboard.
 * @name FORGE.Keyboard#enabled
 * @type {boolean}
 */
Object.defineProperty(FORGE.Keyboard.prototype, "enabled",
{
    /** @this {FORGE.Keyboard} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {FORGE.Keyboard} */
    set: function(value)
    {
        this._enabled = Boolean(value);
    }
});


/**
 * Drag manager module
 * @constructor FORGE.Drag
 * @param {FORGE.DisplayObject} displayObject - The display object concerned by the drag.
 * @extends {FORGE.BaseObject}
 *
 * @todo  work also with rectangle for constrain
 */
FORGE.Drag = function(displayObject)
{
    /**
     * The display object taht will be moved during the drag.
     * @name  FORGE.Drag#_displayObject
     * @type {FORGE.DisplayObject}
     * @private
     */
    this._displayObject = displayObject;

    /**
     * The object that will be litening to mouse down.<br>
     * This is the handle object that initiate the drag.<br>
     * By default, this is the same object that the display object. 
     * @name  FORGE.Drag#_handleObject
     * @type {FORGE.DisplayObject}
     * @private
     */
    this._handleObject = displayObject;

    /**
     * Is the drag is enabled ?
     * @name FORGE.Drag#_enabled
     * @type {boolean}
     * @default  false
     * @private
     */
    this._enabled = false;

    /**
     * The display object taht will be used as constrain.
     * @name  FORGE.Drag#_constrain
     * @type {FORGE.DisplayObject}
     * @default  null
     * @private
     */
    this._constrain = null;

    /**
     * The axis constrain.<br>
     * This could be "x" or "y" or "" an empty string will remove the axis constrain.
     * @name  FORGE.Drag#_axis
     * @type {string}
     * @default ""
     * @private
     */
    this._axis = "";

    /**
     * The position of the object on start drag.
     * @name  FORGE.Drag#_startPostion
     * @type {Object}
     * @property {number} x - The x position.
     * @property {number} y - The y position.
     * @default  null
     * @private
     */
    this._startPostion = null;

    /**
     * The last  mouse position during drag.<br>
     * This is used to calculate distances.
     * @name  FORGE.Drag#_lastMousePosition
     * @type {Object}
     * @property {number} x - The x position.
     * @property {number} y - The y position.
     * @default null
     * @private
     */
    this._lastMousePosition = null;

    /**
     * Flag for dragging.
     * @name  FORGE.Drag#_dragging
     * @type {boolean}
     * @default  false
     * @private
     */
    this._dragging = false;

    /**
     * Flag to know if the displayObject have to revert position after drag stop.
     * @name  FORGE.Drag#_revert
     * @type {boolean}
     * @default  false
     * @private
     */
    this._revert = false;

    /**
     * Flag to know if the displayObject is currently reverting its position.
     * @name  FORGE.Drag#_reverting
     * @type {boolean}
     * @default  false
     * @private
     */
    this._reverting = false;

    /**
     * Tween used to revert the dispay object position after drag stops.
     * @name  FORGE.Drag#_revertTween
     * @type {FORGE.Tween}
     * @private
     */
    this._revertTween = null;

    /**
     * The revert duration in milliseconds.
     * @name FORGE.Drag#_revertDuration
     * @type {number}
     * @default 200
     * @private
     */
    this._revertDuration = 200;

    /**
     * This is a backup of the original alpha when alpha is altered during drag.
     * @name  FORGE.Drag#_originalAlpha
     * @type {number}
     * @private
     */
    this._originalAlpha = 1;

    /**
     * This is the alpha that will be applied to the display object during drag.
     * @name FORGE.Drag#_alpha
     * @type {number}
     * @private
     */
    this._alpha = 1;

    /**
     * The revert easing method.
     * @name FORGE.Drag#_revertEasing
     * @type {Function}
     * @default  {@link FORGE.Easing.LINEAR}
     * @private
     */
    this._revertEasing = FORGE.Easing.LINEAR;

    /**
     * On start event dispatcher.
     * @name  FORGE.Drag#_onStart
     * @type {FORGE.EventDispatcher}
     * @default  null
     * @private
     */
    this._onStart = null;

    /**
     * On drag event dispatcher.
     * @name  FORGE.Drag#_onDrag
     * @type {FORGE.EventDispatcher}
     * @default  null
     * @private
     */
    this._onDrag = null;

    /**
     * On stop event dispatcher.
     * @name  FORGE.Drag#_onStop
     * @type {FORGE.EventDispatcher}
     * @default  null
     * @private
     */
    this._onStop = null;

    /**
     * On revert event dispatcher.
     * @name  FORGE.Drag#_onRevert
     * @type {FORGE.EventDispatcher}
     * @default  null
     * @private
     */
    this._onRevert = null;

    FORGE.BaseObject.call(this, "Drag");

    this._boot();
};

FORGE.Drag.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Drag.prototype.constructor = FORGE.Drag;

/**
 * Boot sequence
 * @method FORGE.Drag#_boot
 * @private
 */
FORGE.Drag.prototype._boot = function()
{
    this._alpha = this._displayObject.alpha;
};

/**
 * Set the object that will be the handle object.<br>
 * Sets up mouse events on the handle.
 * @method  FORGE.Drag#_setHandleObject
 * @private
 * @param {FORGE.DisplayObject} displayObject - The {@link FORGE.DisplayObject} that will be the handle.
 */
FORGE.Drag.prototype._setHandleObject = function(displayObject)
{
    if(this._handleObject !== null)
    {
        this._unsetHandleObject();
    }

    this._handleObject = displayObject;

    this._handleObject.pointer.enabled = true;
    this._handleObject.pointer.onPanStart.add(this._panStartHandler, this);
    this._handleObject.pointer.onPanMove.add(this._panMoveHandler, this);
    this._handleObject.pointer.onPanEnd.add(this._panEndHandler, this);
};

/**
 * Unset the handle object.<br>
 * Remove mouse events on the previous handle.
 * @method  FORGE.Drag#_unsetHandleObject
 * @private
 */
FORGE.Drag.prototype._unsetHandleObject = function()
{
    if(this._handleObject !== null)
    {
        this._handleObject.pointer.onPanStart.remove(this._panStartHandler, this);
        this._handleObject.pointer.onPanMove.remove(this._panMoveHandler, this);
        this._handleObject.pointer.onPanEnd.remove(this._panEndHandler, this); 
    }

    this._handleObject = null;
};

/**
 * Internal pan start handler, this event is on the handle object.
 * 
 * @method  FORGE.Drag#_panStartHandler
 * @private
 * @param  {MouseEvent} event - The resulting event object from pan start.
 */
FORGE.Drag.prototype._panStartHandler = function(event)
{
    this.log("_panStartHandler");

    var hammerEvent = event.data;
    var mouseEvent = event.data["srcEvent"];

    //If it is a touch event we need to get the coordinate from the first touch
    if(typeof mouseEvent.touches !== "undefined" && typeof mouseEvent.touches[0] === "object")
    {
        mouseEvent = mouseEvent.touches[0];
    }

    //Cancel the drag if reverting OR if its not the target OR if its start position isn't valid
    if(this._reverting === true || hammerEvent.target !== this._handleObject.dom || this._isPositionValid() === false)
    {
        return;
    }

    this._dragging = true;

    this._startPostion = {x: this._displayObject.x, y: this._displayObject.y};
    
    this._displayObject.top = null;
    this._displayObject.right = null;
    this._displayObject.bottom = null;
    this._displayObject.left = null;

    this._lastMousePosition = {x: mouseEvent.pageX, y: mouseEvent.pageY};

    this._originalAlpha = this._displayObject.alpha;
    this._displayObject.alpha = this._alpha;

    if(this._onStart !== null)
    {
        this._onStart.dispatch();
    }
};

/**
 * Internal pan end handler.
 * @method  FORGE.Drag#_panEndHandler
 * @private
 */
FORGE.Drag.prototype._panEndHandler = function()
{
    this.log("_panEndHandler");

    if(this._dragging !== true)
    {
        return;
    }

    this._dragging = false;

    if(this._onStop !== null)
    {
        this._onStop.dispatch();
    }

    if(this._revert === true && this._revertTween !== null)
    {
        this._reverting = true;
        this._revertTween.to({x: this._startPostion.x, y: this._startPostion.y}, this._revertDuration, this._revertEasing).start();
    }
    else
    {
        this._displayObject.alpha = this._originalAlpha;
    }

    this._startPostion = null;
    
    this._lastMousePosition = null;
};

/**
 * Internal pointer pan move handler.
 *
 * @method  FORGE.Drag#_panMoveHandler
 * @private
 * @param  {MouseEvent} event - The resulting event object from pan move.
 */
FORGE.Drag.prototype._panMoveHandler = function(event)
{
    this.log("_panMoveHandler");

    if(this._dragging !== true)
    {
        return;
    }

    var mouseEvent = event.data["srcEvent"];

    //If it is a touch event we need to get the coordinate from the first touch
    if(typeof mouseEvent.touches !== "undefined" && typeof mouseEvent.touches[0] === "object")
    {
        mouseEvent = mouseEvent.touches[0];
    }

    var position = {x: mouseEvent.pageX, y: mouseEvent.pageY};
    var dx = position.x - this._lastMousePosition.x;
    var dy = position.y - this._lastMousePosition.y;

    this._lastMousePosition = position;

    if(this._constrain !== null)
    {
        var o = this._displayObject.globalOffset; // o = offset
        var po = this._displayObject.parent.globalOffset; // po = parent offset
        var co = this._constrain.globalOffset; // co = constrain offset

        if(this._axis === "" || this._axis === "x")
        {
            if(o.left + dx < co.left)
            {
                this.log("out left");
                this._displayObject.x = Math.abs(po.left - co.left);
            }
            else if(o.left + dx + this._displayObject.pixelWidth > co.left + this._constrain.innerWidth)
            {
                this.log("out right");
                this._displayObject.x = Math.abs(po.left - co.left) + this._constrain.innerWidth - this._displayObject.pixelWidth;
            }
            else
            {
                this._displayObject.x += dx;
            }
        }
        
        if(this._axis === "" || this._axis === "y")
        {
            if(o.top + dy < co.top)
            {
                this.log("out top");
                this._displayObject.y = Math.abs(po.top - co.top);
            }
            else if(o.top + dy + this._displayObject.pixelHeight > co.top + this._constrain.innerHeight)
            {
                this.log("out bottom");
                this._displayObject.y = Math.abs(po.top - co.top) + this._constrain.innerHeight - this._displayObject.pixelHeight;
            }
            else
            {
                this._displayObject.y += dy;
            }
        }
    }
    else
    {
        if(this._axis === "" || this._axis === "x")
        {
            this._displayObject.x += dx;
        }
        
        if(this._axis === "" || this._axis === "y")
        {
            this._displayObject.y += dy;
        }
    }

    if(this._onDrag !== null)
    {
        this._onDrag.dispatch();
    }
};

/**
 * Internal handler for the revert tween complete.
 * @method  FORGE.Drag#_revertCompleteHandler
 * @private
 */
FORGE.Drag.prototype._revertCompleteHandler = function()
{
    this.log("_revertCompleteHandler");

    this._reverting = false;
    this._displayObject.alpha = this._originalAlpha;

    if(this._onRevert !== null)
    {
        this._onRevert.dispatch();
    }
};

/**
 * Helper that check if the display object position is valid.<br>
 * By valid I mean in its constrain if it have one.
 * @method  FORGE.Drag#_isPositionValid
 * @private
 * @return {boolean} Returns true if the current dragged object position is valid, false if not.
 */
FORGE.Drag.prototype._isPositionValid = function()
{
    //If no constrain, the position is always valid.
    if(this._constrain === null)
    {
        return true;
    }

    var o = this._displayObject.globalOffset; // o = offset
    var co = this._constrain.globalOffset; // co = constrain offset

    //Is it out of bound for left, right, top & bottom?
    var left = (o.left < co.left);
    var right = (o.left + this._displayObject.pixelWidth > co.left + this._constrain.innerWidth);
    var top = (o.top < co.top);
    var bottom = (o.top + this._displayObject.pixelHeight > co.top + this._constrain.innerHeight);

    if(left === true || right === true || top === true || bottom === true)
    {
        return false;
    }
        
    return true;
};

/**
 * Enable the drag on its display object
 * @method FORGE.Drag.enable
 */
FORGE.Drag.prototype.enable = function()
{
    this._enabled = true;
    this._setHandleObject(this._handleObject);
};

/**
 * Disable the drag on its display object
 * @method FORGE.Drag.disable
 */
FORGE.Drag.prototype.disable = function()
{
    this._enabled = false;
};

/**
 * Destroy sequence
 * @method FORGE.Drag#destroy
 */
FORGE.Drag.prototype.destroy = function()
{
    this.revert = false; //This unbind events and nullify revertTween

    if(this._onStart !== null)
    {
        this._onStart.destroy();
        this._onStart = null;
    }

    if(this._onDrag !== null)
    {
        this._onDrag.destroy();
        this._onDrag = null;
    }

    if(this._onStop !== null)
    {
        this._onStop.destroy();
        this._onStop = null;
    }

    if(this._onRevert !== null)
    {
        this._onRevert.destroy();
        this._onRevert = null;
    }

    this._handleObject = null;
    this._displayObject = null;
    this._constrain = null;

    this._lastMousePosition = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Enabled flag for the drag module
 * @name FORGE.Drag#enabled
 * @type {boolean} 
 * @default false
 */
Object.defineProperty(FORGE.Drag.prototype, "enabled", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {FORGE.Drag} */
    set: function(value)
    {
        var enabled = Boolean(value);

        if(enabled === true)
        {
            this.enable();
        }
        else
        {
            this.disable();
        }
    }
});

/**
 * Dragging flag for the drag module
 * @name FORGE.Drag#dragging
 * @readonly
 * @type {boolean} 
 */
Object.defineProperty(FORGE.Drag.prototype, "dragging", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        return this._dragging;
    }
});

/**
 * Get and set the handle object
 * @name FORGE.Drag#handle
 * @type {FORGE.DisplayObject} 
 */
Object.defineProperty(FORGE.Drag.prototype, "handle", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        return this._handleObject;
    },

    /** @this {FORGE.Drag} */
    set: function(value)
    {
        this._setHandleObject(value);
    }
});

/**
 * Get and set the constrain object
 * @name FORGE.Drag#constrain
 * @type {FORGE.DisplayObject} 
 * @default  null
 */
Object.defineProperty(FORGE.Drag.prototype, "constrain", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        return this._constrain;
    },

    /** @this {FORGE.Drag} */
    set: function(value)
    {
        this._constrain = value;
    }
});

/**
 * Get the progress of the drag position on its contrain on two axes.<br>
 * If no constrain, this wiil return undefined.
 * @name  FORGE.Drag#progress
 * @readonly
 * @type {Object}
 * @property {number} [x] The progress on x axis between 0 and 1.
 * @property {number} [y] The progress on y axis between 0 and 1.
 */
Object.defineProperty(FORGE.Drag.prototype, "progress", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        if(this._constrain === null)
        {
            return undefined;
        }

        var o = this._displayObject.globalOffset; // o = offset
        var co = this._constrain.globalOffset; // co = constrain offset
        var progressX = (o.left - co.left) / (this._constrain.innerWidth - this._displayObject.pixelWidth);
        var progressY = (o.top - co.top) / (this._constrain.innerHeight - this._displayObject.pixelHeight);
        return {x: progressX, y: progressY};
    }
});

/**
 * Get and set the axis constrains.<br>
 * Values can be "x" or "y".<br>
 * To disable axis constrain, you can set an empty string or anything else.
 * @name FORGE.Drag#axis
 * @type {string} 
 * @default  "empty string"
 */
Object.defineProperty(FORGE.Drag.prototype, "axis", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        return this._axis;
    },

    /** @this {FORGE.Drag} */
    set: function(value)
    {
        if(value === "x" || value === "y")
        {
            this._axis = value;
        }
        else
        {
            this._axis = "";
        }
    }
});

/**
 * Get and set the alpha of the display object during drag
 * Value can be between 0 and 1.
 * @name FORGE.Drag#alpha
 * @type {number} 
 * @default 1
 */
Object.defineProperty(FORGE.Drag.prototype, "alpha", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        return this._alpha;
    },

    /** @this {FORGE.Drag} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._alpha = value;
        }
    }
});

/**
 * Reverting flag for the drag module
 * @name FORGE.Drag#reverting
 * @readonly
 * @type {boolean} 
 */
Object.defineProperty(FORGE.Drag.prototype, "reverting", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        return this._reverting;
    }
});

/**
 * Get and set the revert flag.
 * If revert is at true, the display object will revert its position to its original position after the drag stop.
 * @name FORGE.Drag#revert
 * @type {boolean} 
 * @default  false
 */
Object.defineProperty(FORGE.Drag.prototype, "revert", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        return this._revert;
    },

    /** @this {FORGE.Drag} */
    set: function(value)
    {
        this._revert = Boolean(value);

        if(this._revert === true && this._revertTween === null)
        {
            this._revertTween = new FORGE.Tween(this._displayObject.viewer, this._displayObject);
            this._revertTween.onComplete.add(this._revertCompleteHandler, this);
            this._displayObject.viewer.tween.add(this._revertTween);
        }
        else if(this._revert === false && this._revertTween !== null)
        {
            this._displayObject.viewer.tween.remove(this._revertTween);
            this._revertTween.onComplete.remove(this._revertCompleteHandler, this);
            this._revertTween.destroy();
            this._revertTween = null;
        }
    }
});

/**
 * Get and set the revert duration in milliseconds
 * @name FORGE.Drag#revertDuration
 * @type {number} 
 * @default  200
 */
Object.defineProperty(FORGE.Drag.prototype, "revertDuration", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        return this._revertDuration;
    },

    /** @this {FORGE.Drag} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._revertDuration = value;
        }
    }
});

/**
 * Get and set the revert easing method
 * @name FORGE.Drag#revertEasing
 * @type {Function} 
 * @default FORGE.Easing.LINEAR
 */
Object.defineProperty(FORGE.Drag.prototype, "revertEasing", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        return this._revertEasing;
    },

    /** @this {FORGE.Drag} */
    set: function(value)
    {
        if(typeof value === "function")
        {
            this._revertEasing = value;
        }
    }
});


/**
 * Get the onStart {@link FORGE.EventDispatcher}.
 * @name  FORGE.Drag#onStart
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Drag.prototype, "onStart", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        if(this._onStart === null)
        {
            this._onStart = new FORGE.EventDispatcher(this._displayObject);
        }
        
        return this._onStart;
    }
});

/**
 * Get the onDrag {@link FORGE.EventDispatcher}.
 * @name  FORGE.Drag#onDrag
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Drag.prototype, "onDrag", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        if(this._onDrag === null)
        {
            this._onDrag = new FORGE.EventDispatcher(this._displayObject);
        }
        
        return this._onDrag;
    }
});

/**
 * Get the onStop {@link FORGE.EventDispatcher}.
 * @name  FORGE.Drag#onStop
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Drag.prototype, "onStop", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        if(this._onStop === null)
        {
            this._onStop = new FORGE.EventDispatcher(this._displayObject);
        }
        
        return this._onStop;
    }
});

/**
 * Get the onRevert {@link FORGE.EventDispatcher}.
 * @name  FORGE.Drag#onRevert
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Drag.prototype, "onRevert", 
{
    /** @this {FORGE.Drag} */
    get: function()
    {
        if(this._onRevert === null)
        {
            this._onRevert = new FORGE.EventDispatcher(this._displayObject);
        }
        
        return this._onRevert;
    }
});



/**
 * Pointer input management, work with mouse and touch screen (using Hammer.js)
 * @constructor FORGE.Pointer
 * @param {FORGE.DisplayObject} displayObject - The display object on which you want to listen to pointer events
 * @extends {FORGE.BaseObject}
 *
 * @todo prevent event binding if not supported (ex: prevent pinch if not touch screen)
 */
FORGE.Pointer = function(displayObject)
{
    /**
     * The {@link FORGE.DisplayObject} on which events will be listened.
     * @name FORGE.Pointer#_displayObject
     * @type {FORGE.DisplayObject}
     * @private
     */
    this._displayObject = displayObject;

    /**
     * Enabled flag for pointer module
     * @name  FORGE.Pointer#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = false;

    /**
     * Cursor css string.
     * @name FORGE.Pointer#_cursor
     * @type {string}
     * @private
     */
    this._cursor = FORGE.Pointer.cursors.DEFAULT;

    /**
     * Hammer manager reference.
     * @name FORGE.Pointer#_hammer
     * @type {Hammer.Manager}
     * @private
     */
    this._hammer = null;

    /**
     * Array that keeps reference to listeners.
     * @name FORGE.Pointer#_listeners
     * @type {Array}
     * @private
     */
    this._listeners = [];

    /**
     * Hammer Tap recognizer
     * @name FORGE.Pointer._tap
     * @type {Hammer.Tap}
     * @private
     */
    this._tap = null;

    /**
     * Hammer Double tap recognizer
     * @name FORGE.Pointer._doubleTap
     * @type {Hammer.Tap}
     * @private
     */
    this._doubleTap = null;

    /**
     * Hammer Press recognizer
     * @name FORGE.Pointer._press
     * @type {Hammer.Press}
     * @private
     */
    this._press = null;

    /**
     * Hammer Pan recognizer
     * @name FORGE.Pointer._pan
     * @type {Hammer.Pan}
     * @private
     */
    this._pan = null;

    /**
     * Hammer Pinch recognizer
     * @name FORGE.Pointer._pinch
     * @type {Hammer.Pinch}
     * @private
     */
    this._pinch = null;

    /**
     * Hammer Rotate recognizer
     * @name FORGE.Pointer._rotate
     * @type {Hammer.Rotate}
     * @private
     */
    this._rotate = null;

    /**
     * Hammer Swipe recognizer
     * @name FORGE.Pointer._swipe
     * @type {Hammer.Swipe}
     * @private
     */
    this._swipe = null;

    /**
     * {@link FORGE.EventDispatcher} for the enable event.
     * @name FORGE.Pointer#_onEnable
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onEnable = null;

    /**
     * {@link FORGE.EventDispatcher} for the disable event.
     * @name FORGE.Pointer#_onDisable
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onDisable = null;

    /**
     * {@link FORGE.EventDispatcher} for the tap event.
     * @name FORGE.Pointer#_onTap
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onTap = null; //alias onClick

    /**
     * {@link FORGE.EventDispatcher} for the double tap event.
     * @name FORGE.Pointer#_onDoubleTap
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onDoubleTap = null; //alias onDoubleClick

    /**
     * {@link FORGE.EventDispatcher} for the press start event.
     * @name FORGE.Pointer#_onPressStart
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPressStart = null; //alias onMouseDown

    /**
     * {@link FORGE.EventDispatcher} for the press end event.
     * @name FORGE.Pointer#_onPressEnd
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPressEnd = null; //alias onMouseUp

    /**
     * {@link FORGE.EventDispatcher} for the pan start event.
     * @name FORGE.Pointer#_onPanStart
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPanStart = null;

    /**
     * {@link FORGE.EventDispatcher} for the pan move event.
     * @name FORGE.Pointer#_onPanMove
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPanMove = null;

    /**
     * {@link FORGE.EventDispatcher} for the pan end event.
     * @name FORGE.Pointer#_onPanEnd
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPanEnd = null;

    /**
     * {@link FORGE.EventDispatcher} for the pinch start event.
     * @name FORGE.Pointer#_onPinchStart
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPinchStart = null;

    /**
     * {@link FORGE.EventDispatcher} for the pinch move event.
     * @name FORGE.Pointer#_onPinchMove
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPinchMove = null;

    /**
     * {@link FORGE.EventDispatcher} for the pinch end event.
     * @name FORGE.Pointer#_onPinchEnd
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPinchEnd = null;

    /**
     * {@link FORGE.EventDispatcher} for the rotate start event.
     * @name FORGE.Pointer#_onRotateStart
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onRotateStart = null;

    /**
     * {@link FORGE.EventDispatcher} for the rotate move event.
     * @name FORGE.Pointer#_onRotateMove
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onRotateMove = null;

    /**
     * {@link FORGE.EventDispatcher} for the rotate end event.
     * @name FORGE.Pointer#_onRotateEnd
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onRotateEnd = null;

    /**
     * {@link FORGE.EventDispatcher} for the swipe event.
     * @name FORGE.Pointer#_onSwipe
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onSwipe = null;

    /**
     * {@link FORGE.EventDispatcher} for the enter event.
     * @name FORGE.Pointer#_onEnter
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onEnter = null;

    /**
     * {@link FORGE.EventDispatcher} for the leave event.
     * @name FORGE.Pointer#_onLeave
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onLeave = null;

    /**
     * {@link FORGE.EventDispatcher} for the over event.
     * @name FORGE.Pointer#_onOver
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onOver = null;

    /**
     * {@link FORGE.EventDispatcher} for the out event.
     * @name FORGE.Pointer#_onOut
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onOut = null;

    /**
     * {@link FORGE.EventDispatcher} for the move event.
     * @name FORGE.Pointer#_onMove
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onMove = null;

    /**
     * {@link FORGE.EventDispatcher} for the wheel event.
     * @name FORGE.Pointer#_onWheel
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onWheel = null;

    FORGE.BaseObject.call(this, "Pointer");

    this._boot();
};

FORGE.Pointer.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Pointer.prototype.constructor = FORGE.Pointer;

/**
 * Boot sequence
 * @method  FORGE.Pointer#_boot
 * @private
 */
FORGE.Pointer.prototype._boot = function()
{
    //Create a Hammer manager
    this._hammer = new Hammer.Manager(this._displayObject.dom);
    //Disabled by default
    this._hammer.set({ enable: false });
};

/**
 * Get the index of a listener (event + callback + type), internal only.
 * @method FORGE.Pointer#_indexOfListener
 * @private
 * @param  {string} event - The event name ("tap", "swipe", click", "mousedown", "mouseover" ...).
 * @param  {Function} callback - The function that handles the event, this is one of the private function like _tapHandler for tap & click event.
 * @param  {number} type - The type of listener (could be 0 for native or 1 for hammer)
 * @return {number} Returns the index of the reserached listener if found, -1 if not.
 */
FORGE.Pointer.prototype._indexOfListener = function(event, callback, type)
{
    var listener;

    for ( var i = 0, ii = this._listeners.length; i < ii; i++ )
    {
        listener = this._listeners[i];

        if(listener.event === event && listener.callback === callback && listener.type === type)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Add a callback function associated to an event name.
 * @method FORGE.Pointer#_addListener
 * @private
 * @param  {string} event - The event name ("tap", "swipe", click", "mousedown", "mouseover" ...).
 * @param  {Function} callback - The function that handles the event, this is one of the private function like _tapHandler for tap & click event.
 * @param  {number} type - The type of listener (could be 0 for native or 1 for hammer)
 * @return {boolean} Returns true if the listener is successfully added, false if not.
 */
FORGE.Pointer.prototype._addListener = function(event, callback, type)
{
    var index = this._indexOfListener(event, callback, type);

    if(index === -1)
    {
        this._listeners.push({ event: event, callback: callback, type: type });

        if(type === FORGE.Pointer.listenerTypes.NATIVE)
        {
            this._displayObject.dom.addEventListener(event, Hammer.bindFn(callback, this));
        }
        else if(type === FORGE.Pointer.listenerTypes.HAMMER)
        {
            this._hammer.on(event, Hammer.bindFn(callback, this));
        }

        return true;
    }

    return false;
};

/**
 * Remove a lister function associated to an HTML DOM mouse related event name.
 * @method FORGE.Pointer#_removeListener
 * @private
 * @param  {string} event - The event name ("tap", "swipe", click", "mousedown", "mouseover" ...).
 * @param  {Function} callback - The function that handles the event, this is one of the private function like _tapHandler for tap & click event.
 * @param  {number} type - The type of listener (could be 0 for native or 1 for hammer)
 * @return {boolean} Returns true if the listener is successfully removed, false if not.
 */
FORGE.Pointer.prototype._removeListener = function(event, callback, type)
{
    var index = this._indexOfListener(event, callback, type);

    if(index !== -1)
    {
        this._listeners.splice(index, 1);

        if(type === FORGE.Pointer.listenerTypes.NATIVE)
        {
            this._displayObject.dom.removeEventListener(event, callback);
        }
        else if(type === FORGE.Pointer.listenerTypes.HAMMER)
        {
            this._hammer.off(event);
        }

        return true;
    }

    return false;
};

/**
 * Handler to remove event listener on mouse events.
 * @method FORGE.Pointer#_generateDestroyCallback
 * @private
 * @param  {string} event - The event name ("tap", "swipe", click", "mousedown", "mouseover" ...).
 * @param  {Function} callback - The function that handles the event, this is one of the private function like _tapHandler for tap & click event.
 * @param  {number} type - The type of listener (could be 0 for native or 1 for hammer)
 */
FORGE.Pointer.prototype._generateDestroyCallback = function(event, callback, type)
{
    var destroyCallback = function destroyCallback()
    {
        this._removeListener(event, callback, type);
    };

    return destroyCallback;
};

/**
 * Internal handler for the "tap" event.
 * @method FORGE.Pointer#_tapHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._tapHandler = function(event)
{
    if(this._onTap !== null && this._enabled === true)
    {
        this._onTap.dispatch(event);
    }
};

/**
 * Internal handler for the "doubletap" event.
 * @method FORGE.Pointer#_doubleTapHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._doubleTapHandler = function(event)
{
    if(this._onDoubleTap !== null && this._enabled === true)
    {
        this._onDoubleTap.dispatch(event);
    }
};

/**
 * Internal handler for the "pressstart" event.
 * @method FORGE.Pointer#_pressStartHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._pressStartHandler = function(event)
{
    if(this._onPressStart !== null && this._enabled === true)
    {
        this._onPressStart.dispatch(event);
    }
};

/**
 * Internal handler for the "pressend" event.
 * @method FORGE.Pointer#_pressEndHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._pressEndHandler = function(event)
{
    if(this._onPressEnd !== null && this._enabled === true)
    {
        this._onPressEnd.dispatch(event);
    }
};

/**
 * Internal handler for the "panstart" event.
 * @method FORGE.Pointer#_panStartHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._panStartHandler = function(event)
{
    if(this._onPanStart !== null && this._enabled === true)
    {
        this._onPanStart.dispatch(event);
    }
};

/**
 * Internal handler for the "panmove" event.
 * @method FORGE.Pointer#_panMoveHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._panMoveHandler = function(event)
{
    if(this._onPanMove !== null && this._enabled === true)
    {
        this._onPanMove.dispatch(event);
    }
};

/**
 * Internal handler for the "panend" event.
 * @method FORGE.Pointer#_panEndHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._panEndHandler = function(event)
{
    if(this._onPanEnd !== null && this._enabled === true)
    {
        this._onPanEnd.dispatch(event);
    }
};

/**
 * Internal handler for the "pinchstart" event.
 * @method FORGE.Pointer#_pinchStartHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._pinchStartHandler = function(event)
{
    if(this._onPinchStart !== null && this._enabled === true)
    {
        this._onPinchStart.dispatch(event);
    }
};

/**
 * Internal handler for the "pinchmove" event.
 * @method FORGE.Pointer#_pinchMoveHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._pinchMoveHandler = function(event)
{
    if(this._onPinchMove !== null && this._enabled === true)
    {
        this._onPinchMove.dispatch(event);
    }
};

/**
 * Internal handler for the "pinchend" event.
 * @method FORGE.Pointer#_pinchEndHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._pinchEndHandler = function(event)
{
    if(this._onPinchEnd !== null && this._enabled === true)
    {
        this._onPinchEnd.dispatch(event);
    }
};

/**
 * Internal handler for the "rotatestart" event.
 * @method FORGE.Pointer#_rotateStartHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._rotateStartHandler = function(event)
{
    if(this._onRotateStart !== null && this._enabled === true)
    {
        this._onRotateStart.dispatch(event);
    }
};

/**
 * Internal handler for the "rotatemove" event.
 * @method FORGE.Pointer#_rotateMoveHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._rotateMoveHandler = function(event)
{
    if(this._onRotateMove !== null && this._enabled === true)
    {
        this._onRotateMove.dispatch(event);
    }
};

/**
 * Internal handler for the "rotateend" event.
 * @method FORGE.Pointer#_rotateEndHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._rotateEndHandler = function(event)
{
    if(this._onRotateEnd !== null && this._enabled === true)
    {
        this._onRotateEnd.dispatch(event);
    }
};

/**
 * Internal handler for the "swipe" event.
 * @method FORGE.Pointer#_swipeHandler
 * @private
 * @param  {Object} event - The Hammer event.
 */
FORGE.Pointer.prototype._swipeHandler = function(event)
{
    if(this._onSwipe !== null && this._enabled === true)
    {
        this._onSwipe.dispatch(event);
    }
};

/**
 * Internal handler for the "mouseenter" event.
 * @method FORGE.Pointer#_enterHandler
 * @private
 * @param  {MouseEvent} event - The mouse event.
 */
FORGE.Pointer.prototype._enterHandler = function(event)
{
    if(this._onEnter !== null && this._enabled === true)
    {
        this._onEnter.dispatch(event);
    }
};

/**
 * Internal handler for the "mouseleave" event.
 * @method FORGE.Pointer#_leaveHandler
 * @private
 * @param  {Object} event - The mouse event.
 */
FORGE.Pointer.prototype._leaveHandler = function(event)
{
    if(this._onLeave !== null && this._enabled === true)
    {
        this._onLeave.dispatch(event);
    }
};

/**
 * Internal handler for the "mouseover" event.
 * @method FORGE.Pointer#_overHandler
 * @private
 * @param  {Object} event - The mouse event.
 */
FORGE.Pointer.prototype._overHandler = function(event)
{
    if(this._onOver !== null && this._enabled === true)
    {
        this._onOver.dispatch(event);
    }
};

/**
 * Internal handler for the "mouseout" event.
 * @method FORGE.Pointer#_outHandler
 * @private
 * @param  {Object} event - The mouse event.
 */
FORGE.Pointer.prototype._outHandler = function(event)
{
    if(this._onOut !== null && this._enabled === true)
    {
        this._onOut.dispatch(event);
    }
};

/**
 * Internal handler for the "mousemove" event.
 * @method FORGE.Pointer#_moveHandler
 * @private
 * @param  {Object} event - The mouse event.
 */
FORGE.Pointer.prototype._moveHandler = function(event)
{
    if(this._onMove !== null && this._enabled === true)
    {
        this._onMove.dispatch(event);
    }
};

/**
 * Internal handler for the "wheel" event.
 * @method FORGE.Pointer#_wheelHandler
 * @private
 * @param  {Object} event - The mouse event.
 */
FORGE.Pointer.prototype._wheelHandler = function(event)
{
    if(this._onWheel !== null && this._enabled === true)
    {
        this._onWheel.dispatch(event);
    }
};

/**
 * Enable the pointer module
 * @method  FORGE.Pointer#enable
 */
FORGE.Pointer.prototype.enable = function()
{
    if(FORGE.Device.cssPointerEvents === true)
    {
        this._displayObject.dom.style.pointerEvents = "auto";
    }

    this._hammer.set({ enable: true });

    if(this._tap === null)
    {
        this._tap = new Hammer.Tap();
        this._hammer.add(this._tap);
    }

    if(this._doubleTap === null)
    {
        this._doubleTap = new Hammer.Tap({ event: FORGE.Pointer.events.DOUBLE_TAP, taps: 2}).recognizeWith(this._tap);
        this._hammer.add(this._doubleTap);
    }

    if(this._press === null)
    {
        this._press = new Hammer.Press().recognizeWith(this._tap); //{ time: 0 }
        this._hammer.add(this._press);
    }

    if(this._pan === null)
    {
        this._pan = new Hammer.Pan();
        this._hammer.add(this._pan);
    }

    if(this._pinch === null)
    {
        this._pinch = new Hammer.Pinch();
        this._hammer.add(this._pinch);
    }

    if(this._rotate === null)
    {
        this._rotate = new Hammer.Rotate().recognizeWith(this._pinch);
        this._hammer.add(this._rotate);
    }

    if(this._swipe === null)
    {
        this._swipe = new Hammer.Swipe().recognizeWith(this._pan);
        this._hammer.add(this._swipe);
    }

    this._enabled = true;

    if(this._onEnable !== null)
    {
        this._onEnable.dispatch();
    }
};

/**
 * Disable the pointer module
 * @method  FORGE.Pointer#disable
 */
FORGE.Pointer.prototype.disable = function()
{
    if(FORGE.Device.cssPointerEvents === true)
    {
        this._displayObject.dom.style.pointerEvents = "none";
    }

    this._enabled = false;

    this._hammer.set({ enable: false });

    if(this._onDisable !== null)
    {
        this._onDisable.dispatch();
    }
};

/**
 * Destroy sequence
 * @method  FORGE.Pointer#destroy
 */
FORGE.Pointer.prototype.destroy = function()
{
    this.disable();

    this._tap = null;
    this._doubleTap = null;
    this._press = null;
    this._pan = null;
    this._pinch = null;
    this._rotate = null;
    this._swipe = null;

    if(this._onEnable !== null)
    {
        this._onEnable.destroy();
        this._onEnable = null;
    }

    if(this._onDisable !== null)
    {
        this._onDisable.destroy();
        this._onDisable = null;
    }

    if(this._onTap !== null)
    {
        this._onTap.destroy();
        this._onTap = null;
    }

    if(this._onDoubleTap !== null)
    {
        this._onDoubleTap.destroy();
        this._onDoubleTap = null;
    }

    if(this._onPressStart !== null)
    {
        this._onPressStart.destroy();
        this._onPressStart = null;
    }

    if(this._onPressEnd !== null)
    {
        this._onPressEnd.destroy();
        this._onPressEnd = null;
    }

    if(this._onPanStart !== null)
    {
        this._onPanStart.destroy();
        this._onPanStart = null;
    }

    if(this._onPanMove !== null)
    {
        this._onPanMove.destroy();
        this._onPanMove = null;
    }

    if(this._onPanEnd !== null)
    {
        this._onPanEnd.destroy();
        this._onPanEnd = null;
    }

    if(this._onPinchStart !== null)
    {
        this._onPinchStart.destroy();
        this._onPinchStart = null;
    }

    if(this._onPinchMove !== null)
    {
        this._onPinchMove.destroy();
        this._onPinchMove = null;
    }

    if(this._onPinchEnd !== null)
    {
        this._onPinchEnd.destroy();
        this._onPinchEnd = null;
    }

    if(this._onRotateStart !== null)
    {
        this._onRotateStart.destroy();
        this._onRotateStart = null;
    }

    if(this._onRotateMove !== null)
    {
        this._onRotateMove.destroy();
        this._onRotateMove = null;
    }

    if(this._onRotateEnd !== null)
    {
        this._onRotateEnd.destroy();
        this._onRotateEnd = null;
    }

    if(this._onSwipe !== null)
    {
        this._onSwipe.destroy();
        this._onSwipe = null;
    }

    if(this._onEnter !== null)
    {
        this._onEnter.destroy();
        this._onEnter = null;
    }

    if(this._onLeave !== null)
    {
        this._onLeave.destroy();
        this._onLeave = null;
    }

    if(this._onOver !== null)
    {
        this._onOver.destroy();
        this._onOver = null;
    }

    if(this._onOut !== null)
    {
        this._onOut.destroy();
        this._onOut = null;
    }

    if(this._onMove !== null)
    {
        this._onMove.destroy();
        this._onMove = null;
    }

    if(this._onWheel !== null)
    {
        this._onWheel.destroy();
        this._onWheel = null;
    }

    this._displayObject = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the relative mouse position inside the target element of a mouse event
 * @method FORGE.Pointer.getRelativeMousePosition
 * @static
 * @param {MouseEvent} event - The mouse event
 * @return {THREE.Vector2}
 */
FORGE.Pointer.getRelativeMousePosition = function(event)
{
    if(typeof event.target.getBoundingClientRect === "function")
    {
        var rect = event.target.getBoundingClientRect();

        // event.center is part of an Hammer event but it is not set on all kinds of events.
        if(typeof event.center !== "undefined")
        {
            var centerX = event.center.x;
            var centerY = event.center.y;
        }

        var clientX = event.clientX;
        var clientY = event.clientY;
        var pageX = event.pageX;
        var pageY = event.pageY;

        if(typeof event.srcEvent !== "undefined")
        {
            clientX = event.srcEvent.clientX;
            clientY = event.srcEvent.clientY;
            pageX = event.srcEvent.pageX;
            pageY = event.srcEvent.pageY;
        }

        var x = (centerX || clientX || pageX) - rect.left;
        var y = (centerY || clientY || pageY) - rect.top;

        return new THREE.Vector2(x, y);
    }

    return null;
};

/**
* Get or set the enabled flag.
* @name FORGE.Pointer#enabled
* @type {boolean}
*/
Object.defineProperty(FORGE.Pointer.prototype, "enabled",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {FORGE.Pointer} */
    set: function(value)
    {
        if(Boolean(value) === true)
        {
            this.enable();
        }
        else
        {
            this.disable();
        }
    }
});

/**
* Get or set the cursor value.<br>
* Use the constant {@link FORGE.Pointer.cursors} to set a valid cursor.
* @name FORGE.Pointer#cursor
* @type {string}
*/
Object.defineProperty(FORGE.Pointer.prototype, "cursor",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        return this._cursor;
    },

    /** @this {FORGE.Pointer} */
    set: function(value)
    {
        this._displayObject.dom.style.cursor = value;

        //On webkit browsers some cursors have to have -webkit prefix
        //If invalid cursor value, webkit will leave an empty string or the previous value intact.
        if(value !== this._displayObject.dom.style.cursor || this._displayObject.dom.style.cursor === "")
        {
            this._displayObject.dom.style.cursor = "-webkit-"+value;
        }

        this._cursor = value;
    }
});

/**
* Gets the onEnable {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.
* @name FORGE.Pointer#onEnable
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onEnable",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onEnable === null)
        {
            this._onEnable = new FORGE.EventDispatcher(this);
        }

        return this._onEnable;
    }
});

/**
* Gets the onDisable {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.
* @name FORGE.Pointer#onDisable
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onDisable",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onDisable === null)
        {
            this._onDisable = new FORGE.EventDispatcher(this);
        }

        return this._onDisable;
    }
});

/**
* Gets the onTap {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.
* @name FORGE.Pointer#onTap
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onTap",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onTap === null)
        {
            this._onTap = new FORGE.EventDispatcher(this._displayObject);
            this._onTap.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.TAP, this._tapHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.TAP, this._tapHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onTap;
    }
});

/**
* Gets the onClick {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* This is an alias for onTap.
* @name FORGE.Pointer#onClick
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onClick",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        return this.onTap;
    }
});

/**
* Gets the onDoubleTap {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.
* @name FORGE.Pointer#onDoubleTap
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onDoubleTap",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onDoubleTap === null)
        {
            this._onDoubleTap = new FORGE.EventDispatcher(this._displayObject);
            this._onDoubleTap.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.DOUBLE_TAP, this._doubleTapHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.DOUBLE_TAP, this._doubleTapHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onDoubleTap;
    }
});

/**
* Gets the onDoubleClick {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* This is an alias for onDoubleTap.
* @name FORGE.Pointer#onDoubleClick
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onDoubleClick",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        return this.onDoubleTap;
    }
});

/**
* Gets the onPressStart {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onPressStart
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onPressStart",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onPressStart === null)
        {
            this._onPressStart = new FORGE.EventDispatcher(this._displayObject);
            this._onPressStart.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.PRESS_START, this._pressStartHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.PRESS_START, this._pressStartHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onPressStart;
    }
});

/**
* Gets the onDown {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* This is an alias for onPressStart.
* @name FORGE.Pointer#onDown
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onDown",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        return this.onPressStart;
    }
});

/**
* Gets the onPressEnd {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onPressEnd
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onPressEnd",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onPressEnd === null)
        {
            this._onPressEnd = new FORGE.EventDispatcher(this._displayObject);
            this._onPressEnd.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.PRESS_END, this._pressEndHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.PRESS_END, this._pressEndHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onPressEnd;
    }
});

/**
* Gets the onUp {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* This is an alias for onPressEnd.
* @name FORGE.Pointer#onUp
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onUp",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        return this.onPressEnd;
    }
});

/**
* Gets the onPanStart {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onPanStart
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onPanStart",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onPanStart === null)
        {
            this._onPanStart = new FORGE.EventDispatcher(this._displayObject);
            this._onPanStart.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.PAN_START, this._panStartHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.PAN_START, this._panStartHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onPanStart;
    }
});

/**
* Gets the onPanMove {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onPanMove
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onPanMove",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onPanMove === null)
        {
            this._onPanMove = new FORGE.EventDispatcher(this._displayObject);
            this._onPanMove.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.PAN_MOVE, this._panMoveHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.PAN_MOVE, this._panMoveHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onPanMove;
    }
});

/**
* Gets the onPanEnd {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onPanEnd
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onPanEnd",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onPanEnd === null)
        {
            this._onPanEnd = new FORGE.EventDispatcher(this._displayObject);
            this._onPanEnd.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.PAN_END, this._panEndHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.PAN_END, this._panEndHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onPanEnd;
    }
});

/**
* Gets the onPinchStart {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onPinchStart
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onPinchStart",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onPinchStart === null)
        {
            this._onPinchStart = new FORGE.EventDispatcher(this._displayObject);
            this._onPinchStart.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.PINCH_START, this._pinchStartHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.PINCH_START, this._pinchStartHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onPinchStart;
    }
});

/**
* Gets the onPinchMove {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onPinchMove
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onPinchMove",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onPinchMove === null)
        {
            this._onPinchMove = new FORGE.EventDispatcher(this._displayObject);
            this._onPinchMove.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.PINCH_MOVE, this._pinchMoveHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.PINCH_MOVE, this._pinchMoveHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onPinchMove;
    }
});

/**
* Gets the onPinchEnd {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onPinchEnd
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onPinchEnd",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onPinchEnd === null)
        {
            this._onPinchEnd = new FORGE.EventDispatcher(this._displayObject);
            this._onPinchEnd.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.PINCH_END, this._pinchEndHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.PINCH_END, this._pinchEndHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onPinchEnd;
    }
});

/**
* Gets the onRotateStart {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onRotateStart
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onRotateStart",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onRotateStart === null)
        {
            this._onRotateStart = new FORGE.EventDispatcher(this._displayObject);
            this._onRotateStart.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.ROTATE_START, this._rotateStartHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.ROTATE_START, this._rotateStartHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onRotateStart;
    }
});

/**
* Gets the onRotateMove {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onRotateMove
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onRotateMove",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onRotateMove === null)
        {
            this._onRotateMove = new FORGE.EventDispatcher(this._displayObject);
            this._onRotateMove.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.ROTATE_MOVE, this._rotateMoveHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.ROTATE_MOVE, this._rotateMoveHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onRotateMove;
    }
});

/**
* Gets the onRotateEnd {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onRotateEnd
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onRotateEnd",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onRotateEnd === null)
        {
            this._onRotateEnd = new FORGE.EventDispatcher(this._displayObject);
            this._onRotateEnd.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.ROTATE_END, this._rotateEndHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.ROTATE_END, this._rotateEndHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onRotateEnd;
    }
});

/**
* Gets the onSwipe {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onSwipe
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onSwipe",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onSwipe === null)
        {
            this._onSwipe = new FORGE.EventDispatcher(this._displayObject);
            this._onSwipe.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.SWIPE, this._swipeHandler, FORGE.Pointer.listenerTypes.HAMMER), this );
            this._addListener(FORGE.Pointer.events.SWIPE, this._swipeHandler, FORGE.Pointer.listenerTypes.HAMMER);
        }

        return this._onSwipe;
    }
});

/**
* Gets the onEnter {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onEnter
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onEnter",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onEnter === null)
        {
            this._onEnter = new FORGE.EventDispatcher(this._displayObject);
            this._onEnter.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.ENTER, this._enterHandler, FORGE.Pointer.listenerTypes.NATIVE), this );
            this._addListener(FORGE.Pointer.events.ENTER, this._enterHandler, FORGE.Pointer.listenerTypes.NATIVE);
        }

        return this._onEnter;
    }
});

/**
* Gets the onLeave {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onLeave
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onLeave",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onLeave === null)
        {
            this._onLeave = new FORGE.EventDispatcher(this._displayObject);
            this._onLeave.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.LEAVE, this._leaveHandler, FORGE.Pointer.listenerTypes.NATIVE), this );
            this._addListener(FORGE.Pointer.events.LEAVE, this._leaveHandler, FORGE.Pointer.listenerTypes.NATIVE);
        }

        return this._onLeave;
    }
});

/**
* Gets the onOver {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onOver
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onOver",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onOver === null)
        {
            this._onOver = new FORGE.EventDispatcher(this._displayObject);
            this._onOver.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.OVER, this._overHandler, FORGE.Pointer.listenerTypes.NATIVE), this );
            this._addListener(FORGE.Pointer.events.OVER, this._overHandler, FORGE.Pointer.listenerTypes.NATIVE);
        }

        return this._onOver;
    }
});

/**
* Gets the onOut {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onOut
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onOut",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onOut === null)
        {
            this._onOut = new FORGE.EventDispatcher(this._displayObject);
            this._onOut.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.OUT, this._outHandler, FORGE.Pointer.listenerTypes.NATIVE), this );
            this._addListener(FORGE.Pointer.events.OUT, this._outHandler, FORGE.Pointer.listenerTypes.NATIVE);
        }

        return this._onOut;
    }
});

/**
* Gets the onMove {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onMove
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onMove",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onMove === null)
        {
            this._onMove = new FORGE.EventDispatcher(this._displayObject);
            this._onMove.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.MOVE, this._moveHandler, FORGE.Pointer.listenerTypes.NATIVE), this );
            this._addListener(FORGE.Pointer.events.MOVE, this._moveHandler, FORGE.Pointer.listenerTypes.NATIVE);
        }

        return this._onMove;
    }
});

/**
* Gets the onWheel {@link FORGE.EventDispatcher}.<br>
* The {@link FORGE.EventDispatcher} is created only if you ask for it.<br>
* @name FORGE.Pointer#onWheel
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Pointer.prototype, "onWheel",
{
    /** @this {FORGE.Pointer} */
    get: function()
    {
        if(this._onWheel === null)
        {
            this._onWheel = new FORGE.EventDispatcher(this._displayObject);
            this._onWheel.onDestroy.addOnce( this._generateDestroyCallback(FORGE.Pointer.events.WHEEL, this._wheelHandler, FORGE.Pointer.listenerTypes.NATIVE), this );
            this._addListener(FORGE.Pointer.events.WHEEL, this._wheelHandler, FORGE.Pointer.listenerTypes.NATIVE);
        }

        return this._onWheel;
    }
});

/**
 * @name FORGE.Pointer.listenerTypes
 * @type {Object}
 * @const
 */
FORGE.Pointer.listenerTypes = {};

/**
 * @name FORGE.Pointer.listenerTypes.NATIVE
 * @type {number}
 * @const
 */
FORGE.Pointer.listenerTypes.NATIVE = 0;

/**
 * @name FORGE.Pointer.listenerTypes.HAMMER
 * @type {number}
 * @const
 */
FORGE.Pointer.listenerTypes.HAMMER = 1;


/**
 * @name FORGE.Pointer.events
 * @type {Object}
 * @const
 */
FORGE.Pointer.events = {};

/**
 * @name FORGE.Pointer.events.TAP
 * @type {string}
 * @const
 */
FORGE.Pointer.events.TAP = "tap";

/**
 * @name FORGE.Pointer.events.DOUBLE_TAP
 * @type {string}
 * @const
 */
FORGE.Pointer.events.DOUBLE_TAP = "doubletap";

/**
 * @name FORGE.Pointer.events.PRESS_START
 * @type {string}
 * @const
 */
FORGE.Pointer.events.PRESS_START = "press";

/**
 * @name FORGE.Pointer.events.PRESS_END
 * @type {string}
 * @const
 */
FORGE.Pointer.events.PRESS_END = "pressup";

/**
 * @name FORGE.Pointer.events.PAN_START
 * @type {string}
 * @const
 */
FORGE.Pointer.events.PAN_START = "panstart";

/**
 * @name FORGE.Pointer.events.PAN_MOVE
 * @type {string}
 * @const
 */
FORGE.Pointer.events.PAN_MOVE = "panmove";

/**
 * @name FORGE.Pointer.events.PAN_END
 * @type {string}
 * @const
 */
FORGE.Pointer.events.PAN_END = "panend";

/**
 * @name FORGE.Pointer.events.PINCH_START
 * @type {string}
 * @const
 */
FORGE.Pointer.events.PINCH_START = "pinchstart";

/**
 * @name FORGE.Pointer.events.PINCH_MOVE
 * @type {string}
 * @const
 */
FORGE.Pointer.events.PINCH_MOVE = "pinchmove";

/**
 * @name FORGE.Pointer.events.PINCH_END
 * @type {string}
 * @const
 */
FORGE.Pointer.events.PINCH_END = "pinchend";

/**
 * @name FORGE.Pointer.events.ROTATE_START
 * @type {string}
 * @const
 */
FORGE.Pointer.events.ROTATE_START = "rotatestart";

/**
 * @name FORGE.Pointer.events.ROTATE_MOVE
 * @type {string}
 * @const
 */
FORGE.Pointer.events.ROTATE_MOVE = "rotatemove";

/**
 * @name FORGE.Pointer.events.ROTATE_END
 * @type {string}
 * @const
 */
FORGE.Pointer.events.ROTATE_END = "rotateend";

/**
 * @name FORGE.Pointer.events.SWIPE
 * @type {string}
 * @const
 */
FORGE.Pointer.events.SWIPE = "swipe";

/**
 * @name FORGE.Pointer.events.ENTER
 * @type {string}
 * @const
 */
FORGE.Pointer.events.ENTER = "mouseenter";

/**
 * @name FORGE.Pointer.events.LEAVE
 * @type {string}
 * @const
 */
FORGE.Pointer.events.LEAVE = "mouseleave";

/**
 * @name FORGE.Pointer.events.OVER
 * @type {string}
 * @const
 */
FORGE.Pointer.events.OVER = "mouseover";

/**
 * @name FORGE.Pointer.events.OUT
 * @type {string}
 * @const
 */
FORGE.Pointer.events.OUT = "mouseout";

/**
 * @name FORGE.Pointer.events.MOVE
 * @type {string}
 * @const
 */
FORGE.Pointer.events.MOVE = "mousemove";

/**
 * @name FORGE.Pointer.events.WHEEL
 * @type {string}
 * @const
 */
FORGE.Pointer.events.WHEEL = "wheel";


/**
 * @name FORGE.Pointer.cursors
 * @type {Object}
 * @const
 */
FORGE.Pointer.cursors = {};

/**
 * @name FORGE.Pointer.cursors.DEFAULT
 * @type {string}
 * @const
 */
FORGE.Pointer.cursors.DEFAULT = "default";

/**
 * @name FORGE.Pointer.cursors.POINTER
 * @type {string}
 * @const
 */
FORGE.Pointer.cursors.POINTER = "pointer";

/**
 * @name FORGE.Pointer.cursors.GRAB
 * @type {string}
 * @const
 */
FORGE.Pointer.cursors.GRAB = "grab";

/**
 * @name FORGE.Pointer.cursors.GRABBING
 * @type {string}
 * @const
 */
FORGE.Pointer.cursors.GRABBING = "grabbing";

/**
 * Gyroscope manager that handles gyroscope events.
 *
 * @constructor FORGE.Gyroscope
 * @param {FORGE.Viewer} viewer {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.Gyroscope = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.Gyroscope#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Is the keyboard is enabled?
     * @name FORGE.Gyroscope#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * On orientation event dispatcher
     * @name FORGE.Gyroscope#_onDeviceOrientationChange
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onDeviceOrientationChange = null;

    /**
     * On orientation event dispatcher
     * @name FORGE.Gyroscope#_onScreenOrientationChange
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onScreenOrientationChange = null;

    FORGE.BaseObject.call(this, "Gyroscope");

    this._boot();
};

FORGE.Gyroscope.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Gyroscope.prototype.constructor = FORGE.Gyroscope;

/**
 * Boot sequence
 * @method FORGE.Gyroscope#_boot
 * @suppress {checkTypes}
 * @private
 */
FORGE.Gyroscope.prototype._boot = function()
{
    if (FORGE.Device.deviceOrientation === false)
    {
        return;
    }

    window.addEventListener("deviceorientation", this._deviceOrientationHandler.bind(this), false);
    window.addEventListener("orientationchange", this._screenOrientationHandler.bind(this), false);
};

/**
 * Device orientation handler
 * @method FORGE.Gyroscope#_deviceOrientationHandler
 * @param {DeviceOrientationEvent} event - the event associated to the device orientation
 * @private
 */
FORGE.Gyroscope.prototype._deviceOrientationHandler = function(event)
{
    // Fire the event
    if (this._onDeviceOrientationChange !== null && this._enabled === true)
    {
        this._onDeviceOrientationChange.dispatch(event);
    }
};

/**
 * Screen orientation handler
 * @method FORGE.Gyroscope#_screenOrientationHandler
 * @private
 */
FORGE.Gyroscope.prototype._screenOrientationHandler = function()
{
    // Fire the event
    if (this._onScreenOrientationChange !== null && this._enabled === true)
    {
        this._onScreenOrientationChange.dispatch();
    }
};

/**
 * Destroy sequence.
 * @method FORGE.Gyroscope#destroy
 * @suppress {checkTypes}
 */
FORGE.Gyroscope.prototype.destroy = function()
{
    this._viewer = null;

    window.removeEventListener("deviceorientation", this._deviceOrientationHandler.bind(this), false);
    window.removeEventListener("orientationchange", this._screenOrientationHandler.bind(this), false);

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Gets or sets the enabled status of the gyroscope.
 * @name FORGE.Gyroscope#enabled
 * @type {boolean}
 */
Object.defineProperty(FORGE.Gyroscope.prototype, "enabled",
{
    /** @this {FORGE.Gyroscope} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {FORGE.Gyroscope} */
    set: function(value)
    {
        this._enabled = Boolean(value);
    }
});

/**
 * Gets the onDeviceOrientationChange {@link FORGE.EventDispatcher}.
 * @name FORGE.Gyroscope#onDeviceOrientationChange
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Gyroscope.prototype, "onDeviceOrientationChange",
{
    /** @this {FORGE.Gyroscope} */
    get: function()
    {
        if (this._onDeviceOrientationChange === null)
        {
            this._onDeviceOrientationChange = new FORGE.EventDispatcher(this);
        }

        return this._onDeviceOrientationChange;
    }
});

/**
 * Gets the onScreenOrientationChange {@link FORGE.EventDispatcher}.
 * @name FORGE.Gyroscope#onScreenOrientationChange
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Gyroscope.prototype, "onScreenOrientationChange",
{
    /** @this {FORGE.Gyroscope} */
    get: function()
    {
        if (this._onScreenOrientationChange === null)
        {
            this._onScreenOrientationChange = new FORGE.EventDispatcher(this);
        }

        return this._onScreenOrientationChange;
    }
});

/**
 * Gamepads manager that handles gamepads
 *
 * @constructor FORGE.GamepadsManager
 * @param {FORGE.Viewer} viewer {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.GamepadsManager = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.GamepadsManager#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The list of associated gamepads
     * @name FORGE.GamepadsManager#_gamepads
     * @type {?Array<FORGE.Gamepad>}
     * @private
     */
    this._gamepads = null;

    /**
     * On gamepad connected event dispatcher.
     * @name FORGE.GamepadsManager#_onGamepadConnected
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onGamepadConnected = null;

    /**
     * On gamepad disconnected event dispatcher.
     * @name FORGE.GamepadsManager#_onGamepadDisconnected
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onGamepadDisconnected = null;

    FORGE.BaseObject.call(this, "GamepadsManager");

    this._boot();
};

FORGE.GamepadsManager.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.GamepadsManager.prototype.constructor = FORGE.GamepadsManager;

/**
 * Boot sequence.
 * @method FORGE.GamepadsManager#_boot
 * @private
 */
FORGE.GamepadsManager.prototype._boot = function()
{
    if (FORGE.Device.gamepad === false)
    {
        this.warn("Gamepads are not available with your browser");
        return;
    }

    this._gamepads = [];
};

/**
 * Check if a gamepad (of type Gamepad) is connected.
 * @method FORGE.GamepadsManager#_isConnected
 * @param {Gamepad} gamepad - the gamepad to check
 * @return {boolean} is the gamepad present ?
 * @private
 */
FORGE.GamepadsManager.prototype._isConnected = function(gamepad)
{
    for (var i = 0, ii = this._gamepads.length; i < ii; i++)
    {
        if (this._gamepads[i].name === (gamepad.id + "-" + gamepad.index))
        {
            return true;
        }
    }

    return false;
};

/**
 * Connect a gamepad (of type Gamepad).
 * @method FORGE.GamepadsManager#_connect
 * @param {Gamepad} pad - the gamepad to connect
 * @private
 */
FORGE.GamepadsManager.prototype._connect = function(pad)
{
    var gamepad = new FORGE.Gamepad(this._viewer, pad);

    this._gamepads[pad.index] = gamepad;

    // TODO: add a haptic feedback if available

    if (this._onGamepadConnected !== null)
    {
        this._onGamepadConnected.dispatch(gamepad);
    }
};

/**
 * Disconnect a gamepad (of type FORGE.Gamepad).
 * @method FORGE.GamepadsManager#_disconnect
 * @param {number} index - the index of the gamepad to disconnect
 * @private
 */
FORGE.GamepadsManager.prototype._disconnect = function(index)
{
    var name = this._gamepads[index].name;

    this._gamepads[index].destroy();
    this._gamepads[index] = null;

    if (this._onGamepadDisconnected !== null)
    {
        this._onGamepadDisconnected.dispatch(name);
    }
};

/**
 * Update routine: check each time if a new gamepad is connected, and update any gamepad currently
 * connected in this manager.
 * @method FORGE.GamepadsManager#update
 */
FORGE.GamepadsManager.prototype.update = function()
{
    if(this._gamepads === null)
    {
        return;
    }

    var gamepad, gamepads = navigator.getGamepads();

    for (var i = 0, ii = gamepads.length; i < ii; i++)
    {
        gamepad = gamepads[i];

        if (typeof gamepad !== "undefined" && gamepad !== null)
        {
            if (this._isConnected(gamepad) === false)
            {
                this._connect(gamepad);
            }
            // curious behavior in edge, the pad isn't kept as a reference
            // so it isn't updated: the solution for now is to refresh the
            // gamepad each time
            else if (FORGE.Device.edge === true)
            {
                var pad = this._gamepads[gamepad.index];
                pad.gamepad = gamepad;
            }

            this._gamepads[i].update();
        }
        else if (gamepad === null && typeof this._gamepads[i] !== "undefined")
        {
            this._disconnect(i);
        }
    }
};

/**
 * Destroy sequence.
 * @method FORGE.GamepadsManager#destroy
 */
FORGE.GamepadsManager.prototype.destroy = function()
{
    this._viewer = null;

    for (var i = 0, ii = this._gamepads.length; i < ii; i++)
    {
        this._disconnect(i);
    }
    this._gamepads = null;

    if (this._onGamepadConnected !== null)
    {
        this._onGamepadConnected.destroy();
        this._onGamepadConnected = null;
    }

    if (this._onGamepadDisconnected !== null)
    {
        this._onGamepadDisconnected.destroy();
        this._onGamepadDisconnected = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * On gamepad connected event dispatcher.
 * @name FORGE.GamepadsManager#onGamepadConnected
 * @type {?FORGE.EventDispatcher}
 * @readonly
 */
Object.defineProperty(FORGE.GamepadsManager.prototype, "onGamepadConnected",
{
    /** @this {FORGE.GamepadsManager} */
    get: function()
    {
        if (this._onGamepadConnected === null)
        {
            this._onGamepadConnected = new FORGE.EventDispatcher(this);
        }

        return this._onGamepadConnected;
    }
});

/**
 * On gamepad disconnected event dispatcher.
 * @name FORGE.GamepadsManager#onGamepadDisconnected
 * @type {?FORGE.EventDispatcher}
 * @readonly
 */
Object.defineProperty(FORGE.GamepadsManager.prototype, "onGamepadDisconnected",
{
    /** @this {FORGE.GamepadsManager} */
    get: function()
    {
        if (this._onGamepadDisconnected === null)
        {
            this._onGamepadDisconnected = new FORGE.EventDispatcher(this);
        }

        return this._onGamepadDisconnected;
    }
});

/**
 * Get a list of all connected gamepads.
 * @name FORGE.GamepadsManager#all
 * @type {Array<FORGE.Gamepad>}
 * @readonly
 */
Object.defineProperty(FORGE.GamepadsManager.prototype, "all",
{
    /** @this {FORGE.GamepadsManager} */
    get: function()
    {
        return this._gamepads || [];
    }
});

/**
 * Gamepads manager that handles gamepads
 *
 * @constructor FORGE.Gamepad
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {Gamepad} ref - the reference to the Gamepad object.
 * @extends {FORGE.BaseObject}
 */
FORGE.Gamepad = function(viewer, ref)
{
    /**
     * The viewer reference.
     * @name FORGE.Gamepad#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The reference to the Gamepad object
     * @name FORGE.Gamepad#_gamepad
     * @type {Gamepad}
     * @private
     */
    this._gamepad = ref;

    /**
     * The timestamp saved the last time the gamepad was updated.
     * @name FORGE.Gamepad#_previousTimestamp
     * @type {number}
     * @private
     */
    this._previousTimestamp = 0;

    /**
     * Is the gamepad enabled?
     * @name FORGE.Gamepad#_enabled
     * @type {boolean}
     * @private
     */
    this._enabled = true;

    /**
     * The array that handles the {@link FORGE.ButtonBinding} objects.
     * @name FORGE.Gamepad#_buttonBindings
     * @type {?Array<FORGE.ButtonBinding>}
     * @private
     */
    this._buttonBindings = null;

    /**
     * The array that handles the {@link FORGE.AxesBinding} objects.
     * @name FORGE.Gamepad#_axisBindings
     * @type {?Array<FORGE.AxisBinding>}
     * @private
     */
    this._axisBindings = null;

    /**
     * The array that handles the button codes that are considered as pressed.
     * @name FORGE.Gamepad#_buttonPressed
     * @type {?Array<number>}
     * @private
     */
    this._buttonPressed = null;

    FORGE.BaseObject.call(this, "Gamepad");

    this._boot();
};

FORGE.Gamepad.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Gamepad.prototype.constructor = FORGE.Gamepad;

/**
 * Boot sequence.
 * @method FORGE.Gamepad#_boot
 * @private
 */
FORGE.Gamepad.prototype._boot = function()
{
    this._uid = this._gamepad.id + "-" + this._gamepad.index;
    this._register();

    this._buttonBindings = [];
    this._axisBindings = [];

    this._buttonPressed = [];
};

/**
 * Get the index of a ButtonBinding.
 * @method FORGE.Gamepad#_indexOfBinding
 * @param  {FORGE.BaseBinding} value - The ButtonBinding.
 * @return {number} Returns the searched index if found, if not, returns -1.
 * @private
 */
FORGE.Gamepad.prototype._indexOfBinding = function(value)
{
    if (this._buttonBindings === null || this._buttonBindings.length === 0)
    {
        return -1;
    }

    if (typeof value === "object")
    {
        if (value.type === "ButtonBinding")
        {
            return this._buttonBindings.indexOf(/** @type {FORGE.ButtonBinding} */ (value));
        }
        else if (value.type === "AxisBinding")
        {
            return this._axisBindings.indexOf(/** @type {FORGE.AxisBinding} */ (value));
        }
    }

    return -1;
};

/**
 * Process all buttons in the gamepad.
 * @method FORGE.Gamepad#_processButtons
 * @param {Array<GamepadButton>} buttons - the array of GamepadButton
 * @private
 */
FORGE.Gamepad.prototype._processButtons = function(buttons)
{
    var button, index, binding;

    // First process buttons
    for (var i = 0, ii = buttons.length; i < ii; i++)
    {
        button = buttons[i];
        index = this._buttonPressed.indexOf(i);

        if (button.pressed === true && index === -1)
        {
            this.log("button pressed " + i);
            this._buttonPressed.push(i);

            this._applyButton(i, button.value, true);
        }
        else if (button.pressed === false && index !== -1)
        {
            this.log("button released " + i);
            this._buttonPressed.splice(index, 1);

            this._applyButton(i, button.value, false);
        }
    }
};

/**
 * Apply any hold action present for a button.
 * @method FORGE.Gamepad#_applyHoldButtons
 * @private
 */
FORGE.Gamepad.prototype._applyHoldButtons = function()
{
    var binding;

    for (var i = 0, ii = this._buttonBindings.length; i < ii; i++)
    {
        binding = this._buttonBindings[i];

        if (binding.pressed === true)
        {
            if (binding.hasToWaitToHold === true && binding.downComplete === false)
            {
                continue;
            }

            binding.hold();
        }
    }
};


/**
 * Get an array of bindings associated to the button.
 * @method FORGE.Gamepad#_getButtonBindings
 * @param {number} index - the index of the button
 * @return {Array<FORGE.ButtonBinding>} an array of bindings
 * */
FORGE.Gamepad.prototype._getButtonBindings = function(index)
{
    var bindings = [];

    for (var i = 0, ii = this._buttonBindings.length; i < ii; i++)
    {
        if (this._buttonBindings[i].hasButtonIn(index) === true)
        {
            bindings.push(this._buttonBindings[i]);
        }
    }

    return bindings;
};

/**
 * Apply the callbacks associated to the button.
 * @method FORGE.Gamepad#_applyButton
 * @param {number} index - the index of the button
 * @param {number} value - the value of the button
 * @param {boolean} pressed - is the button pressed ?
 * @private
 */
FORGE.Gamepad.prototype._applyButton = function(index, value, pressed)
{
    var binding, bindings = this._getButtonBindings(index);

    for (var i = 0, ii = bindings.length; i < ii; i++)
    {
        binding = bindings[i];

        // Button down
        if (pressed === true && binding.pressed === false)
        {
            binding.down(value);
        }
        // Button up
        else if (pressed === false && binding.pressed === true)
        {
            binding.up(value);
        }
    }
};

/**
 * Get an array of bindings associated to the axis.
 * @method FORGE.Gamepad#_getAxisBindings
 * @param {number} index - the index of the axis
 * @return {Array<FORGE.AxisBinding>} an array of bindings
 */
FORGE.Gamepad.prototype._getAxisBindings = function(index)
{
    var bindings = [];

    for (var i = 0, ii = this._axisBindings.length; i < ii; i++)
    {
        if (this._axisBindings[i].axis === index)
        {
            bindings.push(this._axisBindings[i]);
        }
    }

    return bindings;
};

/**
 * Process all buttons in the gamepad.
 * @method FORGE.Gamepad#_processAxes
 * @param {Array<number>} axes - the value of each axis
 * @private
 */
FORGE.Gamepad.prototype._processAxes = function(axes)
{
    var bindings;

    // First process buttons
    for (var i = 0, ii = axes.length; i < ii; i++)
    {
        bindings = this._getAxisBindings(i);

        for (var j = 0, jj = bindings.length; j < jj; j++)
        {
            bindings[j].change(axes[i]);
        }
    }
};

/**
 * Update routine.
 * @method FORGE.Gamepad#update
 */
FORGE.Gamepad.prototype.update = function()
{
    if (this._enabled === true)
    {
        if (this._gamepad.timestamp > this._previousTimestamp)
        {
            this._previousTimestamp = this._gamepad.timestamp;

            // Process buttons
            if (typeof this._gamepad.buttons !== "undefined")
            {
                this._processButtons(this._gamepad.buttons);
            }

            // Process axis
            if (typeof this._gamepad.axes !== "undefined")
            {
                this._processAxes(this._gamepad.axes);
            }
        }

        // Apply buttons holdings
        this._applyHoldButtons();
    }
};

/**
 * Add a BaseBinding to the Gamepad's correct bindings array.
 * @method FORGE.Gamepad#addBinding
 * @param {FORGE.BaseBinding} binding - The FORGE.BaseBinding you want to add.
 * @return {boolean} Returns true if it's correctly added, false if it's already in or if wrong type.
 */
FORGE.Gamepad.prototype.addBinding = function(binding)
{
    if (typeof binding !== "object" && binding.type !== "ButtonBinding" && binding.type !== "AxisBinding")
    {
        return false;
    }

    var index = this._indexOfBinding(binding);

    if (index === -1)
    {
        if (binding.type === "ButtonBinding")
        {
            this._buttonBindings.push(/** @type {FORGE.ButtonBinding} */ (binding));
            return true;
        }
        else if (binding.type === "AxisBinding")
        {
            this._axisBindings.push(/** @type {FORGE.AxisBinding} */ (binding));
            return true;
        }
    }
    else
    {
        this.warn("Trying to add a duplicate binding on the gamepad !");
    }

    return false;
};

/**
 * Remove a BaseBinding of the Gamepad.
 * @method FORGE.Gamepad#removeBinding
 * @param  {FORGE.BaseBinding} binding - The binding to remove.
 * @return {boolean} Returns true if it's removed, false if not found.
 */
FORGE.Gamepad.prototype.removeBinding = function(binding)
{
    var index = this._indexOfBinding(binding);

    if (index === -1)
    {
        if (binding.type === "ButtonBinding")
        {
            this._buttonBindings[index].destroy();
            this._buttonBindings.splice(index, 1);
            return true;
        }
        else if (binding.type === "AxisBinding")
        {
            this._axisBindings[index].destroy();
            this._axisBindings.splice(index, 1);
            return true;
        }
    }

    return false;
};

/**
 * Destroy sequence.
 * @method FORGE.Gamepad#destroy
 */
FORGE.Gamepad.prototype.destroy = function()
{
    this._viewer = null;

    var buttonBinding;

    while (this._buttonBindings !== null && this._buttonBindings.length > 0)
    {
        buttonBinding = this._buttonBindings.pop();
        buttonBinding.destroy();
    }
    this._buttonBindings = null;

    var axisBinding;

    while (this._axisBindings !== null && this._axisBindings.length > 0)
    {
        axisBinding = this._axisBindings.pop();
        axisBinding.destroy();
    }
    this._axisBindings = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Gets the name of the gamepad.
 * @name FORGE.Gamepad#name
 * @type {string}
 * @readonly
 */
Object.defineProperty(FORGE.Gamepad.prototype, "name",
{
    /** @this {FORGE.Gamepad} */
    get: function()
    {
        return this._gamepad.id + "-" + this._gamepad.index;
    }
});

/**
 * Gets the mapping of the gamepad.
 * @name FORGE.Gamepad#mapping
 * @type {string}
 * @readonly
 */
Object.defineProperty(FORGE.Gamepad.prototype, "mapping",
{
    /** @this {FORGE.Gamepad} */
    get: function()
    {
        return this._gamepad.mapping;
    }
});

/**
 * Gets the hand of the gamepad if any.
 * @name FORGE.Gamepad#hand
 * @type {string}
 * @readonly
 */
Object.defineProperty(FORGE.Gamepad.prototype, "hand",
{
    /** @this {FORGE.Gamepad} */
    get: function()
    {
        return this._gamepad.hand;
    }
});

/**
 * Gets the position of the gamepad, relative to the camera.
 * @name FORGE.Gamepad#position
 * @type {GamepadPose}
 * @readonly
 */
Object.defineProperty(FORGE.Gamepad.prototype, "position",
{
    /** @this {FORGE.Gamepad} */
    get: function()
    {
        return this._gamepad.pose;
    }
});

/**
 * Gets or sets the enabled status of the gamepad.
 * @name FORGE.Gamepad#enabled
 * @type {boolean}
 */
Object.defineProperty(FORGE.Gamepad.prototype, "enabled",
{
    /** @this {FORGE.Gamepad} */
    get: function()
    {
        return this._enabled;
    },

    /** @this {FORGE.Gamepad} */
    set: function(value)
    {
        this._enabled = Boolean(value);
    }
});

/**
 * Gets the raw data of the gamepad (the Gamepad object, not the FORGE one).
 * @name FORGE.Gamepad#gamepad
 * @type {Gamepad}
 */
Object.defineProperty(FORGE.Gamepad.prototype, "gamepad",
{
    /** @this {FORGE.Gamepad} */
    get: function()
    {
        return this._gamepad;
    },

    /** @this {FORGE.Gamepad} */
    set: function(value)
    {
        if (value !== null)
        {
            this._gamepad = value;
        }
    }
});


/**
 * Manage Display Objects list and fullscreen events.
 * @constructor FORGE.DisplayList
 * @extends {FORGE.BaseObject}
 * @param {FORGE.Viewer} viewer - Viewer reference.
 */
FORGE.DisplayList = function(viewer)
{
    /**
     * The viewer reference.
     * @name  FORGE.DisplayList#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Array that references all the display objects.
     * @name  FORGE.DisplayList#_objects
     * @type {Array<FORGE.DisplayObject>}
     * @private
     */
    this._objects = [];

    /**
     * Array that references the display objects that needs to be updated.
     * @name  FORGE.DisplayList#_objectsToUpdate
     * @type {Array<Object>}
     * @private
     */
    this._objectsToUpdate = [];

    /**
     * fullscreen change handler binded to this context.
     * @name FORGE.DisplayList#_fullScreenChangeBind
     * @type {Function}
     * @private
     */
    this._fullScreenChangeBind = null;

    /**
     * The object that is currently in fullscreen.
     * @name FORGE.DisplayObject#_fullscreenObject
     * @type {FORGE.DisplayObject}
     * @private
     */
    this._fullscreenObject = null;

    FORGE.BaseObject.call(this, "DisplayList");

    this._boot();
};

FORGE.DisplayList.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.DisplayList.prototype.constructor = FORGE.DisplayList;

/**
 * Boot sequence
 * @method FORGE.DisplayList#_boot
 * @private
 */
FORGE.DisplayList.prototype._boot = function()
{
    this._fullScreenChangeBind = this._fullScreenChangeHandler.bind(this);

    //Listen to all kind of events for cross browser compatibility
    document.addEventListener("fullscreenchange", this._fullScreenChangeBind, false);
    document.addEventListener("mozfullscreenchange", this._fullScreenChangeBind, false);
    document.addEventListener("webkitfullscreenchange", this._fullScreenChangeBind, false);
    document.addEventListener("MSFullscreenChange", this._fullScreenChangeBind, false);
};

/**
 * Event handler for full screen change.
 * @name  FORGE.DisplayList#_fullScreenChangeHandler
 * @private
 */
FORGE.DisplayList.prototype._fullScreenChangeHandler = function()
{
    this.log("_fullScreenChangeHandler");

    if(document[FORGE.Device.fullscreenElement] !== null)
    {
        var obj;
        var n = this._objects.length;

        while(n--)
        {
            obj = this._objects[n];

            if(obj.dom === document[FORGE.Device.fullscreenElement])
            {
                this._fullscreenObject = obj;
                this._fullscreenObject._notifyFullscreenEnter();
                break;
            }
        }
    }
    else
    {
        this._fullscreenObject._notifyFullscreenExit();
        this._fullscreenObject = null;
    }
};

/**
 * Registers a display object in the display list.
 * @method  FORGE.DisplayList#register
 * @param  {FORGE.DisplayObject} object - The display object to register.
 * @param  {boolean=} update - Is this display object needs to be updated updated?
 */
FORGE.DisplayList.prototype.register = function(object, update)
{
    this._objects.push(object);

    if(update === true)
    {
        this._objectsToUpdate.push(object);
    }
};

/**
 * Unregister a display object from the display list.
 * @method  FORGE.DisplayList#unregister
 * @param {FORGE.DisplayObject} object - The object to unregister from the display list.
 */
FORGE.DisplayList.prototype.unregister = function(object)
{
    this._objects.splice(this._objects.indexOf(object), 1);

    var index = this._objectsToUpdate.indexOf(object);

    if(index !== -1)
    {
        this._objectsToUpdate.splice(index, 1);
    }
};

/**
 * Update method of the DisplayList
 * @method FORGE.DispalyList#update
 */
FORGE.DisplayList.prototype.update = function()
{
    for(var i = 0, ii = this._objectsToUpdate.length; i < ii; i++)
    {
        this._objectsToUpdate[i].update();
    }
};

/**
 * Destroy sequence
 * @method FORGE.DisplayList#destroy
 */
FORGE.DisplayList.prototype.destroy = function()
{
    var objCount = this._objects.length;
    while(objCount--)
    {
        this._objects[objCount].destroy();
    }

    this._objects = [];
    this._objectsToUpdate = [];

    document.removeEventListener("fullscreenchange", this._fullScreenChangeBind, false);
    document.removeEventListener("mozfullscreenchange", this._fullScreenChangeBind, false);
    document.removeEventListener("webkitfullscreenchange", this._fullScreenChangeBind, false);
    document.removeEventListener("MSFullscreenChange", this._fullScreenChangeBind, false);

    this._fullScreenChangeBind = null;
    this._fullscreenObject = null;
};

/**
 * Types of display objects.
 * @name  FORGE.DisplayList.types
 * @type {Array<string>}
 */
FORGE.DisplayList.types =
[
    "DisplayObject",
    "DisplayObjectContainer",
    "Image",
    "TextField",
    "Button",
    "VideoDash",
    "VideoHTML5",
    "Canvas",
    "Sprite",
    "Iframe"
];

/**
 * A display object is a visual element which has width / height and coordianate x / y in space.<br>
 * It's a way to create and manipulate a div element, many other class inherit from this one.
 *
 * @constructor FORGE.DisplayObject
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {Element|HTMLElement=} dom - Use a specific dom element to be the display object, if undefined a div will be created.
 * @param {string=} className - The className of the object as long as many other object inherits from this one.
 * @extends {FORGE.BaseObject}
 *
 * @todo Define a better behavior for anchors / margins. If we set a top and a bottom anchor what happen ?
 * @todo Do the last anchor have the priority ? Does the DisplayObject will change its height if a top and a bottom anchors are set ?
 * @todo  Remove the _borderUpdate, at least find a way to do it properly ?!
 */
FORGE.DisplayObject = function(viewer, dom, className)
{
    /**
     * The viewer reference.
     * @name FORGE.DisplayObject#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The dom element that represent the display object.
     * @name FORGE.DisplayObject#_dom
     * @type {Element|HTMLElement}
     * @private
     */
    this._dom = dom || null;

    /**
     * The parent element of the display object, generally it is a {@link FORGE.DisplayObjectContainer}.
     * @name FORGE.DisplayObject#_parent
     * @type {?FORGE.DisplayObjectContainer|HTMLElement}
     * @private
     */
    this._parent = null;

    /**
     * The index of the display object, understand it as the z-index CSS property.
     * @name FORGE.DisplayObject#_index
     * @type {number}
     * @private
     */
    this._index = 0;

    /**
     * The id of the display object, this id is associated to the dom element.
     * @name  FORGE.DisplayObject#_id
     * @type {string}
     * @private
     */
    this._id = "";

    /**
     * The x position of the display object relative to it's parent origin.
     * @name  FORGE.DisplayObject#_x
     * @type {number}
     * @private
     */
    this._x = 0;

    /**
     * The x position of the display object relative to it's parent origin.
     * @name  FORGE.DisplayObject#_y
     * @type {number}
     * @private
     */
    this._y = 0;

    /**
     * Does this display object have to automatically keeps its ratio when width or height change?
     * @name  FORGE.DisplayObject#_keepRatio
     * @type {boolean}
     * @private
     */
    this._keepRatio = false;

    /**
     * The width of the display object whatever is its unit, it can be pixel or percent.
     * @name  FORGE.DisplayObject#_width
     * @type {number}
     * @private
     */
    this._width = 0;

    /**
     * The unit of the display object's width, it can be "px" or "%".
     * @name  FORGE.DisplayObject#_unitWidth
     * @type {string}
     * @private
     */
    this._unitWidth = "px";

    /**
     * The display object's scale width.
     * @name  FORGE.DisplayObject#_scaleWidth
     * @type {number}
     * @private
     */
    this._scaleWidth = 1;

    /**
     * The height of the display object whatever is its unit, it can be pixel or percent.
     * @name  FORGE.DisplayObject#_height
     * @type {number}
     * @private
     */
    this._height = 0;

    /**
     * The unit of the display object's height, it can be "px" or "%".
     * @name  FORGE.DisplayObject#_unitHeight
     * @type {string}
     * @private
     */
    this._unitHeight = "px";

    /**
     * The display object's scale height.
     * @name  FORGE.DisplayObject#_scaleHeight
     * @type {number}
     * @private
     */
    this._scaleHeight = 1;

    /**
     * Does this display object have to center (horizontally) itself inside its parent?
     * @name  FORGE.DisplayObject#_horizontalCenter
     * @type {boolean}
     * @private
     */
    this._horizontalCenter = false;

    /**
     * Does this display object have to center (vertically) itself inside its parent?
     * @name  FORGE.DisplayObject#_verticalCenter
     * @type {boolean}
     * @private
     */
    this._verticalCenter = false;

    /**
     * The top anchor of the display object inside its parent? It can be null.
     * @name  FORGE.DisplayObject#_top
     * @type {?number}
     * @private
     */
    this._top = null;

    /**
     * The right anchor of the display object inside its parent? It can be null.
     * @name  FORGE.DisplayObject#_right
     * @type {?number}
     * @private
     */
    this._right = null;

    /**
     * The bottom anchor of the display object inside its parent? It can be null.
     * @name  FORGE.DisplayObject#_bottom
     * @type {?number}
     * @private
     */
    this._bottom = null;

    /**
     * The left anchor of the display object inside its parent? It can be null.
     * @name  FORGE.DisplayObject#_left
     * @type {?number}
     * @private
     */
    this._left = null;

    /**
     * The alpha value of the display object (0 to 1).
     * @name  FORGE.DisplayObject#_alpha
     * @type {number}
     * @private
     */
    this._alpha = 1;

    /**
     * The rotation value of the display object (in degree).
     * @name  FORGE.DisplayObject#_rotation
     * @type {number}
     * @private
     */
    this._rotation = 0;

    /**
     * The {@link FORGE.Pointer} reference for this display object.
     * @name  FORGE.DisplayObject#_pointer
     * @type {FORGE.Pointer}
     * @private
     */
    this._pointer = null;

    /**
     * The {@link FORGE.Drag} module reference for this display Object.
     * @name FORGE.DisplayObject#_drag
     * @type {FORGE.Drag}
     * @private
     */
    this._drag = null;

    /**
     * The background CSS value for this display object.
     * @name  FORGE.DisplayObject#_background
     * @type {string}
     * @private
     */
    this._background = "";

    /**
     * The border-style CSS value for this display object.
     * @name  FORGE.DisplayObject#_borderStyle
     * @type {string}
     * @private
     */
    this._borderStyle = "solid";

    /**
     * The border-width CSS value for this display object.
     * @name  FORGE.DisplayObject#_borderWidth
     * @type {number}
     * @private
     */
    this._borderWidth = 0;

    /**
     * The border-color CSS value for this display object.
     * @name  FORGE.DisplayObject#_borderColor
     * @type {string}
     * @private
     */
    this._borderColor = "rgb(0, 0, 0)";

    /**
     * The border-radius CSS value for this display object.
     * @name  FORGE.DisplayObject#_borderRadius
     * @type {number}
     * @private
     */
    this._borderRadius = 0;

    /**
     * Does this display object have to be maximized (in size) inside its parent.
     * @name  FORGE.DisplayObject#_maximized
     * @type {boolean}
     * @private
     */
    this._maximized = false;

    /**
     * The tooltip of this display object. It's the "title" value of the dom element.
     * @name  FORGE.DisplayObject#_tooltip
     * @type {string}
     * @private
     */
    this._tooltip = "";

    /**
     * Any custom data you want to associate to this display object.
     * @name  FORGE.DisplayObject#_data
     * @type {?Object}
     * @private
     */
    this._data = null;

    /**
     * Is this display object is ready?
     * @name  FORGE.DisplayObject#_ready
     * @type {boolean}
     * @private
     */
    this._ready = false;

    /**
     * Does the display object have to put some properties in pending ?
     * @name FORGE.DisplayObject#_needPending
     * @type {boolean}
     * @private
     */
    this._needPending = true;

    /**
     * This object save pending values to be applied after the display object will be ready.
     * @name  FORGE.DisplayObject#_pending
     * @type {?Object}
     * @private
     */
    this._pending = null;

    /**
     * This is a flag to set if the display object is currently applying its pending values when ready.
     * @name  FORGE.DisplayObject#_pendingApplying
     * @type {boolean}
     * @private
     */
    this._pendingApplying = false;

    /**
     * This object is here to store data when fullscreen state changes.<br>
     * @name  FORGE.DisplayObject#_fullscreenData
     * @type {?ScreenData}
     * @private
     */
    this._fullscreenData = null;

    /**
     * On ready event dispatcher.
     * @name  FORGE.DisplayObject#_onReady
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onReady = null;

    /**
     * On resize event dispatcher.
     * @name  FORGE.DisplayObject#_onResize
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onResize = null;

    /**
     * On border resize event dispatcher.
     * @name FORGE.DisplayObject#_onBorderResize
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onBorderResize = null;

    /**
     * On move event dispatcher.
     * @name  FORGE.DisplayObject#_onMove
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onMove = null;

    /**
     * On added to parent event dispatcher
     * @name  FORGE.DisplayObject#_onAddedToParent
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onAddedToParent = null;

    /**
     * On added to dom event dispatcher
     * @name  FORGE.DisplayObject#_onAddedToDom
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onAddedToDom = null;

    /**
     * On show event dispatcher
     * @name  FORGE.DisplayObject#_onShow
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onShow = null;

    /**
     * On hide event dispatcher
     * @name  FORGE.DisplayObject#_onHide
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onHide = null;

    /**
     * On fullscreen enter event dispatcher
     * @name  FORGE.DisplayObject#_onFullscreenEnter
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onFullscreenEnter = null;

    /**
     * On fullscreen exit event dispatcher
     * @name  FORGE.DisplayObject#_onFullscreenExit
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onFullscreenExit = null;

    FORGE.BaseObject.call(this, className || "DisplayObject");

    this._boot();
};

FORGE.DisplayObject.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.DisplayObject.prototype.constructor = FORGE.DisplayObject;

/**
 * Boot sequence.
 * @method FORGE.DisplayObject#_boot
 * @private
 */
FORGE.DisplayObject.prototype._boot = function()
{
    if(this._ready === true)
    {
        return;
    }

    this._register();

    this._createDom();

    this._pending = [];

    //Many object extends the DisplayObject, it's the only one that can be ready here!
    if(this._className === "DisplayObject")
    {
        this._viewer.display.register(this);
        this._notifyReady();
        this._applyPending(false);
    }
};

/**
 * Create the dom if not specified, apply default CSS.
 * @method FORGE.DisplayObject#_createDom
 * @private
 */
FORGE.DisplayObject.prototype._createDom = function()
{
    if(typeof this._dom === "undefined" || this._dom === null)
    {
        this._dom = document.createElement("div");
    }
    else
    {
        //Dom is predifined we have to determine width height stuff
        this._width = FORGE.Dom.getValueWidth(this._dom);
        this._unitWidth = FORGE.Dom.getUnitWidth(this._dom);

        this._height = FORGE.Dom.getValueHeight(this._dom);
        this._unitHeight = FORGE.Dom.getUnitHeight(this._dom);
    }

    this._dom.style.width = this._width+""+this._unitWidth;
    this._dom.style.height = this._height+""+this._unitHeight;

    this._dom.style.display = "block";
    this._dom.style.position = "relative";
    this._dom.style.margin = "0px";
    this._dom.style.padding = "0px";
    this._dom.style.top = this._y+"px";
    this._dom.style.left = this._x+"px";
    this._dom.style.overflow = "hidden";
    this._dom.style.boxSizing = "border-box";

    if(FORGE.Device.cssPointerEvents === true)
    {
        this._dom.style.pointerEvents = "none";
    }

    this._dom.style.userSelect = "none";
    this._dom.style.webkitUserSelect = "none";
    this._dom.style.mozUserSelect = "none";
    this._dom.style.msUserSelect = "none";
    this._dom.style.webkitTouchCallout = "none";

    this._dom.style.borderStyle = this._borderStyle;
    this._dom.style.borderWidth = this._borderWidth+"px";
    this._dom.style.borderColor = this._borderColor;
    this._dom.style.background = this._background;
};

/**
 * Method to notify that the display object is ready !<br>
 * This part of of code is here to be overrided by object that inherits from display object.
 * @method  FORGE.DisplayObject#_notifyReady
 * @private
 */
FORGE.DisplayObject.prototype._notifyReady = function()
{
    if(this._ready === true)
    {
        return;
    }

    this.log("_notifyReady");
    this._ready = true;

    if(this._onReady !== null)
    {
        this._onReady.dispatch();
    }
};

/**
 * Internal method used by parents to notify that this DisplayObject has been added to DOM.
 * @method FORGE.DisplayObject#_notifyAddedToDom
 * @private
 */
FORGE.DisplayObject.prototype._notifyAddedToDom = function()
{
    this.log("_notifyAddedToDom");

    if(this._onAddedToDom !== null)
    {
        this._onAddedToDom.dispatch();
    }
};

/**
 * Notify that the visibility of this DisplayObject has changed to visible.
 * @method FORGE.DisplayObject#_notifyShow
 * @private
 */
FORGE.DisplayObject.prototype._notifyShow = function()
{
    this.log("_notifyShow");

    if(this.isInDom() === false)
    {
        return;
    }

    if(this._onShow !== null && this.visible === true)
    {
        this._onShow.dispatch();
    }
};

/**
 * Notify that the visibility of this DisplayObject has changed to invisible.
 * @method FORGE.DisplayObject#_notifyHide
 * @private
 */
FORGE.DisplayObject.prototype._notifyHide = function()
{
    this.log("_notifyHide");

    if(this._onHide !== null && this.visible === false)
    {
        this._onHide.dispatch();
    }
};

/**
 * Method to notify that borders has been resized.<br>
 * This can be override by other class that inherits from DisplayObject.
 * @method  FORGE.DisplayObject#_notifyBorderResize
 * @private
 */
FORGE.DisplayObject.prototype._notifyBorderResize = function()
{
    if(this._onBorderResize !== null)
    {
        this._onBorderResize.dispatch();
    }
};

/**
 * Method used by parents to adapt size and position.
 * @method FORGE.DisplayObject#_notifyParentResize
 * @private
 * @param {PropertyToUpdate} data - The data contains the property that have changed.
 */
FORGE.DisplayObject.prototype._notifyParentResize = function(data)
{
    if(this._maximized === true)
    {
        this.maximize(this._maximized);
    }

    this._updatePercentValues(data.property);
    this._updateAnchors();
};

/**
 * Notify that the dispay object has been resized.<br>
 * This method can be overrided by object that extends FORGE.DisplayObject.
 * @method  FORGE.DisplayObject#_notifyResize
 * @private
 * @param {PropertyToUpdate} data - The data contains the property that have changed.
 */
FORGE.DisplayObject.prototype._notifyResize = function(data)
{
    this._updateAnchors();

    if(this._onResize !== null)
    {
        this._onResize.dispatch(data);
    }
};

/**
 * Notify the display object that it entered in fullscreen.
 * @method FORGE.DisplayObject#_notifyfullscreenEnter
 * @private
 */
FORGE.DisplayObject.prototype._notifyFullscreenEnter = function()
{
    this.log("_notifyFullscreenEnter");

    this._fullscreenSaveData();

    if(this._onFullscreenEnter !== null)
    {
        this._onFullscreenEnter.dispatch();
    }
};

/**
 * Notify the display object that it left fullscreen mode.
 * @method FORGE.DisplayObject#_notifyFullscreenExit
 * @private
 */
FORGE.DisplayObject.prototype._notifyFullscreenExit = function()
{
    this.log("_notifyFullscreenChange");

    this._fullscreenRestoreData();

    if(this._onFullscreenExit !== null)
    {
        this._onFullscreenExit.dispatch();
    }
};

/**
 * Save the display object state into fullscreenData for further restoration.<br>
 * Set the object's dom css to be in fullscreen.
 * @method FORGE.DisplayObject#_fullscreenSaveData
 * @private
 */
FORGE.DisplayObject.prototype._fullscreenSaveData = function()
{
    this.log("_fullscreenSaveData");

    this._fullscreenData =
    {
        x: this._x,
        y: this._y,

        width: this._width,
        unitWidth: this._unitWidth,
        height: this._height,
        unitHeight: this._unitHeight,

        top: this._top,
        right: this._right,
        bottom: this._bottom,
        left: this._left
    };

    this._x = 0;
    this._y = 0;

    this._width = screen.width;
    this._unitWidth = "px";
    this._dom.style.width = this._width+"px";

    this._height = screen.height;
    this._unitHeight = "px";
    this._dom.style.height = this._height+"px";

    this._top = null;
    this._right = null;
    this._bottom = null;
    this._left = null;

    this._dom.style.top = "0";
    this._dom.style.left = "0";

    this._notifyResize({property: "both"});
};

/**
 * Restore the object state at what it was before fullscreen.
 * Happens on fullscreen exit.
 * @method FORGE.DisplayObject#_fullscreenRestoreData
 * @private
 */
FORGE.DisplayObject.prototype._fullscreenRestoreData = function()
{
    this.log("_fullscreenRestoreData");

    this._x = this._fullscreenData.x;
    this._dom.style.left = this._x+"px";
    this._y = this._fullscreenData.y;
    this._dom.style.top = this._y+"px";

    this._width = this._fullscreenData.width;
    this._unitWidth = this._fullscreenData.unitWidth;
    this._dom.style.width = this.pixelWidth+"px";

    this._height = this._fullscreenData.height;
    this._unitHeight = this._fullscreenData.unitHeight;
    this._dom.style.height = this.pixelHeight+"px";

    this._top = this._fullscreenData.top;
    this._right = this._fullscreenData.right;
    this._bottom = this._fullscreenData.bottom;
    this._left = this._fullscreenData.left;

    //this._updateAnchors();
    this._notifyResize({property: "both"});

    this._fullscreenData = null;
};

/**
 * Apply anchor values. Adapt the position of the display object according to its anchors and its alignement flags.
 * @method FORGE.DisplayObject#_updateAnchors
 * @private
 */
FORGE.DisplayObject.prototype._updateAnchors = function()
{
    //No need to update anchors if has no parent or no size!
    if(this._parent === null || this._width === 0 || this._height === 0)
    {
        return;
    }

    this.log("_updateAnchors");

    if(this._horizontalCenter === true)
    {
        this.horizontalCenter = true;
    }
    else
    {
        this.left = this._left;
        this.right = this._right;
    }

    if(this._verticalCenter === true)
    {
        this.verticalCenter = true;
    }
    else
    {
        this.top = this._top;
        this.bottom = this._bottom;
    }
};

/**
 * Update width or height if it's set in percent. It happened when a parent is set or if the parent is resize.
 * @method FORGE.DisplayObject#_updatePercentValues
 * @private
 * @param {string} property - The property that have changed.
 */
FORGE.DisplayObject.prototype._updatePercentValues = function(property)
{
    var widthRelated = property.toLowerCase().indexOf("width") !== -1 || property === "both";
    var heightRelated = property.toLowerCase().indexOf("height") !== -1 || property === "both";
    var notification = 0;

    if(widthRelated === true && this._unitWidth === "%")
    {
        this._dom.style.width = this.pixelWidth+"px";
        this._dom.width = this.pixelWidth;
        notification += 1;
    }

    if(heightRelated === true && this._unitHeight === "%")
    {
        this._dom.style.height = this.pixelHeight+"px";
        this._dom.height = this.pixelHeight;
        notification += 2;
    }

    switch(notification)
    {
        case 1:
            this._notifyResize({ property: "width" });
            break;
        case 2:
            this._notifyResize({ property: "height" });
            break;
        case 3:
            this._notifyResize({ property: "both" });
            break;
        default:
            // no notification needed
    }
};

/**
 * Internal method that add a pending value for a specific property.
 * @method FORGE.DisplayObject#_addPending
 * @private
 * @param {string} prop - The property name for the pending value.
 * @param {*} value - The value you want to associate to the property.
 */
FORGE.DisplayObject.prototype._addPending = function(prop, value)
{
    //this._pending[prop] = value;
    this._pending.push(
    {
        prop: prop,
        value: value
    });
};

/**
 * Internal method to known if a property have a pending value.
 * @method FORGE.DisplayObject#_hasPending
 * @private
 * @param {string} prop - The property name for the pending value.
 * @return {boolean} Returns true if the property have a pending value, false if not.
 */
FORGE.DisplayObject.prototype._hasPending = function(prop)
{
    //return (typeof this._pending[prop] !== "undefined");
    for(var i = 0, ii = this._pending.length; i < ii; i++)
    {
        if(this._pending[i].prop === prop)
        {
            return true;
        }
    }

    return false;
};

/**
 * Method to clear a specific property from the pending list
 * @method  FORGE.DisplayObject#_clearPending
 * @private
 * @param  {string=} prop - The prop to clear, if not specified clear all the pending
 */
FORGE.DisplayObject.prototype._clearPending = function(prop)
{
    if(typeof prop === "string")
    {
        //delete this._pending[prop];
        var i = this._pending.length;

        while(i--)
        {
            if(this._pending[i].prop === prop)
            {
                this._pending.splice(i, 1);
            }
        }
    }
    else
    {
        this._pending = [];
    }
};

/**
 * Apply all the pending values then reset the object that stores these values.
 * @method FORGE.DisplayObject#_applyPending
 * @private
 * @param {boolean} needPending - does it need pending ?
 */
FORGE.DisplayObject.prototype._applyPending = function(needPending)
{
    this.log("_applyPending");

    this._needPending = needPending;

    if(this._pending === null || this._pending.length === 0)
    {
        return;
    }

    this._pendingApplying = true;

    // for(var prop in this._pending)
    // {
    //     this[prop] = this._pending[prop];
    // }

    for(var i = 0, ii = this._pending.length; i < ii; i++)
    {
        this[this._pending[i].prop] = this._pending[i].value;
    }

    this._pendingApplying = false;

    this._clearPending();
};

/**
 * Show this display object.
 * @method FORGE.DisplayObject#show
 */
FORGE.DisplayObject.prototype.show = function()
{
    this._dom.style.display = "block";
    this._notifyShow();
};

/**
 * Hide this display object.
 * @method FORGE.DisplayObject#hide
 */
FORGE.DisplayObject.prototype.hide = function()
{
    this._dom.style.display = "none";
    this._notifyHide();
};

/**
 * Toggles th visibility of this display object.
 * @method  FORGE.DisplayObject#toggleVisibility
 */
FORGE.DisplayObject.prototype.toggleVisibility = function()
{
    this.visible = !this.visible;
};

/**
 * Maximize the size of this display object to the size of its parent.
 * @method FORGE.DisplayObject#maximize
 * @param {boolean} keepMaximized - Set this param to true if you want that this display object auto resize to max when its parent is resized.
 */
FORGE.DisplayObject.prototype.maximize = function(keepMaximized)
{
    if(keepMaximized === true)
    {
        this._maximized = true;

        if(this._needPending === true)
        {
            this._addPending("maximized", true);
        }
    }

    if(this._parent !== null)
    {
        this._keepRatio = false;

        var width = this.pixelWidth;
        this._width = this._parent.innerWidth;
        this._unitWidth = "px";
        this._dom.style.width = this._parent.innerWidth+"px";
        this._dom.width = this._parent.innerWidth;

        var height = this.pixelHeight;
        this._height = this._parent.innerHeight;
        this._unitHeight = "px";
        this._dom.style.height = this._parent.innerHeight+"px";
        this._dom.height = this._parent.innerHeight;

        if(width !== this.pixelWidth || height !== this.pixelHeight)
        {
            this._notifyResize({ property: "both" });
        }
    }
};

/**
 * Method to know if a display object is in dom.
 * @method  FORGE.DisplayObject#isInDom
 * @return {boolean} Returns true if the display Object is in DOM, false if not.
 */
FORGE.DisplayObject.prototype.isInDom = function()
{
    return FORGE.Dom.has(this._dom);
};

/**
 * Resize this display object to a given width / height.
 * @method FORGE.DisplayObject#resize
 * @param {number|string} width - The width you want to set, it can be for example 10, "10px" or "10%".
 * @param {number|string} height - The height you want to set, it can be for example 10, "10px" or "10%".
 */
FORGE.DisplayObject.prototype.resize = function(width, height)
{
    if(width !== null && typeof width !== "undefined")
    {
        this.width = width;
    }

    if(height !== null && typeof height !== "undefined")
    {
        this.height = height;
    }
};

/**
 * Request a fullscreen enter on this display object.
 * @method  FORGE.DisplayObject#fullscreenEnter
 */
FORGE.DisplayObject.prototype.fullscreenEnter = function()
{
    if(document[FORGE.Device.fullscreenEnabled] === true && this.isFullscreen() === false)
    {
        this._dom[FORGE.Device.requestFullscreen]();
    }
};

/**
 * Request a fullscreen exit on this display object.
 * @method  FORGE.DisplayObject#fullscreenExit
 */
FORGE.DisplayObject.prototype.fullscreenExit = function()
{
    if(document[FORGE.Device.fullscreenEnabled] === true && this.isFullscreen() === true)
    {
        document[FORGE.Device.exitFullscreen]();
    }
};

/**
 * Know if this display object is in fullscreen
 * @method  FORGE.DisplayObject#isFullscreen
 * @return {boolean}
 */
FORGE.DisplayObject.prototype.isFullscreen = function()
{
    return document[FORGE.Device.fullscreenElement] === this._dom;
};

/**
 * Destroy method.
 * @method FORGE.DisplayObject#destroy
 */
FORGE.DisplayObject.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    this._viewer.display.unregister(this);

    if(this._parent !== null)
    {
        this._parent.removeChild(this, false);
        this._parent = null;
    }

    if(this._pointer !== null)
    {
        this._pointer.destroy();
        this._pointer = null;
    }

    if(this._drag !== null)
    {
        this._drag.destroy();
        this._drag = null;
    }

    if(this._onResize !== null)
    {
        this._onResize.destroy();
        this._onResize = null;
    }

    if(this._onBorderResize !== null)
    {
        this._onBorderResize.destroy();
        this._onBorderResize = null;
    }

    if(this._onReady !== null)
    {
        this._onReady.destroy();
        this._onReady = null;
    }

    if(this._onAddedToParent !== null)
    {
        this._onAddedToParent.destroy();
        this._onAddedToParent = null;
    }

    if(this._onAddedToDom !== null)
    {
        this._onAddedToDom.destroy();
        this._onAddedToDom = null;
    }

    if(this._onFullscreenEnter !== null)
    {
        this._onFullscreenEnter.destroy();
        this._onFullscreenEnter = null;
    }

    if(this._onFullscreenExit !== null)
    {
        this._onFullscreenExit.destroy();
        this._onFullscreenExit = null;
    }

    this._dom = null;

    this._data = null;

    this._viewer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the viewer reference object.
 * @name FORGE.DisplayObject#viewer
 * @readonly
 * @type {FORGE.Viewer}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "viewer",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._viewer;
    }
});

/**
 * Get the dom element that compose this display object.
 * @name FORGE.DisplayObject#dom
 * @readonly
 * @type {Element|HTMLElement}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "dom",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._dom;
    }
});

/**
 * Get and set the id of this display object.
 * @name FORGE.DisplayObject#id
 * @type {string}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "id",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._id;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        this._id = value;
        this._dom.id = this._id;
    }
});

/**
 * Get the ready status of this display object.
 * @name FORGE.DisplayObject#ready
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "ready",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._ready;
    }
});

/**
 * Get and set the parent of this display object.
 * @name FORGE.DisplayObject#parent
 * @type {FORGE.DisplayObjectContainer}
 *
 * @todo  Find a clean way to identify DisplayObjectContainer and other class that inherits from.
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "parent",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._parent;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "object" || Array.isArray(value.children) === false || value === this._parent)
        {
            return;
        }

        this._parent = value;
        this._dom.style.position = "absolute";

        if(this._maximized === true)
        {
            this.maximize(this._maximized);
        }

        this._updatePercentValues("both");
        this._updateAnchors();

        if(this._onAddedToParent !== null)
        {
            this._onAddedToParent.dispatch();
        }

        if(this._parent.isInDom() === true)
        {
            this._notifyAddedToDom();
            this._notifyShow();
        }
    }
});

/**
 * Get and set the visibility of this display object.
 * @name FORGE.DisplayObject#visible
 * @type {boolean}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "visible",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._dom.style.display === "block";
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        if(value === true)
        {
            this.show();
        }
        else
        {
            this.hide();
        }
    }
});

/**
 * Get and set the x position of this display object.
 * @name FORGE.DisplayObject#x
 * @type {number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "x",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._x;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var x = this._x;
        this._x = value;
        this._dom.style.left = this._x+"px";

        if(this._onMove !== null && x !== this._x)
        {
            this._onMove.dispatch({ property: "x" });
        }
    }
});

/**
 * Get and set the y position of this display object.
 * @name FORGE.DisplayObject#y
 * @type {number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "y",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._y;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var y = this._y;
        this._y = value;
        this._dom.style.top = this._y+"px";

        if(this._onMove !== null && y !== this._y)
        {
            this._onMove.dispatch({ property: "y" });
        }
    }
});

/**
 * Get and set the keepRatio status of this display object.
 * @name FORGE.DisplayObject#keepRatio
 * @type {boolean}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "keepRatio",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._keepRatio;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "boolean" || value === this._keepRatio)
        {
            return;
        }

        this._keepRatio = value;
    }
});

/**
 * Get and set the width of this display object.
 * The getter will always return a number, but you can pass to the setter either a number like 10 or a string like "10px" or "10%".
 * @name FORGE.DisplayObject#width
 * @type {number|string}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "width",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._width;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        var width = this._width;
        var unitWidth = this._unitWidth;

        if(typeof value === "string")
        {
            var size = FORGE.Utils.parseSizeString(value);

            if(size.value === null || size.unit === null)
            {
                throw "FORGE.DisplayObject.width value "+value+" is incorrect";
            }

            this._unitWidth = size.unit;
            this._width = size.value;
        }
        else if(typeof value === "number")
        {
            this._width = value;
        }
        else
        {
            return;
        }

        if(this._needPending === true)
        {
            this._addPending("width", this._width);
            return;
        }

        this._maximized = false;

        this._dom.style.width = this.pixelWidth+"px";
        this._dom.width = this.pixelWidth;

        if((width !== this._width || unitWidth !== this._unitWidth) || this._pendingApplying === true)
        {
            this._notifyResize({ property: "width" });
        }
    }
});

/**
 * Get and set the width of this display object in pixel only.
 * @name FORGE.DisplayObject#pixelWidth
 * @type {number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "pixelWidth",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._unitWidth === "px")
        {
            return this._width;
        }
        else if (this._unitWidth === "%")
        {
            if(this._parent !== null)
            {
                return this._parent.innerWidth * this._width / 100;
            }
            else
            {
                return 0;
            }
        }
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var width = this._width;
        var unitWidth = this._unitWidth;

        this._width = value;
        this._unitWidth = "px";

        if(this._needPending === true)
        {
            this._addPending("pixelWidth", value);
            return;
        }

        this._maximized = false;

        this._dom.style.width = this.pixelWidth+"px";
        this._dom.width = this.pixelWidth;

        if((width !== this._width || unitWidth !== "px") || this._pendingApplying === true)
        {
            this._notifyResize({ property: "pixelWidth" });
        }
    }
});

/**
 * Get and set the width of this display object in percent only.
 * @name FORGE.DisplayObject#percentWidth
 * @type {number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "percentWidth",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._unitWidth === "%")
        {
            return this._width;
        }
        else if(this._unitWidth === "px")
        {
            if(this._parent !== null)
            {
                return this._width / this._parent.innerWidth * 100;
            }
            else
            {
                return 0;
            }
        }
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var width = this._width;
        var unitWidth = this._unitWidth;

        this._width = value;
        this._unitWidth = "%";

        if(this._needPending === true)
        {
            this._addPending("percentWidth", value);
            return;
        }

        this._maximized = false;

        this._dom.style.width = this.pixelWidth+"px";
        this._dom.width = this.pixelWidth;

        if((width !== this._width || unitWidth !== "%") || this._pendingApplying === true)
        {
            this._notifyResize({ property: "percentWidth" });
        }
    }
});

/**
 * Get and set the width unit of this display object.
 * @name FORGE.DisplayObject#unitWidth
 * @type {string}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "unitWidth",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._unitWidth;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "string" || (value !== "px" && value !== "%"))
        {
            return;
        }

        var unitWidth = this._unitWidth;

        this._unitWidth = value;

        if(this._needPending === true)
        {
            this._addPending("unitWidth", value);
            return;
        }

        this._maximized = false;

        this._dom.style.width = this.pixelWidth+"px";
        this._dom.width = this.pixelWidth;

        if(unitWidth !== this._unitWidth || this._pendingApplying === true)
        {
            this._notifyResize({ property: "unitWidth" });
        }
    }
});

/**
 * Get the inner width (understand width without borders) of this DisplayObject.
 * @name  FORGE.DisplayObject#innerWidth
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "innerWidth",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this.pixelWidth - (this._borderWidth * 2);
    }
});

/**
 * Get and set the height of this display object.
 * The getter will always return a number, but you can pass to the setter either a number like 10 or a string like "10px" or "10%".
 * @name FORGE.DisplayObject#height
 * @type {number|string}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "height",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._height;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        var height = this._height;
        var unitHeight = this._unitHeight;

        if(typeof value === "string")
        {
            var size = FORGE.Utils.parseSizeString(value);

            if(size.value === null || size.unit === null)
            {
                throw "FORGE.DisplayObject.height value "+value+" is incorrect";
            }

            this._unitHeight = size.unit;
            this._height = size.value;
        }
        else if(typeof value === "number")
        {
            this._height = value;
        }
        else
        {
            return;
        }

        if(this._needPending === true)
        {
            this._addPending("height", this._height);
            return;
        }

        this._maximized = false;

        this._dom.style.height = this.pixelHeight+"px";
        this._dom.height = this.pixelHeight;

        if((height !== this._height || unitHeight !== this._unitHeight) || this._pendingApplying === true)
        {
            this._notifyResize({ property: "height" });
        }
    }
});

/**
 * Get and set the height of this display object in pixel only.
 * @name FORGE.DisplayObject#pixelHeight
 * @type {number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "pixelHeight",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._unitHeight === "px")
        {
            return this._height;
        }
        else if (this._unitHeight === "%")
        {
            if(this._parent !== null)
            {
                return this._parent.innerHeight * this._height / 100;
            }
            else
            {
                return 0;
            }
        }
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var height = this._height;
        var unitHeight = this._unitHeight;

        this._height = value;
        this._unitHeight = "px";

        if(this._needPending === true)
        {
            this._addPending("pixelHeight", value);
            return;
        }

        this._maximized = false;

        this._dom.style.height = this.pixelHeight+"px";
        this._dom.height = this.pixelHeight;

        if((height !== this._height || unitHeight !== "px") || this._pendingApplying === true)
        {
            this._notifyResize({ property: "pixelHeight" });
        }
    }
});

/**
 * Get and set the height of this display object in percent only.
 * @name FORGE.DisplayObject#percentHeight
 * @type {number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "percentHeight",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._unitHeight === "%")
        {
            return this._height;
        }
        else if(this._unitHeight === "px")
        {
            if(this._parent !== null)
            {
                return this._height / this._parent.innerHeight * 100;
            }
            else
            {
                return 0;
            }
        }
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var height = this._height;
        var unitHeight = this._unitHeight;

        this._height = value;
        this._unitHeight = "%";

        if(this._needPending === true)
        {
            this._addPending("percentHeight", value);
            return;
        }

        this._maximized = false;

        this._dom.style.height = this.pixelHeight+"px";
        this._dom.height = this.pixelHeight;

        if((height !== this._height || unitHeight !== "%") || this._pendingApplying === true)
        {
            this._notifyResize({ property: "percentHeight" });
        }
    }
});

/**
 * Get and set the height unit of this display object.
 * @name FORGE.DisplayObject#unitHeight
 * @type {string}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "unitHeight",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._unitHeight;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        var unitHeight = this._unitHeight;

        this._unitHeight = value;

        if(this._needPending === true)
        {
            this._addPending("unitHeight", value);
            return;
        }

        this._maximized = false;

        this._dom.style.height = this.pixelHeight+"px";
        this._dom.height = this.pixelHeight;

        if(unitHeight !== this._unitHeight || this._pendingApplying === true)
        {
            this._notifyResize({ property: "unitHeight" });
        }
    }
});

/**
 * Get the inner height in pixels (understand height without borders) of this DisplayObject.
 * @name  FORGE.DisplayObject#innerHeight
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "innerHeight",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this.pixelHeight - (this._borderWidth * 2);
    }
});

/**
 * Get and set the maximized status of this display object.
 * @name FORGE.DisplayObject#maximized
 * @type {boolean}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "maximized",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._maximized;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._maximized = value;

        if(this._maximized === true)
        {
            this.maximize(true);
        }
    }
});


/**
 * Get and set the horizontal center status of this display object.
 * @name FORGE.DisplayObject#horizontalCenter
 * @type {boolean}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "horizontalCenter",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._horizontalCenter;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._horizontalCenter = value;

        if(this._horizontalCenter === true)
        {
            this._left = null;
            this._right = null;
        }

        if(this._parent === null)
        {
            return;
        }

        var x = this._x;
        this._x = (this._parent.innerWidth -this.pixelWidth) / 2;
        this._dom.style.left = this._x+"px";

        if(this._onMove !== null && x !== this._x)
        {
            this._onMove.dispatch({ property: "x" });
        }
    }
});

/**
 * Get and set the vertical center status of this display object.
 * @name FORGE.DisplayObject#verticalCenter
 * @type {boolean}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "verticalCenter",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._verticalCenter;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._verticalCenter = value;

        if(this._verticalCenter === true)
        {
            this._top = null;
            this._bottom = null;
        }

        if(this._parent === null)
        {
            return;
        }

        var y = this._y;
        this._y = (this._parent.innerHeight - this.pixelHeight) / 2;
        this._dom.style.top = this._y+"px";

        if(this._onMove !== null && y !== this._y)
        {
            this._onMove.dispatch({ property: "y" });
        }
    }
});

/**
 * Get and set the top anchor of this display object.
 * @name FORGE.DisplayObject#top
 * @type {?number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "top",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._top;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" && value !== null)
        {
            return;
        }

        this._top = value;
        this._verticalCenter = false;

        if(this._parent === null || this._top === null)
        {
            return;
        }

        var y = this._y;
        this._y = value;
        this._dom.style.top = this._y+"px";

        if(this._onMove !== null && y !== this._y)
        {
            this._onMove.dispatch({ property: "y" });
        }
    }
});

/**
 * Get and set the right anchor of this display object.
 * @name FORGE.DisplayObject#right
 * @type {?number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "right",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._right;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" && value !== null)
        {
            return;
        }

        this._right = value;
        this._horizontalCenter = false;

        if(this._parent === null || this._right === null)
        {
            return;
        }

        var x = this._x;
        this._x = this._parent.innerWidth - this.pixelWidth - value;
        this._dom.style.left = this._x+"px";

        if(this._onMove !== null && x !== this._x)
        {
            this._onMove.dispatch({ property: "x" });
        }
    }
});

/**
 * Get and set the bottom anchor of this display object.
 * @name FORGE.DisplayObject#bottom
 * @type {?number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "bottom",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._bottom;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" && value !== null)
        {
            return;
        }

        this._bottom = value;
        this._verticalCenter = false;

        if(this._parent === null || this._bottom === null)
        {
            return;
        }

        var y = this._y;
        this._y = this._parent.innerHeight - this.pixelHeight - value;
        this._dom.style.top = this._y+"px";

        if(this._onMove !== null && y !== this._y)
        {
            this._onMove.dispatch({ property: "y" });
        }
    }
});

/**
 * Get and set the left anchor of this display object.
 * @name FORGE.DisplayObject#left
 * @type {?number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "left",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._left;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" && value !== null)
        {
            return;
        }

        this._left = value;
        this._horizontalCenter = false;

        if(this._parent === null || this._left === null)
        {
            return;
        }

        var x = this._x;
        this._x = value;
        this._dom.style.left = this._x+"px";

        if(this._onMove !== null && x !== this._x)
        {
            this._onMove.dispatch({ property: "x" });
        }
    }
});

/**
 * Get and set the left alpha of this display object. (between 0 and 1).
 * @name FORGE.DisplayObject#alpha
 * @type {number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "alpha",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._alpha;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" || value === this._alpha)
        {
            return;
        }

        this._alpha = value;
        this._dom.style.opacity = this._alpha;
    }
});

/**
 * Get and set the rotation of this display object. (in degree).
 * @name FORGE.DisplayObject#rotation
 * @type {number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "rotation",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._rotation;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" || value === this._rotation)
        {
            return;
        }

        this._rotation = value;
        this._dom.style.transform = "rotate("+this._rotation+"deg)";
    }
});

/**
 * Get and set the backgound CSS value of this display object.
 * @name FORGE.DisplayObject#background
 * @type {string}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "background",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._background;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "string" || value === this._background)
        {
            return;
        }

        this._background = value;
        this._dom.style.background = this._background;
    }
});

/**
 * Get and set the border-style CSS value of this display object.
 * @name FORGE.DisplayObject#borderStyle
 * @type {string}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "borderStyle",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._borderStyle;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        var borderStyles =
        [
            "none",
            "dotted",
            "dashed",
            "solid",
            "double",
            "groove",
            "ridge",
            "inset",
            "outset"
        ];

        if(borderStyles.indexOf(value) === -1 || value === this._borderStyle)
        {
            return;
        }

        this._borderStyle = value;

        if(this._needPending === true)
        {
            this._addPending("borderStyle", value);
            return;
        }

        this._dom.style.borderStyle = this._borderStyle;
    }
});

/**
 * Get and set the border-width CSS value of this display object.
 * @name FORGE.DisplayObject#borderWidth
 * @type {number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "borderWidth",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._borderWidth;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        var borderWidth = this._borderWidth;

        this._borderWidth = value;

        if(this._needPending === true)
        {
            this._addPending("borderWidth", value);
            return;
        }

        this._dom.style.borderWidth = this._borderWidth+"px";

        if(borderWidth !== this._borderWidth || this._pendingApplying === true)
        {
            this._notifyBorderResize();
        }
    }
});

/**
 * Get and set the border-color CSS value of this display object.
 * @name FORGE.DisplayObject#borderColor
 * @type {string}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "borderColor",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._borderColor;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "string" || value === this._borderColor)
        {
            return;
        }

        this._borderColor = value;
        this._dom.style.borderColor = this._borderColor;
    }
});

/**
 * Get and set the border-radius CSS value of this display object.
 * @name FORGE.DisplayObject#borderRadius
 * @type {number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "borderRadius",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._borderRadius;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if((typeof value !== "number" && typeof value !== "string") || value === this._borderRadius)
        {
            return;
        }

        if (typeof value === "string")
        {
            value = parseInt(value, 10);
        }

        if (isNaN(value))
        {
            return;
        }

        this._borderRadius = value;
        this._dom.style.borderRadius = this._borderRadius + "px";
    }
});

/**
 * Get the global offset
 * @name FORGE.DisplayObject#globalOffset
 * @readonly
 * @type {{top:number,left:number}}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "globalOffset",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        var element = this._dom;
        var top = 0, left = 0;

        do
        {
            top += element.offsetTop || 0;
            left += element.offsetLeft || 0;
            element = element.offsetParent;
        }
        while(element);

        return { top: top, left: left };
    }
});

/**
 * Get and set the tooltip value of this display object. This is the title dom property.
 * @name FORGE.DisplayObject#tooltip
 * @type {string}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "tooltip",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._tooltip;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "string" || value === this._tooltip)
        {
            return;
        }

        this._tooltip = value;
        this._dom.title = this._tooltip;
    }
});

/**
 * Get and set the index value of this display object. This is the z-index CSS property.
 * @name FORGE.DisplayObject#index
 * @type {number}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "index",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        return this._index;
    },

    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "number" || value === this._index)
        {
            return;
        }

        this._index = value;
        this._dom.style.zIndex = this._index;
    }
});

/**
 * Set the fullscreen property of this display object.
 * @name FORGE.DisplayObject#fullscreen
 * @type {boolean}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "fullscreen",
{
    /** @this {FORGE.DisplayObject} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        if(value === true)
        {
            this.fullscreenEnter();
        }
        else
        {
            this.fullscreenExit();
        }
    }
});

/**
 * Get the {@link FORGE.Pointer} object that handles mouse and touch events for this display object.
 * @name FORGE.DisplayObject#pointer
 * @readonly
 * @type {FORGE.Pointer}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "pointer",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._pointer === null)
        {
            this._pointer = new FORGE.Pointer(this);
        }

        return this._pointer;
    }
});

/**
 * Get the {@link FORGE.Drag} object that handles drag events for this display object.
 * @name FORGE.DisplayObject#drag
 * @readonly
 * @type {FORGE.Drag}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "drag",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._drag === null)
        {
            this._drag = new FORGE.Drag(this);
        }

        return this._drag;
    }
});

/**
 * Get the "onResize" {@link FORGE.EventDispatcher} of this display object.
 * @name FORGE.DisplayObject#onResize
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "onResize",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._onResize === null)
        {
            this._onResize = new FORGE.EventDispatcher(this);
        }

        return this._onResize;
    }
});

/**
 * Get the "onBorderResize" {@link FORGE.EventDispatcher} of this display object.
 * @name FORGE.DisplayObject#onBorderChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "onBorderResize",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._onBorderResize === null)
        {
            this._onBorderResize = new FORGE.EventDispatcher(this);
        }

        return this._onBorderResize;
    }
});

/**
 * Get the "onMove" {@link FORGE.EventDispatcher} of this display object.<br>
 * This event is triggered when object's coordinate (x, y) changed.
 * @name FORGE.DisplayObject#onMove
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "onMove",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._onMove === null)
        {
            this._onMove = new FORGE.EventDispatcher(this);
        }

        return this._onMove;
    }
});

/**
 * Get the "onReady" {@link FORGE.EventDispatcher} of this display object.
 * @name FORGE.DisplayObject#onReady
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "onReady",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._onReady === null)
        {
            this._onReady = new FORGE.EventDispatcher(this, true);
        }

        return this._onReady;
    }
});

/**
 * Get the "onAddedToParent" {@link FORGE.EventDispatcher} of this display object.
 * @name FORGE.DisplayObject#onAddedToParent
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "onAddedToParent",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._onAddedToParent === null)
        {
            this._onAddedToParent = new FORGE.EventDispatcher(this);
        }

        return this._onAddedToParent;
    }
});

/**
 * Get the "onAddedToDom" {@link FORGE.EventDispatcher} of this display object.
 * @name FORGE.DisplayObject#onAddedToDom
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "onAddedToDom",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._onAddedToDom === null)
        {
            this._onAddedToDom = new FORGE.EventDispatcher(this);
        }

        return this._onAddedToDom;
    }
});

/**
 * Get the "onShow" {@link FORGE.EventDispatcher} of this display object.
 * @name FORGE.DisplayObject#onShow
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "onShow",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._onShow === null)
        {
            this._onShow = new FORGE.EventDispatcher(this);
        }

        return this._onShow;
    }
});

/**
 * Get the "onHide" {@link FORGE.EventDispatcher} of this display object.
 * @name FORGE.DisplayObject#onHide
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "onHide",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._onHide === null)
        {
            this._onHide = new FORGE.EventDispatcher(this);
        }

        return this._onHide;
    }
});

/**
 * Get the "onFullscreenEnter" {@link FORGE.EventDispatcher} of this display object.
 * @name FORGE.DisplayObject#onFullscreenEnter
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "onFullscreenEnter",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._onFullscreenEnter === null)
        {
            this._onFullscreenEnter = new FORGE.EventDispatcher(this);
        }

        return this._onFullscreenEnter;
    }
});

/**
 * Get the "onFullscreenExit" {@link FORGE.EventDispatcher} of this display object.
 * @name FORGE.DisplayObject#onFullscreenExit
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.DisplayObject.prototype, "onFullscreenExit",
{
    /** @this {FORGE.DisplayObject} */
    get: function()
    {
        if(this._onFullscreenExit === null)
        {
            this._onFullscreenExit = new FORGE.EventDispatcher(this);
        }

        return this._onFullscreenExit;
    }
});



/**
 * A display object container is a {@link FORGE.DisplayObject} that can contains other {@link FORGE.DisplayObject} as children.
 *
 * @constructor FORGE.DisplayObjectContainer
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {?(Element|HTMLElement)=} dom - Use a specific dom element to be the display object, if undefined a div will be created.
 * @param {?string=} className - Define a className of object for objects that extends DisplayObjectContainer.
 * @param {(Element|HTMLElement)=} root - Is this container a root? Root is the main viewer container or any container<br>
 * that haven't a FORGE.DisplayObject as parent but a dom element that is not a ForgeJS object.
 * @extends {FORGE.DisplayObject}
 *
 * @todo Delete children on demand (recursive) + remove only children (recursive)
 */
FORGE.DisplayObjectContainer = function(viewer, dom, className, root)
{
    /**
     * Array of {@link FORGE.DisplayObject} of this display object container.
     * @name FORGE.DisplayObjectContainer#_children
     * @type {Array<FORGE.DisplayObject>}
     * @private
     */
    this._children = [];

    /**
     * Is this container a root one?
     * @name  FORGE.DisplayObjectContainer#_root
     * @type {Element|HTMLElement}
     * @private
     */
    this._root = (typeof root !== "undefined") ? root : null;

    /**
     * This object handles all variables related to a root resizable container.
     * @name  FORGE.DisplayObjectContainer#_rootData
     * @type {?DisplayObjectContainerRootData}
     * @private
     */
    this._rootData = null;

    /**
     * Fit has been already applied on the container?
     * @name  FORGE.DisplayObjectContainer#_fitted
     * @type {boolean}
     * @private
     */
    this._fitted = false;

    /**
     * The overflow mode of the container (CSS property)
     * @name  FORGE.DisplayObjectContainer#_overflow
     * @type {string}
     * @private
     */
    this._overflow = "hidden";

    FORGE.DisplayObject.call(this, viewer, dom, className || "DisplayObjectContainer");
};

FORGE.DisplayObjectContainer.prototype = Object.create(FORGE.DisplayObject.prototype);
FORGE.DisplayObjectContainer.prototype.constructor = FORGE.DisplayObjectContainer;


/**
 * Boot sequence
 * @method  FORGE.DisplayObjectContainer#_boot
 * @private
 */
FORGE.DisplayObjectContainer.prototype._boot = function()
{
    FORGE.DisplayObject.prototype._boot.call(this);

    if(this._className === "DisplayObjectContainer")
    {
        //root container have to be updated
        var needsUpdate = this._root !== null;

        if(needsUpdate === true)
        {
            this._rootData =
            {
                originalWidth: this._root.clientWidth,
                originalHeight: this._root.clientHeight,
                currentWidth: this._root.clientWidth,
                currentHeight: this._root.clientHeight,
                scaleWidth: 1,
                scaleHeight: 1,

                frameCount: 0, //Current frame count
                frameInterval: 10 //Number of frame needed to check size
            };

            this._width = this._rootData.currentWidth;
            this._dom.style.width = this.pixelWidth+"px";

            this._height = this._rootData.currentHeight;
            this._dom.style.height = this.pixelHeight+"px";

            this._dom.style.position = "absolute";

            this._root.appendChild(this._dom);
        }

        this._viewer.display.register(this, needsUpdate);
        this._notifyReady();
        this._applyPending(false);
    }
};

/**
 * Notify that the dispay object has been resized.<br>
 * This method ovverrides the {@link FORGE.DisplayObject} method.<br>
 * The parent will notify their children of its resize.
 * @method  FORGE.DisplayObjectContainer#_notifyResize
 * @private
 * @param {PropertyToUpdate} data - The data contains the property that have changed.
 */
FORGE.DisplayObjectContainer.prototype._notifyResize = function(data)
{
    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        this._children[i]._notifyParentResize(data);
    }

    FORGE.DisplayObject.prototype._notifyResize.call(this, data);
};


/**
 * Internal method used by parents to notify that this DisplayObject has been added to DOM.
 * It notifies all children in addition of the usual behavior.
 * @method FORGE.DisplayObject#_notifyAddedToDom
 * @private
 */
FORGE.DisplayObjectContainer.prototype._notifyAddedToDom = function()
{
    FORGE.DisplayObject.prototype._notifyAddedToDom.call(this);

    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        this._children[i]._notifyAddedToDom();
    }
};

/**
 * Notify that the visibility of this DisplayObjectContainer has changed to visible.<br>
 * This method overrides the DisplayObject's one.<br>
 * It notifies all children in addition of the usual behavior.
 * @method FORGE.DisplayObjectContainer#_notifyShow
 * @private
 */
FORGE.DisplayObjectContainer.prototype._notifyShow = function()
{
    FORGE.DisplayObject.prototype._notifyShow.call(this);

    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        this._children[i]._notifyShow();
    }
};

/**
 * Notify that the visibility of this DisplayObjectContainer has changed to invisible.<br>
 * This method overrides the DisplayObject's one.<br>
 * It notifies all children in addition of the usual behavior.
 * @method FORGE.DisplayObjectContainer#_notifyHide
 * @private
 */
FORGE.DisplayObjectContainer.prototype._notifyHide = function()
{
    FORGE.DisplayObject.prototype._notifyHide.call(this);

    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        this._children[i]._notifyHide();
    }
};

/**
 * Get the index of a child.
 * @method  FORGE.DisplayObjectContainer#_indexOfChild
 * @private
 * @param  {FORGE.DisplayObject} child - The child you search for.
 * @return {number} Returns index of the searched child if found, -1 if not found.
 */
FORGE.DisplayObjectContainer.prototype._indexOfChild = function(child)
{
    if(this._children === null)
    {
        return -1;
    }

    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        if(this._children[i] === child)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Apply the index of the children.
 * @method  FORGE.DisplayObjectContainer#_applyChildrenIndexes
 * @private
 */
FORGE.DisplayObjectContainer.prototype._applyChildrenIndexes = function()
{
    var child;
    for(var i = 0, ii = this._children.length; i < ii; i++)
    {
        child = this._children[i];
        child.index = i;
    }
};

/**
 * Update method that is called only if the container is a root container.
 * @method FORGE.DisplayObjectContainer#update
 */
FORGE.DisplayObjectContainer.prototype.update = function()
{
    this._rootData.frameCount++;

    //trigger update every X frames defined by this._frameInterval
    if(this._rootData.frameCount < this._rootData.frameInterval)
    {
        return;
    }

    this._rootData.frameCount = 0;

    var w = this._root.clientWidth;
    var h = this._root.clientHeight;

    var resized = false;

    if(w !== this._rootData.currentWidth)
    {
        this._rootData.currentWidth = w;
        this._rootData.scaleWidth = this._rootData.currentWidth / this._rootData.originalWidth;
        resized = true;
    }

    if(h !== this._rootData.currentHeight)
    {
        this._rootData.currentHeight = h;
        this._rootData.scaleHeight = this._rootData.currentHeight / this._rootData.scaleHeight;
        resized = true;
    }

    if(resized === true)
    {
        this.resize(this._rootData.currentWidth, this._rootData.currentHeight);
    }
};

/**
 * Add a child to this display object container.
 * @method  FORGE.DisplayObjectContainer#addChild
 * @param {FORGE.DisplayObject|Element} child - The {@link FORGE.DisplayObject} you want to add to this display object container.
 */
FORGE.DisplayObjectContainer.prototype.addChild = function(child)
{
    if (child === this)
    {
        throw "You can't add a FORGE.DisplayObjectContainer to itself!";
    }

    var c = child;

    // If a DOM Element is added, convert it to a display object.
    if (child instanceof Element)
    {
        c = new FORGE.DisplayObject(this._viewer, child);
    }

    // Add dom element to the container dom
    this._dom.appendChild(c.dom);

    // Affect the parent value (it triigers the added to parent event so it is important to be in DOM before!)
    c.parent = this;

    // Set the index
    var index = this._children.push(/** @type {FORGE.DisplayObject} */ (c)) - 1;
    if (c.index === null)
    {
        c.index = index;
    }
};

/**
 * Add a child to this display object container at a specific index.
 * @method  FORGE.DisplayObjectContainer#addChildAt
 * @param {FORGE.DisplayObject|Element} child - The {@link FORGE.DisplayObject} you want to add to this display object container.
 * @param {number} index - The index you want to apply to your child.
 */
FORGE.DisplayObjectContainer.prototype.addChildAt = function(child, index)
{
    var c = child;

    // If a DOM Element is added, convert it to a display object.
    if (child instanceof Element)
    {
        c = new FORGE.DisplayObject(this._viewer, child);
    }

    // Add dom element to the container dom
    this._dom.appendChild(c.dom);

    // Affect the parent value (it triggers the added to parent event so it is important to be in DOM before!)
    c.parent = this;

    // Set the index
    this._children.splice(index, 0, /** @type {FORGE.DisplayObject} */ (c));
    c.index = index;

    this._applyChildrenIndexes();
};

/**
 * Make the container to fit content.
 * @method  FORGE.DisplayObjectContainer#fitToContent
 */
FORGE.DisplayObjectContainer.prototype.fitToContent = function()
{
    var children = this._children;

    if(children.length > 0)
    {
        this._fitted = true;

        for(var i = 0, ii = children.length; i < ii; i++)
        {
            if(children[i].isInDom() === true && children[i].visible === true)
            {
                //@todo what happens if visible or isInDOM are set after?

                var maxWidth = Math.max(children[i].width + children[i].x, children[i].width + children[i].left, children[i].width + children[i].right);
                var maxHeight = Math.max(children[i].height + children[i].y, children[i].height + children[i].top, children[i].height + children[i].bottom);
                if(maxWidth > this.pixelWidth)
                {
                    this.width = maxWidth;
                }
                if(maxHeight > this.pixelHeight)
                {
                    this.height = maxHeight;
                }
            }
        }
    }

    if(this.parent !== null && FORGE.Utils.isTypeOf(this.parent, "DisplayObjectContainer") === true && this.parent._fitted === true)
    {
        //recursive to parent
        this.parent.fitToContent();
    }
};

/**
 * Remove a child from this display object container.
 * @method  FORGE.DisplayObjectContainer#removeChild
 * @param {FORGE.DisplayObject} child - The {@link FORGE.DisplayObject} you want to remove from this display object container.
 * @param {boolean=} destroy - Does the container have to destroy the child that is removed.
 */
FORGE.DisplayObjectContainer.prototype.removeChild = function(child, destroy)
{
    var index = this._indexOfChild(child);

    if(index !== -1)
    {
        this.removeChildAt(index, destroy);
    }
};

/**
 * Remove child at a specific index.
 * @method  FORGE.DisplayObjectContainer#removeChildAt
 * @param  {number} index - The index at which you want to remove the child .
 * @param  {boolean=} destroy - Does the method should destroy the child in addtion of removing of the display list.
 */
FORGE.DisplayObjectContainer.prototype.removeChildAt = function(index, destroy)
{
    if(index >= 0 && index < this._children.length)
    {
        var child = this._children[index];

        this._children.splice(index, 1);

        this._dom.removeChild(child.dom);

        if(typeof destroy === "undefined" || destroy === true)
        {
            child.destroy();
        }

        // reset container size if fit to content
        if(this._fitted === true && this._children.length === 0)
        {
            this.width = 0;
            this.height = 0;
        }
    }
};

/**
 * Remove all children.
 * @method  FORGE.DisplayObjectContainer#empty
 * @param  {boolean} destroy - Does the method should destroy the children in addtion of removing of the display list.
 */
FORGE.DisplayObjectContainer.prototype.empty = function(destroy)
{
    var index = this._children.length;

    while(index--)
    {
        this.removeChildAt(index, destroy);
    }
};

/**
 * Check if a {@link FORGE.DisplayObject} is a child of this display object container.
 * @method  FORGE.DisplayObjectContainer#hasChild
 * @param {FORGE.DisplayObject} child - The {@link FORGE.DisplayObject} you want to check.
 */
FORGE.DisplayObjectContainer.prototype.hasChild = function(child)
{
    return this._indexOfChild(child) !== -1;
};

/**
 * Destroy method.
 * @method FORGE.DisplayObjectContainer#destroy
 */
FORGE.DisplayObjectContainer.prototype.destroy = function()
{
    this.empty(false);

    this._children = null;

    this._root = null;
    this._rootData = null;

    FORGE.DisplayObject.prototype.destroy.call(this);
};

/**
* Get the children array.
* @name FORGE.DisplayObjectContainer#children
* @readonly
* @type {Array}
*/
Object.defineProperty(FORGE.DisplayObjectContainer.prototype, "children",
{
    /** @this {FORGE.DisplayObjectContainer} */
    get: function()
    {
        return this._children;
    }
});

/**
* Get and set the overflow property.
* @name FORGE.DisplayObjectContainer#oveflow
* @type {string}
*/
Object.defineProperty(FORGE.DisplayObjectContainer.prototype, "overflow",
{
    /** @this {FORGE.DisplayObjectContainer} */
    get: function()
    {
        return this._overflow;
    },

    /** @this {FORGE.DisplayObjectContainer} */
    set: function(value)
    {
        var values = ["hidden", "visible", "scroll"];

        if(values.indexOf(value) !== -1)
        {
            this._overflow = value;
            this._dom.style.overflow = value;
        }

    }
});


/**
 * Iframe display object.<br>
 * Can load an exteranl web page with i18n url.
 * @constructor FORGE.Iframe
 * @param {FORGE.Viewer} viewer - The viewer reference.
 * @param {(IframeConfig|string)=} config - Iframe configuration.
 * @extends {FORGE.DisplayObject}
 */
FORGE.Iframe = function(viewer, config)
{
    /**
     * The iframe html element
     * @name  FORGE.Iframe#_element
     * @type {Element|HTMLIFrameElement}
     * @private
     */
    this._element = null;

    /**
     * The configuration object.
     * @name  FORGE.Iframe#_config
     * @type {?(IframeConfig|string)}
     * @private
     */
    this._config = config || null;

    /**
     * The current url of the Iframe element.
     * @name FORGE.Iframe#_url
     * @type {string}
     * @private
     */
    this._url = "";

    /**
     * The i18n flag of this display object.
     * @name FORGE.Iframe#_i18n
     * @type {boolean}
     * @private
     */
    this._i18n = false;

    /**
     * The i18n key for the url to load into the iframe.
     * @name FORGE.Iframe#_i18nUrl
     * @type {string}
     * @private
     */
    this._i18nUrl = "";

    /**
     * The i18n locale string used to translate the url to load into the iframe.
     * @name FORGE.Iframe#_i18nUrlLocaleString
     * @type {FORGE.LocaleString}
     * @private
     */
    this._i18nUrlLocaleString = null;

    /**
     * This is copy of load complete handler with this as this reference (bind).
     * @name  FORGE.Iframe#_loadCompleteBind
     * @type {Function}
     * @default  null
     * @private
     */
    this._loadCompleteBind = null;

    /**
     * Is the current web content of the iframe is loaded.
     * @name FORGE.Iframe#_loaded
     * @type {boolean}
     * @private
     */
    this._loaded = false;

    /**
     * On load start event dispatcher.
     * @name  FORGE.Iframe#_onLoadStart
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLoadStart = null;

    /**
     * On load complete event dispatcher.
     * @name  FORGE.Iframe#_onLoadComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;

    FORGE.DisplayObject.call(this, viewer, null, "Iframe");
};

FORGE.Iframe.prototype = Object.create(FORGE.DisplayObject.prototype);
FORGE.Iframe.prototype.constructor = FORGE.Iframe;

/**
 * Boot sequence.
 * @method FORGE.Iframe#_boot
 * @private
 */
FORGE.Iframe.prototype._boot = function()
{
    FORGE.DisplayObject.prototype._boot.call(this);

    this._loadCompleteBind = this._loadCompleteHandler.bind(this);

    this._element = document.createElement("iframe");
    this._element.style.width = "100%";
    this._element.style.height = "100%";
    this._element.style.border = 0;
    this._element.style.overflow = "hidden";
    this._element.addEventListener("load", this._loadCompleteBind, this !== null && this !== undefined);
    this._element.setAttribute("allowFullScreen", "");
    this._dom.appendChild(this._element);

    if(this._config !== null)
    {
        this.load(this._config);
    }

    this._viewer.display.register(this);
    this._notifyReady();
    this._applyPending(false);
};

/**
 * Handler for locale change.
 * @method FORGE.Iframe#_localeChangeComplete
 * @private
 */
FORGE.Iframe.prototype._localeChangeComplete = function()
{
    this.log("_localeChangeComplete");

    if(this._viewer.i18n.hasValue(this._i18nUrl) === true)
    {
        var url = this._i18nUrlLocaleString.value;
        this._loadIframe(url);
    }
};

/**
 * Load iframe content
 * @method  FORGE.Iframe#_loadIframe
 * @param  {string} url - The url you want to load in the iframe.
 * @private
 */
FORGE.Iframe.prototype._loadIframe = function(url)
{
    this.log("_loadIframe url: "+url);
    this._loaded = false;

    if(this._onLoadStart !== null)
    {
        this._onLoadStart.dispatch();
    }

    this._url = url;
    this._element.src = this._url;
};

/**
 * Internal handler for load complete.
 * This method is copied in _loadCompleteBind on boot with a new this reference!
 * @method  FORGE.Iframe#_loadCompleteHandler
 * @private
 */
FORGE.Iframe.prototype._loadCompleteHandler = function()
{
    //At creation the iframe load an empty url?
    //Just to prevent false load complete notification
    if(this._url === "")
    {
        return;
    }

    this.log("_loadCompleteHandler url: "+this._url);
    this._loaded = true;

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.dispatch();
    }
};

/**
 * Parse the iframe configuration.
 * @method  FORGE.Iframe#_parseConfig
 * @param {(IframeConfig|string)} config - The configuration object to parse.
 * @private
 */
FORGE.Iframe.prototype._parseConfig = function(config)
{
    if(typeof config === "object" && config !== null)
    {
        this._i18n = config.i18n || false;

        if(this._i18n === true)
        {
            this._url = "";
            this._i18nUrl = config.url;
        }
        else
        {
            this._url = config.url;
        }
    }
    else
    {
        this._i18n = false;
        this._url = "";

        if(typeof config === "string")
        {
            this._url = config;
        }
    }
};

/**
 * Add locale change complete listener.
 * @method FORGE.Iframe#_addLocaleChangeListener
 * @private
 */
FORGE.Iframe.prototype._addLocaleChangeListener = function()
{
    if(this._viewer.i18n.onLocaleChangeComplete.has(this._localeChangeComplete, this) === false)
    {
        this._viewer.i18n.onLocaleChangeComplete.add(this._localeChangeComplete, this);
    }
};

/**
 * Load an iframe configuration.
 * @method  FORGE.Iframe#load
 * @param {(string|IframeConfig)} config - The url string or the configuration object to load.
 */
FORGE.Iframe.prototype.load = function(config)
{
    this._parseConfig(config);

    var url;
    if(this._i18n === true && (typeof this._i18nUrl === "string" && this._i18nUrl !== ""))
    {
        this._i18nUrlLocaleString = new FORGE.LocaleString(this._viewer, this._i18nUrl);

        this._addLocaleChangeListener();

        url = this._i18nUrlLocaleString.value;
    }
    else if(typeof this._url === "string" && this._url !== "")
    {
        url = this._url;
    }

    if(typeof url !== "undefined")
    {
        this._loadIframe(url);
    } 
};

/**
 * Destroy method.
 * @method FORGE.Iframe#destroy
 */
FORGE.Iframe.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    if(this._i18nUrlLocaleString !== null)
    {
        this._i18nUrlLocaleString.destroy();
        this._i18nUrlLocaleString = null;
        this._viewer.i18n.onLocaleChangeComplete.remove(this._localeChangeComplete, this);
    }

    if(this._onLoadStart !== null)
    {
        this._onLoadStart.destroy();
        this._onLoadStart = null;
    }

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    this._element = null;
    this._loadCompleteBind = null;

    FORGE.DisplayObject.prototype.destroy.call(this);
};

/**
* Get and set the i18n iframe url.
* @name FORGE.Iframe#i18nUrl
* @type {string} 
*/
Object.defineProperty(FORGE.Iframe.prototype, "i18nUrl", 
{
    /** @this {FORGE.Iframe} */
    get: function()
    {
        return this._i18nUrl;
    },

    /** @this {FORGE.Iframe} */
    set: function(value)
    {
        if(typeof value === "string")
        {
            this._i18n = true;
            this._i18nUrl = value;

            var url;
            if(this._i18nUrl !== "")
            {
                this._i18nUrlLocaleString = new FORGE.LocaleString(this._viewer, this._i18nUrl);

                this._addLocaleChangeListener();

                url = this._i18nUrlLocaleString.value;
            }

            if(typeof url !== "undefined")
            {
                this._loadIframe(url);
            }
        }
    }
});

/**
* Get and set the iframe url.<br>
* You'll lose the i18n behavior if you use this setter.
* @name FORGE.Iframe#url
* @type {string} 
*/
Object.defineProperty(FORGE.Iframe.prototype, "url", 
{
    /** @this {FORGE.Iframe} */
    get: function()
    {
        return this._url;
    },

    /** @this {FORGE.Iframe} */
    set: function(value)
    {
        if(typeof value === "string")
        {
            this._i18n = false;
            this._loadIframe(value);
        }
    }
});

/**
* Get the loaded status of the iframe.
* @name FORGE.Iframe#loaded
* @readonly
* @type {boolean} 
*/
Object.defineProperty(FORGE.Iframe.prototype, "loaded", 
{
    /** @this {FORGE.Iframe} */
    get: function()
    {
        return this._loaded;
    }
});

/**
* Get the onLoadStart {@link FORGE.EventDispatcher}.
* @name FORGE.Iframe#onLoadStart
* @readonly
* @type {FORGE.EventDispatcher} 
*/
Object.defineProperty(FORGE.Iframe.prototype, "onLoadStart", 
{
    /** @this {FORGE.Iframe} */
    get: function()
    {
        if(this._onLoadStart === null)
        {
            this._onLoadStart = new FORGE.EventDispatcher(this);
        }
        
        return this._onLoadStart;
    }
});

/**
* Get the onLoadComplete {@link FORGE.EventDispatcher}.
* @name FORGE.Iframe#onLoadComplete
* @readonly
* @type {FORGE.EventDispatcher} 
*/
Object.defineProperty(FORGE.Iframe.prototype, "onLoadComplete", 
{
    /** @this {FORGE.Iframe} */
    get: function()
    {
        if(this._onLoadComplete === null)
        {
            this._onLoadComplete = new FORGE.EventDispatcher(this);
        }
        
        return this._onLoadComplete;
    }
});


/**
 * A FORGE.TextField is a display object that displays an internationalizable string.
 *
 * @constructor FORGE.TextField
 * @param {FORGE.Viewer} viewer {@link FORGE.Viewer} reference.
 * @param {(TextFieldConfig|string)=} config - The text field config.
 * @extends {FORGE.DisplayObject}
 *
 * @todo    vertical-align ?
 * @todo    NO WILL DO A FONT MANAGER web-fonts with <link>
 * @todo    why +1 into _updateDom method
 * @todo    DONE _updateDom and auto size won't work if not displayed
 * @todo    I don't think that margin has to be part of any display object as long as all is postionned in x/y
 * @todo  clarify _updateTextarea "calc thing"
 */
FORGE.TextField = function(viewer, config)
{
    //CONTAINER @todo
    //margin
    //padding
    //shadow + range + angle + color + alpha : box-shadow: none|     h-shadow v-shadow blur spread color [inset]    |initial|inherit;

    //GOOGLE FONT @todo
    //to add :
    //<link href='https://fonts.googleapis.com/css?family=Open+Sans&subset=latin,vietnamese' rel='stylesheet' type='text/css'>
    //@import url(https://fonts.googleapis.com/css?family=Open+Sans&subset=latin,vietnamese);
    //to use
    //font-family: 'Open Sans', sans-serif;
    //
    // this._webfont = ""; //@todo test with google font url + font name (and options) as attributes
    // this._stdfont = "sans-serif";

    //_editable
    //todo editable => textarea with some css values + boxSizing + parent width and height if no values
    //ENTER => validate save data and set it as textfield.

    /**
     * Button Configuration object.
     * @name  FORGE.TextField#_config
     * @type {(TextFieldConfig|string|undefined)}
     * @private
     */
    this._config = config;

    /**
     * i18n key for internationalizable strings.
     * @name  FORGE.TextField#_i18nKey
     * @type {string}
     * @private
     */
    this._i18nKey = "";

    /**
     * Flag to know if the textfield is in i18n mode.
     * @name FORGE.TextField#_i18n
     * @type {boolean}
     * @private
     */
    this._i18n = false;

    /**
     * Internal {@link FORGE.LocaleString} reference.
     * @name  FORGE.TextField#_i18nLocaleString
     * @type {FORGE.LocaleString}
     * @private
     */
    this._i18nLocaleString = null;

    /**
     * Internal reference to the string that the text field have to display.
     * @name  FORGE.TextField#_value
     * @type {string}
     * @private
     */
    this._value = "";

    /**
     * Internal reference to the color of the displayed string, can be any CSS value.
     * @name  FORGE.TextField#_color
     * @type {string}
     * @private
     */
    this._color = "rgb(0, 0, 0)";

    /**
     * Does the text field manages its width automatically?
     * @name  FORGE.TextField#_autoWidth
     * @type {boolean}
     * @private
     */
    this._autoWidth = true;

    /**
     * Does the text field manages its height automatically?
     * @name  FORGE.TextField#_autoHeight
     * @type {boolean}
     * @private
     */
    this._autoHeight = true;

    /**
     * Margin of the text.
     * @name  FORGE.TextField#_margin
     * @type {number}
     * @private
     */
    //this._margin = 0;

    /**
     * Padding of the text.
     * @name  FORGE.TextField#_padding
     * @type {(number|string)}
     * @private
     */
    this._padding = 0;

    /**
     * Is the text is user selectable?
     * @name  FORGE.TextField#_selectable
     * @type {boolean}
     * @private
     */
    this._selectable = false;

    /**
     * Is the text is user editable?<br>
     * When edited the textfield is converted into a textarea element until the ENTER key is pressed.
     * @name  FORGE.TextField#_editable
     * @type {boolean}
     * @private
     */
    this._editable = false;

    /**
     * Reference to the keybinding used for the editable feature.
     * @name  FORGE.TextField#_editableKeyBinding
     * @type {FORGE.KeyBinding}
     * @private
     */
    this._editableKeyBinding = null;

    /**
     * Is the text can be breaked when reach the max width ?<br>
     * Will be unactive if autoWidth is set to true.
     * @name  FORGE.TextField#_wordWrap
     * @type {boolean}
     * @private
     */
    this._wordWrap = false;

    /**
     * The text-align CSS value. Can be "", "inherit", "left", "right", "center" and "justify".
     * @name  FORGE.TextField#_textAlign
     * @type {string}
     * @private
     */
    this._textAlign = "";

    /**
     * The text-decoration CSS value. Can be "", "inherit", "none", "underline", "overline" and "line-through".
     * @name  FORGE.TextField#_textDecoration
     * @type {string}
     * @private
     */
    this._textDecoration = "";

    /**
     * The text-shadow CSS value. Can be "", "inherit", "none" or a properties list. The properties that can be set, are (in order): "h-shadow v-shadow blur-radius color".
     * @name  FORGE.TextField#_textShadow
     * @type {string}
     * @private
     */
    this._textShadow = "";

    /**
     * The text-transform CSS value. Can be "", "inherit", "none", "capitalize", "uppercase" or "lowercase".
     * @name  FORGE.TextField#_textTransform
     * @type {string}
     * @private
     */
    this._textTransform = "";

    /**
     * The text-overflow CSS value. Can be "", "clip", "ellipsis", "initial", "inherit" or a string to render the clip.
     * @name  FORGE.TextField#_textOverflow
     * @type {string}
     * @private
     */
    this._textOverflow = "";

    /**
     * The white-space CSS value. Can be "", "normal", "nowrap", "pre", "pre-line", "pre-wrap", "initial" or "inherit".
     * @name  FORGE.TextField#_whiteSpace
     * @type {string}
     * @private
     */
    this._whiteSpace = "";

    /**
     * The font CSS value. Can be "", "inherit" or a properties list. The properties that can be set, are (in order): "font-style font-variant font-weight font-size/line-height font-family".<br>
     * The font-size and font-family values are required.
     * @name  FORGE.TextField#_font
     * @type {string}
     * @private
     */
    this._font = "";

    /**
     * The font-family CSS value. Can be "", inherit" or a web safe font family name.<br>
     * List of the web safe fonts :<br>
     * Serif<br>
     * - "Times New Roman", Times, serif<br>
     * - Georgia, serif<br>
     * - "Palatino Linotype", "Book Antiqua", Palatino, serif<br>
     * Sans-serif<br>
     * - Arial, Helvetica, sans-serif<br>
     * - Verdana, Geneva, sans-serif<br>
     * - "Arial Black", Gadget, sans-serif<br>
     * - "Comic Sans MS", cursive, sans-serif<br>
     * - Impact, Charcoal, sans-serif<br>
     * - "Lucida Sans Unicode", "Lucida Grande", sans-serif<br>
     * - Tahoma, Geneva, sans-serif<br>
     * - "Trebuchet MS", Helvetica, sans-serif<br>
     * Monospace<br>
     * - "Courier New", Courier, monospace<br>
     * - "Lucida Console", Monaco, monospace
     * @name  FORGE.TextField#_font
     * @type {string}
     * @private
     */
    this._fontFamily = "";

    /**
     * The font-size CSS value. Can be "", "inherit", "medium", "xx-small", "x-small", "small", "large", "x-large", "xx-large", "smaller", "larger", % or length.
     * @name  FORGE.TextField#_fontSize
     * @type {string}
     * @private
     */
    this._fontSize = "";

    /**
     * The font-style CSS value. Can be "", "inherit", "normal" or "italic".
     * @name  FORGE.TextField#_fontStyle
     * @type {string}
     * @private
     */
    this._fontStyle = "";

    /**
     * The font-weight CSS value. Can be "", "inherit", "normal" (400), "bold" (700), "bolder", "lighter" or a value between 100 and 900.
     * @name  FORGE.TextField#_fontWeight
     * @type {string}
     * @private
     */
    this._fontWeight = "";

    /**
     * The font-variant CSS value. Can be "", "inherit", "normal" or "small-caps".
     * @name  FORGE.TextField#_fontVariant
     * @type {string}
     * @private
     */
    this._fontVariant = "";

    /**
     * The line-height CSS value. Can be "", "inherit", "normal", % or length.
     * @name  FORGE.TextField#_lineHeight
     * @type {string}
     * @private
     */
    this._lineHeight = "";

    /**
     * This is the dom element into which the value will be injected
     * @name  FORGE.TextField#_span
     * @type {(Element|HTMLSpanElement)}
     * @private
     */
    this._span = null;

    /**
     * The textarea element to replace the textfield once set as "editable".
     * @name FORGE.TextField#_textArea
     * @type {(Element|HTMLTextAreaElement)}
     * @private
     */
    this._textArea = null;

    /**
     * This is a reference to clickHandler function but with a different this bind reference.
     * @name  FORGE.TextField#_clickBind
     * @type {Function}
     * @private
     */
    this._clickBind = null;

    /**
     * This is a reference to changeHandler function but with a different this bind reference.
     * @name  FORGE.TextField#_changeBind
     * @type {Function}
     * @private
     */
    this._changeBind = null;

    /**
     * This is a reference to blurHandler function but with a different this bind reference.
     * @name  FORGE.TextField#_blurBind
     * @type {Function}
     * @private
     */
    this._blurBind = null;

    /**
     * Has this TextField loaded its configuration?
     * @name  FORGE.TextField#_loaded
     * @type {boolean}
     * @private
     */
    this._loaded = false;

    /**
     * Event dispatcher for onValueChange event
     * @name  FORGE.TextField#_onValueChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onValueChange = null;

    /**
     * Event dispatcher for onLoadComplete event
     * @name  FORGE.TextField#_onLoadComplete
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;

    FORGE.DisplayObject.call(this, viewer, null, "TextField");
};


FORGE.TextField.prototype = Object.create(FORGE.DisplayObject.prototype);
FORGE.TextField.prototype.constructor = FORGE.TextField;

/**
 * Boot sequence.
 * @method FORGE.TextField#_boot
 * @private
 */
FORGE.TextField.prototype._boot = function()
{
    FORGE.DisplayObject.prototype._boot.call(this);

    this._clickBind = this._clickHandler.bind(this);
    this._changeBind = this._changeHandler.bind(this);
    this._blurBind = this._blurHandler.bind(this);

    this._span = document.createElement("span");
    this._dom.appendChild(this._span);

    if(typeof this._config !== "undefined" && this._config !== null)
    {
        this.load(this._config);
    }

    this._viewer.display.register(this);
    this._notifyReady();
    this._applyPending(false);
};

/**
 * Notify that the dispay object has been resized.<br>
 * This method ovverrides the {@link FORGE.DisplayObject} method.
 * @method  FORGE.TextField#_notifyResize
 * @private
 * @param  {PropertyToUpdate} data - The data contains the property that have changed.
 */
FORGE.TextField.prototype._notifyResize = function(data)
{
    var property = data.property;

    //If property is related to width except autoWidth
    if(property.toLowerCase().indexOf("width") !== -1 && property !== "autoWidth")
    {
        this._autoWidth = false;
    }

    //If property is related to height except autoHeight
    if(property.toLowerCase().indexOf("height") !== -1 && property !== "autoHeight")
    {
        this._autoHeight = false;
    }

    //this._updateTextarea();

    FORGE.DisplayObject.prototype._notifyResize.call(this, data);
};

/**
 * Notify that the dispay object is now visible.<br>
 * This method ovverrides the {@link FORGE.DisplayObject} method.
 * @method  FORGE.TextField#_notifyShow
 * @private
 */
FORGE.TextField.prototype._notifyShow = function()
{
    this._updateAutoSize();

    FORGE.DisplayObject.prototype._notifyShow.call(this);
};

/**
 * Update the dom with a new value.
 * @method FORGE.TextField#_updateValue
 * @param {(number|string)} value - The new value to display.
 * @private
 */
FORGE.TextField.prototype._updateValue = function(value)
{
    if(value !== this._value)
    {
        this._value = String(value);
        this._span.innerHTML = value;
        this._updateAutoSize();
        this._updateAnchors();

        if(this._onValueChange !== null)
        {
            this._onValueChange.dispatch();
        }
    }

    if(this._i18n === false || (this._i18n === true && this._i18nLocaleString.loaded === true))
    {
        this._loaded = true;

        if(this._onLoadComplete !== null)
        {
            this._onLoadComplete.dispatch();
        }
    }
};

/**
 * Update auto sizes, ajust width and height if auto size is enabled.
 * @method  FORGE.TextField#_updateAutoSize
 * @private
 */
FORGE.TextField.prototype._updateAutoSize = function()
{
    //If not in dom, no need to update autosize!
    if(this.isInDom() === false)
    {
        return;
    }

    if(this._autoWidth === true)
    {
        var width = this.pixelWidth;
        this._dom.style.width = "";

        //increment the width by 1 to follow the possible float value returned by the browser
        var w = this._dom.offsetWidth;
        if(w > 0)
        {
            w += 1;
        }

        this._width = w;
        this._unitWidth = "px";
        this._dom.style.width = this._width+"px";

        if(width !== this._width)
        {
            this._notifyResize({ property: "autoWidth" });
        }
    }

    if(this._autoHeight === true)
    {
        var height = this.pixelHeight;
        this._dom.style.height = "";

        //increment the height by 1 to follow the possible float value returned by the browser
        var h = this._dom.offsetHeight;
        if(h > 0)
        {
            h += 1;
        }

        this._height = h;
        this._unitHeight = "px";
        this._dom.style.height = this._height+"px";

        if(height !== this._height)
        {
            this._notifyResize({ property: "autoHeight" });
        }
    }
};

/**
 * Create an internal {@link FORGE.LocaleString} for internationalization.
 * @method FORGE.TextField#_createLocaleString
 * @private
 */
FORGE.TextField.prototype._createLocaleString = function()
{
    if(this._i18nLocaleString === null)
    {
        this._i18nLocaleString = new FORGE.LocaleString(this._viewer, this._i18nKey);
    }

    this._updateValue(this._i18nLocaleString.value);
};

/**
 * Binds an event listener for locale change.
 * @method FORGE.TextField#_createLocaleStringEvent
 * @private
 */
FORGE.TextField.prototype._createLocaleStringEvent = function()
{
    if(this._viewer.i18n.onLocaleChangeComplete.has(this._localeChangeComplete, this) === false)
    {
        this._viewer.i18n.onLocaleChangeComplete.add(this._localeChangeComplete, this);
    }
};

/**
 * Event handler for locale change.
 * @method FORGE.TextField#_localeChangeComplete
 * @private
 */
FORGE.TextField.prototype._localeChangeComplete = function()
{
    this.log("_localeChangeComplete");

    if(this._viewer.i18n.hasValue(this._i18nKey) === true)
    {
        this.value = this._i18nLocaleString.value;
    }
};

/**
 * Handler for textarea linked to the textfield if "editable" is set to true.
 * @method FORGE.TextField#_textareaResizeHandler
 * @private
 */
FORGE.TextField.prototype._updateTextarea = function()
{
    // if(this._editable === false)
    // {
    //     return;
    // }

    // if(this.pixelWidth !== 0)
    // {
    //     this._textArea.style.width = this.pixelWidth+"px";
    // }
    // else
    // {
    //     this._textArea.style.width = "calc(100% - "+(this._dom.style.marginLeft+this._dom.style.marginRight)+")";
    // }

    // if(this.pixelHeight !== 0)
    // {
    //     this._textArea.style.height = this.pixelHeight+"px";
    // }
    // else
    // {
    //     this._textArea.style.height = "calc(100% - "+(this._dom.style.marginTop+this._dom.style.marginBottom)+")";
    // }
};

/**
 * Event handler on textarea for keyup event.
 * @method FORGE.TextField#_textareaInput
 * @param  {Event} event - The onkeyup event.
 * @private
 */
// FORGE.TextField.prototype._textareaInput = function(event)
// {
//     if(event.keyCode === 13 && event.shiftKey === false && event.ctrlKey === false)
//     {
//         this.tfElement.value = this.value;

//         this.tfElement.editable = false;

//     }
//     else if(event.keyCode === 13)
//     {
//         this.value = this.value + "\n";
//     }
//     else if(event.keyCode === 27)
//     {
//         this.tfElement.editable = false;
//     }
// };

/**
 * Event handler for click on the textfield, to switch to editable mode.
 * @method  FORGE.TextField#_clickHandler
 * @private
 */
FORGE.TextField.prototype._clickHandler = function()
{
    if(this._editable === true && this._textArea === null)
    {
        this._createInput();
        this._textArea.focus();
    }
};

/**
 * Event handler for input change on the textarea.
 * @method  FORGE.TextField#_changeHandler
 * @private
 */
FORGE.TextField.prototype._changeHandler = function()
{
    this._updateValue(this._textArea.value);
};

/**
 * Event handler for blut on textaera, will quit edit mode on blur.
 * @method FORGE.TextField#_blurHandler
 * @private
 */
FORGE.TextField.prototype._blurHandler = function()
{
    this._destroyInput();
};

/**
 * Create a textarea to enter in editable mode.
 * @method FORGE.TextField#_createInput
 * @private
 */
FORGE.TextField.prototype._createInput = function()
{
    this._editing = true;

    this._textArea = document.createElement("textarea");

    this._textArea.style.position = "absolute";
    this._textArea.style.top = "0px";
    this._textArea.style.left = "0px";
    this._textArea.style.width = "100%"; //this.innerWidth+"px";
    this._textArea.style.height = "100%"; //this.innerHeight+"px";
    this._textArea.style.resize = "none"; // Prevent the browser resize corner
    this._textArea.style.margin = "0px";
    this._textArea.style.padding = "0px";
    this._textArea.style.overflowX = "hidden";
    this._textArea.style.overflowY = "auto";
    this._textArea.style.boxSizing = "border-box";

    this._textArea.value = this._value;

    this._textArea.addEventListener("input", this._changeBind, false);
    this._textArea.addEventListener("blur", this._blurBind, false);

    this._dom.appendChild(this._textArea);
};

/**
 * Destroy the textarea to leave the editable mode.
 * @method FORGE.TextField#_destroyInput
 * @private
 */
FORGE.TextField.prototype._destroyInput = function()
{
    this._editing = false;

    if(this._textArea !== null)
    {
        this._textArea.removeEventListener("input", this._changeBind, false);
        this._textArea.removeEventListener("blur", this._blurBind, false);
        this._dom.removeChild(this._textArea);
        this._textArea = null;
    }
};

/**
 * Parse the TextField configuration.
 * @method  FORGE.TextField#_parseConfig
 * @private
 * @param  {(TextFieldConfig|string)} config - The TextField object config or a string that is an i18n key.
 */
FORGE.TextField.prototype._parseConfig = function(config)
{
    if(typeof config === "object" && config !== null)
    {
        if(config.color)
        {
            this.color = config.color;
        }
        if(config.font)
        {
            this.font = config.font;
        }
        if(config.fontFamily)
        {
            this.fontFamily = config.fontFamily;
        }
        if(config.fontWeight)
        {
            this.fontWeight = config.fontWeight;
        }
        if(config.fontSize)
        {
            this.fontSize = config.fontSize;
        }
        if(config.fontStyle)
        {
            this.fontStyle = config.fontStyle;
        }
        if(config.fontVariant)
        {
            this.fontVariant = config.fontVariant;
        }
        if(config.textAlign)
        {
            this.textAlign = config.textAlign;
        }
        if(config.textShadow)
        {
            this.textShadow = config.textShadow;
        }
        if(config.textDecoration)
        {
            this.textDecoration = config.textDecoration;
        }
        if(config.textOverflow)
        {
            this.textOverflow = config.textOverflow;
        }
        if(config.textTransform)
        {
            this.textTransform = config.textTransform;
        }
        if(config.whiteSpace)
        {
            this.whiteSpace = config.whiteSpace;
        }
        if(config.wordWrap)
        {
            this.wordWrap = config.wordWrap;
        }
        if(config.lineHeight)
        {
            this.lineHeight = config.lineHeight;
        }
        if(config.autoWidth)
        {
            this.autoWidth = config.autoWidth;
        }
        if(config.autoHeight)
        {
            this.autoHeight = config.autoHeight;
        }
        if(config.padding)
        {
            this.padding = config.padding;
        }
        if(config.selectable)
        {
            this.selectable = config.selectable;
        }
        if(config.editable)
        {
            this.editable = config.editable;
        }

        this._i18n = config.i18n || false;

        //If there is a i18n key in the configuration
        if(this._i18n === true)
        {
            this._i18nKey = config.value;
        }
        else
        {
            this.value = config.value;
        }
    }
    else if(typeof config === "string")
    {
        this._i18n = false;
        this.value = config;
    }
};

/**
 * Load a textfield configuration.
 * @method  FORGE.TextField#load
 * @param  {(TextFieldConfig|string)} config - The config object to load, if it's a simple string will try to get i18n from the string.
 */
FORGE.TextField.prototype.load = function(config)
{
    this._loaded = false;

    this._parseConfig(config);

    if(this._i18n === true && (typeof this._i18nKey === "string" && this._i18nKey !== ""))
    {
        this._createLocaleString();
        this._createLocaleStringEvent();
    }
};

/**
 * Destroy method.
 * @method FORGE.TextField#destroy
 */
FORGE.TextField.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    if(this._i18nLocaleString !== null)
    {
        this._i18nLocaleString.destroy();
        this._i18nLocaleString = null;
        this._viewer.i18n.onLocaleChangeComplete.remove(this._localeChangeComplete, this);
    }

    this._destroyInput();

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    if(this._onValueChange !== null)
    {
        this._onValueChange.destroy();
        this._onValueChange = null;
    }

    FORGE.DisplayObject.prototype.destroy.call(this);
};

/**
* Get and set the i18n key of the textfield value.
* @name FORGE.TextField#i18nValue
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "i18nValue",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._i18nKey;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        if(this._i18nKey === "")
        {
            this._createLocaleStringEvent();
        }

        this._i18n = true;
        this._i18nKey = value;

        this._createLocaleString();
    }
});

/**
 * Get the flag to know if this TextField works in i18n mode.
 * @name  FORGE.TextField#i18n
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(FORGE.TextField.prototype, "i18n",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._i18n;
    }
});

/**
* Get and set the value displayed by the text field.<br>
* You'll lose the i18n behavior if you use this setter.
* @name FORGE.TextField#value
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "value",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._value;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if((typeof value !== "string" && typeof value !== "number"))
        {
            return;
        }

        this._i18n = false;
        this._updateValue(value);
    }
});

/**
* Get and set the color CSS of the text.
* @name FORGE.TextField#color
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "color",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._color;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._color = value;
        this._dom.style.color = this._color;
    }
});

/**
* Get and set the font CSS of the text.
* @name FORGE.TextField#font
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "font",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._font;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        var valueArray = value.split(" ").toString();
        if(valueArray.length < 2)
        {
            return;
        }

        this._font = value.replace(/"/g, "\"");
        this._dom.style.font = this._font;

        //this._updateAutoSize();
    }
});

/**
* Get and set the font-family CSS of the text.
* @name FORGE.TextField#fontFamily
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "fontFamily",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._fontFamily;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._fontFamily = value.replace(/"/g, "\"");
        this._dom.style.fontFamily = this._fontFamily;

        this._updateAutoSize();
    }
});

/**
* Get and set the line-height CSS of the text.
* @name FORGE.TextField#fontSize
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "fontSize",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._fontSize;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "number" && typeof value !== "string")
        {
            return;
        }

        if (typeof value === "number")
        {
            value = value+"px";
        }

        this._fontSize = value;
        this._dom.style.fontSize = this._fontSize;

        //this._updateAutoSize();
    }
});

/**
* Get and set the font-style CSS of the text.
* @name FORGE.TextField#fontStyle
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "fontStyle",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._fontStyle;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._fontStyle = value;
        this._dom.style.fontStyle = this._fontStyle;

        //this._updateAutoSize();
    }
});

/**
* Get and set the font-weight CSS of the text.
* @name FORGE.TextField#fontWeight
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "fontWeight",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._fontWeight;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "string" && typeof value !== "number")
        {
            return;
        }

        this._fontWeight = value.toString();
        this._dom.style.fontWeight = this._fontWeight;

        //this._updateAutoSize();
    }
});

/**
* Get and set the font-variant CSS of the text.
* @name FORGE.TextField#fontVariant
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "fontVariant",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._fontVariant;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._fontVariant = value;
        this._dom.style.fontVariant = this._fontVariant;
    }
});

/**
* Get and set the line-height CSS of the text.
* @name FORGE.TextField#lineHeight
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "lineHeight",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._lineHeight;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "number" && typeof value !== "string")
        {
            return;
        }

        if (typeof value === "number")
        {
            value = value+"px";
        }

        this._lineHeight = value;
        this._dom.style.lineHeight = this._lineHeight;
    }
});

/**
* Get and set the text-align CSS of the text.
* @name FORGE.TextField#textAlign
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "textAlign",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._textAlign;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._textAlign = value;
        this._dom.style.textAlign = this._textAlign;
    }
});

/**
* Get and set the text-shadow CSS of the text.
* @name FORGE.TextField#textShadow
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "textShadow",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._textShadow;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._textShadow = value;
        this._dom.style.textShadow = this._textShadow;
    }
});

/**
* Get and set the text-decoration CSS of the text.
* @name FORGE.TextField#textDecoration
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "textDecoration",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._textDecoration;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._textDecoration = value;
        this._dom.style.textDecoration = this._textDecoration;
    }
});

/**
* Get and set the text-transform CSS of the text.
* @name FORGE.TextField#textTransform
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "textTransform",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._textTransform;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._textTransform = value;
        this._dom.style.textTransform = this._textTransform;
    }
});

/**
* Get and set the flag for auto size on width.
* @name FORGE.TextField#autoWidth
* @type {boolean}
*/
Object.defineProperty(FORGE.TextField.prototype, "autoWidth",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._autoWidth;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._autoWidth = value;

        this._updateAutoSize();
    }
});

/**
* Get and set the flag for auto size on height.
* @name FORGE.TextField#autoHeight
* @type {boolean}
*/
Object.defineProperty(FORGE.TextField.prototype, "autoHeight",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._autoHeight;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._autoHeight = value;

        this._updateAutoSize();
    }
});

/**
* Get and set the padding CSS value of the text.
* @name FORGE.TextField#padding
* @type {(number|string)}
*/
Object.defineProperty(FORGE.TextField.prototype, "padding",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._padding;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "number" && typeof value !== "string")
        {
            return;
        }

        if (typeof value === "string")
        {
            var valueArray = value.split(" ", 4).toString();
            value = valueArray.replace(/,/g, " ");
        }
        else
        {
            value = value+"px";
        }

        this._padding = value;
        this._dom.style.padding = this._padding;
    }
});

/**
* Get and set the selectable property of the text.
* @name FORGE.TextField#selectable
* @type {boolean}
*/
Object.defineProperty(FORGE.TextField.prototype, "selectable",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._selectable;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._selectable = value;
        if(this._selectable === false)
        {
            if(this._editable === false && this._restoreMouse === true)
            {
                this.pointer.enabled = false;
                this._restoreMouse = false;
            }

            this._dom.style.userSelect = "none";
            this._dom.style.webkitUserSelect = "none";
            this._dom.style.mozUserSelect = "none";
            this._dom.style.msUserSelect = "none";
            this._dom.style.webkitTouchCallout = "none";
        }
        else
        {
            if(this.pointer.enabled === false)
            {
                this.pointer.enabled = true;
                this._restoreMouse = true;
            }

            this._dom.style.userSelect = "text";
            this._dom.style.webkitUserSelect = "text";
            this._dom.style.mozUserSelect = "text";
            this._dom.style.msUserSelect = "text";
            this._dom.style.webkitTouchCallout = "inherit";
        }
    }
});

/**
* Get and set the word-wrap CSS property of the text.
* @name FORGE.TextField#wordWrap
* @type {boolean}
*/
Object.defineProperty(FORGE.TextField.prototype, "wordWrap",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._wordWrap;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._wordWrap = value;
        if(this._wordWrap === false)
        {
            this._dom.style.wordWrap = "normal";
        }
        else
        {
            this._dom.style.wordWrap = "break-word";
        }
    }
});

/**
* Get and set the white-space CSS property of the text.
* @name FORGE.TextField#whiteSpace
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "whiteSpace",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._whiteSpace;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._whiteSpace = value;
        this._dom.style.whiteSpace = this._whiteSpace;
    }
});

/**
* Get and set the text-overflow CSS property of the text.
* @name FORGE.TextField#textOverflow
* @type {string}
*/
Object.defineProperty(FORGE.TextField.prototype, "textOverflow",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._textOverflow;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        if(typeof value !== "string")
        {
            return;
        }

        this._textOverflow = value;
        this._dom.style.textOverflow = this._textOverflow;
    }
});

/**
 * Get and set the editable status for the textfield.<br>
 * When editable is set to true the textfield is transformed into a textarea field.<br>
 * Important: the editable status must be set after the textfield add into a container.
 * @name FORGE.TextField#editable
 * @type {boolean}
 */
Object.defineProperty(FORGE.TextField.prototype, "editable",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._editable;
    },

    /** @this {FORGE.TextField} */
    set: function(value)
    {
        var bool = Boolean(value);

        if(this._editable === bool)
        {
            return;
        }

        this._editable = bool;

        if(this._editable === false)
        {
            this._dom.removeEventListener("click", this._clickBind, this !== null && this !== undefined);

            this._viewer.keyboard.removeBinding(this._editableKeyBinding);
            this._editableKeyBinding = null;

            this.pointer.enabled = true;
            this._dom.style.cursor = "text";
        }
        else
        {
            this._dom.addEventListener("click", this._clickBind, this !== null && this !== undefined);

            this._editableKeyBinding = new FORGE.KeyBinding(this._viewer, [13, 27], this._destroyInput, null, null, null, this);
            this._viewer.keyboard.addBinding(this._editableKeyBinding);

            this._dom.style.cursor = "default";
        }
    }
});

/**
* Get the loaded status of the TextField.
* @name FORGE.TextField#loaded
* @readonly
* @type {boolean}
*/
Object.defineProperty(FORGE.TextField.prototype, "loaded",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        return this._loaded;
    }
});

/**
* Get the onLoadComplete {@link FORGE.EventDispatcher}.
* @name FORGE.TextField#onLoadComplete
* @readonly
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.TextField.prototype, "onLoadComplete",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        if(this._onLoadComplete === null)
        {
            this._onLoadComplete = new FORGE.EventDispatcher(this);
        }

        return this._onLoadComplete;
    }
});

/**
* Get the onValueChange {@link FORGE.EventDispatcher}.
* @name FORGE.TextField#onValueChange
* @readonly
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.TextField.prototype, "onValueChange",
{
    /** @this {FORGE.TextField} */
    get: function()
    {
        if(this._onValueChange === null)
        {
            this._onValueChange = new FORGE.EventDispatcher(this);
        }

        return this._onValueChange;
    }
});



/**
 * A button with three states with out, over and down.
 *
 * @constructor FORGE.Button
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {ButtonConfig=} config - The button config.
 * @extends {FORGE.DisplayObjectContainer}
 *
 * @todo  Add tween for properties
 * @todo  Ability to set image size to the defined width/height/padding/margin of the button
 */
FORGE.Button = function(viewer, config)
{
    /**
     * Button configuration object.
     * @name FORGE.Button#_config
     * @type {?ButtonConfig}
     * @private
     */
    this._config = config || null;

    /**
     * Object that handles the button skins.
     * @name FORGE.Button#_skins
     * @type {Object}
     * @private
     */
    this._skins = {};

    /**
     * Current skin name.
     * @name FORGE.Button#_skin
     * @type {string}
     * @private
     */
    this._skin = "";

    /**
     * Current state of the button.<br>
     * Available states are in {link FORGE.Button.states}.
     * @type {string}
     * @private
     */
    this._state = "";

    /**
     * Name of the default skin.
     * @name  FORGE.Button#_defaultSkin
     * @type {string}
     * @private
     */
    this._defaultSkin = "";

    /**
     * Button image component.
     * @name  FORGE.Button#_image
     * @type {FORGE.Image}
     * @private
     */
    this._image = null;

    /**
     * Button label component.
     * @name  FORGE.Button#_label
     * @type {FORGE.TextField}
     * @private
     */
    this._label = null;

    /**
     * Is this button is on auto width?
     * @name FORGE.Button#_autoWidth
     * @type {boolean}
     * @private
     */
    this._autoWidth = false;

    /**
     * Is this button is on auto height?
     * @name FORGE.Button#_autoHeight
     * @type {boolean}
     * @private
     */
    this._autoHeight = false;

    /**
     * The number of items to load.
     * @name  FORGE.Button#_itemToLoad
     * @type {number}
     * @private
     */
    //this._itemsToLoad = 0;

    /**
     * Item that are loaded.
     * @name  FORGE.Button#_itemToLoad
     * @type {number}
     * @private
     */
    this._itemsLoaded = 0;

    /**
     * Is this button loaded?
     * @name  FORGE.Button#_loaded
     * @type {boolean}
     * @private
     */
    this._loaded = false;

    FORGE.DisplayObjectContainer.call(this, viewer, null, "Button");
};

FORGE.Button.prototype = Object.create(FORGE.DisplayObjectContainer.prototype);
FORGE.Button.prototype.constructor = FORGE.Button;

/**
 * Button possible states
 * @name  FORGE.Button.states
 * @type {Object}
 * @property {string} OUT
 * @property {string} OVER
 * @property {string} DOWN
 * @const
 */
FORGE.Button.states =
{
    OUT: "out",
    OVER: "over",
    DOWN: "down"
};

/**
 * Boot sequence.
 * @method FORGE.Button#_boot
 * @private
 */
FORGE.Button.prototype._boot = function()
{
    FORGE.DisplayObjectContainer.prototype._boot.call(this);

    this._state = FORGE.Button.states.OUT;

    this._image = new FORGE.Image(this._viewer);
    this._image.onLoadComplete.add(this._itemLoadComplete, this);
    this._image.onResize.add(this._itemResizeHandler, this);
    this.addChild(this._image);

    this._label = new FORGE.TextField(this._viewer);
    this._label.onLoadComplete.add(this._itemLoadComplete, this);
    this._label.onResize.add(this._itemResizeHandler, this);
    this._label.autoWidth = true;
    this._label.autoHeight = true;
    this.addChild(this._label);

    this.pointer.enabled = true;
    this.pointer.cursor = FORGE.Pointer.cursors.POINTER;
    this.pointer.onEnter.add(this._mouseEnterHandler, this);
    this.pointer.onLeave.add(this._mouseLeaveHandler, this);
    this.pointer.onPressStart.add(this._pressStartHandler, this);
    this.pointer.onPressEnd.add(this._pressEndHandler, this);

    this._viewer.display.register(this);
    this._notifyReady();
    this._applyPending(false);

    this._viewer.i18n.onLocaleChangeComplete.add(this._localeChangeCompleteHandler, this);

    this.load(this._config);
};

/**
 * Handler for mouse enter.
 * @method FORGE.Button#_mouseEnterHandler
 * @private
 */
FORGE.Button.prototype._mouseEnterHandler = function()
{
    this._applyState(FORGE.Button.states.OVER);
};

/**
 * Handler for mouse leave.
 * @method FORGE.Button#_mouseLeaveHandler
 * @private
 */
FORGE.Button.prototype._mouseLeaveHandler = function()
{
    this._applyState(FORGE.Button.states.OUT);
};

/**
 * Handler for mouse down.
 * @method FORGE.Button#_mouseDownHandler
 * @private
 */
FORGE.Button.prototype._pressStartHandler = function()
{
    this._applyState(FORGE.Button.states.DOWN);
};

/**
 * Handler for mouse up.
 * @method FORGE.Button#_mouseUpHandler
 * @private
 */
FORGE.Button.prototype._pressEndHandler = function()
{
    this._applyState(FORGE.Button.states.OVER);
};

/**
 * Handler for localeChangeComplete.
 * @method FORGE.Button#_localeChangeCompleteHandler
 * @private
 */
FORGE.Button.prototype._localeChangeCompleteHandler = function()
{
    this._applyState(this._state);
};

/**
 * Image or Label load complete callback.
 * @method FORGE.Button._imageLoadComplete
 * @private
 */
FORGE.Button.prototype._itemLoadComplete = function(event)
{
    this.log("_itemLoadComplete "+event.emitter.className);
    this._itemsLoaded++;

    //if(this._itemsLoaded === this._itemsToLoad)
    if(this._itemsLoaded === 2)
    {
        this._allItemsLoaded();
    }
};

/**
 * This method is called after all items are loaded. (image and label).
 * @method FORGE.Button#_allItemsLoaded
 * @private
 */
FORGE.Button.prototype._allItemsLoaded = function()
{
    this.log("_allItemsLoaded");
    this._updateLayout();
    this._updateAutoSize();
    this._loaded = true;
};

/**
 * Event handler for items resize.
 * @method FORGE.Button#_itemResizeHandler
 * @private
 */
FORGE.Button.prototype._itemResizeHandler = function()
{
    this._updateLayout();
    this._updateAutoSize();
};

/**
 * Apply a skin to the button.
 * @method  FORGE.Button#_applySkin
 * @private
 * @param {string} name - The of the skin you want to apply.
 */
FORGE.Button.prototype._applySkin = function(name)
{
    this._skin = name;

    this._applyState(this._state);
};

/**
 * Apply a specified state of the current skin.
 * @method  FORGE.Button._applyState
 * @private
 * @param  {string} state - The name of the state you want to apply (listed on FORGE.Button.states)
 */
FORGE.Button.prototype._applyState = function(state)
{
    //The button is not loaded the time to apply its skin and load its resources
    this._loaded = false;

    //Set the current state (out, over, down)
    this._state = state;

    //Get the current skin
    var skin = this._skins[this._skin];

    //Reset the load count
    this._itemsLoaded = 0;
    //this._itemsToLoad = 0;

    var hasImage = skin.hasImage(this._state);

    // if(hasImage === true)
    // {
    //     this._itemsToLoad ++;
    // }

    //var hasLabel = skin.hasLabel(this._state);
    //if(hasLabel === true)
    // {
    //     this._itemsToLoad ++;
    // }

    // var width = skin.getProperty("width", state);
    // var height = skin.getProperty("height", state);

    // if(width !== this.width)
    // {
    //     this.width = width;
    // }

    // if(height !== this.height)
    // {
    //     this.height = height;
    // }

    this.background = /** @type {string} */ (skin.getProperty("background", this._state));
    this.borderStyle = /** @type {string} */ (skin.getProperty("borderStyle", this._state));
    this.borderColor = /** @type {string} */ (skin.getProperty("borderColor", this._state));
    this.borderRadius = /** @type {number} */ (skin.getProperty("borderRadius", this._state));
    this.borderWidth = /** @type {number} */ (skin.getProperty("borderWidth", this._state));

    this._autoWidth = /** @type {boolean} */ (skin.getProperty("autoWidth", this._state));
    this._autoHeight = /** @type {boolean} */ (skin.getProperty("autoHeight", this._state));

    var label = /** @type {(string|TextFieldConfig)} */ (skin.getProperty("label", this._state)); //@todo !!!
    if(typeof label !== "undefined")
    {
        this._label.load(label);
    }

    // Image =================================

    if(hasImage === true)
    {
        this._image.load(/** @type {(string|ImageConfig)} */ (skin.getProperty("image", this._state)));
    }
    else
    {
        // this._image.load(null);
    }

    // if(hasImage === false && hasLabel === false)
    // {
    //     this._allItemsLoaded();
    // }
};

/**
 * Apply the layout of the button skin elements.
 * @method  FORGE.Button.prototype#_updateLayout
 * @private
 */
FORGE.Button.prototype._updateLayout = function()
{
    this.log("_updateLayout");

    var skin = this._skins[this._skin];
    var align = skin.getProperty("align", this._state);
    var padding = skin.getProperty("padding", this._state);
    var spacing = skin.getProperty("spacing", this._state);
    var f = skin.getProperty("first", this._state);
    var first, second;

    if(f === "label")
    {
        first = this._label;
        second = this._image;
    }
    else
    {
        first = this._image;
        second = this._label;
    }

    switch(align)
    {
        case "left":
            first.left = padding;
            first.verticalCenter = true;
            second.left = first.left + spacing + first.pixelWidth;
            second.verticalCenter = true;
            break;

        case "right":
            first.right = padding;
            first.verticalCenter = true;
            second.right = first.right + spacing + first.pixelWidth;
            second.verticalCenter = true;
            break;

        case "top":
            first.top = padding;
            first.horizontalCenter = true;
            second.top = first.top + first.pixelHeight + spacing;
            second.horizontalCenter = true;
            break;

        case "bottom":
            first.bottom = padding;
            first.horizontalCenter = true;
            second.bottom = first.bottom + spacing + first.pixelHeight;
            second.horizontalCenter = true;
            break;

        default:
            //center
            first.horizontalCenter = true;
            first.verticalCenter = true;
            second.horizontalCenter = true;
            second.verticalCenter = true;
    }

};

/**
 * Update auto sizes, ajust width and height if auto size is enabled.
 * @method  FORGE.Button#_updateAutoSize
 * @private
 */
FORGE.Button.prototype._updateAutoSize = function()
{

    this.log("_updateAutoSize");

    if(this._autoWidth === false && this._autoHeight === false)
    {
        return;
    }

    var skin = this._skins[this._skin];
    var padding = /** @type {number} */ (skin.getProperty("padding", this._state));

    if(this._autoWidth === true)
    {
        var width = this.pixelWidth;
        var xMin = Math.min(this._label.x, this._image.x);
        var xMax = Math.max(this._label.x + this._label.pixelWidth, this._image.x + this._image.pixelWidth);

        this._width = (xMax - xMin) + padding * 2 + this._borderWidth * 2;
        this._unitWidth = "px";
        this._dom.style.width = this._width+"px";

        if(width !== this.pixelWidth)
        {
            this._notifyResize({ property: "autoWidth" });
        }
    }

    if(this._autoHeight === true)
    {
        var height = this.pixelHeight;
        var yMin = Math.min(this._label.y, this._image.y);
        var yMax = Math.max(this._label.y + this._label.pixelHeight, this._image.y + this._image.pixelHeight);

        this._height = (yMax - yMin) + padding * 2 + this._borderWidth * 2;
        this._unitHeight = "px";
        this._dom.style.height = this._height+"px";

        if(height !== this.pixelHeight)
        {
            this._notifyResize({ property: "autoHeight" });
        }
    }
};

/**
 * Parse a Button configuration
 * @method FORGE.Button#_parseConfig
 * @private
 * @param  {(ButtonConfig|FORGE.ButtonSkin)} config - The configuration to parse.
 */
FORGE.Button.prototype._parseConfig = function(config)
{
    if(typeof config !== "undefined" && config !== null)
    {
        //If there is an array of skins, add them
        if(FORGE.Utils.isArrayOf(config.skins, "ButtonSkin") === true)
        {
            for(var i = 0, ii = config.skins.length; i < ii; i++)
            {
                this.addSkin(config.skins[i]);
            }
        }
        else
        {
            //convert skins object definition into FORGE.ButtonSkin objects
            if(typeof config.skins === "object" && config.skins.length > 0)
            {
                var skin;
                for(var j = 0, jj = config.skins.length; j < jj; j++)
                {
                    skin = new FORGE.ButtonSkin(config.skins[j].name, config.skins[j].states);
                    this.addSkin(skin);
                }
            }
        }
        //If there is a single skin in config, add it
        if(FORGE.Utils.isTypeOf(config.skin, "ButtonSkin"))
        {
            this.addSkin(config.skin);
        }
        else
        {
            //convert skin object definition into FORGE.ButtonSkin
            if(typeof config.skin === "object")
            {
                var singleSkin = new FORGE.ButtonSkin(config.skin.name, config.skin.states);
                this.addSkin(singleSkin);
            }
        }

        if(FORGE.Utils.isTypeOf(config.default, "string") === true && this.hasSkin(/** @type {string} */ (config.default)) === true)
        {
            this._defaultSkin = /** @type {string} */ (config.default);
        }
    }

    //If no skin found, add the default skin
    var skins = this._skins || {};
    if(Object.keys(skins).length === 0)
    {
        var defaultSkin = new FORGE.ButtonSkin("default");
        this.addSkin(defaultSkin);
        // this._skins.default = new FORGE.ButtonSkin("default");
    }

    //If no skin have been chosen pick the first one
    if(this._defaultSkin === "")
    {
        this._defaultSkin = this._skins[Object.keys(skins)[0]].name;
    }
};

/**
 * Destroy image method.
 * @method FORGE.Button#_destroyImage
 * @private
 */
FORGE.Button.prototype._destroyImage = function()
{
    if(this._image !== null)
    {
        this._image.onLoadComplete.remove(this._itemLoadComplete, this);
        this._image.onResize.remove(this._itemResizeHandler, this);

        this.removeChild(this._image, true);
        this._image = null;
    }
};

/**
 * Destroy label method.
 * @method FORGE.Button#_destroyLabel
 * @private
 */
FORGE.Button.prototype._destroyLabel = function()
{
    if(this._label !== null)
    {
        this._label.onLoadComplete.remove(this._itemLoadComplete, this);
        this._label.onResize.remove(this._itemResizeHandler, this);

        this.removeChild(this._label, true);
        this._label = null;
    }
};

/**
 * Load a button configuration.
 * @method  FORGE.Button#load
 * @param  {(ButtonConfig|FORGE.ButtonSkin)} config - The button configuration to load.
 */
FORGE.Button.prototype.load = function(config)
{
    this._parseConfig(config);
    this._applySkin(this._defaultSkin);
};

/**
 * Add a skin to the button
 * @method  FORGE.Button#addSkin
 * @param {FORGE.ButtonSkin} skin - The button skin you want to add to this button.
 * @param {boolean=} setup - Does the skin you add should be defined as the new current skin.
 */
FORGE.Button.prototype.addSkin = function(skin, setup)
{
    if(FORGE.Utils.isTypeOf(skin, "ButtonSkin") === false)
    {
        throw "FORGE.Button: Invalid button skin!";
    }

    skin.setDefaultFromState(FORGE.Button.states.OUT);
    this._skins[skin.name] = skin;

    if(setup === true)
    {
        this._applySkin(skin.name);
    }
};

/**
 * Set the button skin
 * @method FORGE.Button#setSkin
 * @param {(string|FORGE.ButtonSkin)} value - Either an existing skin name or an existing or a new {@link FORGE.ButtonSkin}
 */
FORGE.Button.prototype.setSkin = function(value)
{
    if(typeof value === "string" && FORGE.Utils.isTypeOf(this._skins[value], "ButtonSkin") === true)
    {
        this._applySkin(value);
    }
    else if(FORGE.Utils.isTypeOf(value, "ButtonSkin") === true)
    {
        if(this._skins[value.name] === value)
        {
            this._applySkin(value.name);
        }
        else if(typeof this._skins[value.name] === "undefined" || this._skins[value.name] === null)
        {
            this.addSkin(/** @type {FORGE.ButtonSkin} */ (value), true);
        }
    }
};

/**
 * Does the button has a specified skin ?
 * @param  {string}  name - The name of the skin you want to check.
 * @return {boolean} Returns true if the button have a skin with asked name.
 */
FORGE.Button.prototype.hasSkin = function(name)
{
    return (typeof this._skins[name] !== "undefined");
};

/**
 * Update the skin display, use this method if you change the skin and you need to update it.
 * @method  FORGE.Button#updateSkin
 */
FORGE.Button.prototype.updateSkin = function()
{
    this._skins[this._skin].setDefaultFromState(FORGE.Button.states.OUT);
    this._applySkin(this._skin);
};

/**
 * Destroy method.
 * @method FORGE.Button#destroy
 */
FORGE.Button.prototype.destroy = function()
{
    this._viewer.i18n.onLocaleChangeComplete.remove(this._localeChangeCompleteHandler, this);

    if(typeof this._skins !== "undefined" && this._skins.length > 0)
    {
        for(var i in this._skins)
        {
            if(this._skins.hasOwnProperty(i))
            {
                this._skins[i].destroy();
            }
        }
    }
    this._skins = {};

    this._destroyImage();

    this._destroyLabel();

    FORGE.DisplayObjectContainer.prototype.destroy.call(this);
};

/**
 * Get the skins list.
 * @name  FORGE.Button#skins
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.Button.prototype, "skins",
{
    /** @this {FORGE.Button} */
    get: function()
    {
        return this._skins;
    }
});

/**
 * Get and set the current skin.
 * @name  FORGE.Button#skin
 * @type {FORGE.ButtonSkin}
 */
Object.defineProperty(FORGE.Button.prototype, "skin",
{
    /** @this {FORGE.Button} */
    get: function()
    {
        return this._skins[this._skin];
    },

    /** @this {FORGE.Button} */
    set: function(value)
    {
        this.setSkin(value);
    }
});

/**
* Get and set the flag for auto size on width.
* @name FORGE.Button#autoWidth
* @type {boolean}
*/
Object.defineProperty(FORGE.Button.prototype, "autoWidth",
{
    /** @this {FORGE.Button} */
    get: function()
    {
        return this._autoWidth;
    },

    /** @this {FORGE.Button} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._autoWidth = value;

        this._updateAutoSize();
    }
});

/**
* Get and set the flag for auto size on height.
* @name FORGE.Button#autoHeight
* @type {boolean}
*/
Object.defineProperty(FORGE.Button.prototype, "autoHeight",
{
    /** @this {FORGE.Button} */
    get: function()
    {
        return this._autoHeight;
    },

    /** @this {FORGE.Button} */
    set: function(value)
    {
        if(typeof value !== "boolean")
        {
            return;
        }

        this._autoHeight = value;

        this._updateAutoSize();
    }
});

/**
 * This class describe a button skin.
 * @constructor FORGE.ButtonSkin
 * @param {string=} name - The name of this button skin.
 * @param {Object=} states - An object that describe the different states.
 * @extends {FORGE.BaseObject}
 */
FORGE.ButtonSkin = function(name, states)
{
    /**
     * Button skin name.
     * @name FORGE.ButtonSkin#_config
     * @type {string}
     * @private
     */
    this._name = name || "";

    /**
     * Default skin state.
     * @name FORGE.ButtonSkin#_defaultState
     * @type {ButtonSkinStateConfig}
     * @private
     */
    this._defaultState = /** @type {ButtonSkinStateConfig} */ (FORGE.Utils.extendSimpleObject(FORGE.ButtonSkin.DEFAULT_STATE, {}));

    /**
     * List of skin states.
     * @name FORGE.ButtonSkin#_states
     * @type {Object<ButtonSkinStateConfig>}
     * @private
     */
    this._states = /** @type {Object<ButtonSkinStateConfig>} */ (FORGE.Utils.extendSimpleObject((states || {}), {"out": {}, "over": {}, "down": {}}));

    FORGE.BaseObject.call(this, "ButtonSkin");
};

FORGE.ButtonSkin.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.ButtonSkin.prototype.constructor = FORGE.ButtonSkin;

/**
 * This is the empty Skin state for image
 * @name  FORGE.ButtonSkin.EMPTY_STATE_IMAGE
 * @type {ImageConfig}
 * @const
 */
FORGE.ButtonSkin.EMPTY_STATE_IMAGE =
{
    key: "",
    url: "",
    i18n: false,
    keepRatio: true,
    maximized: false,
    alpha: 1
};

/**
 * This is the empty Skin state for label
 * @name  FORGE.ButtonSkin.EMPTY_STATE_LABEL
 * @type {TextFieldConfig}
 * @const
 */
FORGE.ButtonSkin.EMPTY_STATE_LABEL =
{
    value: "",
    i18n: false,
    color: "",
    fontFamily: "",
    fontWeight: ""
};

/**
 * This is the empty Skin state
 * @name  FORGE.ButtonSkin.EMPTY_STATE
 * @type {ButtonSkinStateConfig}
 * @const
 */
FORGE.ButtonSkin.EMPTY_STATE =
{
    name: "",
    background: "",
    borderStyle: "solid",
    borderColor: "",
    borderRadius: 0,
    borderWidth: 0,
    autoWidth: true,
    autoHeight: true,
    align: "center",
    padding: 0,
    spacing: 0,
    first: "image",

    image: /** @type {ImageConfig} */ (FORGE.ButtonSkin.EMPTY_STATE_IMAGE),

    label: /** @type {TextFieldConfig} */ (FORGE.ButtonSkin.EMPTY_STATE_LABEL)
};

/**
 * This is the empty Skin state for image
 * @name  FORGE.ButtonSkin.DEFAULT_STATE_IMAGE
 * @type {ImageConfig}
 * @const
 */
FORGE.ButtonSkin.DEFAULT_STATE_IMAGE =
{
    key: "",
    url: "",
    i18n: false,
    keepRatio: true,
    maximized: false,
    alpha: 1
};

/**
 * This is the empty Skin state for label
 * @name  FORGE.ButtonSkin.DEFAULT_STATE_LABEL
 * @type {TextFieldConfig}
 * @const
 */
FORGE.ButtonSkin.DEFAULT_STATE_LABEL =
{
    value: "Button",
    i18n: false,
    color: "",
    fontFamily: "",
    fontWeight: ""
};

/**
 * This is the default Skin
 * @name  FORGE.ButtonSkin.DEFAULT_STATE
 * @type {ButtonSkinStateConfig}
 * @const
 */
FORGE.ButtonSkin.DEFAULT_STATE =
{
    name: "default",
    background: "#eee",
    borderStyle: "solid",
    borderColor: "#555",
    borderRadius: 5,
    borderWidth: 2,
    autoWidth: true,
    autoHeight: true,
    align: "left",
    padding: 5,
    spacing: 0,
    first: "image",

    image: /** @type {ImageConfig} */ (FORGE.ButtonSkin.DEFAULT_STATE_IMAGE),

    label: /** @type {TextFieldConfig} */ (FORGE.ButtonSkin.DEFAULT_STATE_LABEL)
};

/**
 * Set the default skin from a declared state, by default the default skin state will be "out".
 * @method FORGE.ButtonSkin#setDefaultFromState
 * @param {string} name - The name of the state that you want to be the default one.
 */
FORGE.ButtonSkin.prototype.setDefaultFromState = function(name)
{
    if(typeof this._states[name] !== "undefined")
    {
        //this._defaultState = FORGE.Utils.extendSimpleObject(FORGE.ButtonSkin.EMPTY_STATE, this._states[name]);
        //this._defaultState = FORGE.Utils.extendSimpleObject(this._defaultState, this._states[name]);
        this._defaultState = this._states[name];
    }
};

/**
 * Static method to validate a {@link FORGE.ButtonSkin}
 * @method  FORGE.ButtonSkin.isValid
 * @static
 * @param  {FORGE.ButtonSkin} skin
 * @return {boolean} Returns true if the button skin is valid.
 */
FORGE.ButtonSkin.isValid = function(skin)
{
    // @todo This is WIP obviously
    if(skin)
    {
        return true;
    }

    return false;
};

/**
 * Get a property of a specified state.
 * @method FORGE.ButtonSkin#getProperty
 * @param  {string} property - The property name you want to get (eg: "borderColor")
 * @param  {string} state - For which state you want the property ? (out, ouver or down)
 * @return {*} Returns the property you asked for, if the property doesn't exist on the requested state, this will return a default value.
 */
FORGE.ButtonSkin.prototype.getProperty = function(property, state)
{
    var result = FORGE.Utils.getObjectProperty(this._states, state+"."+property,
                        FORGE.Utils.getObjectProperty(this._defaultState, property,
                            FORGE.Utils.getObjectProperty(FORGE.ButtonSkin.EMPTY_STATE, property)));

    if(typeof result === "object")
    {
        result = FORGE.Utils.extendSimpleObject(this._defaultState[property], /** @type {Object} */ (result));
    }

    return result;
};

/**
 * Know if a skin state has an image?
 * @method  FORGE.ButtonSkin#hasImage
 * @param  {string} state - For which state you want to know if there is an image ? (out, ouver or down)
 * @return {boolean} Returns true if the specified state has an image
 */
FORGE.ButtonSkin.prototype.hasImage = function(state)
{
    var image = this.getProperty("image", state);
    return (typeof image !== "undefined" && (typeof image.url === "string" && image.url !== ""));
};

/**
 * Know if a skin state has a label?
 * @method  FORGE.ButtonSkin#hasLabel
 * @param  {string} state - For which state you want to know if there is a label ? (out, ouver or down)
 * @return {boolean} Returns true if the specified state has a label
 */
FORGE.ButtonSkin.prototype.hasLabel = function(state)
{
    var label = this.getProperty("label", state);
    return (typeof label !== "undefined" && (typeof label.value === "string" && label.value !== ""));
};

/**
 * Get the name of this skin.
 * @name FORGE.ButtonSkin#name
 * @type {string}
 */
Object.defineProperty(FORGE.ButtonSkin.prototype, "name",
{
    /** @this {FORGE.ButtonSkin} */
    get: function()
    {
        return this._name;
    }
});

/**
 * Get and set the default state of this skin.
 * @name FORGE.ButtonSkin#default
 * @type {ButtonSkinStateConfig}
 */
Object.defineProperty(FORGE.ButtonSkin.prototype, "default",
{
    /** @this {FORGE.ButtonSkin} */
    get: function()
    {
        return this._defaultState;
    },

    /** @this {FORGE.ButtonSkin} */
    set: function(value)
    {
        this._defaultState = value;
    }
});

/**
 * Get and set the "out" state of this skin.
 * @name FORGE.ButtonSkin#out
 * @type {ButtonSkinStateConfig}
 */
Object.defineProperty(FORGE.ButtonSkin.prototype, "out",
{
    /** @this {FORGE.ButtonSkin} */
    get: function()
    {
        return this._states.out;
    },

    /** @this {FORGE.ButtonSkin} */
    set: function(value)
    {
        this._states.out = value;
    }
});

/**
 * Get and set the "over" state of this skin.
 * @name FORGE.ButtonSkin#over
 * @type {ButtonSkinStateConfig}
 */
Object.defineProperty(FORGE.ButtonSkin.prototype, "over",
{
    /** @this {FORGE.ButtonSkin} */
    get: function()
    {
        return this._states.over;
    },

    /** @this {FORGE.ButtonSkin} */
    set: function(value)
    {
        this._states.over = value;
    }
});

/**
 * Get and set the "down" state of this skin.
 * @name FORGE.ButtonSkin#down
 * @type {ButtonSkinStateConfig}
 */
Object.defineProperty(FORGE.ButtonSkin.prototype, "down",
{
    /** @this {FORGE.ButtonSkin} */
    get: function()
    {
        return this._states.down;
    },

    /** @this {FORGE.ButtonSkin} */
    set: function(value)
    {
        this._states.down = value;
    }
});


/**
 * Canvas display object.
 * @constructor FORGE.Canvas
 * @param {FORGE.Viewer} viewer - The {@link FORGE.Viewer} reference.
 * @extends {FORGE.DisplayObject}
 */
FORGE.Canvas = function(viewer)
{
    FORGE.DisplayObject.call(this, viewer, document.createElement("canvas"), "Canvas");
};

FORGE.Canvas.prototype = Object.create(FORGE.DisplayObject.prototype);
FORGE.Canvas.prototype.constructor = FORGE.Canvas;

/**
 * Canvas capture modes
 * @name FORGE.Canvas.formats
 * @type {Object}
 * @const
 */
FORGE.Canvas.formats = {};

/**
 * Image format.
 * @name FORGE.Canvas.formats.IMAGE
 * @type {string}
 * @const
 */
FORGE.Canvas.formats.IMAGE = "image";

/**
 * Data format.
 * @name FORGE.Canvas.formats.DATA
 * @type {string}
 * @const
 */
FORGE.Canvas.formats.DATA = "data";

/**
 * Boot sequence.
 * @method FORGE.Canvas#_boot
 * @private
 */
FORGE.Canvas.prototype._boot = function()
{
    FORGE.DisplayObject.prototype._boot.call(this);

    this._viewer.display.register(this);
    this._notifyReady();
    this._applyPending(false);
};

/**
 * Capture the canvas and return an image or the DataURL.
 * @method FORGE.Canvas#capture
 * @param {string} format
 */
FORGE.Canvas.prototype.capture = function(format)
{
    format = format || FORGE.Canvas.formats.IMAGE;

    var data = this._dom.toDataURL();

    switch(format)
    {
        case FORGE.Canvas.formats.DATA:
            return data;

        case FORGE.Canvas.formats.IMAGE:
            var image = new Image();
            image.src = data;
            return image;
    }
};

/**
 * Get the context for 2D.
 * @name FORGE.Canvas#context2D
 * @type {CanvasRenderingContext2D}
 * @readonly
 */
Object.defineProperty(FORGE.Canvas.prototype, "context2D",
{
    /** @this {FORGE.Canvas} */
    get: function()
    {
        return this._dom.getContext("2d");
    }
});

/**
 * Get the webGl context for 3D.
 * @name FORGE.Canvas#context3D
 * @type {WebGLRenderingContext}
 * @readonly
 */
Object.defineProperty(FORGE.Canvas.prototype, "context3D",
{
    /** @this {FORGE.Canvas} */
    get: function()
    {
        return this._dom.getContext("webgl");
    }
});

/**
 * Get the canvas DOM element
 * @name FORGE.Canvas#element
 * @type {HTMLCanvasElement}
 * @readonly
 */
Object.defineProperty(FORGE.Canvas.prototype, "element",
{
    /** @this {FORGE.Canvas} */
    get: function()
    {
        return this._dom;
    }
});


/**
 * An image is a display object with an internationalizable image source.
 *
 * @constructor FORGE.Image
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {(ImageConfig|string)=} config - The image configuration to load.
 * @param {string=} className - The className of the object.
 * @extends {FORGE.DisplayObject}
 */
FORGE.Image = function(viewer, config, className)
{
    /**
     * Image configuration
     * @name  FORGE.Image#_config
     * @type {?ImageConfig|string}
     * @property {string} key - The cache key associated to this image.
     * @property {string} url - The URL of the image if not i18n
     * @property {string} i18n - The i18n key to find the URL of an i18n image.
     * @private
     */
    this._config = config || null;

    /**
     * The key associated to this image.
     * @name  FORGE.Image#_imageKey
     * @type {string}
     * @private
     */
    this._imageKey = "";

    /**
     * The url of this image.
     * @name  FORGE.Image#_imageUrl
     * @type {string}
     * @private
     */
    this._imageUrl = "";

    /**
     * Is this image is internationnalized?
     * @name  FORGE.Image#_i18n
     * @type {boolean}
     * @private
     */
    this._i18n = false;

    /**
     * The i18n key associated to the image resource in cache.
     * @name  FORGE.Image#_i18nImageKey
     * @type {string}
     * @private
     */
    this._i18nImageKey = "";

    /**
     * The i18n key associated to the url.
     * @name  FORGE.Image#_i18nImageUrl
     * @type {string}
     * @private
     */
    this._i18nImageUrl = "";

    /**
     * The {@link FORGE.LocaleString} that handles the different url for different languages.
     * @name  FORGE.Image#_i18nImageUrlLocaleString
     * @type {?FORGE.LocaleString}
     * @private
     */
    this._i18nImageUrlLocaleString = null;

    /**
     * The HTML Image object from the cache source.
     * @name FORGE.Image#_img
     * @type {?Element|HTMLImageElement}
     * @private
     */
    this._img = null;

    /**
     * Is the Image source is loaded?
     * @name  FORGE.Image#_imageLoaded
     * @type {boolean}
     * @private
     */
    this._imageLoaded = false;

    /**
     * The frame represent the portion of the image source that will be used as background for dom.<br>
     * A frame is described like this : {x: 0, y: 0, w: 0, h: 0}.
     * @name  FORGE.Image#_frame
     * @type {?ImageFrame}
     * @private
     */
    this._frame = null;

    /**
     * An image can have different frames.<br>
     * This array contains all available frames for this image.
     * @type {Array<ImageFrameConfig>}
     * @private
     */
    this._frames = null;

    /**
     * This is the url of the frames JSON file.
     * @name  FORGE.Image#_framesUrl
     * @type {string}
     * @private
     */
    this._framesUrl = "";

    /**
     * Flag to know if the frames are loaded.<br>
     * If there are no frames, they are considered as loaded.
     * @name FORGE.Image#_framesLoaded
     * @type {boolean}
     * @private
     */
    this._framesLoaded = false;

    /**
     * Is the current resource is loaded.
     * @name FORGE.Image#_loaded
     * @type {boolean}
     * @private
     */
    this._loaded = false;

    /**
     * Auto width flag, default to true
     * @name  FORGE.Image#_autoWidth
     * @type {boolean}
     * @private
     */
    this._autoWidth = true;

    /**
     * Auto height flag, default to true
     * @name  FORGE.Image#_autoHeight
     * @type {boolean}
     * @private
     */
    this._autoHeight = true;

    /**
     * Which render mode is used for image rendering?.<br>
     * Available render modes are listed in a constant FORGE.Image.renderModes
     * and the default mode is stored in FORGE.Image.renderMode.
     * @name  FORGE.Image#_renderMode
     * @type {string}
     * @private
     */
    this._renderMode = "";

    /**
     * If the renderMode is CANVAS, you'll need a canvas element, so this is the canvas reference.
     * @name  FORGE.Image#_canvas
     * @type {Element|HTMLCanvasElement}
     * @private
     */
    this._canvas = null;

    /**
     * On load start event dispatcher.
     * @name  FORGE.Image#_onLoadStart
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLoadStart = null;

    /**
     * On load complete event dispatcher.
     * @name  FORGE.Image#_onLoadComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLoadComplete = null;

    /**
     * On load error event dispatcher.
     * @name  FORGE.Image#_onLoaderror
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLoadError = null;

    FORGE.DisplayObject.call(this, viewer, null, className || "Image");
};

FORGE.Image.prototype = Object.create(FORGE.DisplayObject.prototype);
FORGE.Image.prototype.constructor = FORGE.Image;

/**
 * Render modes list.
 * @name FORGE.Image.renderModes
 * @type {Object}
 * @const
 */
FORGE.Image.renderModes = {};

/**
 * @name FORGE.Image.renderModes.CSS
 * @type {string}
 * @const
 */
FORGE.Image.renderModes.CSS = "css";

/**
 * @name FORGE.Image.renderModes.CANVAS
 * @type {string}
 * @const
 */
FORGE.Image.renderModes.CANVAS = "canvas";

/**
 * Default render mode.
 * @name FORGE.Image.renderModes
 * @type {string}
 */
FORGE.Image.renderMode = FORGE.Image.renderModes.CANVAS;

/**
 * Boot sequence.
 * @method FORGE.Image#_boot
 * @private
 */
FORGE.Image.prototype._boot = function()
{
    FORGE.DisplayObject.prototype._boot.call(this);

    //Images keeps ratio by default
    this._keepRatio = true;

    if(this._config !== null)
    {
        this.load(this._config);
    }

    this._viewer.display.register(this);
    this._notifyReady();
};

/**
 * Notify that the dispay object has been resized.<br>
 * This method ovverrides the {@link FORGE.DisplayObject} method.
 * @method  FORGE.Image#_notifyResize
 * @private
 * @param  {PropertyToUpdate} data - The data contains the property that have changed.
 */
FORGE.Image.prototype._notifyResize = function(data)
{
    var property = data.property;

    //If property is related to width except autoWidth
    if(property.toLowerCase().indexOf("width") !== -1 && property !== "autoWidth")
    {
        this._autoWidth = false;
    }

    //If property is related to height except autoHeight
    if(property.toLowerCase().indexOf("height") !== -1 && property !== "autoHeight")
    {
        this._autoHeight = false;
    }

    if(this._img === null)
    {
        return;
    }

    if(this._renderMode === FORGE.Image.renderModes.CSS)
    {
        this._updateBackgroundSize();
        this._updateBackgroundPosition();
    }
    else if(this._renderMode === FORGE.Image.renderModes.CANVAS)
    {
        if(this._frame !== null)
        {
            this._drawFrame(this._frame);
        }
    }

    if(this._keepRatio === true)
    {
        if(property.toLowerCase().indexOf("width") !== -1)
        {
            this._updateScaleWidth();
        }
        else if(property.toLowerCase().indexOf("height") !== -1)
        {
            this._updateScaleHeight();
        }
    }

    FORGE.DisplayObject.prototype._notifyResize.call(this, data);
};

/**
 * Internal method that updates image position to be centered in this borders.<br>
 * this is an override of the DisplayObject method
 * @method FORGE.Image#_notifyBorderResize
 * @private
 */
FORGE.Image.prototype._notifyBorderResize = function()
{
    if(this._renderMode === FORGE.Image.renderModes.CSS)
    {
        this._dom.style.backgroundPosition = (- this._borderWidth)+"px "+(- this._borderWidth)+"px";
    }
    else if(this._renderMode === FORGE.Image.renderModes.CANVAS)
    {
        this._canvas.style.top = - this._borderWidth+"px";
        this._canvas.style.left = - this._borderWidth+"px";
    }

    FORGE.DisplayObject.prototype._notifyBorderResize.call(this);
};

/**
 * Internal method that notify the load complete.<br>
 * this method can be overrided by a class that extends Image.
 * @method FORGE.Image#_notifyLoadComplete
 * @private
 */
FORGE.Image.prototype._notifyLoadComplete = function()
{
    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.dispatch();
    }
};

/**
 * Get the cache key for a specific locale.
 * @method FORGE.Image#_getLocalizedCacheKey
 * @private
 * @param  {string} locale - The locale of the cache key you ask for.
 * @return {string} The cache key for the locale you asked.
 */
FORGE.Image.prototype._getLocalizedCacheKey = function(locale)
{
    return this._imageKey + "_" + locale;
};

/**
 * Handler for locale change.
 * @method FORGE.Image#_localeChangeComplete
 * @private
 */
FORGE.Image.prototype._localeChangeComplete = function()
{
    var key = this._getLocalizedCacheKey(this._viewer.i18n.locale);

    if(key === this._i18nImageKey)
    {
        return;
    }

    this._i18nImageKey = key;

    if(this._viewer.i18n.hasValue(this._i18nImageUrl) === true)
    {
        var url = this._i18nImageUrlLocaleString.value;
        this._loadImage(key, url);
    }
};

/**
 * Set the render mode of the image
 * @method FORGE.Image#_setRenderMode
 * @private
 */
FORGE.Image.prototype._setRenderMode = function(mode)
{
    if(mode === FORGE.Image.renderModes.CSS || mode === FORGE.Image.renderModes.CANVAS)
    {
        this._renderMode = mode;
    }

    if(this._renderMode === FORGE.Image.renderModes.CSS)
    {
        this._dom.style.backgroundRepeat = "no-repeat";
    }
    else if(this._renderMode === FORGE.Image.renderModes.CANVAS && this._canvas === null)
    {
        this._canvas = document.createElement("canvas");
        this._canvas.style.position = "absolute";
        this._canvas.style.top = "0px";
        this._canvas.style.left = "0px";
        this._dom.appendChild(this._canvas);
    }
};

/**
 * Set the image frame.<br>
 * The frame is the source rctangle that is used as background image.
 * @method  FORGE.Image#_setFrame
 * @private
 * @param {ImageFrame} frame - A frame is described like this : {x: 0, y: 0, w: 0, h: 0}.
 */
FORGE.Image.prototype._setFrame = function(frame)
{
    this._frame = frame;

    if(this._autoWidth === true)
    {
        this._width = this._frame.w;
        this._unitWidth = "px";
        this._dom.style.width = this.pixelWidth+"px";
    }

    if(this._autoHeight === true)
    {
        this._height = this._frame.h;
        this._unitHeight = "px";
        this._dom.style.height = this.pixelHeight+"px";
    }

    if(this._renderMode === FORGE.Image.renderModes.CSS)
    {
        this._updateBackgroundSize();
        this._updateBackgroundPosition();
    }
    else if(this._renderMode === FORGE.Image.renderModes.CANVAS)
    {
        this._drawFrame(this._frame);
    }
};

/**
 * Method to draw the frame if render mode is CANVAS.
 * @method FORGE.Image#_drawFrame
 * @private
 * @param  {Object} frame - The frame to draw
 */
FORGE.Image.prototype._drawFrame = function(frame)
{
    if(this._img === null || this._imageLoaded === false)
    {
        return;
    }

    this._canvas.width = this.innerWidth;
    this._canvas.height = this.innerHeight;

    var ctx = this._canvas.getContext("2d");
    ctx.clearRect(0, 0, this.innerWidth, this.innerHeight);
    ctx.drawImage(this._img, frame.x, frame.y, frame.w, frame.h, 0, 0, this.innerWidth, this.innerHeight);
};

/**
 * Internal method to update the background image size.
 * @method FORGE.Image#_updateBackgroundSize
 * @private
 */
FORGE.Image.prototype._updateBackgroundSize = function()
{
    var backgroundWidth = (this.pixelWidth / this._frame.w) * this._img.naturalWidth;
    var backgroundHeight = (this.pixelHeight / this._frame.h) * this._img.naturalHeight;
    this._dom.style.backgroundSize = backgroundWidth+"px "+backgroundHeight+"px";
};

/**
 * Internal method to update the background image position.
 * @method FORGE.Image#_updateBackgroundPosition
 * @private
 */
FORGE.Image.prototype._updateBackgroundPosition = function()
{
    var posX = (- this._frame.x - this._borderWidth) * (this.pixelWidth / this._frame.w);
    var posY = (- this._frame.y - this._borderWidth) * (this.pixelHeight / this._frame.h);
    this._dom.style.backgroundPosition = posX+"px "+posY+"px";
};

/**
 * Update the size of the image based on scale width.
 * @method  FORGE.Image#_updateScaleWidth
 * @private
 */
FORGE.Image.prototype._updateScaleWidth = function()
{
    var scaleWidth = this.pixelWidth / this._frame.w;

    if(scaleWidth === this._scaleWidth)
    {
        return;
    }

    this._scaleWidth = scaleWidth;

    if(this._keepRatio === true)
    {
        this._scaleHeight = scaleWidth;
        this.height = this._frame.h * this._scaleHeight;
    }
};

/**
 * Update the size of the image based on scale height.
 * @method  FORGE.Image#_updateScaleHeight
 * @private
 */
FORGE.Image.prototype._updateScaleHeight = function()
{
    var scaleHeight = this.pixelHeight / this._frame.h;

    if(scaleHeight === this._scaleHeight)
    {
        return;
    }

    this._scaleHeight = scaleHeight;

    if(this._keepRatio === true)
    {
        this._scaleWidth = scaleHeight;
        this.width = this._frame.w * this._scaleWidth;
    }
};

/**
 * Internal method to load an image asset.
 * @method FORGE.Image#_load
 * @private
 * @param {string} key - The key associated to the asset for cache.
 * @param {string} url - The URL of the asset.
 */
FORGE.Image.prototype._loadImage = function(key, url)
{
    this._loaded = false;
    this._viewer.load.image(key, url, this._loadImageComplete, this._loadImageError, this);
};

/**
 * Event handler for image load complete.
 * @method FORGE.Image#_loadImageComplete
 * @private
 */
FORGE.Image.prototype._loadImageComplete = function(file)
{
    //If image is destroy during loading time, don't execute the callback
    if(this._alive === false)
    {
        return;
    }

    this._img = file.data;

    if(this._renderMode === FORGE.Image.renderModes.CSS)
    {
        this._dom.style.backgroundImage = "url('"+file.url+"')";
    }

    this._imageLoaded = true;

    this._loadComplete();
};

/**
 * Event handler for image load error.
 * @method FORGE.Image#_loadImageError
 * @private
 */
FORGE.Image.prototype._loadImageError = function(file)
{
    //If image is destroy during loading time, don't execute the callback
    if(this._alive === false)
    {
        return;
    }

    this.warn(file.url + " load error");

    if(this._onLoadError !== null)
    {
        this._onLoadError.dispatch();
    }
};

/**
 * Method to load frames data.
 * @method  FORGE.Image#_loadFrames
 * @param  {string} url - Url of the JSON file taht handles frame data.
 * @private
 */
FORGE.Image.prototype._loadFrames = function(url)
{
    this._loaded = false;

    var key = this._imageKey+"-frames";
    this._viewer.load.json(key, url, this._loadFramesComplete, this);
};

/**
 * Event handler for frame data load complete.
 * @method  FORGE.Image#_loadFramesComplete
 * @param  {FORGE.File} file - The file that is loaded
 * @private
 */
FORGE.Image.prototype._loadFramesComplete = function(file)
{
    if(typeof file.data.frames !== "undefined")
    {
        this._frames = file.data.frames;
    }
    else
    {
        this.warn("No frames found in file!");
    }

    this._framesLoaded = true;

    this._loadComplete();
};

/**
 * This method validate the complete loading of all the assets (image + frames)
 * @method FORGE.Image#_loadComplete
 * @private
 */
FORGE.Image.prototype._loadComplete = function()
{
    if(this._loaded === true)
    {
        return;
    }

    if(this._imageLoaded === true && this._framesLoaded === true)
    {
        this._loaded = true;

        var frame;

        if(this._frame !== null)
        {
            frame = this._frame;
        }
        else
        {
            if(this._frames !== null)
            {
                frame = this._frames[0].frame;
            }
            else
            {
                frame =
                {
                    x: 0,
                    y: 0,
                    w: this._img.naturalWidth,
                    h: this._img.naturalHeight
                };
            }
        }

        this._setFrame(frame);

        this._updateAnchors();

        this._applyPending(false);

        this._notifyLoadComplete();
    }
};

/**
 * Inner method that parse an image configuration.
 * @method FORGE.Image#_parseConfig
 * @param  {ImageConfig|string} config - Image configuration object
 * @private
 */
FORGE.Image.prototype._parseConfig = function(config)
{
    if(typeof config === "object" && config !== null)
    {
        var renderMode = (typeof config.renderMode === "string") ? config.renderMode : FORGE.Image.renderMode;
        this._setRenderMode(renderMode);

        this._imageKey = config.key || "";

        this._i18n = config.i18n || false;

        if(this._i18n === true)
        {
            this._imageUrl = "";
            this._i18nImageUrl = config.url;
        }
        else
        {
            this._imageUrl = config.url;
        }

        this._frame = config.frame || null;

        if(typeof config.frames === "string")
        {
            this._framesUrl = config.frames;
        }
        else if(typeof config.frames === "object" && config.frames !== null)
        {
            this._frames = config.frames;
        }

        //Applying style in config
        this.alpha = config.alpha;
        this.keepRatio = config.keepRatio;
        this.maximized = config.maximized;
        this.width = config.width;
        this.height = config.height;
    }
    else
    {
        this._setRenderMode(FORGE.Image.renderMode);

        this._imageKey = "";
        this._imageUrl = "";
        this._i18n = false;

        if(typeof config === "string")
        {
            this._imageUrl = config;
        }
    }
};

/**
 * Internal method to load an image asset.
 * @method FORGE.Image#load
 * @param {string|ImageConfig} config - The config to load, can be an url or a configuration object.
 */
FORGE.Image.prototype.load = function(config)
{
    this._loaded = false;
    this._imageLoaded = false;
    this._framesLoaded = false;

    this._parseConfig(config);

    var imageKey = this._imageKey;
    var imageUrl = this._imageUrl;

    if(this._i18n === true && typeof this._i18nImageUrl === "string")
    {
        this._i18nImageUrlLocaleString = new FORGE.LocaleString(this._viewer, this._i18nImageUrl);

        if(this._viewer.i18n.onLocaleChangeComplete.has(this._localeChangeComplete, this) === false)
        {
            this._viewer.i18n.onLocaleChangeComplete.add(this._localeChangeComplete, this);
        }

        var locale = this._viewer.i18n.locale;
        if(locale !== "")
        {
            imageKey = this._getLocalizedCacheKey(locale);
        }

        if(this._viewer.i18n.hasValue(this._i18nImageUrl) === true)
        {
            imageUrl = this._i18nImageUrlLocaleString.value;
        }
    }

    if(imageUrl !== "")// && typeof imageUrl !== "undefined")
    {
        this._loadImage(imageKey, imageUrl);
    }
    else
    {
        this._imageLoaded = true;
    }

    if(typeof this._framesUrl === "string" && this._framesUrl !== "")
    {
        this._loadFrames(this._framesUrl);
    }
    else
    {
        this._framesLoaded = true; //Consider frames as loaded if there are no frames
    }
};

/**
 * Unload the image background from the DOM object.
 * @method  FORGE.Image#unload
 */
FORGE.Image.prototype.unload = function()
{
    this._dom.style.backgroundImage = "";
    this._img = null;
};

/**
 * Destroy method.
 * @method FORGE.Image#destroy
 * @param {boolean=} clearCache - Does the destroy sequence have to clear the image cache?
 */
FORGE.Image.prototype.destroy = function(clearCache)
{
    if(this._alive === false)
    {
        return;
    }

    if(this._i18nImageUrlLocaleString !== null)
    {
        this._i18nImageUrlLocaleString.destroy();
        this._i18nImageUrlLocaleString = null;
        this._viewer.i18n.onLocaleChangeComplete.remove(this._localeChangeComplete, this);
    }

    if(this._onLoadStart !== null)
    {
        this._onLoadStart.destroy();
        this._onLoadStart = null;
    }

    if(this._onLoadComplete !== null)
    {
        this._onLoadComplete.destroy();
        this._onLoadComplete = null;
    }

    if(this._onLoadError !== null)
    {
        this._onLoadError.destroy();
        this._onLoadError = null;
    }

    this._img = null;

    if(typeof clearCache === "undefined" || clearCache === true)
    {
        if(this._i18n === true)
        {
            var locales = this._viewer.i18n.locales;
            var cacheKey;
            for(var i = 0, ii = locales.length; i < ii; i++)
            {
                cacheKey = this._getLocalizedCacheKey(locales[i]);
                this._viewer.cache.remove(FORGE.Cache.types.IMAGE, cacheKey);
            }
        }
        else
        {
            this._viewer.cache.remove(FORGE.Cache.types.IMAGE, this._imageKey);
        }
    }

    FORGE.DisplayObject.prototype.destroy.call(this);
};

/**
* Get the loaded status of the image.
* @name FORGE.Image#loaded
* @readonly
* @type {boolean}
*/
Object.defineProperty(FORGE.Image.prototype, "loaded",
{
    /** @this {FORGE.Image} */
    get: function()
    {
        return this._loaded;
    }
});

/**
* Get the current image element.
* @name FORGE.Image#element
* @readonly
* @type {?Element|HTMLImageElement}
*/
Object.defineProperty(FORGE.Image.prototype, "element",
{
    /** @this {FORGE.Image} */
    get: function()
    {
        return this._img;
    }
});

/**
* Get the canvas element for canvas renderer mode.
* @name FORGE.Image#canvas
* @readonly
* @type {Element|HTMLCanvasElement}
*/
Object.defineProperty(FORGE.Image.prototype, "canvas",
{
    /** @this {FORGE.Image} */
    get: function()
    {
        return this._canvas;
    }
});

/**
* Get and set the current frame {x: 0, y: 0, w: 0, h: 0}.
* @name FORGE.Image#frame
* @type {Object}
*/
Object.defineProperty(FORGE.Image.prototype, "frame",
{
    /** @this {FORGE.Image} */
    get: function()
    {
        return this._frame;
    },

    /** @this {FORGE.Image} */
    set: function(frame)
    {
        this._setFrame(frame);
    }
});

/**
* Get the frames array.
* @name FORGE.Image#frames
* @readonly
* @type {Array<ImageFrameConfig>}
*/
Object.defineProperty(FORGE.Image.prototype, "frames",
{
    /** @this {FORGE.Image} */
    get: function()
    {
        return this._frames;
    }
});

/**
* Get the original width of the image.
* @name FORGE.Image#originalWidth
* @readonly
* @type {number}
*/
Object.defineProperty(FORGE.Image.prototype, "originalWidth",
{
    /** @this {FORGE.Image} */
    get: function()
    {
        if(this._img !== null)
        {
            return this._img.naturalWidth;
        }
    }
});

/**
* Get the original height of the image.
* @name FORGE.Image#originalHeight
* @readonly
* @type {number}
*/
Object.defineProperty(FORGE.Image.prototype, "originalHeight",
{
    /** @this {FORGE.Image} */
    get: function()
    {
        if(this._img !== null)
        {
            return this._img.naturalHeight;
        }
    }
});

/**
* Get the onLoadStart {@link FORGE.EventDispatcher}.
* @name FORGE.Image#onLoadStart
* @readonly
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Image.prototype, "onLoadStart",
{
    /** @this {FORGE.Image} */
    get: function()
    {
        if(this._onLoadStart === null)
        {
            this._onLoadStart = new FORGE.EventDispatcher(this);
        }

        return this._onLoadStart;
    }
});

/**
* Get the onLoadComplete {@link FORGE.EventDispatcher}.
* @name FORGE.Image#onLoadComplete
* @readonly
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Image.prototype, "onLoadComplete",
{
    /** @this {FORGE.Image} */
    get: function()
    {
        if(this._onLoadComplete === null)
        {
            this._onLoadComplete = new FORGE.EventDispatcher(this);
        }

        return this._onLoadComplete;
    }
});

/**
* Get the onLoadError {@link FORGE.EventDispatcher}.
* @name FORGE.Image#onLoadError
* @readonly
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.Image.prototype, "onLoadError",
{
    /** @this {FORGE.Image} */
    get: function()
    {
        if(this._onLoadError === null)
        {
            this._onLoadError = new FORGE.EventDispatcher(this);
        }

        return this._onLoadError;
    }
});


/**
 * A Sprite is like an Image, except it can have animations.
 *
 * @constructor FORGE.Sprite
 * @param {FORGE.Viewer} viewer - The Viewer reference.
 * @param {(string|ImageConfig)} config - Configuration object.
 * @extends {FORGE.Image}
 */
FORGE.Sprite = function(viewer, config)
{
    /**
     * Animation manager
     * @name  FORGE.Sprite#_animations
     * @type {FORGE.SpriteAnimationManager}
     * @private
     */
    this._animations = null;

    FORGE.Image.call(this, viewer, config, "Sprite");
};

FORGE.Sprite.prototype = Object.create(FORGE.Image.prototype);
FORGE.Sprite.prototype.constructor = FORGE.Sprite;

/**
 * Boot Sequence
 * @method FORGE.Sprite#_boot
 * @private
 */
FORGE.Sprite.prototype._boot = function()
{
    this._animations = new FORGE.SpriteAnimationManager(this);

    FORGE.Image.prototype._boot.call(this);

    this._viewer.display.register(this, true);
};

/**
 * Parse Sprite configuration
 * @method FORGE.Sprite#_parseConfig
 */
FORGE.Sprite.prototype._parseConfig = function(config)
{
    FORGE.Image.prototype._parseConfig.call(this, config);

    if(typeof config.frameRate === "number")
    {
        this._animations.frameRate = config.frameRate;
    }

    if(Array.isArray(config.animations) === true)
    {
        this._animations.addConfig(config.animations);
    }

    var animation = (typeof config.animation === "string") ? config.animation : "default";
    var loop = (typeof config.loop === "boolean") ? config.loop : true;
    var frame = (typeof config.frame === "number" && isNaN(config.frame) === false) ? config.frame : 0;

    this._animations.play(animation, loop, frame);

    if(config.paused === true || typeof config.paused === "number")
    {
        this._animations.pause(frame);
    }
};

/**
 * Play an animation.<br>
 * This is a proxy to the {@link FORGE.SpriteAnimationManager} play method.
 * @method  FORGE.Sprite#play
 * @param  {string=} [animation] - The animation name you want to play. Default is the current animation.
 * @param  {boolean=} [loop=false] - Does the animation should loop?
 * @param  {number=} [index=0] - The frame index on which to start playing the animation.
 */
FORGE.Sprite.prototype.play = function(animation, loop, index)
{
    this._animations.play(animation, loop, index);
};

/**
 * Pauses the current animation.<br>
 * This is a proxy to the {@link FORGE.SpriteAnimationManager} pause method.
 * @method FORGE.Sprite#pause
 * @param  {number=} index - The frame index on which to pause the animation. Default will be the current frame.
 */
FORGE.Sprite.prototype.pause = function(index)
{
    this._animations.pause(index);
};

/**
 * Resume the current animation.<br>
 * This is a proxy to the {@link FORGE.SpriteAnimationManager} resume method.
 * @method FORGE.Sprite.resume
 * @param  {number=} index - The frame index on which to resume the animation. Default will be the current frame.
 */
FORGE.Sprite.prototype.resume = function(index)
{
    this._animations.resume(index);
};

/**
 * Stops the current animation.<br>
 * This is a proxy to the {@link FORGE.SpriteAnimationManager} stop method.
 * @method FORGE.Sprite.stop
 */
FORGE.Sprite.prototype.stop = function()
{
    this._animations.stop();
};

/**
 * Update method called by the display list.
 * @method FORGE.Sprite#update
 */
FORGE.Sprite.prototype.update = function()
{
    this._animations.update();
};

/**
 * Destroy method
 * @method  FORGE.Sprite#destroy
 */
FORGE.Sprite.prototype.destroy = function()
{
    if(this._alive === false)
    {
        return;
    }

    this._animations.destroy();
    this._animations = null;

    FORGE.Image.prototype.destroy.call(this);
};

/**
 * Get the animation manager of this Sprite.
 * @name  FORGE.Sprite#animations
 * @readonly
 * @type {FORGE.SpriteAnimationManager}
 */
Object.defineProperty(FORGE.Sprite.prototype, "animations",
{
    /** @this {FORGE.Sprite} */
    get: function()
    {
        return this._animations;
    }
});

/**
 * Get the curretn animation of this Sprite.
 * @name  FORGE.Sprite#animation
 * @readonly
 * @type {FORGE.Animation}
 */
Object.defineProperty(FORGE.Sprite.prototype, "animation",
{
    /** @this {FORGE.Sprite} */
    get: function()
    {
        return this._animations.current;
    }
});


/**
 * Animation manager, handles animations for the {@link FORGE.Sprite} display class.
 * @constructor FORGE.SpriteAnimationManager
 * @param {FORGE.Sprite} sprite - The Sprite attached to this animation manager.
 * @extends {FORGE.BaseObject}
 */
FORGE.SpriteAnimationManager = function(sprite)
{
    /**
     * The Sprite attached to this SpriteAnimationManager.
     * @name  FORGE.SpriteAnimationManager#_sprite
     * @type {FORGE.Sprite}
     * @private
     */
    this._sprite = sprite;

    /**
     * The Object that handles all animation declarations.
     * @name  FORGE.SpriteAnimationManager#_anims
     * @type {Object<string,FORGE.SpriteAnimation>}
     * @private
     */
    this._anims = {};

    /**
     * Reference to the current animation name.
     * @name  FORGE.SpriteAnimationManager#_animation
     * @type {string}
     * @private
     */
    this._animation = "default";

    /**
     * The default frame rate used by the animations.
     * @name  FORGE.SpriteAnimationManager#_frameRate
     * @type {number}
     * @private
     */
    this._frameRate = 30;

    /**
     * List of pending actions.<br>
     * some action are placed here if the Sprite is not loaded.
     * @name  FORGE.SpriteAnimationManager#_pending
     * @type {Array<AnimationConfiguration>}
     * @private
     */
    this._pending = [];

    FORGE.BaseObject.call(this, "SpriteAnimationManager");

    this._boot();
};

FORGE.SpriteAnimationManager.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.SpriteAnimationManager.prototype.constructor = FORGE.SpriteAnimationManager;

/**
 * Boot sequence.
 * @method FORGE.SpriteAnimationManager#_boot
 * @private
 */
FORGE.SpriteAnimationManager.prototype._boot = function()
{
    // Add the default animation that includes all frames @60fps
    this.add("default");

    if(this._sprite.loaded === false)
    {
        this._sprite.onLoadComplete.addOnce(this._spriteLoadComplete, this);
    }
};

/**
 * Apply pending animation declaration on sprite load complete.
 * @method FORGE.SpriteAnimationManager#_spriteLoadComplete
 * @private
 */
FORGE.SpriteAnimationManager.prototype._spriteLoadComplete = function()
{
    this.log("_spriteLoadComplete");

    var method, args;
    for(var i = 0, ii = this._pending.length; i < ii; i++)
    {
        method = this._pending[i].method;
        args = this._pending[i].args;
        FORGE.SpriteAnimationManager.prototype[method].apply(this, args);
    }

    this._pending = [];
};

/**
 * Add a configuration for animations
 * @method FORGE.SpriteAnimationManager#addConfig
 * @param {Array<SpriteAnimationConfig>} config - The configuration to add
 */
FORGE.SpriteAnimationManager.prototype.addConfig = function(config)
{
    if(Array.isArray(config) === true)
    {
        var anim;

        for(var i = 0, ii = config.length; i < ii; i++)
        {
            anim = config[i];
            this.add(anim.name, anim.start, anim.end, anim.frameRate, anim.loop);
        }
    }
};

/**
 * Add an animation sequence to this sprite.
 * @method FORGE.SpriteAnimationManager#add
 * @param {string=} name - The name of your animation sequence.
 * @param {number=} start - The starting frame index of the full frames array.
 * @param {number=} end - The end frame index of the full frame array.
 * @param {number=} frameRate - The frame rate of this animation (default: 60)
 * @param {boolean=} loop - Does the animation have to loop? (default: false)
 */
FORGE.SpriteAnimationManager.prototype.add = function(name, start, end, frameRate, loop)
{
    if(this._sprite.loaded === false)
    {
        this._pending.push({
            method: "add",
            args: arguments
        });

        return;
    }

    this.log("add");

    name = (typeof name === "string") ? name : "default";
    start = parseInt(start, 10);
    end = parseInt(end, 10);
    frameRate = (typeof frameRate === "number") ? frameRate : this._frameRate;
    loop = (typeof loop === "boolean") ? loop : true;

    var frames = this._sprite.frames;

    if(typeof start !== "number" || isNaN(start) === true || start < 0 || start >= frames.length)
    {
        start = 0;
    }

    if(typeof end !== "number" || isNaN(end) === true || end < 0 || end >= frames.length)
    {
        end = frames.length - 1;
    }

    var selectedFrames = frames.slice(start, end + 1);

    this._anims[name] = new FORGE.SpriteAnimation(this._sprite, name, selectedFrames, frameRate, loop);
};

/**
 * Play the curretn animation or a specified animation.<br>
 * If the Sprite is not loaded, kepp this method call in pending.
 * @method  FORGE.SpriteAnimationManager#play
 * @param  {string=} animation - The animation name you want to play.
 * @param  {boolean=} loop - Does the animation should loop?
 * @param  {number=} index - The index of the animation to play
 */
FORGE.SpriteAnimationManager.prototype.play = function(animation, loop, index)
{
    if(this._sprite.loaded === false)
    {
        this._pending.push(
        {
            method: "play",
            args: [animation, loop, index]
        });

        return;
    }

    // if there is an animation name use it, if not play the current animation, if no current animation, play the default one.
    animation = (typeof animation === "string") ? animation : (this.current !== null) ? this.current.name : "default";
    loop = (typeof loop === "boolean") ? loop : true;
    index = (typeof index === "number" && isNaN(index) === false) ? index : 0;

    var anim = this.get(animation);

    if(anim !== null)
    {
        anim.play(loop, index);
    }
};

/**
 * Pause the animation.
 * @method  FORGE.SpriteAnimationManager#pause
 * @param  {number=} index - The frame index on which to pause to animation. Default will be the current frame.
 */
FORGE.SpriteAnimationManager.prototype.pause = function(index)
{
    if(this._sprite.loaded === false)
    {
        this._pending.push({
            method: "pause",
            args: [index]
        });

        return;
    }

    if(this.current !== null)
    {
        this.current.pause(index);
    }
};

/**
 * Resume the animation.
 * @method  FORGE.SpriteAnimationManager#resume
 * @param  {number=} index - The frame index on which to pause to animation. Default will be the current frame.
 */
FORGE.SpriteAnimationManager.prototype.resume = function(index)
{
    if(this._sprite.loaded === false)
    {
        this._pending.push({
            method: "resume",
            args: [index]
        });

        return;
    }

    if(this.current !== null)
    {
        this.current.resume(index);
    }
};

/**
 * Stops the current animation, reset it to its first frame.
 * @method  FORGE.SpriteAnimationManager#stop
 */
FORGE.SpriteAnimationManager.prototype.stop = function()
{
    if(this._sprite.loaded === false)
    {
        this._pending.push({
            method: "stop",
            args: []
        });

        return;
    }

    if(this.current !== null)
    {
        this.current.stop();
    }
};


/**
 * Get an animation by its name.
 * @method  FORGE.SpriteAnimationManager#get
 * @param  {string} name - The name of the animation you want to get.
 * @return {FORGE.SpriteAnimation} Returns the asked animation if exists, null if not.
 */
FORGE.SpriteAnimationManager.prototype.get = function(name)
{
    if(FORGE.Utils.isTypeOf(this._anims[name], "SpriteAnimation") === true)
    {
        return this._anims[name];
    }

    return null;
};

/**
 * Internal update method.<br>
 * Main purpose is to update the current animation.
 * @method FORGE.SpriteAnimationManager#update
 */
FORGE.SpriteAnimationManager.prototype.update = function()
{
    if(this.current !== null)
    {
        this.current.update();
    }
};

/**
 * Destroy method
 * @method FORGE.SpriteAnimationManager#destroy
 */
FORGE.SpriteAnimationManager.prototype.destroy = function()
{
    for(var name in this._anims)
    {
        this._anims[name].destroy();
        this._anims[name] = null;
    }

    this._sprite = null;
    this._anims = null;
    this._pending = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get and set the default frame raet.
 * @name FORGE.SpriteAnimationManager#frameRate
 * @type {number}
 */
Object.defineProperty(FORGE.SpriteAnimationManager.prototype, "frameRate",
{
    /** @this {FORGE.SpriteAnimationManager} */
    get: function()
    {
        return this._frameRate;
    },

    /** @this {FORGE.SpriteAnimationManager} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._frameRate = value;
        }
    }
});

/**
 * Get and set the current animation.
 * @name FORGE.SpriteAnimationManager#current
 * @type {FORGE.SpriteAnimation}
 */
Object.defineProperty(FORGE.SpriteAnimationManager.prototype, "current",
{
    /** @this {FORGE.SpriteAnimationManager} */
    get: function()
    {
        return this.get(this._animation);
    },

    /** @this {FORGE.SpriteAnimationManager} */
    set: function(animation)
    {
        if(FORGE.Utils.isTypeOf(animation, "SpriteAnimation") === true)
        {
            this._animation = animation.name;
        }
    }
});

/**
 * Get all the animations.
 * @name FORGE.SpriteAnimationManager#all
 * @type {FORGE.SpriteAnimation}
 */
Object.defineProperty(FORGE.SpriteAnimationManager.prototype, "all",
{
    /** @this {FORGE.SpriteAnimationManager} */
    get: function()
    {
        return this._anims;
    }
});




/**
 * Animation for Sprites.
 * @constructor FORGE.SpriteAnimation
 * @param {FORGE.Sprite} sprite - The Sprite that is animated.
 * @param {string} name - Name of the animation.
 * @param {Array} frames - The frames taht compose this animation.
 * @param {number=} [frameRate=30] - Frame rate of this animation (default: 30)
 * @param {boolean=} [loop=true] - The loop flag
 * @extends {FORGE.BaseObject}
 *
 * @todo Work on trimmed textures
 */
FORGE.SpriteAnimation = function(sprite, name, frames, frameRate, loop)
{
    /**
     * The sprite attached to this animation.
     * @name  FORGE.SpriteAnimation#_sprite
     * @type {FORGE.Sprite}
     * @private
     */
    this._sprite = sprite;

    /**
     * Name of the animation.
     * @name  FORGE.SpriteAnimation#_name
     * @type {string}
     * @private
     */
    this._name = name;

    /**
     * Array of frames that compose this animation
     * @name  FORGE.SpriteAnimation#_frames
     * @type {Array<Object>}
     * @private
     */
    this._frames = frames || [];

    /**
     * The index of the current frame.
     * @name  FORGE.SpriteAnimation#_frameIndex
     * @type {number}
     * @private
     */
    this._frameIndex = 0;

    /**
     * Frame rate of this animation, this is the number of frames per second.
     * @name  FORGE.SpriteAnimation#_frameRate
     * @type {number}
     * @private
     */
    this._frameRate = frameRate || 30;

    /**
     * Does this animation loop?
     * @name  FORGE.SpriteAnimation#_loop
     * @type {boolean}
     * @private
     */
    this._loop = loop || false;

    /**
     * The number of times this animation has looped.
     * @name  FORGE.SpriteAnimation#_loopCount
     * @type {number}
     * @private
     */
    this._loopCount = 0;

    /**
     * The delay in milliseconds between two frames.
     * @name  FORGE.SpriteAnimation#_delay
     * @type {number}
     * @private
     */
    this._delay = 1000 / frameRate;

    /**
     * The time of the last frame.
     * @name  FORGE.SpriteAnimation#_timeLastFrame
     * @type {number}
     * @private
     */
    this._timeLastFrame = 0;

    /**
     * The time of the next frame.
     * @name  FORGE.SpriteAnimation#_timeNextFrame
     * @type {number}
     * @private
     */
    this._timeNextFrame = 0;

    /**
     * The time between the current time and the next frame.
     * @name  FORGE.SpriteAnimation#_frameDiff
     * @type {number}
     * @private
     */
    this._frameDiff = 0;

    /**
     * The number of frames to skip when laag occurs.
     * @name  FORGE.SpriteAnimation#_frameSkip
     * @type {number}
     * @private
     */
    this._frameSkip = 1;

    /**
     * Is this animation is currently playing?
     * @name  FORGE.SpriteAnimation#_playing
     * @type {boolean}
     * @private
     */
    this._playing = false;

    /**
     * Is this animation is currently paused?
     * @name  FORGE.SpriteAnimation#_paused
     * @type {boolean}
     * @private
     */
    this._paused = false;

    /**
     * Is this animation is complete?
     * @name  FORGE.SpriteAnimation#_complete
     * @type {boolean}
     * @private
     */
    this._complete = false;

    /**
     * On play event dispatcher.
     * @name  FORGE.SpriteAnimation#_onPlay
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On pause event dispatcher.
     * @name  FORGE.SpriteAnimation#_onPause
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * On resume event dispatcher.
     * @name  FORGE.SpriteAnimation#_onResume
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onResume = null;

    /**
     * On loop event dispatcher.
     * @name  FORGE.SpriteAnimation#_onLoop
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onLoop = null;

    /**
     * On stop event dispatcher.
     * @name  FORGE.SpriteAnimation#_onStop
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onStop = null;

    /**
     * On complete event dispatcher.
     * @name  FORGE.SpriteAnimation#_onComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onComplete = null;

    FORGE.BaseObject.call(this, "SpriteAnimation");
};

FORGE.SpriteAnimation.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.SpriteAnimation.prototype.constructor = FORGE.SpriteAnimation;

/**
 * Internal method to notify when animation is complete.
 * @method  FORGE.SpriteAnimation#_notifyComplete
 * @private
 */
FORGE.SpriteAnimation.prototype._notifyComplete = function()
{
    this._setFrameIndex(this._frames.length - 1);

    this._playing = false;
    this._complete = true;
    this._paused = false;

    if(this._onComplete !== null)
    {
        this._onComplete.dispatch();
    }
};

/**
 * Internal method to set the frame index of the animation and update the sprite display.
 * @method  FORGE.SpriteAnimation#_setFrameIndex
 * @private
 * @param {number=} [index=0] - The frame index to set.
 */
FORGE.SpriteAnimation.prototype._setFrameIndex = function(index)
{
    this._frameIndex = (typeof index === "number" && index >= 0 && index < this._frames.length) ? index : 0;
    this._sprite.frame = this._frames[this._frameIndex].frame;
};

/**
 * Play this animation.
 * @method  FORGE.SpriteAnimation#play
 * @param {boolean=} loop - Does the animation have to loop on complete?
 * @param {number=} index - the index to play at
 */
FORGE.SpriteAnimation.prototype.play = function(loop, index)
{
    if(typeof loop === "boolean")
    {
        this._loop = loop;
    }

    this._playing = true;
    this._complete = false;
    this._paused = false;
    this._loopCount = 0;

    var time = this._sprite.viewer.clock.time;
    this._timeLastFrame = time;
    this._timeNextFrame = time + this._delay;

    this._setFrameIndex(index); //Default will be 0 :)

    this._sprite.animations.current = this;

    if(this._onPlay !== null)
    {
        this._onPlay.dispatch();
    }
};

/**
 * Pause the animation.
 * @method  FORGE.SpriteAnimation#pause
 * @param  {number} [index] - The frame index on which to pause the animation. Default will be the current frame.
 */
FORGE.SpriteAnimation.prototype.pause = function(index)
{
    if(this._paused === true)
    {
        return;
    }

    this._paused = true;

    if(typeof index === "number")
    {
        this._setFrameIndex(index);
    }

    if(this._onPause !== null)
    {
        this._onPause.dispatch();
    }
};

/**
 * Resume the animation
 * @method FORGE.SpriteAnimation#resume
 * @param  {number} [index] - The frame index on which to resume the animation. Default will be the current frame.
 */
FORGE.SpriteAnimation.prototype.resume = function(index)
{
    if(this._paused === false)
    {
        return;
    }

    this._paused = false;

    if(typeof index === "number")
    {
        this._setFrameIndex(index);
    }

    if(this._playing)
    {
        this._timeNextFrame = this._sprite.viewer.clock.time + this._delay;
    }

    if(this._onResume !== null)
    {
        this._onResume.dispatch();
    }
};

/**
 * Stops the animation, reset it to the first frame.
 * @method  FORGE.SpriteAnimation#stop
 */
FORGE.SpriteAnimation.prototype.stop = function()
{
    this._playing = false;
    this._complete = true;
    this._paused = false;

    this._setFrameIndex(0);

    if(this._onStop !== null)
    {
        this._onStop.dispatch();
    }
};

/**
 * Update loop that will be called by the DisplayList through Sprite & SpriteAnimationManager update
 * @method FORGE.SpriteAnimation#update
 */
FORGE.SpriteAnimation.prototype.update = function()
{
    if (this._paused === true)
    {
        return;
    }

    var time = this._sprite.viewer.clock.time;

    if (this._playing === true && time >= this._timeNextFrame)
    {
        this._frameSkip = 1;
        this._frameDiff = time - this._timeNextFrame;
        this._timeLastFrame = time;

        if (this._frameDiff > this._delay)
        {
            this._frameSkip = Math.floor(this._frameDiff / this._delay);
            this._frameDiff -= (this._frameSkip * this._delay);
        }

        this._timeNextFrame = time + (this._delay - this._frameDiff);

        var frameIndex = this._frameIndex + this._frameSkip;

        if (frameIndex >= this._frames.length)
        {
            if (this._loop === true)
            {
                frameIndex %= this._frames.length;
                this._loopCount++;

                if(this._onLoop !== null)
                {
                    this._onLoop.dispatch();
                }

                this._setFrameIndex(frameIndex);
            }
            else
            {
                this._notifyComplete();
            }
        }
        else
        {
            this._setFrameIndex(frameIndex);
        }
    }
};

/**
 * Destroy method
 * @method FORGE.SpriteAnimation#destroy
 */
FORGE.SpriteAnimation.prototype.destroy = function()
{
    this._sprite = null;
    this._frames = null;

    if(this._onPlay !== null)
    {
        this._onPlay.destroy();
        this._onPlay = null;
    }

    if(this._onPause !== null)
    {
        this._onPause.destroy();
        this._onPause = null;
    }

    if(this._onResume !== null)
    {
        this._onResume.destroy();
        this._onResume = null;
    }

    if(this._onComplete !== null)
    {
        this._onComplete.destroy();
        this._onComplete = null;
    }

    if(this._onLoop !== null)
    {
        this._onLoop.destroy();
        this._onLoop = null;
    }

    if(this._onStop !== null)
    {
        this._onStop.destroy();
        this._onStop = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
* Get the name of the SpriteAnimation.
* @name FORGE.SpriteAnimation#name
* @readonly
* @type {string}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "name",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        return this._name;
    }
});

/**
* Get the frames array of the SpriteAnimation.
* @name FORGE.SpriteAnimation#frames
* @readonly
* @type {Array<Object>}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "frames",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        return this._frames;
    }
});

/**
* Get the current frame index of the SpriteAnimation.
* @name FORGE.SpriteAnimation#frameIndex
* @readonly
* @type {number}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "frameIndex",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        return this._frameIndex;
    }
});

/**
* Get the frame rate of the SpriteAnimation.
* @name FORGE.SpriteAnimation#frameRate
* @readonly
* @type {string}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "frameRate",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        return this._frameRate;
    },

    /** @this {FORGE.SpriteAnimation} */
    set: function(value)
    {
        if(typeof value !== "number")
        {
            return;
        }

        this._frameRate = value;
        this._delay = 1000 / this._frameRate;
    }
});

/**
* Get and set the loop flag of the SpriteAnimation.
* @name FORGE.SpriteAnimation#loop
* @type {boolean}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "loop",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        return this._loop;
    },

    /** @this {FORGE.SpriteAnimation} */
    set: function(value)
    {
        this._loop = Boolean(value);
    }
});

/**
* Get the loop count of the SpriteAnimation.
* @name FORGE.SpriteAnimation#loopCount
* @readonly
* @type {boolean}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "loopCount",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        return this._loopCount;
    }
});


/**
* Get the playing status of the SpriteAnimation.
* @name FORGE.SpriteAnimation#playing
* @readonly
* @type {boolean}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "playing",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        return this._playing;
    }
});

/**
* Get the paused status of the SpriteAnimation.
* @name FORGE.SpriteAnimation#paused
* @type {boolean}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "paused",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        return this._paused;
    },

    /** @this {FORGE.SpriteAnimation} */
    set: function(value)
    {
        if(Boolean(value) === true)
        {
            this.pause();
        }
        else
        {
            this.resume();
        }
    }
});

/**
* Get the complete status of the SpriteAnimation.
* @name FORGE.SpriteAnimation#complete
* @readonly
* @type {boolean}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "complete",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        return this._complete;
    }
});

/**
* Get the onPlay {@link FORGE.EventDispatcher}.
* @name FORGE.SpriteAnimation#onPlay
* @readonly
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "onPlay",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        if(this._onPlay === null)
        {
            this._onPlay = new FORGE.EventDispatcher(this);
        }

        return this._onPlay;
    }
});

/**
* Get the onPause {@link FORGE.EventDispatcher}.
* @name FORGE.SpriteAnimation#onPause
* @readonly
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "onPause",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        if(this._onPause === null)
        {
            this._onPause = new FORGE.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
* Get the onResume {@link FORGE.EventDispatcher}.
* @name FORGE.SpriteAnimation#onResume
* @readonly
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "onResume",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        if(this._onResume === null)
        {
            this._onResume = new FORGE.EventDispatcher(this);
        }

        return this._onResume;
    }
});

/**
* Get the onLoop {@link FORGE.EventDispatcher}.
* @name FORGE.SpriteAnimation#onLoop
* @readonly
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "onLoop",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        if(this._onLoop === null)
        {
            this._onLoop = new FORGE.EventDispatcher(this);
        }

        return this._onLoop;
    }
});

/**
* Get the onComplete {@link FORGE.EventDispatcher}.
* @name FORGE.SpriteAnimation#onComplete
* @readonly
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "onComplete",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        if(this._onComplete === null)
        {
            this._onComplete = new FORGE.EventDispatcher(this);
        }

        return this._onComplete;
    }
});

/**
* Get the onStop {@link FORGE.EventDispatcher}.
* @name FORGE.SpriteAnimation#onStop
* @readonly
* @type {FORGE.EventDispatcher}
*/
Object.defineProperty(FORGE.SpriteAnimation.prototype, "onStop",
{
    /** @this {FORGE.SpriteAnimation} */
    get: function()
    {
        if(this._onStop === null)
        {
            this._onStop = new FORGE.EventDispatcher(this);
        }

        return this._onStop;
    }
});


/**
 * Abstract video class.
 *
 * @constructor FORGE.VideoBase
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {string} name - the name of the video class
 * @extends {FORGE.DisplayObject}
 */
FORGE.VideoBase = function(viewer, name)
{
    /**
     * Playing status of the video.
     * @name  FORGE.VideoBase#_playing
     * @type {boolean}
     * @private
     */
    this._playing = false;

    /**
     * Boolean flag to know if can play is already received.
     * @name FORGE.VideoBase#_canPlay
     * @type {boolean}
     * @private
     */
    this._canPlay = false;

    /**
     * Number of play action on this video.
     * @name  FORGE.VideoBase#_playCount
     * @type {number}
     * @private
     */
    this._playCount = 0;

    /**
     * Number of the video ended.
     * @name  FORGE.VideoBase#_endCount
     * @type {number}
     * @private
     */
    this._endCount = 0;

    /**
     * The paused state of the video.
     * @name FORGE.VideoBase#_paused
     * @type {boolean}
     * @private
     */
    this._paused = false;

    FORGE.DisplayObject.call(this, viewer, null, name);
};

FORGE.VideoBase.prototype = Object.create(FORGE.DisplayObject.prototype);
FORGE.VideoBase.prototype.constructor = FORGE.VideoBase;

/**
 * Boot sequence.
 * @method FORGE.VideoBase#_boot
 * @private
 */
FORGE.VideoBase.prototype._boot = function()
{
    FORGE.DisplayObject.prototype._boot.call(this);

    // Listen to the Page Visibility event
    this._viewer.onPause.add(this._onVisibilityChange, this);
    this._viewer.onResume.add(this._onVisibilityChange, this);
};

/**
 * Handles the change of the visibility of the page.
 * @method FORGE.VideoBase#_onVisibilityChange
 * @param {FORGE.Event} event - the received event
 * @private
 */
FORGE.VideoBase.prototype._onVisibilityChange = function(event)
{
    var status = document[FORGE.Device.visibilityState];
    var external = (event.data.internal === undefined);

    // Pause if playing, leaving and authorized to pause
    if (this._viewer.config.autoPause === true && (status === "hidden" || external === true) && this._playing === true)
    {
        this.pause();
        this._paused = false; // can safely be set at false, as the playing state is checked
        return;
    }

    // Resume if paused, entering and authorized to resume
    if (this._viewer.config.autoResume === true && (status === "visible" || external === true) && this._playing === false && this._paused === false)
    {
        this.play();
        return;
    }
};

/**
 * Plays the video.
 * @method FORGE.VideoBase#play
 * @param {number=} time - Current video time to start playback.
 * @param {boolean=} loop - Media must be looped?
 */
FORGE.VideoBase.prototype.play = function(time, loop)
{
    this.currentTime = time;
    this.loop = loop;
};

/**
 * Pauses the video.
 * @method  FORGE.VideoBase#pause
 */
FORGE.VideoBase.prototype.pause = function()
{
};

/**
 * Destroy sequence.
 * @method FORGE.VideoBase#destroy
 */
FORGE.VideoBase.prototype.destroy = function()
{
    this._viewer.onPause.remove(this._onVisibilityChange, this);
    this._viewer.onResume.remove(this._onVisibilityChange, this);

    FORGE.DisplayObject.prototype.destroy.call(this);
};

/**
 * Get the playing status of the video.
 * @name FORGE.VideoBase#playing
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.VideoBase.prototype, "playing",
{
    /** @this {FORGE.VideoBase} */
    get: function()
    {
        return this._playing;
    }
});

/**
 * Get the number of play action of the video.
 * @name FORGE.VideoBase#playCount
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.VideoBase.prototype, "playCount",
{
    /** @this {FORGE.VideoBase} */
    get: function()
    {
        return this._playCount;
    }
});

/**
 * Get the canPlay status of the video.
 * @name FORGE.VideoBase#canPlay
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.VideoBase.prototype, "canPlay",
{
    /** @this {FORGE.VideoBase} */
    get: function()
    {
        return this._canPlay;
    }
});

/**
 * Get the paused status of the video.
 * @name FORGE.VideoBase#paused
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.VideoBase.prototype, "paused",
{
    /** @this {FORGE.VideoBase} */
    get: function()
    {
        return this._paused;
    }
});

/**
 * Get the number of the video ends.
 * @name FORGE.VideoBase#endCount
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.VideoBase.prototype, "endCount",
{
    /** @this {FORGE.VideoBase} */
    get: function()
    {
        return this._endCount;
    }
});

/**
 * Display object that contains a html video tag.<br>
 * <br>
 * Mobile limitations :<br>
 * - Can't play a video without user touch interaction, so we can't do smooth multiquality.
 *
 * @constructor FORGE.VideoHTML5
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {string} key - The video file id reference.
 * @param {?(string|FORGE.VideoQuality|Array<(string|FORGE.VideoQuality)>)=} config - Either a {@link FORGE.VideoQuality} or a String URL, or an array of strings or {@link FORGE.VideoQuality} if multiquality.
 * @param {?string=} qualityMode - The default quality mode.
 * @param {?boolean=} ambisonic - Is the video sound ambisonic?
 * @extends {FORGE.VideoBase}
 *
 * @todo  Define a config object for videos, maybe a class like VideoConfig to describe this porperly.
 * @todo  Make it work with several sources if the user wants to pass a mp4 + webm + ogg for example.
 * @todo  Deal with playback speeds.
 * @todo  Add subtitles management with <track> and VTT/TTML(EBU-TT-D) files
 */
FORGE.VideoHTML5 = function(viewer, key, config, qualityMode, ambisonic)
{
    /**
     * The video identifier.
     * @name FORGE.VideoHTML5#_key
     * @type {string}
     * @private
     */
    this._key = key;

    /**
     * {@link FORGE.VideoQuality} for this video, it can be temporarily a string into the constructor.
     * @name FORGE.VideoHTML5#_config
     * @type {?(string|FORGE.VideoQuality|Array<(string|FORGE.VideoQuality)>)}
     * @private
     */
    this._config = config || null;

    /**
     * Array of {@link FORGE.VideoQuality}.
     * @name  FORGE.VideoHTML5#_qualities
     * @type {Array<FORGE.VideoQuality>}
     * @private
     */
    this._qualities = null;

    /**
     * Default quality mode, it can be either "auto" or "manual", modes are listed by FORGE.VideoQualityMode constant.
     * @name FORGE.VideoHTML5#_defaultQualityMode
     * @type {string}
     * @private
     */
    this._defaultQualityMode = qualityMode || FORGE.VideoQualityMode.AUTO;

    /**
     * Current Quality mode.
     * @name  FORGE.VideoHTML5#_qualityMode
     * @type {string}
     * @private
     */
    this._qualityMode = "";

    /**
     * Array of videos objects thaht handle the dom and some stats about each videos.
     * @name FORGE.VideoHTML5#_videos
     * @type {Array<VideoHTML5Object>}
     * @private
     */
    this._videos = null;

    /**
     * The index of the requested video (if -1 no video is requested).
     * @name  FORGE.VideoHTML5#_requestIndex
     * @type {number}
     * @private
     */
    this._requestIndex = -1;

    /**
     * The index of the current video (if -1 no video is selected as the current one).
     * @name  FORGE.VideoHTML5#_currentIndex
     * @type {number}
     * @private
     */
    this._currentIndex = -1;

    /**
     * Timer that handler all times event when a video quality request is done.
     * @name  FORGE.VideoHTML5#_requestTimer
     * @type {FORGE.Timer}
     * @private
     */
    this._requestTimer = null;

    /**
     * Do the video quality change should be forced ? This var keep a reference to forceRequest between the diffent functions of callbacks chain.
     * @name  FORGE.VideoHTML5#_forceRequest
     * @type {boolean}
     * @private
     */
    this._forceRequest = false;

    /**
     * The time is milliseconds the requested video is seeked above the current time and wait to be synched.<br>
     * This delay ensure that the requested video have a minimum time to load before being synched.
     * @name  FORGE.VideoHTML5#_syncTime
     * @type {number}
     * @private
     */
    this._syncTime = 6000;

    /**
     * The time is milliseconds the requested video is considered as a failure.
     * @name  FORGE.VideoHTML5#_timeoutTime
     * @type {number}
     * @private
     */
    this._timeoutTime = 20000;

    /**
     * Timer that handler all times loop that check if we have to change quality (up or down).
     * @name  FORGE.VideoHTML5#_autoQualityTimer
     * @type {FORGE.Timer}
     * @private
     */
    this._autoQualityTimer = null;

    /**
     * Does the video loop?
     * @name  FORGE.VideoHTML5#_loop
     * @type {boolean}
     * @private
     */
    this._loop = false;

    /**
     * The volume of the video.
     * @name  FORGE.VideoHTML5#_volume
     * @type {number}
     * @private
     */
    this._volume = 1;

    /**
     * Is the video volume is muted?
     * @name  FORGE.VideoHTML5#_muted
     * @type {boolean}
     * @private
     */
    this._muted = false;

    /**
     * Private reference to the previous volume before mute.
     * @name  FORGE.VideoHTML5#_mutedVolume
     * @type {number}
     * @private
     */
    this._mutedVolume = 0;

    /**
     * Playback rate of the video
     * @name FORGE.VideoHTML5#_playbackRate
     * @type {number}
     * @private
     */
    this._playbackRate = 1;

    /**
     * FOADecoder is a ready-made FOA decoder and binaural renderer.
     * @name  FORGE.VideoHTML5#_decoder
     * @type {?FOADecoder}
     * @private
     */
    this._decoder = null;

    /**
     * Is it an ambisonical video soundtrack?
     * @name  FORGE.VideoHTML5#_ambisonic
     * @type {boolean}
     * @private
     */
    this._ambisonic = ambisonic || false;

    /**
     * Default channel map for ambisonic sound.
     * @name  FORGE.VideoHTML5#_defaultChannelMap
     * @type {Array<number>}
     * @private
     */
    this._defaultChannelMap = [0, 1, 2, 3]; //AMBIX
    //this._defaultChannelMap = [0, 3, 1, 2]; //FUMA

    /**
     * Does the video have received its metaData?
     * @name  FORGE.VideoHTML5#_metaDataLoaded
     * @type {boolean}
     * @private
     */
    this._metaDataLoaded = false;

    /**
     * On load start event dispatcher.
     * @name  FORGE.VideoHTML5#_onLoadStart
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onLoadStart = null;

    /**
     * On loaded metadata event dispatcher.
     * @name  FORGE.VideoHTML5#_onLoadedMetaData
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onLoadedMetaData = null;

    /**
     * On loaded data event dispatcher.
     * @name  FORGE.VideoHTML5#_onLoadedData
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onLoadedData = null;

    /**
     * On progress event dispatcher.
     * @name  FORGE.VideoHTML5#_onProgress
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onProgress = null;

    /**
     * On duration change event dispatcher.
     * @name  FORGE.VideoHTML5#_onDurationChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onDurationChange = null;

    /**
     * On can play event dispatcher.
     * @name  FORGE.VideoHTML5#_onCanPlay
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onCanPlay = null;

    /**
     * On can play through event dispatcher.
     * @name  FORGE.VideoHTML5#_onCanPlayThrough
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onCanPlayThrough = null;

    /**
     * On play event dispatcher.
     * @name  FORGE.VideoHTML5#_onPlay
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On pause event dispatcher.
     * @name  FORGE.VideoHTML5#_onPause
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * On time update event dispatcher.
     * @name  FORGE.VideoHTML5#_onTimeUpdate
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onTimeUpdate = null;

    /**
     * On current time change event dispatcher.
     * @name FORGE.VideoHTML5#_onCurrentTimeChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onCurrentTimeChange = null;

    /**
     * On volume change event dispatcher.
     * @name  FORGE.VideoHTML5#_onVolumeChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onVolumeChange = null;

    /**
     * On seeking event dispatcher.
     * @name  FORGE.VideoHTML5#_onSeeking
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onSeeking = null;

    /**
     * On seeked event dispatcher.
     * @name  FORGE.VideoHTML5#_onSeeked
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onSeeked = null;

    /**
     * On ended event dispatcher.
     * @name  FORGE.VideoHTML5#_onEnded
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onEnded = null;

    /**
     * On error event dispatcher.
     * @name  FORGE.VideoHTML5#_onError
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onError = null;

    /**
     * On waiting event dispatcher.
     * @name  FORGE.VideoHTML5#_onWaiting
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onWaiting = null;

    /**
     * On stalled event dispatcher.
     * @name  FORGE.VideoHTML5#_onStalled
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onStalled = null;

    /**
     * On playing event dispatcher.
     * @name  FORGE.VideoHTML5#_onPlaying
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPlaying = null;

    /**
     * On rate change event dispatcher.
     * @name  FORGE.VideoHTML5#_onRateChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onRateChange = null;

    /**
     * On mute event dispatcher.
     * @name  FORGE.VideoHTML5#_onMute
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onMute = null;

    /**
     * On unmute event dispatcher.
     * @name  FORGE.VideoHTML5#_onUnmute
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onUnmute = null;

    /**
     * On qualityRequest event dispatcher.
     * @name  FORGE.VideoHTML5#_onQualityRequest
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onQualityRequest = null;

    /**
     * On qualityChange event dispatcher.
     * @name  FORGE.VideoHTML5#_onQualityChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onQualityChange = null;

    /**
     * On qualityAbort event dispatcher.
     * @name  FORGE.VideoHTML5#_onQualityAbort
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onQualityAbort = null;

    /**
     * On qualties loaded event dispatcher.
     * @name  FORGE.VideoHTML5#_onQualitiesLoaded
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onQualitiesLoaded = null;

    /**
     * On qualityModeChange event dispatcher.
     * @name  FORGE.VideoHTML5#_onQualityModeChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onQualityModeChange = null;

    /**
     * Event handler for request error binded to this.
     * @name FORGE.VideoHTML5#_onRequestErrorBind
     * @type {Function}
     * @private
     */
    this._onRequestErrorBind = null;

    /**
     * Event handler for request load start binded to this.
     * @name FORGE.VideoHTML5#_onRequestLoadStartBind
     * @type {Function}
     * @private
     */
    this._onRequestLoadStartBind = null;

    /**
     * Event handler for request loaded metadata binded to this.
     * @name FORGE.VideoHTML5#_onRequestLoadedMetaDataBind
     * @type {Function}
     * @private
     */
    this._onRequestLoadedMetaDataBind = null;

    /**
     * Event handler for request loaded data binded to this.
     * @name FORGE.VideoHTML5#_onRequestLoadedDataBind
     * @type {Function}
     * @private
     */
    this._onRequestLoadedDataBind = null;

    /**
     * Event handler for request can play (before seek) binded to this.
     * @name FORGE.VideoHTML5#_onRequestCanPlayBeforeSeekBind
     * @type {Function}
     * @private
     */
    this._onRequestCanPlayBeforeSeekBind = null;

    /**
     * Event handler for request seeked binded to this.
     * @name FORGE.VideoHTML5#_onRequestSeekedBind
     * @type {Function}
     * @private
     */
    this._onRequestSeekedBind = null;

    /**
     * Event handler for request can play (after seek) binded to this.
     * @name FORGE.VideoHTML5#_onRequestCanPlayAfterSeekBind
     * @type {Function}
     * @private
     */
    this._onRequestCanPlayAfterSeekBind = null;

    /**
     * Event handler for request seeked (while synch) binded to this.
     * @name FORGE.VideoHTML5#_onRequestSeekedWhileSyncBind
     * @type {Function}
     * @private
     */
    this._onRequestSeekedWhileSyncBind = null;

    /**
     * Event handler for all events fired by the HTMLVideoElement. See https://developer.mozilla.org/en/docs/Web/Guide/Events/Media_events for a list of available events.
     * @name FORGE.VideoHTML5#_onEventBind
     * @type {Function}
     * @private
     */
    this._onEventBind = null;

    /**
     * Event handler for FOA decoder initialized binded to this.
     * @name FORGE.VideoHTML5#_decoderInitializedSuccessBind
     * @type {Function}
     * @private
     */
    this._decoderInitializedSuccessBind = null;

    /**
     * Event handler for FOA decoder initailization error binded to this.
     * @name FORGE.VideoHTML5#_decoderInitializedErrorBind
     * @type {Function}
     * @private
     */
    this._decoderInitializedErrorBind = null;

    FORGE.VideoBase.call(this, viewer, "VideoHTML5");
};

FORGE.VideoHTML5.prototype = Object.create(FORGE.VideoBase.prototype);
FORGE.VideoHTML5.prototype.constructor = FORGE.VideoHTML5;

/**
 * Boot sequence.
 * @method FORGE.VideoHTML5#_boot
 * @private
 */
FORGE.VideoHTML5.prototype._boot = function()
{
    FORGE.VideoBase.prototype._boot.call(this);

    if (this._ambisonic === true && this._isAmbisonic() === false)
    {
        this.log("FORGE.VideoHTML5: can't manage ambisonic sound without Google Chrome Omnitone library and WebAudio API.");
        this._ambisonic = false;
    }

    //register the uid
    this._uid = this._key;
    this._register();

    this._onRequestErrorBind = this._onRequestError.bind(this);
    this._onRequestLoadStartBind = this._onRequestLoadStart.bind(this);
    this._onRequestLoadedMetaDataBind = this._onRequestLoadedMetaData.bind(this);
    this._onRequestLoadedDataBind = this._onRequestLoadedData.bind(this);
    this._onRequestCanPlayBeforeSeekBind = this._onRequestCanPlayBeforeSeek.bind(this);
    this._onRequestSeekedBind = this._onRequestSeeked.bind(this);
    this._onRequestCanPlayAfterSeekBind = this._onRequestCanPlayAfterSeek.bind(this);
    this._onRequestSeekedWhileSyncBind = this._onRequestSeekedWhileSync.bind(this);

    this._onEventBind = this._onEventHandler.bind(this);

    this._requestTimer = this._viewer.clock.create(false);

    this._autoQualityTimer = this._viewer.clock.create(false);
    this._autoQualityTimer.loop(500, this._autoQualityTimerLoop, this);

    //Listen to the main volume change to adapt the video volume accordingly.
    this._viewer.audio.onVolumeChange.add(this._mainVolumeChangeHandler, this);

    //Listen to the enabled state of the sound manager.
    this._viewer.audio.onDisable.add(this._disableSoundHandler, this);

    //force the creation of "onQualitiesLoaded" event dispatcher and memorize it's data
    this._onQualitiesLoaded = new FORGE.EventDispatcher(this, true);

    if (this._config !== null)
    {
        this.load(this._config);
    }

    this._viewer.display.register(this, this._isAmbisonic());
    this._notifyReady();
    this._applyPending(false);
};

/**
 * Parse the video configuration object.
 * @method FORGE.VideoHTML5#_parseConfig
 * @private
 * @param  {?(string|FORGE.VideoQuality|Array<(string|FORGE.VideoQuality)>)} config - The config object to parse.
 * @return {Array<FORGE.VideoQuality>} Returns the array of {@link FORGE.VideoQuality}.
 */
FORGE.VideoHTML5.prototype._parseConfig = function(config)
{
    if (config !== null)
    {
        if (FORGE.Utils.isTypeOf(config, "string") === true)
        {
            config = [config];
        }
        else if (FORGE.Utils.isTypeOf(config, "VideoQuality") === true)
        {
            config = [config];
        }

        if (FORGE.Utils.isArrayOf(config, "string") === true)
        {
            this._qualities = this._createQualitiesFromURLs( /** @type {Array<string>} */ (config));
        }
        else if (FORGE.Utils.isArrayOf(config, "VideoQuality") === true)
        {
            this._qualities = /** @type {Array<FORGE.VideoQuality>} */ (config);
        }
    }

    if (this._onQualitiesLoaded !== null)
    {
        this._onQualitiesLoaded.dispatch(this._qualities);
    }

    return this._qualities;
};

/**
 * Notify that the dispay object has been resized.<br>
 * This method ovverrides the {@link FORGE.DisplayObject} method.
 * @method  FORGE.VideoHTML5#_notifyResize
 * @private
 * @param  {PropertyToUpdate} data - The data contains the property that have changed.
 */
FORGE.VideoHTML5.prototype._notifyResize = function(data)
{
    var currentVideo = this._getCurrentVideo();

    if (currentVideo !== null && currentVideo.element !== null)
    {
        currentVideo.element.setAttribute("width", this.pixelWidth);
        currentVideo.element.setAttribute("height", this.pixelHeight);
    }

    FORGE.DisplayObject.prototype._notifyResize.call(this, data);
};

/**
 * Create the array of {@link FORGE.VideoQuality} from an array of URLs (strings).
 * @method FORGE.VideoHTML5#_createQualitiesFromURLs
 * @private
 * @param  {Array<string>} urls - Array of URLS (strings) to convert to array of {@link FORGE.VideoQuality}.
 * @param {boolean=} checkURL - Does the function have to check url validity?
 * @return {Array<FORGE.VideoQuality>} Returns the array of {@link FORGE.VideoQuality}.
 */
FORGE.VideoHTML5.prototype._createQualitiesFromURLs = function(urls, checkURL)
{
    var qualities = [];
    var quality;

    for (var i = 0, ii = urls.length; i < ii; i++)
    {
        if (checkURL === true && FORGE.URL.isValid(urls[i]) === false)
        {
            throw "FORGE.VideoHTML5: URL " + urls[i] + " is invalid";
        }

        quality = new FORGE.VideoQuality(urls[i]);
        qualities.push(quality);
    }

    return qualities;
};

/**
 * Get the index of a {@link FORGE.VideoQuality} that is in the _videoQualities array.
 * @method  FORGE.VideoHTML5#_indexOfQuality
 * @private
 * @param  {FORGE.VideoQuality} quality - The quality you need to get its index.
 * @return {number} Returns the index of the quality if found, -1 if not found.
 */
FORGE.VideoHTML5.prototype._indexOfQuality = function(quality)
{
    var q;
    for (var i = 0, ii = this._qualities.length; i < ii; i++)
    {
        q = this._qualities[i];

        if (q === quality)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Get the index of a video object that is in the _videos array.
 * @method  FORGE.VideoHTML5#_indexOfVideo
 * @private
 * @param  {VideoHTML5Object} video - The video object you need to get its index.
 * @return {number} Returns the index of the video object if found, -1 if not found.
 */
FORGE.VideoHTML5.prototype._indexOfVideo = function(video)
{
    var v;
    for (var i = 0, ii = this._videos.length; i < ii; i++)
    {
        v = this._videos[i];

        if (v === video)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Get a video object at a specified index.
 * @method  FORGE.VideoHTML5#_getVideoAt
 * @private
 * @param  {number} index - The index of the video you want to get.
 * @return {?VideoHTML5Object} Returns the video object or null if not found.
 */
FORGE.VideoHTML5.prototype._getVideoAt = function(index)
{
    if (this._videos === null)
    {
        return null;
    }

    var video = this._videos[index];

    if (video !== null && typeof video !== "undefined")
    {
        return video;
    }

    return null;
};

/**
 * Get the video object for the requested video.
 * @method FORGE.VideoHTML5#_getRequestedVideo
 * @private
 * @return {?VideoHTML5Object} Video object for the requested video.
 */
FORGE.VideoHTML5.prototype._getRequestedVideo = function()
{
    return this._getVideoAt(this._requestIndex);
};

/**
 * Get the video object for the current video.
 * @method FORGE.VideoHTML5#_getCurrentVideo
 * @private
 * @return {?VideoHTML5Object} Video object for the current video.
 */
FORGE.VideoHTML5.prototype._getCurrentVideo = function()
{
    return this._getVideoAt(this._currentIndex);
};

/**
 * Get a property of the video element of the current video object.
 * @method  FORGE.VideoHTML5#_getCurrentVideoElementProperty
 * @param  {string} property - The property you want to get from the current video element.
 * @param  {*} defaultReturnValue - The default return value if the video object or its element is null.
 * @return {*} Return the requested property value or the default one if necessary.
 * @private
 */
FORGE.VideoHTML5.prototype._getCurrentVideoElementProperty = function(property, defaultReturnValue)
{
    var video = this._getCurrentVideo();

    if (video !== null && video.element !== null)
    {
        return video.element[property];
    }

    return defaultReturnValue;
};

/**
 * Create placeholders objects for videos and theirs attributes.
 * @method FORGE.VideoHTML5#_createVideoObjects
 * @private
 * @param  {number} count - Number of video objects to create.
 * @return {Array<VideoHTML5Object>} Returns the populated videos array.
 */
FORGE.VideoHTML5.prototype._createVideoObjects = function(count)
{
    var videos = [];
    var video;

    for (var i = 0, ii = count; i < ii; i++)
    {
        video = {
            index: i,
            element: null,
            buffer: null,
            played: null,

            requestCount: 0,
            currentCount: 0,
            abortCount: 0, //Number of times this video has been requested and aborted (accepted: 1 attemp)
            leaveCount: 0, //Number of times this video has been leaved for bandwidth issues (accepted: 2 attemps)
            downCount: 0, //Number of times this video has been requested for downgrade (need 3 attemps)

            lastTimeStamp: 0
        };

        videos[i] = video;
    }

    this._videos = videos;

    return videos;
};

/**
 * Populate a video object at a specified index with an element <video> and a buffer/played {@link FORGE.VideoTimeRanges} managers.
 * @method  FORGE.VideoHTML5#_createVideoAt
 * @private
 * @param  {number} index - The index to create the video in the _videos array.
 * @return {VideoHTML5Object} Returns the populated video object.
 */
FORGE.VideoHTML5.prototype._createVideoAt = function(index)
{
    //Create a video tag and get the quality
    var element = document.createElement("video");
    element.setAttribute("webkit-playsinline", "true");
    element.setAttribute("playsinline", "true");
    element.setAttribute("width", this.pixelWidth);
    element.setAttribute("height", this.pixelHeight);
    element.volume = 0;
    element.playbackRate = this._playbackRate;
    element.crossOrigin = "anonymous";
    element.id = "FORGE-VideoHTML5-" + this._uid + "-" + index;

    var buffer = new FORGE.VideoTimeRanges(element, "buffered");
    var played = new FORGE.VideoTimeRanges(element, "played");

    //Update the video object with the element and fresh buffer and played
    var video = this._videos[index];
    video.element = element;
    video.buffer = buffer;
    video.played = played;

    return video;
};

/**
 * Create the source tag into the video tag.
 * @method FORGE.VideoHTML5#_createSourceTags
 * @private
 * @param {VideoHTML5Object} video - Video object to add the quality to.
 * @param {FORGE.VideoQuality} quality - The quality video source to attach to the video element.
 * @return {VideoHTML5Object} The video object that contains the HTML5 Video Element in which the source is append to.
 */
FORGE.VideoHTML5.prototype._createSourceTags = function(video, quality)
{
    if (FORGE.Device.edge === true)
    {
        // EDGE is not able to restore the currentTime with source tag
        video.element.src = quality.url;
    }
    else
    {
        var source = document.createElement("source");
        source.addEventListener("error", this._onRequestErrorBind, false);
        source.src = quality.url;
        source.type = quality.mimeType;

        video.element.appendChild(source);
    }

    return video;
};

/**
 * Destroy a video object.
 * @method FORGE.VideoHTML5#_destroyVideo
 * @private
 * @param {VideoHTML5Object} video - The video object to destroy.
 */
FORGE.VideoHTML5.prototype._destroyVideo = function(video)
{
    var index = this._indexOfVideo(video);

    if (index !== -1)
    {
        this._destroyVideoAt(index);
    }
};

/**
 * Destroy a video object at a specified index, wiil look at the video object into _videos array then detoy it.
 * @method FORGE.VideoHTML5#_destroyVideoAt
 * @private
 * @param {number} index - The index of the video object to destroy.
 */
FORGE.VideoHTML5.prototype._destroyVideoAt = function(index)
{
    if (index !== -1)
    {
        this.log("_destroyVideoAt " + index);

        var video = this._videos[index];
        var element = video.element;

        if (typeof element !== "undefined" && element !== null)
        {
            this._uninstallEvents(element);
            element.pause();
            element.src = "";

            if (FORGE.Device.edge !== true)
            {
                var source;
                for (var i = 0, ii = element.children.length; i < ii; i++)
                {
                    source = element.children[i];
                    source.removeEventListener("error", this._onRequestErrorBind, false);
                    source.src = "";

                    element.removeChild(source);
                    source = null;
                }
            }

            element.load();

            if (element.parentNode === this._dom)
            {
                this._dom.removeChild(element);
            }
        }

        element = null;
        video.element = null;

        if (video.buffer !== null)
        {
            video.buffer.destroy();
            video.buffer = null;
        }

        if (video.played !== null)
        {
            video.played.destroy();
            video.played = null;
        }
    }
};

/**
 * Set the request index.<br>
 * A video quality change request starts here!
 * @method FORGE.VideoHTML5#_setRequestIndex
 * @private
 * @param {number} index - The index of the video quality that is requested.
 * @param {boolean=} force - Do we have to force the request? Used in downgrade quality, we skip the synch delay to have a minimal interruption of playback.
 */
FORGE.VideoHTML5.prototype._setRequestIndex = function(index, force)
{
    this._forceRequest = force || false;
    this.log("Requesting index: " + index + ", force: " + this._forceRequest);

    //If a request is already being proccessed clear it
    if (this._requestIndex !== -1 && this._requestIndex !== index)
    {
        this._clearRequestedVideo();
    }

    var alreadyRequested = index === this._requestIndex ? true : false;

    //Assign the new request index
    this._requestIndex = index;

    if (this._onQualityRequest !== null)
    {
        this._onQualityRequest.dispatch(index);
    }

    //If this request is alredy being processed or it matches the current video, return!
    if (index === this._currentIndex || alreadyRequested === true)
    {
        return;
    }

    //Create a video tag and get the quality
    var requestedVideo = this._createVideoAt(this._requestIndex);
    requestedVideo.requestCount++;

    //Get the requested quality
    var quality = this._qualities[this._requestIndex];

    //If there is a current video
    if (this._currentIndex > -1)
    {
        //Add listener to begins transition between qualities
        requestedVideo.element.addEventListener("loadstart", this._onRequestLoadStartBind, false);
        requestedVideo.element.addEventListener("error", this._onRequestErrorBind, false);
    }

    //Create source tags according to quality
    this._createSourceTags(requestedVideo, quality);

    this._decoderInitializedSuccessBind = this._decoderInitializedSuccess.bind(this);

    if (this._isAmbisonic() === true)
    {
        //get the global audio context
        this._context = this._viewer.audio.context;

        //FOA decoder and binaural renderer
        this._decoder = Omnitone.createFOADecoder(this._context, requestedVideo.element, {
            channelMap: this._defaultChannelMap
            //HRTFSetUrl: 'YOUR_HRTF_SET_URL', //Base URL for the cube HRTF sets.
            //postGainDB: 0, //Post-decoding gain compensation in dB.
        });

        //Initialize the decoder
        this._decoderInitializedErrorBind = this._decoderInitializedError.bind(this);
        this._decoder.initialize().then(this._decoderInitializedSuccessBind, this._decoderInitializedErrorBind);
    }
    else
    {
        //Load!
        this._decoderInitializedSuccess();
    }

    //If there's no current video, this is the first request, assign the current video directly
    if (this._currentIndex === -1)
    {
        this.log("No current video, set directly the current index");
        this._setCurrentIndex(index);
    }
    else
    {
        //Start a timer to estimate if it is a failure ...
        this._requestTimer.add(this._timeoutTime, this._requestTimeOutHandler, this);
        this._requestTimer.start();
    }
};

/**
 * The FOA decoder has been initialized.
 * @method FORGE.VideoHTML5#_decoderInitializedSuccess
 * @private
 */
FORGE.VideoHTML5.prototype._decoderInitializedSuccess = function()
{
    if (this._requestIndex === -1)
    {
        //get the current video if requested index is set
        this._getCurrentVideo().element.load();
    }
    else
    {
        this._getRequestedVideo().element.load();
    }
};

/**
 * The FOA decoder can't be initialized.
 * @method FORGE.VideoHTML5#_decoderInitializedError
 * @private
 */
FORGE.VideoHTML5.prototype._decoderInitializedError = function()
{
    this.log("FOA decoder could not be initialized");
};

/**
 * Event handler for loadstart, binded on a requested video element.
 * @method FORGE.VideoHTML5#_onRequestLoadStart
 * @private
 */
FORGE.VideoHTML5.prototype._onRequestLoadStart = function()
{
    var element = this._getRequestedVideo().element;

    this.log("_onRequestLoadStart [readyState: " + element.readyState + "]");
    element.removeEventListener("loadstart", this._onRequestLoadStartBind, false);
    element.addEventListener("loadedmetadata", this._onRequestLoadedMetaDataBind, false);
};

/**
 * Event handler for loadedmetadata, binded on a requested video element.
 * @method FORGE.VideoHTML5#_onRequestLoadedMetaData
 * @private
 */
FORGE.VideoHTML5.prototype._onRequestLoadedMetaData = function()
{
    var element = this._getRequestedVideo().element;

    this.log("_onRequestLoadedMetaData [readyState: " + element.readyState + "]");
    element.removeEventListener("loadedmetadata", this._onRequestLoadedMetaDataBind, false);
    element.addEventListener("loadeddata", this._onRequestLoadedDataBind, false);
};

/**
 * Event handler for loadeddata, binded on a requested video element.
 * @method FORGE.VideoHTML5#_onRequestLoadedData
 * @private
 */
FORGE.VideoHTML5.prototype._onRequestLoadedData = function()
{
    var element = this._getRequestedVideo().element;

    this.log("_onRequestLoadedData [readyState: " + element.readyState + "]");
    element.removeEventListener("loadeddata", this._onRequestLoadedDataBind, false);

    if (FORGE.Device.desktop === true)
    {
        element.addEventListener("play", this._onRequestCanPlayBeforeSeekBind, false);
        element.play();
    }
    else
    {
        //For mobile no sync, we are not able to play without user interaction
        this._setCurrentIndex(this._requestIndex, true);
    }
};

/**
 * Event handler for canplay, binded on a requested video element.
 * @method FORGE.VideoHTML5#_onRequestCanPlayBeforeSeek
 * @private
 */
FORGE.VideoHTML5.prototype._onRequestCanPlayBeforeSeek = function()
{
    var element = this._getRequestedVideo().element;

    this.log("_onRequestCanPlayBeforeSeek [readyState: " + element.readyState + "]");
    element.pause();
    element.removeEventListener("play", this._onRequestCanPlayBeforeSeekBind, false);
    element.addEventListener("seeked", this._onRequestSeekedBind, false);

    var currentTime = this.currentTime;

    //If the video is already playing, start buffering the next video quality some seconds after the current time.
    if (this._playing === true && this._forceRequest === false)
    {
        element.currentTime = currentTime + (this._syncTime / 1000);
    }
    else
    {
        element.currentTime = currentTime;
    }
};

/**
 * Event handler for seeked, binded on a requested video element.
 * @method FORGE.VideoHTML5#_onRequestSeeked
 * @private
 */
FORGE.VideoHTML5.prototype._onRequestSeeked = function()
{
    var element = this._getRequestedVideo().element;

    this.log("_onRequestSeeked [readyState: " + element.readyState + "]");
    element.removeEventListener("seeked", this._onRequestSeekedBind, false);

    if (element.readyState === HTMLMediaElement.HAVE_ENOUGH_DATA)
    {
        element.removeEventListener("error", this._onRequestErrorBind, false);
        this._requestWaitSync();
    }
    else
    {
        if (FORGE.Device.edge === true || FORGE.Device.ie === true)
        {
            element.addEventListener("canplaythrough", this._onRequestCanPlayAfterSeekBind, false);
        }
        else
        {
            element.addEventListener("canplay", this._onRequestCanPlayAfterSeekBind, false);
        }
    }
};

/**
 * Event handler for canplay (after a seek), binded on a requested video element.
 * @method FORGE.VideoHTML5#_onRequestCanPlayAfterSeek
 * @private
 */
FORGE.VideoHTML5.prototype._onRequestCanPlayAfterSeek = function()
{
    var element = this._getRequestedVideo().element;

    this.log("_onRequestCanPlayAfterSeek [readyState: " + element.readyState + "]");

    //Force the current time of the requested video to the current video time value. Usefull for long duration chunks downloads.
    element.currentTime = this.currentTime;

    //Clean events listeners on element
    if (FORGE.Device.edge === true || FORGE.Device.ie === true)
    {
        element.removeEventListener("canplaythrough", this._onRequestCanPlayAfterSeekBind, false);
    }
    else
    {
        element.removeEventListener("canplay", this._onRequestCanPlayAfterSeekBind, false);
    }
    element.removeEventListener("error", this._onRequestErrorBind, false);

    this._requestWaitSync();
};

/**
 * Triggers the waiting process of two videos to be synched.
 * @method FORGE.VideoHTML5#_requestWaitSync
 * @private
 */
FORGE.VideoHTML5.prototype._requestWaitSync = function()
{
    //If the current video is seeked, re init the request (abort then retry)
    var currentVideo = this._getCurrentVideo();
    if (currentVideo !== null && currentVideo.element !== null && this._forceRequest === false)
    {
        this.log("Current video listen to seek, wait both video to sync");
        currentVideo.element.addEventListener("seeked", this._onRequestSeekedWhileSyncBind, false);
        this._requestTimer.loop(10, this._videoSyncTimerLoop, this);
    }

    //Clean error event listener on requested source
    if (FORGE.Device.edge !== true)
    {
        var element = this._getRequestedVideo().element;
        var source;
        for (var i = 0, ii = element.children.length; i < ii; i++)
        {
            source = element.children[i];
            source.removeEventListener("error", this._onRequestErrorBind, false);
        }
    }

    if (this._forceRequest === true)
    {
        this._setCurrentIndex(this._requestIndex);
    }
};

/**
 * Event handler for seeked on video while its being synched, binded on a requested video element.<br>
 * if a seeked event occurs while sync, this abort the request and retry with the new current time of the video.
 * @method  FORGE.VideoHTML5#_onRequestSeekedWhileSync
 * @private
 */
FORGE.VideoHTML5.prototype._onRequestSeekedWhileSync = function()
{
    this.log("_onRequestSeekedWhileSync " + this.currentTime);

    var requestIndex = this._requestIndex;
    this._abortRequest(false);
    this._setRequestIndex(requestIndex);
};

/**
 * This is the timer loop handler that check if two videos are synched each other.<br>
 * If sync is ok, sets the requested video as the current one.
 * @method FORGE.VideoHTML5#_videoSyncTimerLoop
 * @private
 */
FORGE.VideoHTML5.prototype._videoSyncTimerLoop = function()
{
    this.log("_videoSyncTimerLoop " + this._requestIndex);

    var video = this._getRequestedVideo();

    if (video !== null && this.currentTime >= video.element.currentTime && this.currentTime < (video.element.currentTime + 0.05))
    {
        this._setCurrentIndex(this._requestIndex);
    }
};

/**
 * Event handler for the timeout timer. Abort the video raquest if the timeout contdown is reached.
 * @method FORGE.VideoHTML5#_requestTimeOutHandler
 * @private
 */
FORGE.VideoHTML5.prototype._requestTimeOutHandler = function()
{
    this.log("_requestTimeOutHandler "+this._requestIndex);
    this._abortRequest(true);
};

/**
 * Event handler for error, binded on a requested video element.
 * @method FORGE.VideoHTML5#_onRequestError
 * @private
 */
FORGE.VideoHTML5.prototype._onRequestError = function(event)
{
    this.log("_onRequestError");
    this.log(event);
    this._abortRequest(true);
};

/**
 * Sets the current video index.<br>
 * This is the end of the video quality request process! Congratulations!
 * @method  FORGE.VideoHTML5#_setCurrentIndex
 * @private
 * @param {number} index - The index of the video to be consider as the current one.
 * @param {boolean=} sync - Does the new video have to be time synched with the previous video time?
 */
FORGE.VideoHTML5.prototype._setCurrentIndex = function(index, sync)
{
    if (index === this._currentIndex)
    {
        return;
    }

    //Remove all video tags from our container div
    this._dom.innerHTML = "";

    //Get the requested video
    var requestedVideo = this._getRequestedVideo();

    //Resume playback if it was already playing
    if (this._playing === true)
    {
        requestedVideo.element.play();
    }

    //Update the volume of the requested video
    this._updateVolume(requestedVideo);

    //Apply the current playback rate
    requestedVideo.element.playbackRate = this._playbackRate;

    //Get the current video and clean some events listener (seek while sync), and destroy video tag.
    var videoToBeRemoved = this._getCurrentVideo();

    //Index switch
    this._requestIndex = -1;
    this._currentIndex = index;

    //Update current video reference
    var currentVideo = this._getCurrentVideo();
    currentVideo.currentCount++;

    //Restore current time on mobile
    if (sync === true && videoToBeRemoved !== null)
    {
        currentVideo.element.currentTime = videoToBeRemoved.element.currentTime;
    }

    //Install the current video events
    this._installEvents(currentVideo.element);

    //Add video to the DOM
    this._dom.appendChild(currentVideo.element);


    if (videoToBeRemoved !== null && videoToBeRemoved.element !== null)
    {
        videoToBeRemoved.element.removeEventListener("seeked", this._onRequestSeekedWhileSyncBind, false);
        this._destroyVideo(videoToBeRemoved);
    }

    //Clear the request timer
    this._requestTimer.stop(true);

    if (this._onQualityChange !== null)
    {
        this._onQualityChange.dispatch(this._currentIndex);
    }

    if (this._qualityMode === "")
    {
        this._setQualityMode(this._defaultQualityMode);
    }
};

/**
 * Event handler for the auto quality timer loop that checks if we have to upgrade or downgrade the quality.
 * @method FORGE.VideoHTML5#_autoQualityTimerLoop
 * @private
 */
FORGE.VideoHTML5.prototype._autoQualityTimerLoop = function()
{
    //If there is a pending request, return
    if (this._playing === false || this._requestIndex !== -1)
    {
        return;
    }

    if (this._shouldAutoQualityDowngrade() === true)
    {
        this._downgradeAutoQuality();
        return;
    }

    if (this._shouldAutoQualityUpgrade() === true)
    {
        this._upgradeAutoQuality();
        return;
    }
};

/**
 * Algo that check if we should upgrade the video quality.
 * @method  FORGE.VideoHTML5#_shouldAutoQualityUpgrade
 * @private
 * @return {boolean} Returns true if we should upgrade the video quality, false if not.
 */
FORGE.VideoHTML5.prototype._shouldAutoQualityUpgrade = function()
{
    var currentVideo = this._getCurrentVideo();

    if (currentVideo !== null && currentVideo.buffer !== null)
    {
        if (currentVideo.buffer.isInRanges(currentVideo.element.currentTime, this._syncTime / 1000))
        {
            return true;
        }
    }

    return false;
};

/**
 * Algo that check if we should downgrade the video quality.
 * @method  FORGE.VideoHTML5#_shouldAutoQualityDowngrade
 * @private
 * @return {boolean} Returns true if we should downgrade the video quality, false if not.
 */
FORGE.VideoHTML5.prototype._shouldAutoQualityDowngrade = function()
{
    var currentVideo = this._getCurrentVideo();
    var time = currentVideo.element.currentTime;

    if (currentVideo.element.playing === false)
    {
        return false;
    }

    if (time === currentVideo.lastTimeStamp)
    {
        currentVideo.downCount++;
        if (currentVideo.downCount >= 3)
        {
            currentVideo.lastTimeStamp = 0;
            return true;
        }
    }
    else
    {
        currentVideo.lastTimeStamp = time;
        currentVideo.downCount = 0;
    }

    return false;
};

/**
 * Upgrade the video quality, triggered by the _autoQualityTimerLoop Timer handler.<br>
 * This part of code decide what is the next quality index to request for a quality upgrade.
 * @method FORGE.VideoHTML5#_upgradeAutoQuality
 * @private
 */
FORGE.VideoHTML5.prototype._upgradeAutoQuality = function()
{
    //If we are not already to the max quality
    if (this._currentIndex !== this._qualities.length - 1)
    {
        var nextIndex = this._currentIndex + 1;

        if (this._videos[nextIndex].abortCount === 0 && this._videos[nextIndex].leaveCount <= 1)
        {
            this.log("AutoQuality upgrade quality");
            this._setRequestIndex(nextIndex);
        }
        else
        {
            this.log("AutoQuality do not attempt to load an already aborted video");
        }
    }
};

/**
 * Downgrade the video quality, triggered by the _autoQualityTimerLoop Timer handler.<br>
 * This part of code decide what is the next quality index to request for a quality downgrade.
 * @method FORGE.VideoHTML5#_downgradeAutoQuality
 * @private
 */
FORGE.VideoHTML5.prototype._downgradeAutoQuality = function()
{
    var currentVideo = this._getCurrentVideo();
    currentVideo.leaveCount++;

    if (this._currentIndex - 1 >= 0)
    {
        this.log("AutoQuality downgrade quality");
        this._setRequestIndex(this._currentIndex - 1, true);
    }
    else
    {
        this.log("Can't downgrade video quality anymore!");
    }

};

/**
 * Sets the quality mode.
 * @method  FORGE.VideoHTML5#_setQualityMode
 * @private
 * @param {string} mode - Quality mode to be set.
 */
FORGE.VideoHTML5.prototype._setQualityMode = function(mode)
{
    if (FORGE.Device.desktop === false)
    {
        mode = FORGE.VideoQualityMode.MANUAL;
        this.warn("Quality mode force to manual, you are not on desktop");
    }

    if (this._qualityMode === mode)
    {
        return;
    }

    if (mode === FORGE.VideoQualityMode.AUTO || mode === FORGE.VideoQualityMode.MANUAL)
    {
        this._qualityMode = mode;

        //Stop quality related timer anyway
        this._autoQualityTimer.stop(false);

        //If mode auto add and start a fresh timer
        if (this._qualityMode === FORGE.VideoQualityMode.AUTO)
        {
            this._autoQualityTimer.start();
        }

        if (this._onQualityModeChange !== null)
        {
            this._onQualityModeChange.dispatch(this._qualityMode);
        }
    }
};

/**
 * Abort a requested video for any reason.
 * @method  FORGE.VideoHTML5#_abortRequest
 * @private
 * @param  {boolean} count - Does the aborted property of the video object have to be increased?
 */
FORGE.VideoHTML5.prototype._abortRequest = function(count)
{
    var requestedVideo = this._getRequestedVideo();

    if (requestedVideo === null)
    {
        return;
    }

    //Increase the aborted count for this video
    if (count === true)
    {
        requestedVideo.abortCount++;
    }

    //Clear the requested video
    this._clearRequestedVideo();

    //Stop the timer, clear all its events
    this._requestTimer.stop(true);

    if (this._onQualityAbort !== null)
    {
        this._onQualityAbort.dispatch();
    }
};

/**
 * Clear the virequested video from its event, detroy the video element etc ...
 * @method FORGE.VideoHTML5#_clearRequestedVideo
 * @private
 */
FORGE.VideoHTML5.prototype._clearRequestedVideo = function()
{
    var video = this._getRequestedVideo();

    if (video !== null)
    {
        //Remove all listeners used for the requested video
        var element = video.element;
        element.removeEventListener("loadstart", this._onRequestLoadStartBind, false);
        element.removeEventListener("loadedmetadata", this._onRequestLoadedMetaDataBind, false);
        element.removeEventListener("loadeddata", this._onRequestLoadedDataBind, false);
        element.removeEventListener("play", this._onRequestCanPlayBeforeSeekBind, false);
        element.removeEventListener("seeked", this._onRequestSeekedBind, false);
        if (FORGE.Device.edge === true || FORGE.Device.ie === true)
        {
            element.removeEventListener("canplaythrough", this._onRequestCanPlayAfterSeekBind, false);
        }
        else
        {
            element.removeEventListener("canplay", this._onRequestCanPlayAfterSeekBind, false);
        }
        element.removeEventListener("error", this._onRequestErrorBind, false);

        //Destroy the requested video
        this._destroyVideo(video);

        //Set the request index to -1, so no video is considered as requested
        this._requestIndex = -1;
    }
};

/**
 * Handles the main volume change, update the volume factor to the video volume.
 * @method FORGE.VideoHTML5#_mainVolumeChangeHandler
 * @private
 */
FORGE.VideoHTML5.prototype._mainVolumeChangeHandler = function()
{
    this._updateVolume();
};

/**
 * Apply the main volume factor to the video volume.
 * @method FORGE.VideoHTML5#_updateVolume
 * @param {Object=} video - The video you want to update the volume, if undefined it will update the currentVideo
 * @private
 */
FORGE.VideoHTML5.prototype._updateVolume = function(video)
{
    var v = video || this._getCurrentVideo();

    if (v !== null && v.element !== null && this._viewer.audio.enabled === true)
    {
        v.element.volume = this._volume * this._viewer.audio.volume;
    }
};

/**
 * Handles the disable status of the sound manager.
 * @method FORGE.VideoHTML5#_disableSoundHandler
 * @private
 */
FORGE.VideoHTML5.prototype._disableSoundHandler = function()
{
    var v = this._getCurrentVideo();

    if (v !== null && v.element !== null && this._viewer.audio.enabled === false)
    {
        v.element.volume = 0;
    }
};

/**
 * Bind native events handler for the current video.
 * @method FORGE.VideoHTML5#_installEvents
 * @private
 * @param {HTMLVideoElement} element - The video element to bind events on.
 */
FORGE.VideoHTML5.prototype._installEvents = function(element)
{
    element.addEventListener("loadstart", this._onEventBind, false);
    element.addEventListener("durationchange", this._onEventBind, false);
    element.addEventListener("loadedmetadata", this._onEventBind, false);
    element.addEventListener("loadeddata", this._onEventBind, false);
    element.addEventListener("progress", this._onEventBind, false);
    element.addEventListener("canplay", this._onEventBind, false);
    element.addEventListener("canplaythrough", this._onEventBind, false);
    element.addEventListener("play", this._onEventBind, false);
    element.addEventListener("pause", this._onEventBind, false);
    element.addEventListener("timeupdate", this._onEventBind, false);
    element.addEventListener("volumechange", this._onEventBind, false);
    element.addEventListener("seeking", this._onEventBind, false);
    element.addEventListener("seeked", this._onEventBind, false);
    element.addEventListener("ended", this._onEventBind, false);
    element.addEventListener("error", this._onEventBind, false);
    element.addEventListener("waiting", this._onEventBind, false);
    element.addEventListener("stalled", this._onEventBind, false);
    element.addEventListener("playing", this._onEventBind, false);
    element.addEventListener("ratechange", this._onEventBind, false);
};

/**
 * Unbind events handler for video.
 * @method FORGE.VideoHTML5#_uninstallEvents
 * @private
 * @param {HTMLVideoElement} element - The video element to unbind events on.
 */
FORGE.VideoHTML5.prototype._uninstallEvents = function(element)
{
    element.removeEventListener("loadstart", this._onEventBind, false);
    element.removeEventListener("durationchange", this._onEventBind, false);
    element.removeEventListener("loadedmetadata", this._onEventBind, false);
    element.removeEventListener("loadeddata", this._onEventBind, false);
    element.removeEventListener("progress", this._onEventBind, false);
    element.removeEventListener("canplay", this._onEventBind, false);
    element.removeEventListener("canplaythrough", this._onEventBind, false);
    element.removeEventListener("play", this._onEventBind, false);
    element.removeEventListener("pause", this._onEventBind, false);
    element.removeEventListener("timeupdate", this._onEventBind, false);
    element.removeEventListener("volumechange", this._onEventBind, false);
    element.removeEventListener("seeking", this._onEventBind, false);
    element.removeEventListener("seeked", this._onEventBind, false);
    element.removeEventListener("ended", this._onEventBind, false);
    element.removeEventListener("error", this._onEventBind, false);
    element.removeEventListener("waiting", this._onEventBind, false);
    element.removeEventListener("stalled", this._onEventBind, false);
    element.removeEventListener("playing", this._onEventBind, false);
    element.removeEventListener("ratechange", this._onEventBind, false);

    //Request specific
    element.removeEventListener("error", this._onRequestErrorBind, false);
};

/**
 * Global handler for all events fired by an HTMLVideoElement.
 * @method FORGE.VideoHTML5#_onEventHandler
 * @param  {Event} event - the fired event
 * @private
 */
FORGE.VideoHTML5.prototype._onEventHandler = function(event)
{
    var element = this._getCurrentVideo().element;
    this.log(event.type + " [readyState: " + element.readyState + "]");

    switch (event.type)
    {
        case "loadstart":
            if (this._onLoadStart !== null)
            {
                this._onLoadStart.dispatch(event);
            }

            break;

        case "durationchange":
            //@firefox - FF dispatch durationchange twice on readystate HAVE_METADATA (1) & HAVE_ENOUGH_DATA (4)
            //I will not dispatch this event if readystate is 4 !
            if (this._onDurationChange !== null && element.readyState === HTMLMediaElement.HAVE_METADATA)
            {
                this._onDurationChange.dispatch(event);
            }

            break;

        case "loadedmetadata":
            this._metaDataLoaded = true;

            if (this._onLoadedMetaData !== null)
            {
                this._onLoadedMetaData.dispatch(event);
            }

            break;

        case "loadeddata":
            if (this._onLoadedData !== null)
            {
                this._onLoadedData.dispatch(event);
            }

            break;

        case "progress":
            if (this._onProgress !== null)
            {
                this._onProgress.dispatch(event);
            }

            break;

        case "canplay":
            this._canPlay = true;

            if (this._onCanPlay !== null)
            {
                this._onCanPlay.dispatch(event);
            }

            break;

        case "canplaythrough":
            this._canPlay = true;

            if (this._onCanPlayThrough !== null)
            {
                this._onCanPlayThrough.dispatch(event);
            }

            break;

        case "play":
            if (this._onPlay !== null)
            {
                this._onPlay.dispatch(event);
            }

            break;

        case "pause":
            this._playing = false;

            if (this._onPause !== null)
            {
                this._onPause.dispatch(event);
            }

            break;

        case "timeupdate":
            if (this._onTimeUpdate !== null)
            {
                this._onTimeUpdate.dispatch(event);
            }

            break;

        case "volumechange":
            //I do not dispatch the volume change if readyState is HAVE_NOTHING (0). Because
            //I set the volume at 0 when I create the video element, it is
            //not usefull to dispatch this internal volume change ?
            if (this._onVolumeChange !== null && element.readyState !== HTMLMediaElement.HAVE_NOTHING)
            {
                this._onVolumeChange.dispatch(event);
            }

            break;

        case "seeking":
            this._canPlay = false;

            if (this._onSeeking !== null)
            {
                this._onSeeking.dispatch(event);
            }

            break;

        case "seeked":
            this._canPlay = false;

            if (this._onSeeked !== null)
            {
                this._onSeeked.dispatch(event);
            }

            break;

        case "ended":
            this._playing = false;
            this.currentTime = 0;
            this._endCount++;

            if (this._loop === true)
            {
                this.play(0);
            }

            if (this._onEnded !== null)
            {
                this._onEnded.dispatch(event);
            }

            break;

        case "error":
            if (this._onError !== null)
            {
                this._onError.dispatch(event);
            }

            break;

        case "waiting":
            if (this._onWaiting !== null)
            {
                this._onWaiting.dispatch(event);
            }

            break;

        case "stalled":
            if (this._onStalled !== null)
            {
                this._onStalled.dispatch(event);
            }

            break;

        case "playing":
            if (this._onPlaying !== null)
            {
                this._onPlaying.dispatch(event);
            }

            break;

        case "ratechange":
            if (this._onRateChange !== null)
            {
                this._onRateChange.dispatch(event);
            }

            break;

        default:
            this.warn("The event \"" + event.type + "\" is not handled.");

            break;
    }
};

/**
 * Does the video sound must be considered as ambisonic?
 * @method FORGE.VideoHTML5#_isAmbisonic
 * @return {boolean} Is ambisonic?
 * @private
 */
FORGE.VideoHTML5.prototype._isAmbisonic = function()
{
    return (this._ambisonic === true && this._viewer.audio.useWebAudio === true && typeof Omnitone !== "undefined");
};

/**
 * Update method called by the viewer main loop.
 * @method FORGE.VideoHTML5#update
 */
FORGE.VideoHTML5.prototype.update = function()
{
    if(this._decoder !== null && this._playing === true)
    {
        //Rotate the binaural renderer based on a Three.js camera object.
        var m4 = this._viewer.renderer.camera.modelViewInverse;
        this._decoder.setRotationMatrixFromCamera(m4);
    }
};

/**
 * Load a config or a video url to the source.
 * @method FORGE.VideoHTML5#load
 * @param {?(string|FORGE.VideoQuality|Array<(string|FORGE.VideoQuality)>)} config - An url to load, or an array of urls or an array ok {@link FORGE.VideoQuality}.
 */
FORGE.VideoHTML5.prototype.load = function(config)
{
    //parse the config in parameters
    this._parseConfig(config);

    if (this._qualities === null || this._qualities.length === 0)
    {
        throw "FORGE.VideoHTML5.load: Can't create video with no qualities set!";
    }

    //Create place holders for videos
    this._createVideoObjects(this._qualities.length);

    //Request the first quality of the quality array
    this._setRequestIndex(0);
};

/**
 * Plays the video.
 * @method  FORGE.VideoHTML5#play
 * @param {number=} time - Time you want to start the playback.
 * @param {boolean=} loop - Does the video have to loop at the end of the duration?
 */
FORGE.VideoHTML5.prototype.play = function(time, loop)
{
    FORGE.VideoBase.prototype.play.call(this, time, loop);

    var currentVideo = this._getCurrentVideo();

    if (currentVideo !== null && currentVideo.element !== null)
    {
        var p = currentVideo.element.play();
        if (typeof p !== "undefined" && typeof Promise !== "undefined" && p instanceof Promise)
        {
            p.then(function()
            {
                this._playing = true;
                this._paused = false;
                this._playCount++;
            }.bind(this))
            .catch(function(error)
            {
                this.log("error while playing the video : " + error);
            }.bind(this));
        }
        else
        {
            this._playing = true;
            this._paused = true;
            this._playCount++;
        }
    }
};

/**
 * Pauses the video.
 * @method  FORGE.VideoHTML5#pause
 */
FORGE.VideoHTML5.prototype.pause = function()
{
    var currentVideo = this._getCurrentVideo();

    if (currentVideo !== null && currentVideo.element !== null)
    {
        currentVideo.element.pause();
        this._playing = false;
        this._paused = true;
    }
};

/**
 * Stop the video the video (pause it and set time to 0).
 * @method  FORGE.VideoHTML5#stop
 */
FORGE.VideoHTML5.prototype.stop = function()
{
    var currentVideo = this._getCurrentVideo();

    if (currentVideo !== null && currentVideo.element !== null)
    {
        currentVideo.element.pause();
        currentVideo.element.currentTime = 0;
        this._playing = false;
        this._paused = true;
    }
};

/**
 * Toggles the playback status, if play toggle to pause and vice versa.
 * @method  FORGE.VideoHTML5#togglePlayback
 */
FORGE.VideoHTML5.prototype.togglePlayback = function()
{
    if (this._playing === true || this._viewer.audio.enabled === false)
    {
        this.pause();
    }
    else
    {
        this.play();
    }
};

/**
 * Mute the video sound.
 * @method  FORGE.VideoHTML5#mute
 */
FORGE.VideoHTML5.prototype.mute = function()
{
    if (this._muted === true || this._viewer.audio.enabled === false)
    {
        return;
    }

    this._muted = true;
    this._mutedVolume = this._volume;

    this._volume = 0;
    this._updateVolume();

    if (this._onMute !== null)
    {
        this._onMute.dispatch();
    }
};

/**
 * Unute the video sound.
 * @method  FORGE.VideoHTML5#unmute
 * @param {number=} volume - The volume to be restored on unmute.
 */
FORGE.VideoHTML5.prototype.unmute = function(volume)
{
    if (this._muted === false)
    {
        return;
    }

    var v = (typeof volume === "number") ? volume : this._mutedVolume;

    this._muted = false;
    this._volume = FORGE.Math.clamp(v, 0, 1);
    this._updateVolume();

    if (this._onUnmute !== null)
    {
        this._onUnmute.dispatch();
    }
};


/**
 * Destroy method.
 * @method FORGE.VideoHTML5#destroy
 */
FORGE.VideoHTML5.prototype.destroy = function()
{
    this._clearRequestedVideo();

    this._requestTimer.destroy();
    this._requestTimer = null;

    this._autoQualityTimer.destroy();
    this._autoQualityTimer = null;

    if (this._onLoadStart !== null)
    {
        this._onLoadStart.destroy();
        this._onLoadStart = null;
    }

    if (this._onLoadedMetaData !== null)
    {
        this._onLoadedMetaData.destroy();
        this._onLoadedMetaData = null;
    }

    if (this._onLoadedData !== null)
    {
        this._onLoadedData.destroy();
        this._onLoadedData = null;
    }

    if (this._onProgress !== null)
    {
        this._onProgress.destroy();
        this._onProgress = null;
    }

    if (this._onDurationChange !== null)
    {
        this._onDurationChange.destroy();
        this._onDurationChange = null;
    }

    if (this._onCanPlay !== null)
    {
        this._onCanPlay.destroy();
        this._onCanPlay = null;
    }

    if (this._onCanPlayThrough !== null)
    {
        this._onCanPlayThrough.destroy();
        this._onCanPlayThrough = null;
    }

    if (this._onPlay !== null)
    {
        this._onPlay.destroy();
        this._onPlay = null;
    }

    if (this._onPause !== null)
    {
        this._onPause.destroy();
        this._onPause = null;
    }

    if (this._onTimeUpdate !== null)
    {
        this._onTimeUpdate.destroy();
        this._onTimeUpdate = null;
    }

    if (this._onCurrentTimeChange !== null)
    {
        this._onCurrentTimeChange.destroy();
        this._onCurrentTimeChange = null;
    }

    if (this._onVolumeChange !== null)
    {
        this._onVolumeChange.destroy();
        this._onVolumeChange = null;
    }

    if (this._onSeeking !== null)
    {
        this._onSeeking.destroy();
        this._onSeeking = null;
    }

    if (this._onSeeked !== null)
    {
        this._onSeeked.destroy();
        this._onSeeked = null;
    }

    if (this._onEnded !== null)
    {
        this._onEnded.destroy();
        this._onEnded = null;
    }

    if (this._onError !== null)
    {
        this._onError.destroy();
        this._onError = null;
    }

    if (this._onWaiting !== null)
    {
        this._onWaiting.destroy();
        this._onWaiting = null;
    }

    if (this._onStalled !== null)
    {
        this._onStalled.destroy();
        this._onStalled = null;
    }

    if (this._onPlaying !== null)
    {
        this._onPlaying.destroy();
        this._onPlaying = null;
    }

    if (this._onRateChange !== null)
    {
        this._onRateChange.destroy();
        this._onRateChange = null;
    }

    if (this._onMute !== null)
    {
        this._onMute.destroy();
        this._onMute = null;
    }

    if (this._onUnmute !== null)
    {
        this._onUnmute.destroy();
        this._onUnmute = null;
    }

    if (this._onQualityRequest !== null)
    {
        this._onQualityRequest.destroy();
        this._onQualityRequest = null;
    }

    if (this._onQualityChange !== null)
    {
        this._onQualityChange.destroy();
        this._onQualityChange = null;
    }

    if (this._onQualityAbort !== null)
    {
        this._onQualityAbort.destroy();
        this._onQualityAbort = null;
    }

    if (this._onQualityModeChange !== null)
    {
        this._onQualityModeChange.destroy();
        this._onQualityModeChange = null;
    }

    if (this._onQualitiesLoaded !== null)
    {
        this._onQualitiesLoaded.destroy();
        this._onQualitiesLoaded = null;
    }

    //destroy all videos
    for (var i = 0, ii = this._videos.length; i < ii; i++)
    {
        this._destroyVideoAt(i);
    }

    //Nullify event listeners binded to this!
    this._decoderInitializedSuccessBind = null;
    this._decoderInitializedErrorBind = null;

    this._onRequestErrorBind = null;
    this._onRequestLoadStartBind = null;
    this._onRequestLoadedMetaDataBind = null;
    this._onRequestLoadedDataBind = null;
    this._onRequestCanPlayBeforeSeekBind = null;
    this._onRequestSeekedBind = null;
    this._onRequestCanPlayAfterSeekBind = null;
    this._onRequestSeekedWhileSyncBind = null;

    this._onEventBind = null;

    //Unbind main volume event
    this._viewer.audio.onVolumeChange.remove(this._mainVolumeChangeHandler, this);

    this._viewer.audio.onDisable.remove(this._disableSoundHandler, this);

    this._config = null;

    this._qualities = null;

    this._videos = null;

    FORGE.VideoBase.prototype.destroy.call(this);
};


/**
 * Get and set the quality index of the video.
 * @name FORGE.VideoHTML5#quality
 * @type {(number|FORGE.VideoQuality)}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "quality",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._qualities[this._currentIndex];
    },

    /** @this {FORGE.VideoHTML5} */
    set: function(value)
    {
        if (typeof value === "number" && value >= 0 && value < this._qualities.length)
        {
            this._setQualityMode(FORGE.VideoQualityMode.MANUAL);
            this._setRequestIndex(value);
        }
        else if (FORGE.Utils.isTypeOf(value, "VideoQuality") === true)
        {
            var i = this._indexOfQuality(value);

            if (i !== -1)
            {
                this._setQualityMode(FORGE.VideoQualityMode.MANUAL);
                this._setRequestIndex(i);
            }
            else
            {
                throw "Unknown quality";
            }
        }
        else
        {
            throw "Video quality " + value + " out of bounds";
        }
    }
});

/**
 * Get and set the quality mode.<br>
 * Available quality mode are listed in FORGE.VideoQualityMode const.
 * @name  FORGE.VideoHTML5#qualityMode
 * @type {string}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "qualityMode",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._qualityMode;
    },

    /** @this {FORGE.VideoHTML5} */
    set: function(value)
    {
        if (value === FORGE.VideoQualityMode.AUTO || value === FORGE.VideoQualityMode.MANUAL)
        {
            this._setQualityMode(value);
        }
    }
});

/**
 * Get the quality array.
 * @name  FORGE.VideoHTML5#qualities
 * @readonly
 * @type {Array<FORGE.VideoQuality>}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "qualities",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._qualities;
    }
});

/**
 * Get the requested quality index, returns -1 if no request is being processed.
 * @name  FORGE.VideoHTML5#requestIndex
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "requestIndex",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._requestIndex;
    }
});

/**
 * Get the current quality index, returns -1 if no current is playing.
 * @name  FORGE.VideoHTML5#currentIndex
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "currentIndex",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._currentIndex;
    }
});

/**
 * Get the video object array.
 * @name  FORGE.VideoHTML5#videos
 * @readonly
 * @type {Array<Object>}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "videos",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._videos;
    }
});

/**
 * Get the html element of the current video.
 * @name FORGE.VideoHTML5#element
 * @readonly
 * @type {?HTMLVideoElement}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "element",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        var currentVideo = this._getCurrentVideo();

        if (currentVideo !== null && currentVideo.element !== null)
        {
            return currentVideo.element;
        }

        return null;
    }
});

/**
 * Get the {@link FORGE.VideoTimeRanges} of the video for buffered ranges.
 * @name FORGE.VideoHTML5#buffer
 * @readonly
 * @type {?FORGE.VideoTimeRanges}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "buffer",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        var currentVideo = this._getCurrentVideo();

        if (currentVideo !== null && currentVideo.buffer !== null)
        {
            return currentVideo.buffer;
        }

        return null;
    }
});

/**
 * Get the {@link FORGE.VideoTimeRanges} of the video for played ranges.
 * @name FORGE.VideoHTML5#played
 * @readonly
 * @type {?FORGE.VideoTimeRanges}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "played",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        var currentVideo = this._getCurrentVideo();

        if (currentVideo !== null && currentVideo.played !== null)
        {
            return currentVideo.played;
        }

        return null;
    }
});

/**
 * Get the original width of the video source.
 * @name FORGE.VideoHTML5#originalWidth
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "originalWidth",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._getCurrentVideoElementProperty("videoWidth", 0);
    }
});

/**
 * Get the original height of the video source.
 * @name FORGE.VideoHTML5#originalHeight
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "originalHeight",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._getCurrentVideoElementProperty("videoHeight", 0);
    }
});

/**
 * Get and set the currentTime  of the video.
 * @name FORGE.VideoHTML5#currentTime
 * @type {number}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "currentTime",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._getCurrentVideoElementProperty("currentTime", 0);
    },

    /** @this {FORGE.VideoHTML5} */
    set: function(value)
    {
        if (typeof value === "number") //@todo see if we can put video currentTime in pending if no metadata received ? (typeof value === "number" && value < this.duration)
        {
            var currentVideo = this._getCurrentVideo();

            if (currentVideo !== null && currentVideo.element !== null)
            {
                currentVideo.element.currentTime = value;

                if (this._onCurrentTimeChange !== null)
                {
                    this._onCurrentTimeChange.dispatch(value);
                }
            }
        }
    }
});

/**
 * Get and set the currentTime  of the video in milliseconds.
 * @name FORGE.VideoHTML5#currentTimeMS
 * @type {number}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "currentTimeMS",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this.currentTime * 1000;
    },

    /** @this {FORGE.VideoHTML5} */
    set: function(value)
    {
        this.currentTime = value / 1000;
    }
});

/**
 * Get the remainingTime of the video.
 * @name FORGE.VideoHTML5#remainingTime
 * @type {number}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "remainingTime",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this.duration - this.currentTime;
    }
});

/**
 * Get the duration of the video in seconds.
 * @name FORGE.VideoHTML5#duration
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "duration",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._getCurrentVideoElementProperty("duration", 0);
    }
});

/**
 * Get the duration of the video in milli seconds.
 * @name FORGE.VideoHTML5#durationMS
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "durationMS",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return Math.round(this.duration * 1000);
    }
});

/**
 * Get the metaDataLoaded status of the video.
 * @name FORGE.VideoHTML5#metaDataLoaded
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "metaDataLoaded",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._metaDataLoaded;
    }
});

/**
 * Get and set the loop status of the video.
 * @name FORGE.VideoHTML5#loop
 * @type {boolean}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "loop",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._loop;
    },

    /** @this {FORGE.VideoHTML5} */
    set: function(value)
    {
        if (typeof value === "boolean")
        {
            this._loop = value;
        }
    }
});

/**
 * Get and set the volume of the video.
 * Set a volume unmute the video
 * @name FORGE.VideoHTML5#volume
 * @type {number}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "volume",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._volume;
    },

    /** @this {FORGE.VideoHTML5} */
    set: function(value)
    {
        if (typeof value === "number")
        {
            this._volume = FORGE.Math.clamp(value, 0, 1);
            this._muted = false;
            this._updateVolume();
        }
    }
});

/**
 * Get and set the mute status of the video.
 * @name FORGE.VideoHTML5#muted
 * @type {boolean}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "muted",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._muted;
    },

    /** @this {FORGE.VideoHTML5} */
    set: function(value)
    {
        if (Boolean(value) === true)
        {
            this.mute();
        }
        else
        {
            this.unmute();
        }
    }
});

/**
 * Get and set the playback rate of the video.
 * @name FORGE.VideoHTML5#playbackRate
 * @type {number}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "playbackRate",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        return this._playbackRate;
    },

    /** @this {FORGE.VideoHTML5} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._playbackRate = Math.abs(value);

            var video = this._getCurrentVideo();

            if (video !== null && video.element !== null)
            {
                video.element.playbackRate = this._playbackRate;
            }
        }
    }
});

/**
 * Get the ambisonic state of the video sound.
 * @name FORGE.VideoHTML5#ambisonic
 * @type {boolean}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "ambisonic",
{
    /** @this {FORGE.VideoHTML5} */
    get: function ()
    {
        return this._ambisonic;
    }
});

/**
 * Get the "onLoadStart" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onLoadStart
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onLoadStart",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onLoadStart === null)
        {
            this._onLoadStart = new FORGE.EventDispatcher(this);
        }

        return this._onLoadStart;
    }
});

/**
 * Get the "onLoadedMetaData" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onLoadedMetaData
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onLoadedMetaData",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onLoadedMetaData === null)
        {
            this._onLoadedMetaData = new FORGE.EventDispatcher(this);
        }

        return this._onLoadedMetaData;
    }
});

/**
 * Get the "onLoadedData" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onLoadedData
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onLoadedData",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onLoadedData === null)
        {
            this._onLoadedData = new FORGE.EventDispatcher(this);
        }

        return this._onLoadedData;
    }
});

/**
 * Get the "onProgress" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onProgress
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onProgress",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onProgress === null)
        {
            this._onProgress = new FORGE.EventDispatcher(this);
        }

        return this._onProgress;
    }
});

/**
 * Get the "onDurationChange" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onDurationChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onDurationChange",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onDurationChange === null)
        {
            this._onDurationChange = new FORGE.EventDispatcher(this);
        }

        return this._onDurationChange;
    }
});

/**
 * Get the "onCanPlay" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onCanPlay
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onCanPlay",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onCanPlay === null)
        {
            this._onCanPlay = new FORGE.EventDispatcher(this);
        }

        return this._onCanPlay;
    }
});

/**
 * Get the "onCanPlayThrough" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onCanPlayThrough
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onCanPlayThrough",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onCanPlayThrough === null)
        {
            this._onCanPlayThrough = new FORGE.EventDispatcher(this);
        }

        return this._onCanPlayThrough;
    }
});

/**
 * Get the "onPlay" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onPlay
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onPlay",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onPlay === null)
        {
            this._onPlay = new FORGE.EventDispatcher(this);
        }

        return this._onPlay;
    }
});

/**
 * Get the "onPause" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onPause
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onPause",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onPause === null)
        {
            this._onPause = new FORGE.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
 * Get the "onTimeUpdate" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onTimeUpdate
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onTimeUpdate",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onTimeUpdate === null)
        {
            this._onTimeUpdate = new FORGE.EventDispatcher(this);
        }

        return this._onTimeUpdate;
    }
});

/**
 * Get the "onCurrentTimeChange" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onCurrentTimeChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onCurrentTimeChange",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onCurrentTimeChange === null)
        {
            this._onCurrentTimeChange = new FORGE.EventDispatcher(this);
        }

        return this._onCurrentTimeChange;
    }
});

/**
 * Get the "onVolumeChange" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onVolumeChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onVolumeChange",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onVolumeChange === null)
        {
            this._onVolumeChange = new FORGE.EventDispatcher(this);
        }

        return this._onVolumeChange;
    }
});

/**
 * Get the "onSeeking" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onSeeking
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onSeeking",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onSeeking === null)
        {
            this._onSeeking = new FORGE.EventDispatcher(this);
        }

        return this._onSeeking;
    }
});

/**
 * Get the "onSeeked" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onSeeked
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onSeeked",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onSeeked === null)
        {
            this._onSeeked = new FORGE.EventDispatcher(this);
        }

        return this._onSeeked;
    }
});

/**
 * Get the "onEnded" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onEnded
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onEnded",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onEnded === null)
        {
            this._onEnded = new FORGE.EventDispatcher(this);
        }

        return this._onEnded;
    }
});

/**
 * Get the "onError" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onError
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onError",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onError === null)
        {
            this._onError = new FORGE.EventDispatcher(this);
        }

        return this._onError;
    }
});

/**
 * Get the "onWaiting" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onWaiting
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onWaiting",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onWaiting === null)
        {
            this._onWaiting = new FORGE.EventDispatcher(this);
        }

        return this._onWaiting;
    }
});

/**
 * Get the "onStalled" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onStalled
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onStalled",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onStalled === null)
        {
            this._onStalled = new FORGE.EventDispatcher(this);
        }

        return this._onStalled;
    }
});

/**
 * Get the "onPlaying" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onPlaying
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onPlaying",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onPlaying === null)
        {
            this._onPlaying = new FORGE.EventDispatcher(this);
        }

        return this._onPlaying;
    }
});

/**
 * Get the "onRateChange" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onRateChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onRateChange",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onRateChange === null)
        {
            this._onRateChange = new FORGE.EventDispatcher(this);
        }

        return this._onRateChange;
    }
});

/**
 * Get the "onMute" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onMute
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onMute",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onMute === null)
        {
            this._onMute = new FORGE.EventDispatcher(this);
        }

        return this._onMute;
    }
});

/**
 * Get the "onUnmute" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onUnmute
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onUnmute",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onUnmute === null)
        {
            this._onUnmute = new FORGE.EventDispatcher(this);
        }

        return this._onUnmute;
    }
});

/**
 * Get the "onQualityRequest" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onQualityRequest
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onQualityRequest",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onQualityRequest === null)
        {
            this._onQualityRequest = new FORGE.EventDispatcher(this);
        }

        return this._onQualityRequest;
    }
});

/**
 * Get the "onQualityChange" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onQualityChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onQualityChange",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onQualityChange === null)
        {
            this._onQualityChange = new FORGE.EventDispatcher(this);
        }

        return this._onQualityChange;
    }
});

/**
 * Get the "onQualityAbort" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onQualityAbort
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onQualityAbort",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onQualityAbort === null)
        {
            this._onQualityAbort = new FORGE.EventDispatcher(this);
        }

        return this._onQualityAbort;
    }
});

/**
 * Get the "onQualityModeChange" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onQualityModeChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onQualityModeChange",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onQualityModeChange === null)
        {
            this._onQualityModeChange = new FORGE.EventDispatcher(this);
        }

        return this._onQualityModeChange;
    }
});

/**
 * Get the "onQualitiesLoaded" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoHTML5#onQualitiesLoaded
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoHTML5.prototype, "onQualitiesLoaded",
{
    /** @this {FORGE.VideoHTML5} */
    get: function()
    {
        if (this._onQualitiesLoaded === null)
        {
            this._onQualitiesLoaded = new FORGE.EventDispatcher(this, true);
        }

        return this._onQualitiesLoaded;
    }
});

/**
 * MPEG-DASH video controller.
 *
 * @constructor FORGE.VideoDash
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @param {string} key - The video file id reference.
 * @param {?(string|FORGE.VideoQuality|Array<(string|FORGE.VideoQuality)>)=} config - Either a {@link FORGE.VideoQuality} or a string URL.
 * @param {string=} qualityMode - The default quality mode.
 * @extends {FORGE.VideoBase}
 *
 * @todo  ability to call the QualityAbort event.
 * @todo  add protection controller and protection key controller to be able to manage external secured streams (DRM)
 * @todo  Deal with playback speeds.
 * @todo  Add subtitles management with <track> and VTT/TTML(EBU-TT-D) files
 */
FORGE.VideoDash = function(viewer, key, config, qualityMode)
{
    /**
     * The video identifier.
     * @name FORGE.VideoDash#_key
     * @type {string}
     * @private
     */
    this._key = key;

    /**
     * {@link FORGE.VideoQuality} for this video, it can be temporarily a string into the constructor.
     * @name FORGE.VideoDash#_config
     * @type {?(string|FORGE.VideoQuality|Array<(string|FORGE.VideoQuality)>)}
     * @private
     */
    this._config = config || null;

    /**
     * The manifest URL.
     * @name FORGE.VideoDash#_manifestUrl
     * @type {string}
     * @private
     */
    this._manifestUrl = "";

    /**
     * Array of {@link FORGE.VideoQuality}.
     * @name  FORGE.VideoDash#_qualities
     * @type {Array<FORGE.VideoQuality>}
     * @private
     */
    this._qualities = null;

    /**
     * The index of the current quality (if -1 no video is selected as the current one).
     * @name  FORGE.Video#_currentQuality
     * @type {number}
     * @private
     */
    // this._currentQuality = -1;

    /**
     * First quality is initialized?
     * @name  FORGE.VideoDash#_qualityInitialized
     * @type {boolean}
     * @private
     */
    // this._qualityInitialized = false;

    /**
     * Default quality mode, it can be either "auto" or "manual", modes are listed by FORGE.VideoQualityMode constants.
     * @name FORGE.VideoDash#_defaultQualityMode
     * @type {string}
     * @private
     */
    this._defaultQualityMode = qualityMode || FORGE.VideoQualityMode.AUTO;

    /**
     * Current Quality mode.
     * @name  FORGE.VideoDash#_qualityMode
     * @type {string}
     * @private
     */
    this._qualityMode = "";

    /**
     * Video object that handle the dom and some stats about the video.
     * @name FORGE.VideoDash#_video
     * @type {Object}
     * @private
     */
    this._video = null;

    /**
     * Does the video loop?
     * @name  FORGE.VideoDash#_loop
     * @type {boolean}
     * @private
     */
    this._loop = false;

    /**
     * The volume of the video.
     * @name  FORGE.VideoDash#_volume
     * @type {number}
     * @private
     */
    this._volume = 1;

    /**
     * Is the video volume is muted?
     * @name  FORGE.VideoDash#_muted
     * @type {boolean}
     * @private
     */
    this._muted = false;

    /**
     * Private reference to the previous volume before mute.
     * @name  FORGE.VideoDash#_mutedVolume
     * @type {number}
     * @private
     */
    this._mutedVolume = 0;

    /**
     * Playback rate of the video
     * @name FORGE.VideoDash#_playbackRate
     * @type {number}
     * @private
     */
    this._playbackRate = 1;

    /**
     * Does the video have received its metaData?
     * @name  FORGE.VideoDash#_metaDataLoaded
     * @type {boolean}
     * @private
     */
    this._metaDataLoaded = false;

    /**
     * The dash.js Media Player library.<br>
     * The dash.js library must be loaded prior to the video instanciation!
     * @name  FORGE.VideoDash#_dashMediaPlayer
     * @type {dashjs.MediaPlayer}
     * @private
     */
    this._dashMediaPlayer = null;

    /**
     * The dash stream info object.
     * @name  FORGE.VideoDash#_streamInfo
     * @type {StreamInfo}
     * @private
     */
    this._streamInfo = null;

    /**
     * The current index for video.
     * @name FORGE.VideoDash#_currentIndex
     * @type {number}
     * @private
     */
    this._currentVideoIndex = 0;

    /**
     * The current pending index for video.
     * @name FORGE.VideoDash#_currentPendingIndex
     * @type {number}
     * @private
     */
    this._currentVideoPendingIndex = 0;

    /**
     * The current index for audio.
     * @name FORGE.VideoDash#_currentIndex
     * @type {number}
     * @private
     */
    this._currentAudioIndex = 0;

    /**
     * The current pending index for audio.
     * @name FORGE.VideoDash#_currentPendingIndex
     * @type {number}
     * @private
     */
    this._currentAudioPendingIndex = 0;

    /**
     * The dash media player video metrics object.
     * @name  FORGE.VideoDash#_playerVideoMetrics
     * @type {Object}
     * @private
     */
    this._playerVideoMetrics = null;

    /**
     * The dash media player audio metrics object.
     * @name  FORGE.VideoDash#_playerAudioMetrics
     * @type {Object}
     * @private
     */
    this._playerAudioMetrics = null;

    /**
     * The dash stream metrics object.
     * @name  FORGE.VideoDash#_dashMetrics
     * @type {DashMetrics}
     * @private
     */
    this._dashMetrics = null;

    /**
     * The monitoring object.
     * @name  FORGE.VideoDash#_monitoring
     * @type {Object}
     * @private
     */
    this._monitoring = null;

    /**
     * On load start event dispatcher.
     * @name  FORGE.VideoDash#_onLoadStart
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onLoadStart = null;

    /**
     * On loaded metadata event dispatcher.
     * @name  FORGE.VideoDash#_onLoadedMetaData
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onLoadedMetaData = null;

    /**
     * On loaded data event dispatcher.
     * @name  FORGE.VideoDash#_onLoadedData
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onLoadedData = null;

    /**
     * On progress event dispatcher.
     * @name  FORGE.VideoDash#_onProgress
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onProgress = null;

    /**
     * On duration change event dispatcher.
     * @name  FORGE.VideoDash#_onDurationChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onDurationChange = null;

    /**
     * On can play event dispatcher.
     * @name  FORGE.VideoDash#_onCanPlay
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onCanPlay = null;

    /**
     * On can play through event dispatcher.
     * @name  FORGE.VideoDash#_onCanPlayThrough
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onCanPlayThrough = null;

    /**
     * On play event dispatcher.
     * @name  FORGE.VideoDash#_onPlay
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPlay = null;

    /**
     * On pause event dispatcher.
     * @name  FORGE.VideoDash#_onPause
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * On time update event dispatcher.
     * @name  FORGE.VideoDash#_onTimeUpdate
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onTimeUpdate = null;

    /**
     * On current time change event dispatcher.
     * @name FORGE.VideoDash#_onCurrentTimeChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onCurrentTimeChange = null;

    /**
     * On volume change event dispatcher.
     * @name  FORGE.VideoDash#_onVolumeChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onVolumeChange = null;

    /**
     * On seeking event dispatcher.
     * @name  FORGE.VideoDash#_onSeeking
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onSeeking = null;

    /**
     * On seeked event dispatcher.
     * @name  FORGE.VideoDash#_onSeeked
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onSeeked = null;

    /**
     * On ended event dispatcher.
     * @name  FORGE.VideoDash#_onEnded
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onEnded = null;

    /**
     * On error event dispatcher.
     * @name  FORGE.VideoDash#_onError
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onError = null;

    /**
     * On stalled event dispatcher.
     * @name  FORGE.VideoDash#_onStalled
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onStalled = null;

    /**
     * On rate change event dispatcher.
     * @name  FORGE.VideoDash#_onRateChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onRateChange = null;

    /**
     * On playing event dispatcher.
     * @name  FORGE.VideoDash#_onPlaying
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPlaying = null;

    /**
     * On mute event dispatcher.
     * @name  FORGE.VideoDash#_onMute
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onMute = null;

    /**
     * On unmute event dispatcher.
     * @name  FORGE.VideoDash#_onUnmute
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onUnmute = null;

    /**
     * On qualityRequest event dispatcher.
     * @name  FORGE.VideoDash#_onQualityRequest
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onQualityRequest = null;

    /**
     * On qualityChange event dispatcher.
     * @name  FORGE.VideoDash#_onQualityChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onQualityChange = null;

    /**
     * On qualityAbort event dispatcher.
     * @name  FORGE.VideoDash#_onQualityAbort
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onQualityAbort = null;

    /**
     * On qualties loaded event dispatcher.
     * @name  FORGE.VideoDash#_onQualitiesLoaded
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onQualitiesLoaded = null;

    /**
     * On qualityModeChange event dispatcher.
     * @name  FORGE.VideoDash#_onQualityModeChange
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onQualityModeChange = null;

    /**
     * On metrics changed event dispatcher.
     * @name  FORGE.VideoDash#_onMetricsChanged
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onMetricsChanged = null;

    /**
     * Event handler for current video load start binded to this.
     * @name FORGE.VideoDash#_onLoadStartBind
     * @type {Function}
     * @private
     */
    this._onLoadStartBind = null;

    /**
     * Event handler for current video loaded meta data binded to this.
     * @name FORGE.VideoDash#_onLoadedMetaDataBind
     * @type {Function}
     * @private
     */
    this._onLoadedMetaDataBind = null;

    /**
     * Event handler for current video loaded data binded to this.
     * @name FORGE.VideoDash#_onLoadedDataBind
     * @type {Function}
     * @private
     */
    this._onLoadedDataBind = null;

    /**
     * Event handler for current video progress binded to this.
     * @name FORGE.VideoDash#_onProgressBind
     * @type {Function}
     * @private
     */
    this._onProgressBind = null;

    /**
     * Event handler for current video duration change binded to this.
     * @name FORGE.VideoDash#_onDurationChangeBind
     * @type {Function}
     * @private
     */
    this._onDurationChangeBind = null;

    /**
     * Event handler for current video can play binded to this.
     * @name FORGE.VideoDash#_onCanPlayBind
     * @type {Function}
     * @private
     */
    this._onCanPlayBind = null;

    /**
     * Event handler for current video can play throught binded to this.
     * @name FORGE.VideoDash#_onCanPlayThroughBind
     * @type {Function}
     * @private
     */
    this._onCanPlayThroughBind = null;

    /**
     * Event handler for current video play binded to this.
     * @name FORGE.VideoDash#_onPlayBind
     * @type {Function}
     * @private
     */
    this._onPlayBind = null;

    /**
     * Event handler for current video pause binded to this.
     * @name FORGE.VideoDash#_onPauseBind
     * @type {Function}
     * @private
     */
    this._onPauseBind = null;

    /**
     * Event handler for current video time update binded to this.
     * @name FORGE.VideoDash#_onTimeUpdateBind
     * @type {Function}
     * @private
     */
    this._onTimeUpdateBind = null;

    /**
     * Event handler for current video volume change binded to this.
     * @name FORGE.VideoDash#_onVolumeChangeBind
     * @type {Function}
     * @private
     */
    this._onVolumeChangeBind = null;

    /**
     * Event handler for current video seeking binded to this.
     * @name FORGE.VideoDash#_onSeekingBind
     * @type {Function}
     * @private
     */
    this._onSeekingBind = null;

    /**
     * Event handler for current video seeked binded to this.
     * @name FORGE.VideoDash#_onSeekedBind
     * @type {Function}
     * @private
     */
    this._onSeekedBind = null;

    /**
     * Event handler for current video ended binded to this.
     * @name FORGE.VideoDash#_onEndedBind
     * @type {Function}
     * @private
     */
    this._onEndedBind = null;

    /**
     * Event handler for current video error binded to this.
     * @name FORGE.VideoDash#_onErrorBind
     * @type {Function}
     * @private
     */
    this._onErrorBind = null;

    /**
     * Event handler for current video stalled binded to this.
     * @name FORGE.VideoDash#_onStalledBind
     * @type {Function}
     * @private
     */
    this._onStalledBind = null;

    /**
     * Event handler for current video rate change binded to this.
     * @name FORGE.VideoDash#_onRateChangeBind
     * @type {Function}
     * @private
     */
    this._onRateChangeBind = null;

    /**
     * Event handler for current video playing binded to this.
     * @name FORGE.VideoDash#_onPlayingBind
     * @type {Function}
     * @private
     */
    this._onPlayingBind = null;

    /**
     * Event handler for current video quality request binded to this.
     * @name  FORGE.VideoDash#_onQualityRequestBind
     * @type {Function}
     * @private
     */
    this._onQualityRequestBind = null;

    /**
     * Event handler for current video quality change binded to this.
     * @name  FORGE.VideoDash#_onQualityChangeBind
     * @type {Function}
     * @private
     */
    this._onQualityChangeBind = null;

    /**
     * Event handler for current video quality change aborted binded to this.
     * @name  FORGE.VideoDash#_onQualityAbortBind
     * @type {Function}
     * @private
     */
    //this._onQualityAbortBind = null;

    /**
     * Event handler for stream switch completed.
     * @name  FORGE.VideoDash#_onSwitchCompletedBind
     * @type {Function}
     * @private
     */
    this._onSwitchCompletedBind = null;

    /**
     * Event handler for metrics changed.
     * @name  FORGE.VideoDash#_onMetricsChangedBind
     * @type {Function}
     * @private
     */
    this._onMetricsChangedBind = null;

    FORGE.VideoBase.call(this, viewer, "VideoDash");
};

FORGE.VideoDash.prototype = Object.create(FORGE.VideoBase.prototype);
FORGE.VideoDash.prototype.constructor = FORGE.VideoDash;

/**
 * Media types list.
 * @name FORGE.VideoDash.mediaType
 * @type {Object}
 * @const
 */
FORGE.VideoDash.mediaType = {};

/**
 * @name FORGE.VideoDash.mediaType.VIDEO
 * @type {string}
 * @const
 */
FORGE.VideoDash.mediaType.VIDEO = "video";

/**
 * @name FORGE.VideoDash.mediaType.AUDIO
 * @type {string}
 * @const
 */
FORGE.VideoDash.mediaType.AUDIO = "audio";

/**
 * Boot sequence.
 * @method FORGE.VideoDash#_boot
 * @private
 */
FORGE.VideoDash.prototype._boot = function()
{
    FORGE.VideoBase.prototype._boot.call(this);

    if (typeof dashjs === "undefined")
    {
        throw "FORGE.VideoDash._boot: Can't create MPEG-DASH video stream without dash.js Media Player.";
    }

    //register the uid
    this._uid = this._key;
    this._register();

    this._onLoadStartBind = this._onLoadStartHandler.bind(this);
    this._onDurationChangeBind = this._onDurationChangeHandler.bind(this);
    this._onLoadedMetaDataBind = this._onLoadedMetaDataHandler.bind(this);
    this._onLoadedDataBind = this._onLoadedDataHandler.bind(this);
    this._onProgressBind = this._onProgressHandler.bind(this);
    this._onCanPlayBind = this._onCanPlayHandler.bind(this);
    this._onCanPlayThroughBind = this._onCanPlayThroughHandler.bind(this);
    this._onPlayBind = this._onPlayHandler.bind(this);
    this._onPauseBind = this._onPauseHandler.bind(this);
    this._onTimeUpdateBind = this._onTimeUpdateHandler.bind(this);
    this._onVolumeChangeBind = this._onVolumeChangeHandler.bind(this);
    this._onSeekingBind = this._onSeekingHandler.bind(this);
    this._onSeekedBind = this._onSeekedHandler.bind(this);
    this._onEndedBind = this._onEndedHandler.bind(this);
    this._onErrorBind = this._onErrorHandler.bind(this);
    this._onStalledBind = this._onStalledHandler.bind(this);
    this._onRateChangeBind = this._onRateChangeHandler.bind(this);
    this._onPlayingBind = this._onPlayingHandler.bind(this);
    this._onQualityRequestBind = this._onQualityRequestHandler.bind(this);
    this._onQualityChangeBind = this._onQualityChangeHandler.bind(this);
    //this._onQualityAbortBind = this._onQualityAbortHandler.bind(this);

    // DASH specific
    this._onSwitchCompletedBind = this._onSwitchCompletedHandler.bind(this);
    this._onMetricsChangedBind = this._onMetricsChangedHandler.bind(this);

    //Listen to the main volume change to adapt the video volume accordingly.
    this._viewer.audio.onVolumeChange.add(this._mainVolumeChangeHandler, this);

    //Listen to the enabled state of the sound manager.
    this._viewer.audio.onDisable.add(this._disableSoundHandler, this);

    //force the creation of "onQualitiesLoaded" event dispatcher and memorize it's data
    this._onQualitiesLoaded = new FORGE.EventDispatcher(this, true);

    if (this._config !== null)
    {
        this.load(this._config);
    }

    this._viewer.display.register(this);
    this._notifyReady();
    this._applyPending(false);
};

/**
 * Parse the video configuration object.
 * @method FORGE.VideoDash#_parseConfig
 * @private
 * @param  {?(string|FORGE.VideoQuality|Array<(string|FORGE.VideoQuality)>)} config - The config object to parse.
 * @return {string} Returns the manifest url for DASH.
 */
FORGE.VideoDash.prototype._parseConfig = function(config)
{
    if (config !== null)
    {
        if (FORGE.Utils.isTypeOf(config, "string") === true)
        {
            config = [config];
        }
        else if (FORGE.Utils.isTypeOf(config, "VideoQuality") === true)
        {
            config = [config];
        }

        if (FORGE.Utils.isArrayOf(config, "string") === true)
        {
            this._manifestUrl = config[0];
        }
        else if (FORGE.Utils.isArrayOf(config, "VideoQuality") === true)
        {
            this._manifestUrl = config[0].url;
        }
    }

    return this._manifestUrl;
};

/**
 * Notify that the dispay object has been resized.<br>
 * This method ovverrides the {@link FORGE.DisplayObject} method.
 * @method  FORGE.VideoDash#_notifyResize
 * @private
 * @param  {PropertyToUpdate} data - The data contains the property that have changed.
 */
FORGE.VideoDash.prototype._notifyResize = function(data)
{
    var video = this._video;

    if (video !== null && video.element !== null)
    {
        video.element.setAttribute("width", this.pixelWidth);
        video.element.setAttribute("height", this.pixelHeight);
    }

    FORGE.DisplayObject.prototype._notifyResize.call(this, data);
};

/**
 * Create placeholders objects for videos and theirs attributes.
 * @method FORGE.VideoDash#_createVideoObject
 * @private
 * @return {Object} Returns the populated videos array.
 */
FORGE.VideoDash.prototype._createVideoObject = function()
{
    var video = {
        index: 0,
        element: null,
        buffer: null,
        played: null
    };

    this._video = video;

    return video;
};

/**
 * Populate a video object with an element <video> and a buffer/played {@link FORGE.VideoTimeRanges} managers.
 * @method  FORGE.VideoDash#_createVideoTag
 * @private
 * @return {Object} Returns the populated video object.
 */
FORGE.VideoDash.prototype._createVideoTag = function()
{
    //Create a video tag and get the quality
    var element = document.createElement("video");
    element.setAttribute("webkit-playsinline", "webkit-playsinline");
    element.setAttribute("width", this.pixelWidth);
    element.setAttribute("height", this.pixelHeight);
    element.volume = 0;
    element.playbackRate = this._playbackRate;
    element.crossOrigin = "anonymous";
    element.id = "FORGE-VideoDash-" + this._uid;

    var buffer = new FORGE.VideoTimeRanges(element, "buffered");
    var played = new FORGE.VideoTimeRanges(element, "played");

    //Update the video object with the element and fresh buffer and played
    var video = this._video;
    video.element = element;
    video.buffer = buffer;
    video.played = played;
    video.lastTimeStamp = 0;

    return video;
};

/**
 * Get a property of the video element of the current video object.
 * @method  FORGE.VideoDash#_getCurrentVideoElementProperty
 * @param  {string} property - The property you want to get from the current video element.
 * @param  {*} defaultReturnValue - The default return value if the video object or its element is null.
 * @return {*} Return the requested property value or the default one if necessary.
 * @private
 */
FORGE.VideoDash.prototype._getCurrentVideoElementProperty = function(property, defaultReturnValue)
{
    var video = this._video;

    if (video !== null && video.element !== null)
    {
        return video.element[property];
    }

    return defaultReturnValue;
};

/**
 * Create instance of the dash.js Media Player.
 * @method FORGE.VideoDash#_instanciateDashMediaPlayer
 * @private
 */
FORGE.VideoDash.prototype._initDashMediaPlayer = function()
{
    // create the Media Player
    this._dashMediaPlayer = dashjs.MediaPlayer().create();
    //deactivate logs
    this._dashMediaPlayer.getDebug().setLogToBrowserConsole(false);
    //init media player
    this._dashMediaPlayer.initialize();
    // playback is paused on start
    this._dashMediaPlayer.setAutoPlay(false);
    //keep downloading fragments in the background when paused
    this._dashMediaPlayer.setScheduleWhilePaused(true);
    //fast switch with ABR
    this._dashMediaPlayer.setFastSwitchEnabled(true);
    // add video tag element and video source file
    this._dashMediaPlayer.attachView(this._video.element);
    this._dashMediaPlayer.attachSource(this._manifestUrl);

    //add events if element and source are defined
    if (this._dashMediaPlayer.isReady() === true)
    {
        this._installEvents();

        this._addVideoToDom();
    }

    if (this._qualityMode === "")
    {
        this._setQualityMode(this._defaultQualityMode);
    }
};

/**
 * Add video element to the DOM.
 * @method FORGE.VideoDash#_addVideoToDom
 * @private
 */
FORGE.VideoDash.prototype._addVideoToDom = function()
{
    // Remove video tag from our container div
    this._dom.innerHTML = "";

    this._dom.appendChild(this._video.element);
};

/**
 * Bind native events handler for the current video.
 * @method FORGE.VideoDash#_installEvents
 * @private
 */
FORGE.VideoDash.prototype._installEvents = function()
{
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["CAN_PLAY"], this._onCanPlayBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["ERROR"], this._onErrorBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["PLAYBACK_ENDED"], this._onEndedBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["PLAYBACK_ERROR"], this._onErrorBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["PLAYBACK_METADATA_LOADED"], this._onLoadedMetaDataBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["PLAYBACK_PAUSED"], this._onPauseBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["PLAYBACK_PROGRESS"], this._onProgressBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["PLAYBACK_SEEKING"], this._onSeekingBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["PLAYBACK_SEEKED"], this._onSeekedBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["PLAYBACK_STARTED"], this._onPlayBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["PLAYBACK_TIME_UPDATED"], this._onTimeUpdateBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["QUALITY_CHANGE_RENDERED"], this._onQualityChangeBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["QUALITY_CHANGE_REQUESTED"], this._onQualityRequestBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["STREAM_INITIALIZED"], this._onLoadStartBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["PLAYBACK_PLAYING"], this._onPlayingBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["BUFFER_EMPTY"], this._onStalledBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["PLAYBACK_RATE_CHANGED"], this._onRateChangeBind);

    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["PERIOD_SWITCH_COMPLETED"], this._onSwitchCompletedBind);
    this._dashMediaPlayer.on(dashjs.MediaPlayer.events["METRIC_CHANGED"], this._onMetricsChangedBind);

    this._video.element.addEventListener("loadeddata", this._onLoadedDataBind, false);
    this._video.element.addEventListener("durationchange", this._onDurationChangeBind, false);
    this._video.element.addEventListener("canplaythrough", this._onCanPlayThroughBind, false);
    this._video.element.addEventListener("volumechange", this._onVolumeChangeBind, false);
};

/**
 * Unbind events handler for video.
 * @method FORGE.VideoDash#_uninstallEvents
 * @private
 */
FORGE.VideoDash.prototype._uninstallEvents = function()
{
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["CAN_PLAY"], this._onCanPlayBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["ERROR"], this._onErrorBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["PLAYBACK_ENDED"], this._onEndedBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["PLAYBACK_ERROR"], this._onErrorBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["PLAYBACK_METADATA_LOADED"], this._onLoadedMetaDataBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["PLAYBACK_PAUSED"], this._onPauseBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["PLAYBACK_PROGRESS"], this._onProgressBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["PLAYBACK_SEEKING"], this._onSeekingBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["PLAYBACK_SEEKED"], this._onSeekedBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["PLAYBACK_STARTED"], this._onPlayBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["PLAYBACK_TIME_UPDATED"], this._onTimeUpdateBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["QUALITY_CHANGE_RENDERED"], this._onQualityChangeBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["QUALITY_CHANGE_REQUESTED"], this._onQualityRequestBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["STREAM_INITIALIZED"], this._onLoadStartBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["PLAYBACK_PLAYING"], this._onPlayingBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["BUFFER_EMPTY"], this._onStalledBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["PLAYBACK_RATE_CHANGED"], this._onRateChangeBind);

    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["PERIOD_SWITCH_COMPLETED"], this._onSwitchCompletedBind);
    this._dashMediaPlayer.off(dashjs.MediaPlayer.events["METRIC_CHANGED"], this._onMetricsChangedBind);

    this._video.element.removeEventListener("loadeddata", this._onLoadedDataBind, false);
    this._video.element.removeEventListener("durationchange", this._onDurationChangeBind, false);
    this._video.element.removeEventListener("canplaythrough", this._onCanPlayThroughBind, false);
    this._video.element.removeEventListener("volumechange", this._onVolumeChangeBind, false);
};

/**
 * Private event handler for loadStart.
 * @method  FORGE.VideoDash#_onLoadStartHandler
 * @param  {Event} event - The native video event.
 * @private
 */
FORGE.VideoDash.prototype._onLoadStartHandler = function(event)
{
    var element = this._video.element;
    this.log("onLoadStart [readyState: " + element.readyState + "]");

    //populate qualities array with the MPEG-DASH bitrates info list
    this._createQualitiesFromBitrateInfoList(this._manifestUrl, this._dashMediaPlayer.getBitrateInfoListFor(FORGE.VideoDash.mediaType.VIDEO));

    if (this._onLoadStart !== null)
    {
        this._onLoadStart.dispatch(event);
    }
};

/**
 * Create a qualities array from the bitrates info list.
 * @method FORGE.VideoDash#_createQualitiesFromBitrateInfoList
 * @param  {string} url - The manifest url.
 * @param  {Array<BitrateInfo>} bitrates - The bitrates array.
 * @param  {boolean=} checkURL - URL must be checked?
 * @return {Array<FORGE.VideoQuality>} The qualities array.
 * @private
 */
FORGE.VideoDash.prototype._createQualitiesFromBitrateInfoList = function(url, bitrates, checkURL)
{
    var qualities = [];
    var quality;

    if (bitrates !== null)
    {
        for (var i = 0, ii = bitrates.length; i < ii; i++)
        {
            if (checkURL === true && FORGE.URL.isValid(url) === false)
            {
                throw "FORGE.Video: URL " + url + " is invalid";
            }

            quality = new FORGE.VideoQuality(url);
            quality.id = bitrates[i].qualityIndex;
            quality.bitrate = bitrates[i].bitrate;
            quality.width = bitrates[i].width;
            quality.height = bitrates[i].height;

            qualities.push(quality);
        }

        this._qualities = /** @type {Array<FORGE.VideoQuality>} */ (qualities);

        if (this._onQualitiesLoaded !== null)
        {
            this._onQualitiesLoaded.dispatch(qualities);
        }
    }
    else
    {
        this.destroy();
    }

    return qualities;
};

/**
 * Get the index of a {@link FORGE.VideoQuality} that is in the _videoQualities array.
 * @method  FORGE.VideoDash#_indexOfQuality
 * @private
 * @param  {FORGE.VideoQuality} quality - The quality you need to get its index.
 * @return {number} Returns the index of the quality if found, -1 if not found.
 */
FORGE.VideoDash.prototype._indexOfQuality = function(quality)
{
    var q;
    for (var i = 0, ii = this._qualities.length; i < ii; i++)
    {
        q = this._qualities[i];

        if (q === quality)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Private event handler for period switch completed.
 * @method  FORGE.VideoDash#_onSwitchCompletedHandler
 * @param  {SwitchEvents} event - The dash.js media player event.
 * @private
 */
FORGE.VideoDash.prototype._onSwitchCompletedHandler = function(event)
{
    var element = this._video.element;
    this.log("_onSwitchCompleted [readyState: " + element.readyState + "]");

    this._streamInfo = /** @type {StreamInfo} */ (event.toStreamInfo);
};

/**
 * Private event handler for mertics changed.
 * @method  FORGE.VideoDash#_onMetricsChangedHandler
 * @param  {MetricChangedEvents} event - The dash.js media player event.
 * @private
 */
FORGE.VideoDash.prototype._onMetricsChangedHandler = function(event)
{
    var element = this._video.element;
    this.log("_onMetricsChangedHandler [readyState: " + element.readyState + "]");

    if (this._playerVideoMetrics === null)
    {
        this._playerVideoMetrics = this._dashMediaPlayer.getMetricsFor(FORGE.VideoDash.mediaType.VIDEO);
    }

    if (this._playerAudioMetrics === null)
    {
        this._playerAudioMetrics = this._dashMediaPlayer.getMetricsFor(FORGE.VideoDash.mediaType.AUDIO);
    }

    if (this._dashMetrics === null)
    {
        this._dashMetrics = this._dashMediaPlayer.getDashMetrics();
    }

    //set the current quality index
    // if (this._playerVideoMetrics !== null && this._dashMetrics !== null)
    // {
    //     var repSwitch = /** @type {RepresentationSwitch} */ (this._dashMetrics.getCurrentRepresentationSwitch(this._playerVideoMetrics));
    //     if (repSwitch !== null)
    //     {
    //         this._currentQuality = this._dashMetrics.getIndexForRepresentation(repSwitch.to, this._streamInfo.index);
    //         if(this._qualityInitialized === false)
    //         {
    //             this._setRequestQuality(this._currentQuality);
    //             this._qualityInitialized = true;
    //         }
    //     }
    // }

    if (this._onMetricsChanged !== null)
    {
        var metrics;

        if (event.mediaType === FORGE.VideoDash.mediaType.VIDEO)
        {
            metrics = this._getMetricsFor(FORGE.VideoDash.mediaType.VIDEO, this._playerVideoMetrics, this._dashMetrics);
            if (metrics)
            {
                this._monitoring = {
                    "videoBitrate": metrics.bitrate,
                    "videoIndex": metrics.index,
                    "videoPendingIndex": metrics.pendingIndex,
                    "videoMaxIndex": metrics.maxIndex,
                    "videoBufferLength": metrics.bufferLength,
                    "videoDroppedFrames": metrics.droppedFrames
                        //"videoRequestsQueue": metrics.requestsQueue
                };
            }
        }

        if (event.mediaType === FORGE.VideoDash.mediaType.AUDIO)
        {
            metrics = this._getMetricsFor(FORGE.VideoDash.mediaType.AUDIO, this._playerAudioMetrics, this._dashMetrics);
            if (metrics)
            {
                this._monitoring = {
                    "audioBitrate": metrics.bitrate,
                    "audioIndex": metrics.index,
                    "audioPendingIndex": metrics.pendingIndex,
                    "audioMaxIndex": metrics.maxIndex,
                    "audioBufferLength": metrics.bufferLength,
                    "audioDroppedFrames": metrics.droppedFrames
                        //"audioRequestsQueue": metrics.requestsQueue
                };
            }
        }

        this._onMetricsChanged.dispatch(event);
    }
};


/**
 * Prepare a metrics object for video/audio data.
 * @method  FORGE.VideoDash#_getMetricsFor
 * @param {string} type - The video or audio type.
 * @param {Object} metrics - The player video or audio metrics.
 * @param {DashMetrics} dashMetrics - The dash stream video or audio metrics.
 * @return {?Object} The monitoring object
 * @private
 */
FORGE.VideoDash.prototype._getMetricsFor = function(type, metrics, dashMetrics)
{
    if (metrics !== null && dashMetrics !== null)
    {
        var streamIndex = this._streamInfo.index;
        var repSwitch, maxIndex, bufferLevel, droppedFramesMetrics, bitrate, index, pendingIndex, bufferLength, droppedFrames; //httpRequests requestsQueue pendingValue

        repSwitch = /** @type {RepresentationSwitch} */ (dashMetrics.getCurrentRepresentationSwitch(metrics));
        if (repSwitch !== null)
        {
            // index = dashMetrics.getIndexForRepresentation(repSwitch.to, streamIndex);
            bitrate = Math.round(dashMetrics.getBandwidthForRepresentation(repSwitch.to, streamIndex) / 1000);
        }
        if (isNaN(bitrate) || bitrate === undefined)
        {
            bitrate = 0;
        }

        if (type === FORGE.VideoDash.mediaType.VIDEO)
        {
            index = this._currentVideoIndex + 1;
            pendingIndex = this._currentVideoPendingIndex + 1;
        }
        else if (type === FORGE.VideoDash.mediaType.AUDIO)
        {
            index = this._currentAudioIndex + 1;
            pendingIndex = this._currentAudioPendingIndex + 1;
        }

        if (isNaN(index) || index === undefined)
        {
            index = 0;
        }
        if (isNaN(pendingIndex) || pendingIndex === undefined)
        {
            pendingIndex = 0;
        }

        maxIndex = dashMetrics.getMaxIndexForBufferType(type, streamIndex);
        if (isNaN(maxIndex) || maxIndex === undefined)
        {
            maxIndex = 0;
        }

        bufferLevel = dashMetrics.getCurrentBufferLevel(metrics);
        if (bufferLevel !== null)
        {
            bufferLength = bufferLevel.toPrecision(5);
        }
        if (isNaN(bufferLength) || bufferLength === undefined)
        {
            bufferLength = 0;
        }

        //httpRequests = dashMetrics.getHttpRequests(metrics);

        droppedFramesMetrics = /** @type {DroppedFrames} */ (dashMetrics.getCurrentDroppedFrames(metrics));
        if (droppedFramesMetrics !== null)
        {
            droppedFrames = droppedFramesMetrics.droppedFrames;
        }

        //pendingValue = this._dashMediaPlayer.getQualityFor(type);

        //requestsQueue = dashMetrics.getRequestsQueue(metrics);

        var result = {
            bitrate: bitrate,
            index: index,
            pendingIndex: pendingIndex,
            maxIndex: maxIndex,
            bufferLength: bufferLength,
            droppedFrames: droppedFrames
                //requestsQueue: requestsQueue
        };

        return result;
    }

    return null;
};

/**
 * Private event handler for quality change.
 * @method  FORGE.VideoDash#_onQualityChangeHandler
 * @private
 * @param  {QualityEvents} event - The dash.js media player event.
 */
FORGE.VideoDash.prototype._onQualityChangeHandler = function(event)
{
    var element = this._video.element;
    this.log("onQualityChange [readyState: " + element.readyState + "]");

    if (event.mediaType === FORGE.VideoDash.mediaType.AUDIO)
    {
        this._currentAudioIndex = event.newQuality;
        this._currentAudioPendingIndex = event.newQuality;
    }
    else if (event.mediaType === FORGE.VideoDash.mediaType.VIDEO)
    {
        this._currentVideoIndex = event.newQuality;
        this._currentVideoPendingIndex = event.newQuality;

        if (this._onQualityChange !== null)
        {
            this._onQualityChange.dispatch(this._currentVideoPendingIndex);
        }
    }
};

/**
 * Private event handler for quality request.
 * @method  FORGE.VideoDash#_onQualityRequestHandler
 * @private
 * @param  {QualityEvents} event - The dash.js media player event.
 */
FORGE.VideoDash.prototype._onQualityRequestHandler = function(event)
{
    var element = this._video.element;
    this.log("onQualityRequest [readyState: " + element.readyState + "]");

    if (event.mediaType === FORGE.VideoDash.mediaType.AUDIO)
    {
        this._currentAudioIndex = event.oldQuality;
        this._currentAudioPendingIndex = event.newQuality;
    }
    else if (event.mediaType === FORGE.VideoDash.mediaType.VIDEO)
    {
        this._currentVideoIndex = event.oldQuality;
        this._currentVideoPendingIndex = event.newQuality;

        if (this._onQualityRequest !== null)
        {
            this._onQualityRequest.dispatch(this._currentVideoPendingIndex);
        }
    }
};

/**
 * Private event handler for quality request aborted.
 * @method  FORGE.VideoDash#_onQualityAbortHandler
 * @private
 * @param  {Event} event - The dash.js media player event.
 */
// FORGE.VideoDash.prototype._onQualityAbortHandler = function(event)
// {
//     var element = this._video.element;
//     this.log("onQualityAbort [readyState: "+element.readyState+"]");

//     if(this._onQualityAbort !== null)
//     {
//         this._onQualityAbort.dispatch(this._video.requestIndex);
//     }
// };

/**
 * Private event handler for durationChange.
 * @method  FORGE.VideoDash#_onDurationChangeHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onDurationChangeHandler = function(event)
{
    var element = this._video.element;
    this.log("onDurationChange [readyState: " + element.readyState + "]");

    //@firefox - FF disptach durationchange twice on readystate HAVE_METADATA (1) & HAVE_ENOUGH_DATA (4)
    //I will not dispatch this event if readystate is HAVE_ENOUGH_DATA (4) !
    if (this._onDurationChange !== null && element.readyState === HTMLMediaElement.HAVE_METADATA)
    {
        this._onDurationChange.dispatch(event);
    }
};

/**
 * Private event handler for loadedMetaData.
 * @method  FORGE.VideoDash#_onLoadedMetaDataHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onLoadedMetaDataHandler = function(event)
{
    var element = this._video.element;
    this.log("onLoadedMetaData [readyState: " + element.readyState + "]");

    this._metaDataLoaded = true;

    if (this._onLoadedMetaData !== null)
    {
        this._onLoadedMetaData.dispatch(event);
    }
};

/**
 * Private event handler for loadedData.
 * @method  FORGE.VideoDash#_onLoadedDataHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onLoadedDataHandler = function(event)
{
    var element = this._video.element;
    this.log("onLoadedData [readyState: " + element.readyState + "]");

    if (this._onLoadedData !== null)
    {
        this._onLoadedData.dispatch(event);
    }
};

/**
 * Private event handler for progress.
 * @method  FORGE.VideoDash#_onProgressHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onProgressHandler = function(event)
{
    //var element = this._video.element;
    //this.log("onProgress [readyState: "+element.readyState+"]");

    if (this._onProgress !== null)
    {
        this._onProgress.dispatch(event);
    }
};

/**
 * Private event handler for canPlay.
 * @method  FORGE.VideoDash#_onCanPlayHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onCanPlayHandler = function(event)
{
    var element = this._video.element;
    this.log("onCanPlay [readyState: " + element.readyState + "]");

    this._canPlay = true;

    if (this._onCanPlay !== null)
    {
        this._onCanPlay.dispatch(event);
    }
};

/**
 * Private event handler for canPlayThrough.
 * @method  FORGE.VideoDash#_onCanPlayThroughHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onCanPlayThroughHandler = function(event)
{
    var element = this._video.element;
    this.log("onCanPlayThrough [readyState: " + element.readyState + "]");

    this._canPlay = true;

    if (this._onCanPlayThrough !== null)
    {
        this._onCanPlayThrough.dispatch(event);
    }
};

/**
 * Private event handler for play.
 * @method  FORGE.VideoDash#_onPlayHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onPlayHandler = function(event)
{
    var element = this._video.element;
    this.log("onPlay [readyState: " + element.readyState + "]");

    if (this._onPlay !== null)
    {
        this._onPlay.dispatch(event);
    }
};

/**
 * Private event handler for pause.
 * @method  FORGE.VideoDash#_onPauseHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onPauseHandler = function(event)
{
    var element = this._video.element;
    this.log("onPause [readyState: " + element.readyState + "]");

    this._playing = false;

    if (this._onPause !== null)
    {
        this._onPause.dispatch(event);
    }
};

/**
 * Private event handler for timeUpdate.
 * @method  FORGE.VideoDash#_onTimeUpdateHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onTimeUpdateHandler = function(event)
{
    //var element = this._video.element;
    //this.log("onTimeUpdate [readyState: "+element.readyState+"]");

    if (this._onTimeUpdate !== null)
    {
        this._onTimeUpdate.dispatch(event);
    }
};

/**
 * Private event handler for volumeChange.
 * @method  FORGE.VideoDash#_onVolumeChangeHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onVolumeChangeHandler = function(event)
{
    var element = this._video.element;
    this.log("onVolumeChange [readyState: " + element.readyState + "]");

    //I do not dispatch the volume change if readyState is HAVE_NOTHING (0).
    //because I set the volume at 0 when I create the video element, it is not usefull to dispatch this internal volume change ?
    if (this._onVolumeChange !== null && element.readyState !== HTMLMediaElement.HAVE_NOTHING)
    {
        this._onVolumeChange.dispatch(event);
    }
};

/**
 * Private event handler for seeking.
 * @method  FORGE.VideoDash#_onSeekingHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onSeekingHandler = function(event)
{
    var element = this._video.element;
    this.log("onSeeking [readyState: " + element.readyState + "]");

    this._canPlay = false;

    if (this._onSeeking !== null)
    {
        this._onSeeking.dispatch(event);
    }
};

/**
 * Private event handler for seeked.
 * @method  FORGE.VideoDash#_onSeekedHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onSeekedHandler = function(event)
{
    var element = this._video.element;
    this.log("onSeeked [readyState: " + element.readyState + "]");

    this._canPlay = false;

    if (this._onSeeked !== null)
    {
        this._onSeeked.dispatch(event);
    }
};

/**
 * Private event handler for ended.
 * @method  FORGE.VideoDash#_onEndedHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onEndedHandler = function(event)
{
    var element = this._video.element;
    this.log("onEnded [readyState: " + element.readyState + "]");

    this._playing = false;
    //this._dom.currentTime = 0;
    this._endCount++;

    if (this._loop === true)
    {
        this.play();
    }

    if (this._onEnded !== null)
    {
        this._onEnded.dispatch(event);
    }
};

/**
 * Private event handler for error.
 * @method  FORGE.VideoDash#_onErrorHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onErrorHandler = function(event)
{
    var element = this._video.element;
    this.log("onError [readyState: " + element.readyState + "]");

    if (this._onError !== null)
    {
        this._onError.dispatch(event);
    }
};

/**
 * Private event handler for stalled.
 * @method  FORGE.VideoDash#_onStalledHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onStalledHandler = function(event)
{
    var element = this._video.element;
    this.log("onStalled [readyState: " + element.readyState + "]");

    if (this._onStalled !== null)
    {
        this._onStalled.dispatch(event);
    }
};

/**
 * Private event handler for rate change.
 * @method  FORGE.VideoDash#_onRateChangeHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onRateChangeHandler = function(event)
{
    var element = this._video.element;
    this.log("onRateChange [readyState: " + element.readyState + "]");

    if (this._onRateChange !== null)
    {
        this._onRateChange.dispatch(event);
    }
};

/**
 * Private event handler for playing.
 * @method  FORGE.VideoDash#_onPlayingHandler
 * @private
 * @param  {Event} event - The native video event.
 */
FORGE.VideoDash.prototype._onPlayingHandler = function(event)
{
    var element = this._video.element;
    this.log("onPlaying [readyState: " + element.readyState + "]");

    if (this._onPlaying !== null)
    {
        this._onPlaying.dispatch(event);
    }
};

/**
 * Destroy a video object at a specified index, wiil look at the video object into _videos array then detoy it.
 * @method FORGE.VideoDash#_destroyVideo
 * @private
 */
FORGE.VideoDash.prototype._destroyVideo = function()
{
    this.log("_destroyVideo");

    if (this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true)
    {
        this._uninstallEvents();

        this._dashMediaPlayer.pause();
        this._dashMediaPlayer.reset();
    }

    var video = this._video;
    var element = video.element;

    if (typeof element !== "undefined" && element !== null)
    {
        if (element.parentNode === this._dom)
        {
            this._dom.removeChild(element);
        }
    }

    element = null;
    video.element = null;

    if (video.buffer !== null)
    {
        video.buffer.destroy();
        video.buffer = null;
    }

    if (video.played !== null)
    {
        video.played.destroy();
        video.played = null;
    }

    video = null;
};

/**
 * Handles the disable status of the sound manager.
 * @method FORGE.VideoDash#_disableSoundHandler
 * @private
 */
FORGE.VideoDash.prototype._disableSoundHandler = function()
{
    var v = this._video;

    if (v !== null && v.element !== null && this._viewer.audio.enabled === false)
    {
        this._dashMediaPlayer.setVolume(0);
    }
};

/**
 * Handles the main volume change, update the volume factor to the video volume.
 * @method FORGE.VideoDash#_mainVolumeChangeHandler
 * @private
 */
FORGE.VideoDash.prototype._mainVolumeChangeHandler = function()
{
    this._updateVolume();
};

/**
 * Apply the main volume factor to the video volume.
 * @method FORGE.VideoDash#_updateVolume
 * @private
 */
FORGE.VideoDash.prototype._updateVolume = function()
{
    var v = this._video;

    if (v !== null && v.element !== null && this._viewer.audio.enabled === true)
    {
        this._dashMediaPlayer.setVolume(this._volume * this._viewer.audio.volume);
        if (this._muted === true)
        {
            this._dashMediaPlayer.setMute(true);
        }
        else
        {
            this._dashMediaPlayer.setMute(false);
        }
    }
};

/**
 * Apply the requested quality index.
 * @method FORGE.VideoDash#_setRequestQuality
 * @param {number} index - The quality index.
 * @private
 */
FORGE.VideoDash.prototype._setRequestQuality = function(index)
{
    this._currentVideoPendingIndex = index;

    if (this._streamInfo !== null && this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true && this._dashMetrics !== null)
    {
        var streamIndex = this._streamInfo.index;
        var maxVideoIndex = this._dashMetrics.getMaxIndexForBufferType(FORGE.VideoDash.mediaType.VIDEO, streamIndex);
        var maxAudioIndex = this._dashMetrics.getMaxIndexForBufferType(FORGE.VideoDash.mediaType.AUDIO, streamIndex);

        var newVideoIndex = index,
            newAudioIndex = index;

        // zero based indexes
        if (newVideoIndex >= maxVideoIndex)
        {
            newVideoIndex = maxVideoIndex - 1;
        }
        if (newVideoIndex < 0)
        {
            newVideoIndex = 0;
        }
        if (newAudioIndex >= maxAudioIndex)
        {
            newAudioIndex = maxAudioIndex - 1;
        }
        if (newAudioIndex < 0)
        {
            newAudioIndex = 0;
        }

        this._dashMediaPlayer.setQualityFor(FORGE.VideoDash.mediaType.VIDEO, newVideoIndex);
        this._dashMediaPlayer.setQualityFor(FORGE.VideoDash.mediaType.AUDIO, newAudioIndex);
    }

    // Update the volume for the requested video
    this._updateVolume();
};

/**
 * Sets the quality mode.<br>
 * This activate or deactivate the adaptative bitrate switching for video and audio (ABR).
 * @method  FORGE.VideoDash#_setQualityMode
 * @private
 * @param {string} mode - Quality mode to be set.
 */
FORGE.VideoDash.prototype._setQualityMode = function(mode)
{
    if (this._qualityMode === mode)
    {
        return;
    }

    if (mode === FORGE.VideoQualityMode.AUTO || mode === FORGE.VideoQualityMode.MANUAL)
    {
        this._qualityMode = mode;

        if (this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true)
        {
            if (mode === FORGE.VideoQualityMode.MANUAL)
            {
                this._dashMediaPlayer.setAutoSwitchQualityFor(FORGE.VideoDash.mediaType.VIDEO, false);
                this._dashMediaPlayer.setAutoSwitchQualityFor(FORGE.VideoDash.mediaType.AUDIO, false);
            }
            else
            {
                this._dashMediaPlayer.setAutoSwitchQualityFor(FORGE.VideoDash.mediaType.VIDEO, true);
                this._dashMediaPlayer.setAutoSwitchQualityFor(FORGE.VideoDash.mediaType.AUDIO, true);
            }
        }

        if (this._onQualityModeChange !== null)
        {
            this._onQualityModeChange.dispatch(this._qualityMode);
        }
    }
};

/**
 * Load a config or a video url to the source.
 * @method FORGE.VideoDash#load
 * @param {?(string|FORGE.VideoQuality|Array<(string|FORGE.VideoQuality)>)} config - The {@link FORGE.VideoQuality} or the url string to load.
 */
FORGE.VideoDash.prototype.load = function(config)
{
    //parse the config in parameters
    this._parseConfig(config);

    if (this._manifestUrl === "")
    {
        throw "FORGE.VideoDash : Can't create video with no manifest!";
    }

    //Create place holders for video and video element
    this._createVideoObject();
    this._createVideoTag();

    this._initDashMediaPlayer();
};

/**
 * Plays the video.
 * @method  FORGE.VideoDash#play
 * @param {number=} time - Current video time to start playback.
 * @param {boolean=} loop - Media must be looped?
 */
FORGE.VideoDash.prototype.play = function(time, loop)
{
    FORGE.VideoBase.prototype.play.call(this, time, loop);

    if (this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true)
    {
        this._dashMediaPlayer.play();
        this._playing = true;
        this._paused = false;
        this._playCount++;
    }
};

/**
 * Pauses the video.
 * @method  FORGE.VideoDash#pause
 */
FORGE.VideoDash.prototype.pause = function()
{
    if (this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true)
    {
        this._dashMediaPlayer.pause();
        this._playing = false;
        this._paused = true;
    }
};

/**
 * Stop the video the video (pause it and set time to 0).
 * @method  FORGE.VideoDash#stop
 */
FORGE.VideoDash.prototype.stop = function()
{
    if (this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true)
    {
        this._dashMediaPlayer.pause();
        this._dashMediaPlayer.seek(0);
        this._video.element.currentTime = 0;
        this._playing = false;
        this._paused = true;
    }
};

/**
 * Toggles the playback status, if play toggle to pause and vice versa.
 * @method  FORGE.VideoDash#togglePlayback
 */
FORGE.VideoDash.prototype.togglePlayback = function()
{
    if (this._playing === true || this._viewer.audio.enabled === false)
    {
        this.pause();
    }
    else
    {
        this.play();
    }
};

/**
 * Mute the video sound.
 * @method  FORGE.VideoDash#mute
 */
FORGE.VideoDash.prototype.mute = function()
{
    if (this._muted === true || this._viewer.audio.enabled === false)
    {
        return;
    }

    this._muted = true;
    this._mutedVolume = this._volume;

    this._volume = 0;
    this._updateVolume();

    if (this._onMute !== null)
    {
        this._onMute.dispatch();
    }
};

/**
 * Unmute the video sound.
 * @method  FORGE.VideoDash#unmute
 * @param {number=} volume - The volume to be restored on unmute.
 */
FORGE.VideoDash.prototype.unmute = function(volume)
{
    if (this._muted === false)
    {
        return;
    }

    var v = (typeof volume === "number") ? volume : this._mutedVolume;

    this._muted = false;
    this._volume = FORGE.Math.clamp(v, 0, 1);
    this._updateVolume();

    if (this._onUnmute !== null)
    {
        this._onUnmute.dispatch();
    }
};

/**
 * Enable/Disable the buffer-occupancy-based (BOLA) ABR rule set.<br>
 * BOLA white paper: http://arxiv.org/abs/1601.06748.
 * @method  FORGE.VideoDash#enableBufferOccupancyABR
 * @param {boolean} bool - Is the BOLA rule set is activated?
 */
FORGE.VideoDash.prototype.enableBufferOccupancyABR = function(bool)
{
    if (this._dashMediaPlayer !== null && this._dashMediaPlayer.isReady() === true)
    {
        this._dashMediaPlayer.enableBufferOccupancyABR(bool);
    }
};

/**
 * Destroy method.
 * @method FORGE.VideoDash#destroy
 */
FORGE.VideoDash.prototype.destroy = function()
{
    this._destroyVideo();

    if (this._onLoadStart !== null)
    {
        this._onLoadStart.destroy();
        this._onLoadStart = null;
    }

    if (this._onLoadedMetaData !== null)
    {
        this._onLoadedMetaData.destroy();
        this._onLoadedMetaData = null;
    }

    if (this._onLoadedData !== null)
    {
        this._onLoadedData.destroy();
        this._onLoadedData = null;
    }

    if (this._onProgress !== null)
    {
        this._onProgress.destroy();
        this._onProgress = null;
    }

    if (this._onDurationChange !== null)
    {
        this._onDurationChange.destroy();
        this._onDurationChange = null;
    }

    if (this._onCanPlay !== null)
    {
        this._onCanPlay.destroy();
        this._onCanPlay = null;
    }

    if (this._onCanPlayThrough !== null)
    {
        this._onCanPlayThrough.destroy();
        this._onCanPlayThrough = null;
    }

    if (this._onPlay !== null)
    {
        this._onPlay.destroy();
        this._onPlay = null;
    }

    if (this._onPause !== null)
    {
        this._onPause.destroy();
        this._onPause = null;
    }

    if (this._onTimeUpdate !== null)
    {
        this._onTimeUpdate.destroy();
        this._onTimeUpdate = null;
    }

    if (this._onCurrentTimeChange !== null)
    {
        this._onCurrentTimeChange.destroy();
        this._onCurrentTimeChange = null;
    }

    if (this._onVolumeChange !== null)
    {
        this._onVolumeChange.destroy();
        this._onVolumeChange = null;
    }

    if (this._onSeeking !== null)
    {
        this._onSeeking.destroy();
        this._onSeeking = null;
    }

    if (this._onSeeked !== null)
    {
        this._onSeeked.destroy();
        this._onSeeked = null;
    }

    if (this._onEnded !== null)
    {
        this._onEnded.destroy();
        this._onEnded = null;
    }

    if (this._onError !== null)
    {
        this._onError.destroy();
        this._onError = null;
    }

    if (this._onStalled !== null)
    {
        this._onStalled.destroy();
        this._onStalled = null;
    }

    if (this._onRateChange !== null)
    {
        this._onRateChange.destroy();
        this._onRateChange = null;
    }

    if (this._onPlaying !== null)
    {
        this._onPlaying.destroy();
        this._onPlaying = null;
    }

    if (this._onQualityRequest !== null)
    {
        this._onQualityRequest.destroy();
        this._onQualityRequest = null;
    }

    if (this._onQualityChange !== null)
    {
        this._onQualityChange.destroy();
        this._onQualityChange = null;
    }

    if (this._onQualityAbort !== null)
    {
        this._onQualityAbort.destroy();
        this._onQualityAbort = null;
    }

    if (this._onQualitiesLoaded !== null)
    {
        this._onQualitiesLoaded.destroy();
        this._onQualitiesLoaded = null;
    }

    if (this._onQualityModeChange !== null)
    {
        this._onQualityModeChange.destroy();
        this._onQualityModeChange = null;
    }

    if (this._onMetricsChanged !== null)
    {
        this._onMetricsChanged.destroy();
        this._onMetricsChanged = null;
    }

    this._onLoadStartBind = null;
    this._onLoadedMetaDataBind = null;
    this._onLoadedDataBind = null;
    this._onProgressBind = null;
    this._onDurationChangeBind = null;
    this._onCanPlayBind = null;
    this._onCanPlayThroughBind = null;
    this._onPlayBind = null;
    this._onPauseBind = null;
    this._onTimeUpdateBind = null;
    this._onVolumeChangeBind = null;
    this._onSeekingBind = null;
    this._onSeekedBind = null;
    this._onEndedBind = null;
    this._onErrorBind = null;
    this._onPlayingBind = null;
    this._onStalledBind = null;
    this._onRateChangeBind = null;
    this._onQualityRequestBind = null;
    this._onQualityChangeBind = null;
    //this._onQualityAbortBind = null;
    this._onMetricsChangedBind = null;

    //Unbind main volume event
    this._viewer.audio.onVolumeChange.remove(this._mainVolumeChangeHandler, this);

    this._viewer.audio.onDisable.remove(this._disableSoundHandler, this);

    this._dashMediaPlayer = null;
    this._playerVideoMetrics = null;
    this._playerAudioMetrics = null;
    this._dashMetrics = null;

    this._monitoring = null;
    this._streamInfo = null;

    this._config = null;

    this._qualities = null;

    this._video = null;

    FORGE.VideoBase.prototype.destroy.call(this);
};

/**
 * Get the monitoring object related to the video.
 * @name FORGE.VideoDash#monitoring
 * @type {Object}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "monitoring",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._monitoring;
    }
});

/**
 * Get and set the quality index of the video.
 * @name FORGE.VideoDash#quality
 * @type {(number|FORGE.VideoQuality)}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "quality",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._qualities[this._currentVideoIndex];
    },

    /** @this {FORGE.VideoDash} */
    set: function(value)
    {
        if (typeof value === "number" && value >= 0 && value < this._qualities.length)
        {
            this._setQualityMode(FORGE.VideoQualityMode.MANUAL);
            this._setRequestQuality(value);
        }
        else if (FORGE.Utils.isTypeOf(value, "VideoQuality") === true)
        {
            var i = this._indexOfQuality(value);

            if (i !== -1)
            {
                this._setQualityMode(FORGE.VideoQualityMode.MANUAL);
                this._setRequestQuality(i);
            }
            else
            {
                throw "Unknown quality";
            }
        }
        else
        {
            throw "Video quality " + value + " out of bounds";
        }
    }
});

/**
 * Get and set the quality mode.<br>
 * Available quality mode are listed in FORGE.VideoQualityMode const.
 * @name  FORGE.VideoDash#qualityMode
 * @type {string}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "qualityMode",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._qualityMode;
    },

    /** @this {FORGE.VideoDash} */
    set: function(value)
    {
        if (value === FORGE.VideoQualityMode.AUTO || value === FORGE.VideoQualityMode.MANUAL)
        {
            this._setQualityMode(value);
        }
    }
});

/**
 * Get the quality array.
 * @name  FORGE.VideoDash#qualities
 * @readonly
 * @type {Array<FORGE.VideoQuality>}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "qualities",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._qualities;
    }
});

/**
 * Get the requested quality index, returns -1 if no request is being processed.
 * @name  FORGE.VideoDash#requestIndex
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "requestIndex",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._currentVideoPendingIndex;
    }
});

/**
 * Get the current quality index, returns -1 if no current is playing.
 * @name  FORGE.VideoDash#currentIndex
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "currentIndex",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._currentVideoIndex;
    }
});

/**
 * Get the video object array.
 * @name  FORGE.VideoDash#video
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "video",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._video;
    }
});

/**
 * Get the html element of the current video.
 * @name FORGE.VideoDash#element
 * @readonly
 * @type {?HTMLVideoElement}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "element",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        var video = this._video;

        if (video !== null && video.element !== null)
        {
            return video.element;
        }

        return null;
    }
});

/**
 * Get the {@link FORGE.VideoTimeRanges} of the video for buffered ranges.
 * @name FORGE.VideoDash#buffer
 * @readonly
 * @type {?FORGE.VideoTimeRanges}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "buffer",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        var video = this._video;

        if (video !== null && video.buffer !== null)
        {
            return video.buffer;
        }

        return null;
    }
});

/**
 * Get the {@link FORGE.VideoTimeRanges} of the video for played ranges.
 * @name FORGE.VideoDash#played
 * @readonly
 * @type {?FORGE.VideoTimeRanges}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "played",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        var video = this._video;

        if (video !== null && video.played !== null)
        {
            return video.played;
        }

        return null;
    }
});

/**
 * Get the original width of the video source.
 * @name FORGE.VideoDash#originalWidth
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "originalWidth",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._getCurrentVideoElementProperty("videoWidth", 0);
    }
});

/**
 * Get the original height of the video source.
 * @name FORGE.VideoDash#originalHeight
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "originalHeight",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._getCurrentVideoElementProperty("videoHeight", 0);
    }
});

/**
 * Get and set the currentTime  of the video.
 * @name FORGE.VideoDash#currentTime
 * @type {number}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "currentTime",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._dashMediaPlayer.time();
    },

    /** @this {FORGE.VideoDash} */
    set: function(value)
    {
        if (typeof value === "number") // && value < this.duration) //@todo see if we can put video currentTime in pending if no metadata received ?
        {
            this._dashMediaPlayer.seek(value);

            if (this._onCurrentTimeChange !== null)
            {
                this._onCurrentTimeChange.dispatch(value);
            }
        }
    }
});

/**
 * Get and set the currentTime  of the video in milliseconds.
 * @name FORGE.VideoDash#currentTimeMS
 * @type {number}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "currentTimeMS",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this.currentTime * 1000;
    },

    /** @this {FORGE.VideoDash} */
    set: function(value)
    {
        this.currentTime = value / 1000;
    }
});

/**
 * Get the remainingTime of the video.
 * @name FORGE.VideoDash#remainingTime
 * @type {number}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "remainingTime",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this.duration - this.currentTime;
    }
});

/**
 * Get the duration of the video in seconds.
 * @name FORGE.VideoDash#duration
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "duration",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._dashMediaPlayer.duration();
    }
});

/**
 * Get the duration of the video in milli seconds.
 * @name FORGE.VideoDash#durationMS
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "durationMS",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return Math.round(this.duration * 1000);
    }
});

/**
 * Get the metaDataLoaded status of the video.
 * @name FORGE.VideoDash#metaDataLoaded
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "metaDataLoaded",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._metaDataLoaded;
    }
});

/**
 * Get and set the loop status of the video.
 * @name FORGE.VideoDash#loop
 * @type {boolean}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "loop",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._loop;
    },

    /** @this {FORGE.VideoDash} */
    set: function(value)
    {
        if (typeof value === "boolean")
        {
            this._loop = value;
        }
    }
});

/**
 * Get and set the volume of the video.
 * Set a volume unmute the video
 * @name FORGE.VideoDash#volume
 * @type {number}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "volume",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._volume;
    },

    /** @this {FORGE.VideoDash} */
    set: function(value)
    {
        if (typeof value === "number")
        {
            this._volume = FORGE.Math.clamp(value, 0, 1);
            this._muted = false;
            this._updateVolume();
        }
    }
});

/**
 * Get and set the mute status of the video.
 * @name FORGE.VideoDash#muted
 * @type {boolean}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "muted",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._muted;
    },

    /** @this {FORGE.VideoDash} */
    set: function(value)
    {
        if (Boolean(value) === true)
        {
            this.mute();
        }
        else
        {
            this.unmute();
        }
    }
});

/**
 * Get and set the playback rate of the video.
 * @name FORGE.VideoDash#playbackRate
 * @type {number}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "playbackRate",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this._playbackRate;
    },

    /** @this {FORGE.VideoDash} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._playbackRate = Math.abs(value);

            if (this._video !== null && this._video.element !== null)
            {
                this._video.element.playbackRate = this._playbackRate;
            }
        }
    }
});

/**
 * Get the "onLoadStart" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onLoadStart
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onLoadStart",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onLoadStart === null)
        {
            this._onLoadStart = new FORGE.EventDispatcher(this);
        }

        return this._onLoadStart;
    }
});

/**
 * Get the "onLoadedMetaData" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onLoadedMetaData
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onLoadedMetaData",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onLoadedMetaData === null)
        {
            this._onLoadedMetaData = new FORGE.EventDispatcher(this);
        }

        return this._onLoadedMetaData;
    }
});

/**
 * Get the "onLoadedData" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onLoadedData
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onLoadedData",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onLoadedData === null)
        {
            this._onLoadedData = new FORGE.EventDispatcher(this);
        }

        return this._onLoadedData;
    }
});

/**
 * Get the "onProgress" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onProgress
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onProgress",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onProgress === null)
        {
            this._onProgress = new FORGE.EventDispatcher(this);
        }

        return this._onProgress;
    }
});

/**
 * Get the "onDurationChange" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onDurationChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onDurationChange",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onDurationChange === null)
        {
            this._onDurationChange = new FORGE.EventDispatcher(this);
        }

        return this._onDurationChange;
    }
});

/**
 * Get the "onCanPlay" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onCanPlay
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onCanPlay",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onCanPlay === null)
        {
            this._onCanPlay = new FORGE.EventDispatcher(this);
        }

        return this._onCanPlay;
    }
});

/**
 * Get the "onCanPlayThrough" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onCanPlayThrough
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onCanPlayThrough",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onCanPlayThrough === null)
        {
            this._onCanPlayThrough = new FORGE.EventDispatcher(this);
        }

        return this._onCanPlayThrough;
    }
});

/**
 * Get the "onPlay" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onPlay
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onPlay",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onPlay === null)
        {
            this._onPlay = new FORGE.EventDispatcher(this);
        }

        return this._onPlay;
    }
});

/**
 * Get the "onPause" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onPause
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onPause",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onPause === null)
        {
            this._onPause = new FORGE.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
 * Get the "onTimeUpdate" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onTimeUpdate
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onTimeUpdate",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onTimeUpdate === null)
        {
            this._onTimeUpdate = new FORGE.EventDispatcher(this);
        }

        return this._onTimeUpdate;
    }
});

/**
 * Get the "onCurrentTimeChange" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onCurrentTimeChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onCurrentTimeChange",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onCurrentTimeChange === null)
        {
            this._onCurrentTimeChange = new FORGE.EventDispatcher(this);
        }

        return this._onCurrentTimeChange;
    }
});

/**
 * Get the "onVolumeChange" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onVolumeChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onVolumeChange",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onVolumeChange === null)
        {
            this._onVolumeChange = new FORGE.EventDispatcher(this);
        }

        return this._onVolumeChange;
    }
});

/**
 * Get the "onSeeking" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onSeeking
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onSeeking",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onSeeking === null)
        {
            this._onSeeking = new FORGE.EventDispatcher(this);
        }

        return this._onSeeking;
    }
});

/**
 * Get the "onSeeked" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onSeeked
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onSeeked",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onSeeked === null)
        {
            this._onSeeked = new FORGE.EventDispatcher(this);
        }

        return this._onSeeked;
    }
});

/**
 * Get the "onEnded" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onEnded
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onEnded",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onEnded === null)
        {
            this._onEnded = new FORGE.EventDispatcher(this);
        }

        return this._onEnded;
    }
});

/**
 * Get the "onError" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onError
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onError",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onError === null)
        {
            this._onError = new FORGE.EventDispatcher(this);
        }

        return this._onError;
    }
});

/**
 * Get the "onStalled" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onStalled
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onStalled",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onStalled === null)
        {
            this._onStalled = new FORGE.EventDispatcher(this);
        }

        return this._onStalled;
    }
});

/**
 * Get the "onRateChange" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onRateChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onRateChange",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onRateChange === null)
        {
            this._onRateChange = new FORGE.EventDispatcher(this);
        }

        return this._onRateChange;
    }
});

/**
 * Get a copy of the "onStalled" event for the "onWaiting" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onWaiting
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onWaiting",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        return this.onStalled;
    }
});

/**
 * Get the "onPlaying" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onPlaying
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onPlaying",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onPlaying === null)
        {
            this._onPlaying = new FORGE.EventDispatcher(this);
        }

        return this._onPlaying;
    }
});

/**
 * Get the "onQualityRequest" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onQualityRequest
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onQualityRequest",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onQualityRequest === null)
        {
            this._onQualityRequest = new FORGE.EventDispatcher(this);
        }

        return this._onQualityRequest;
    }
});

/**
 * Get the "onQualityChange" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onQualityChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onQualityChange",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onQualityChange === null)
        {
            this._onQualityChange = new FORGE.EventDispatcher(this);
        }

        return this._onQualityChange;
    }
});

/**
 * Get the "onQualityAbort" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onQualityAbort
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onQualityAbort",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onQualityAbort === null)
        {
            this._onQualityAbort = new FORGE.EventDispatcher(this);
        }

        return this._onQualityAbort;
    }
});

/**
 * Get the "onMetricsChanged" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onMetricChanged
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onMetricsChanged",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onMetricsChanged === null)
        {
            this._onMetricsChanged = new FORGE.EventDispatcher(this);
        }

        return this._onMetricsChanged;
    }
});

/**
 * Get the "onQualitiesLoaded" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onQualitiesLoaded
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onQualitiesLoaded",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onQualitiesLoaded === null)
        {
            this._onQualitiesLoaded = new FORGE.EventDispatcher(this, true);
        }

        return this._onQualitiesLoaded;
    }
});

/**
 * Get the "onQualityModeChange" event {@link FORGE.EventDispatcher} of the video.
 * @name FORGE.VideoDash#onQualityModeChange
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.VideoDash.prototype, "onQualityModeChange",
{
    /** @this {FORGE.VideoDash} */
    get: function()
    {
        if (this._onQualityModeChange === null)
        {
            this._onQualityModeChange = new FORGE.EventDispatcher(this);
        }

        return this._onQualityModeChange;
    }
});

/**
 * This object describe the video time ranges.
 *
 * @constructor FORGE.VideoTimeRanges
 * @param {Element|HTMLVideoElement} element - The HTMLVideoElement that handle the ranges.
 * @param {string} property - The property of the video element that handles ranges (can be "buffered" or "played").
 * @extends {FORGE.BaseObject}
 */
FORGE.VideoTimeRanges = function(element, property)
{
    /**
     * The HTMLVideoElement associated to this buffer object.
     * @name FORGE.VideoTimeRanges#_element
     * @type {Element|HTMLVideoElement}
     * @private
     */
    this._element = element;

    /**
     * The property that handles the time ranges on the video element.
     * @name  FORGE.VideoTimeRanges#_property
     * @type {string}
     * @private
     */
    this._property = property;

    FORGE.BaseObject.call(this, "VideoTimeRanges");
};

FORGE.VideoTimeRanges.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.VideoTimeRanges.prototype.constructor = FORGE.VideoTimeRanges;

/**
 * Get a time range from it's index.
 * @method FORGE.VideoTimeRanges#getTimeRange
 * @param  {number} index - The index of the asked range.
 * @return {?VideoTimeRangeObject} Returns an object that contains the start and the end value of the asked range.
 */
FORGE.VideoTimeRanges.prototype.getTimeRange = function(index)
{
    var ranges = this._element[this._property];

    if (this.length === 0)
    {
        this.warn("No available range for now");
        return null;
    }

    if (index > this.length - 1)
    {
        this.warn("Time range out of bounds, returning the last available range");
        return this.getTimeRange(this.length - 1);
    }
    else if (index < 0)
    {
        this.warn("Time range out of bounds, returning the first available range");
        return this.getTimeRange(0);
    }

    var _start = ranges.start(index);
    var _end = ranges.end(index);

    return {
        start: _start,
        end: _end
    };
};

/**
 * Know if a given point in time is in any ranges.
 * @method FORGE.VideoTimeRanges#isInRanges
 * @param  {number} time - The time of your request.
 * @param {number} duration - The duration of your requested range.
 * @return {boolean} Returns true if you requested range exists.
 */
FORGE.VideoTimeRanges.prototype.isInRanges = function(time, duration)
{
    if (typeof duration !== "number")
    {
        duration = 0;
    }

    var ranges = this._element[this._property];
    var start, end;
    var i = this.length;

    while (i--)
    {
        start = ranges.start(i);
        end = ranges.end(i);

        if (time >= start && (time + duration) <= end)
        {
            return true;
        }
    }

    return false;
};

/**
 * Get the length of time ranges.
 * @name FORGE.VideoTimeRanges#length
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.VideoTimeRanges.prototype, "length",
{
    /** @this {FORGE.VideoTimeRanges} */
    get: function()
    {
        return this._element[this._property].length;
    }
});

/**
 * Get the complete status of ranges, return true if there is a unique range that covers the entire media.
 * @name FORGE.VideoTimeRanges#complete
 * @readonly
 * @type {boolean}
 */
// Object.defineProperty(FORGE.VideoTimeRanges.prototype, "complete",
// {
//     get: function()
//     {
//         var range = this.getTimeRange(0);
//         return (range.start === 0 && range.end === this._video.duration);
//     }
// });

/**
 * This object describe a video quality preset.
 * @constructor FORGE.VideoQuality
 * @param {string} url - The url of the video source for this video quality preset.
 * @extends {FORGE.BaseObject}
 */
FORGE.VideoQuality = function(url)
{
     /**
     * The name of the quality.
     * @name  FORGE.VideoQuality#_id
     * @type {string|number}
     * @private
     */
    this._id = "";

    /**
     * The url of the video.
     * @name  FORGE.VideoQuality#_url
     * @type {string}
     * @private
     */
    this._url = url || "";

    /**
     * The type of the video quality.
     * @name  FORGE.VideoQuality#_mimeType
     * @type {string}
     * @private
     */
    this._mimeType = "";

    /**
     * The name of the video quality.
     * @name  FORGE.VideoQuality#_name
     * @type {string}
     * @private
     */
    this._name = "";

    /**
     * The framerate of the video quality.
     * @name  FORGE.VideoQuality#_framerate
     * @type {number}
     * @private
     */
    this._framerate = 0;

    /**
     * The bitrate of the video quality.
     * @name  FORGE.VideoQuality#_bitrate
     * @type {number}
     * @private
     */
    this._bitrate = 0;

    /**
     * The width of the video quality.
     * @name  FORGE.VideoQuality#_width
     * @type {number}
     * @private
     */
    this._width = 0;

    /**
     * The height of the video quality.
     * @name  FORGE.VideoQuality#_height
     * @type {number}
     * @private
     */
    this._height = 0;

    /**
     * The speed of the video quality.<br>
     * (1 is foward, -1 is backward, 2 is two times faster, ...).
     * @name  FORGE.VideoQuality#_speed
     * @type {number}
     * @private
     */
    this._speed = 1;


    FORGE.BaseObject.call(this, "VideoQuality");
};

FORGE.VideoQuality.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.VideoQuality.prototype.constructor = FORGE.VideoQuality;

/**
 * Get the MIME type of a video quality preset from it's url.
 * @name  FORGE.VideoQuality#mimeTypeFromURL
 * @param  {string} url - The video preset url.
 * @return {string} The MIME type of the video preset.
 */
FORGE.VideoQuality.mimeTypeFromURL = function(url)
{
    var types = ["mp4", "webm", "ogg"];
    var parsedURL = FORGE.URL.parse(url);
    
    if(parsedURL.extension !== "" && types.indexOf(parsedURL.extension) !== -1)
    {
        return "video/" + parsedURL.extension;
    }

    var streamingTypes = ["mpd"];
    if(parsedURL.extension !== "" && streamingTypes.indexOf(parsedURL.extension) !== -1)
    {
        return "application/dash+xml";
    }

    return "";
};

/**
 * Get and set the video quality preset ID.
 * @name FORGE.VideoQuality#id
 * @type {string|number}
 * @readonly
 */
Object.defineProperty(FORGE.VideoQuality.prototype, "id", 
{
    /** @this {FORGE.VideoQuality} */
    get: function()
    {
        return this._id;
    }, 

    /** @this {FORGE.VideoQuality} */
    set: function(value)
    {
        if(typeof value === "number" || typeof value === "string")
        {
            this._id = value;
        }
    }
});

/**
 * Get the video quality preset url.
 * @name FORGE.VideoQuality#url
 * @type {string}
 * @readonly
 */
Object.defineProperty(FORGE.VideoQuality.prototype, "url", 
{
    /** @this {FORGE.VideoQuality} */
    get: function()
    {
        return this._url;
    }, 

    /** @this {FORGE.VideoQuality} */
    set: function(value)
    {
        if(typeof value === "string")
        {
            this._url = value;
        }
    }
});

/**
 * Get the video quality preset MIME type.
 * @name FORGE.VideoQuality#mimeType
 * @type {string}
 * @readonly
 */
Object.defineProperty(FORGE.VideoQuality.prototype, "mimeType", 
{
    /** @this {FORGE.VideoQuality} */
    get: function()
    {
        if(this._mimeType !== "")
        {
            return this._mimeType;
        }
        else if(this._url !== "")
        {
            this._mimeType = FORGE.VideoQuality.mimeTypeFromURL(this._url);
        }

        return this._mimeType;
    }
});

/**
 * Get the video quality preset name.
 * @name FORGE.VideoQuality#name
 * @type {string}
 * @readonly
 */
Object.defineProperty(FORGE.VideoQuality.prototype, "name", 
{
    /** @this {FORGE.VideoQuality} */
    get: function()
    {
        return this._name;
    },

    /** @this {FORGE.VideoQuality} */
    set: function(value)
    {
        if(typeof value === "string")
        {
            this._name = value;
        }
    }
});

/**
 * Get the video quality preset framerate.
 * @name FORGE.VideoQuality#framerate
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.VideoQuality.prototype, "framerate", 
{
    /** @this {FORGE.VideoQuality} */
    get: function()
    {
        return this._framerate;
    }
});

/**
 * Get and set the video quality preset bitrate.
 * @name FORGE.VideoQuality#bitrate
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.VideoQuality.prototype, "bitrate", 
{
    /** @this {FORGE.VideoQuality} */
    get: function()
    {
        return this._bitrate;
    },

    /** @this {FORGE.VideoQuality} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._bitrate = value;
        }
    }
});

/**
 * Get and set the video quality preset width.
 * @name FORGE.VideoQuality#width
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.VideoQuality.prototype, "width", 
{
    /** @this {FORGE.VideoQuality} */
    get: function()
    {
        return this._width;
    },

    /** @this {FORGE.VideoQuality} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._width = value;
        }
    }
});

/**
 * Get and set the video quality preset height.
 * @name FORGE.VideoQuality#height
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.VideoQuality.prototype, "height", 
{
    /** @this {FORGE.VideoQuality} */
    get: function()
    {
        return this._height;
    },

    /** @this {FORGE.VideoQuality} */
    set: function(value)
    {
        if(typeof value === "number")
        {
            this._height = value;
        }
    }
});

/**
 * Get the video quality preset speed.
 * @name FORGE.VideoQuality#speed
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.VideoQuality.prototype, "speed", 
{
    /** @this {FORGE.VideoQuality} */
    get: function()
    {
        return this._speed;
    }
});


/**
 * Namespace for video quality mode const
 * @namespace {Object} FORGE.VideoQualityMode
 */
FORGE.VideoQualityMode = {};

/**
 * @name FORGE.VideoQualityMode.AUTO
 * @type {string}
 * @const
 */
FORGE.VideoQualityMode.AUTO = "auto";

/**
 * @name FORGE.VideoQualityMode.MANUAL
 * @type {string}
 * @const
 */
FORGE.VideoQualityMode.MANUAL = "manual";

/**
 * Namespace for video format const.
 * @namespace {Object} FORGE.VideoFormat
 */
FORGE.VideoFormat = {};

/**
 * @name FORGE.VideoFormat.DASH
 * @type {string}
 * @const
 */
FORGE.VideoFormat.DASH = "dash";

/**
 * @name FORGE.VideoFormat.HTML5
 * @type {string}
 * @const
 */
FORGE.VideoFormat.HTML5 = "html5";

/**
 * @name FORGE.VideoFormat.UNKNOWN
 * @type {string}
 * @const
 */
FORGE.VideoFormat.UNKNOWN = "unknown";

/**
 * Cache manager for loaded objects.
 *
 * @constructor FORGE.Cache
 * @param {FORGE.Viewer} viewer - The {@link FORGE.Viewer} reference.
 */
FORGE.Cache = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.Cache#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The list of json.
     * @name FORGE.Cache#_json
     * @type {FORGE.Map}
     * @private
     */
    this._json = new FORGE.Map();

    /**
     * The list of xml.
     * @name FORGE.Cache#_xml
     * @type {FORGE.Map}
     * @private
     */
    this._xml = new FORGE.Map();

    /**
     * The list of images.
     * @name FORGE.Cache#_images
     * @type {FORGE.Map}
     * @private
     */
    this._images = new FORGE.Map();

    /**
     * The list of sounds.
     * @name FORGE.Cache#_sounds
     * @type {FORGE.Map}
     * @private
     */
    this._sounds = new FORGE.Map();

    /**
     * The current key increment used to generate keys.
     * @name FORGE.Cache#_keyIncrement
     * @type {number}
     * @private
     */
    this._keyIncrement = 0;
};

/**
 * Default prefix for generated keys
 * @name FORGE.PluginEngine._PREFIX
 * @type {string}
 * @const
 * @private
 */
FORGE.Cache._PREFIX = "FORGE-cache";

/**
 * Const that list different types of cache.
 * @name  FORGE.Cache.types
 * @type {Object}
 * @const
 */
FORGE.Cache.types = {};

/**
 * @name FORGE.Cache.types.JSON
 * @type {string}
 * @const
 */
FORGE.Cache.types.JSON = "json";

/**
 * @name FORGE.Cache.types.XML
 * @type {string}
 * @const
 */
FORGE.Cache.types.XML = "xml";

/**
 * @name FORGE.Cache.types.IMAGE
 * @type {string}
 * @const
 */
FORGE.Cache.types.IMAGE = "image";

/**
 * @name FORGE.Cache.types.SOUND
 * @type {string}
 * @const
 */
FORGE.Cache.types.SOUND = "sound";

/**
 * List of reserved keys for specific cache.
 * @name FORGE.PluginEngine.reserved
 * @type {Object}
 * @const
 */
FORGE.Cache.reserved = {};

/**
 * @name FORGE.Cache.reserved.COMMON
 * @type {Array<string>}
 * @const
 */
FORGE.Cache.reserved.COMMON = ["forge", "forgejs", "FORGE"];

/**
 * @name FORGE.Cache.reserved.JSON
 * @type {Array<string>}
 * @const
 */
FORGE.Cache.reserved.JSON = ["forge.story.config"].concat(FORGE.Cache.reserved.COMMON);

/**
 * @name FORGE.Cache.reserved.XML
 * @type {Array<string>}
 * @const
 */
FORGE.Cache.reserved.XML = [].concat(FORGE.Cache.reserved.COMMON);

/**
 * @name FORGE.Cache.reserved.IMAGE
 * @type {Array<string>}
 * @const
 */
FORGE.Cache.reserved.IMAGE = [].concat(FORGE.Cache.reserved.COMMON);

/**
 * @name FORGE.Cache.reserved.SOUND
 * @type {Array<string>}
 * @const
 */
FORGE.Cache.reserved.SOUND = [].concat(FORGE.Cache.reserved.COMMON);

/**
 * Get a cache map from a type that is listed on FORGE.Cache.types
 * @method FORGE.Cache._getCacheByType
 * @param  {string} type - The type of cache you want to get.
 * @return {?FORGE.Map} Returns the {@link FORGE.Map} associated to the required type of cache.
 * @private
 */
FORGE.Cache.prototype._getCacheByType = function(type)
{
    var cache = null;

    switch(type)
    {
        case FORGE.Cache.types.JSON:
            cache = this._json;
            break;

        case FORGE.Cache.types.XML:
            cache = this._xml;
            break;

        case FORGE.Cache.types.IMAGE:
            cache = this._images;
            break;

        case FORGE.Cache.types.SOUND:
            cache = this._sounds;
            break;
    }

    return cache;
};

/**
 * Get a reserved key array from a type that is listed on FORGE.Cache.types
 * @method FORGE.Cache._getReservedByType
 * @param  {string} type - The type of reserved key you want to get.
 * @return {?Array<string>} Returns the reserved key array associated to the required type of cache.
 * @private
 */
FORGE.Cache.prototype._getReservedByType = function(type)
{
    var reserved = null;

    switch(type)
    {
        case FORGE.Cache.types.JSON:
            reserved = FORGE.Cache.reserved.JSON;
            break;

        case FORGE.Cache.types.XML:
            reserved = FORGE.Cache.reserved.XML;
            break;

        case FORGE.Cache.types.IMAGE:
            reserved = FORGE.Cache.reserved.IMAGE;
            break;

        case FORGE.Cache.types.SOUND:
            reserved = FORGE.Cache.reserved.SOUND;
            break;
    }

    return reserved;
};

/**
 * Generate a key for a specific cache.
 * @method FORGE.Cache#_generateKey
 * @param  {string} type - In which cache type the key should be valid?
 * @param  {string} prefix - Custom key prefix.
 * @return {string} Returns a generated cache key.
 * @private
 */
FORGE.Cache.prototype._generateKey = function(type, prefix)
{
    var cache = this._getCacheByType(type);

    var p = prefix || FORGE.Cache._PREFIX;
    var key = p+"-"+this._keyIncrement;

    this._keyIncrement++;

    if(cache.has(key) === false && this._isReserved(type, key) === false)
    {
        return key;
    }
    else
    {
        return this._generateKey(type, prefix);
    }
};

/**
 * Check if a reserved key has been already added into cache.
 * @method FORGE.Cache#_isReservedAlreadyUsed
 * @param {string} type - The type of cache you want to check.
 * @param {string} key - The cache key to search for.
 * @return {boolean} Return true if the key is reserved and it is already registered
 * @private
 */
FORGE.Cache.prototype._isReservedAlreadyUsed = function(type, key)
{
    var cache = this._getCacheByType(type);
    var reserved = this._getReservedByType(type);

    return (this._isReserved(type, key) === true && cache.has(key) === true);
};

/**
 * Check if a key is reserved for a given type of cache.
 * @param  {string} type - The type of cache you want to check.
 * @param  {string} key - The key you want to check
 * @return {boolean} Return true if the key is a reserved one for the type of cache
 * @private
 */
FORGE.Cache.prototype._isReserved = function(type, key)
{
    var reserved = this._getReservedByType(type);

    if(reserved !== null)
    {
        return reserved.indexOf(key.toLowerCase()) !== -1;
    }

    return false;
};

/**
 * Is a cache has something associated to a key?
 * @method FORGE.Cache#has
 * @param {string} type - The type of cache you want to check.
 * @param {string} key - The key to search for.
 * @return {boolean} Returns true if found, false if not.
 */
FORGE.Cache.prototype.has = function(type, key)
{
    var cache = this._getCacheByType(type);

    if(cache !== null)
    {
        return cache.has(key);
    }

    return false;
};

/**
 * Get the file associated to a key in a specific cache.
 * @method FORGE.Cache#get
 * @param {string} type - The type of cache you want to use.
 * @param {string} key - The key to search for.
 * @return {?FORGE.File} Returns the {@link FORGE.File} object if found, null if not found.
 */
FORGE.Cache.prototype.get = function(type, key)
{
    if(this.has(type, key) === true)
    {
        var cache = this._getCacheByType(type);

        if(cache !== null)
        {
            return cache.get(key);
        }
    }

    return null;
};

/**
 * Add a file to a specific cache.
 * @method FORGE.Cache#add
 * @param {string} type - The type of cache you want to use.
 * @param {string} key - The key for the file.
 * @param {FORGE.File} file - The {@link FORGE.File} object you want to add.
 * @return {boolean} Returns true if the addition is complete, false if not.
 */
FORGE.Cache.prototype.add = function(type, key, file)
{
    if(typeof key !== "string" || key === "" || this._isReservedAlreadyUsed(type, key) === true)
    {
        key = this._generateKey(type, type+"-cache");
    }

    if(this.has(key, type) === false)
    {
        var cache = this._getCacheByType(type);

        if(cache !== null)
        {
            cache.set(key, file);
            return true;
        }
    }

    return false;
};

/**
 * Remove a {@link FORGE.File} from a specific cache.
 * @method FORGE.Cache#remove
 * @param {string} type - The type of cache you want to remove the file from.
 * @param {string} key - The key associated to the file you want to remove.
 * @return {boolean} Returns true if the deletion is complete, false if not.
 */
FORGE.Cache.prototype.remove = function(type, key)
{
    if(this.has(type, key) === true)
    {
        var cache = this._getCacheByType(type);

        if(cache !== null)
        {
            cache.delete(key);
            return true;
        }
    }

    return false;
};

/**
 * Destroy sequence.
 * @method FORGE.Cache#destroy
 */
FORGE.Cache.prototype.destroy = function()
{
    this._viewer = null;
    this._json = null;
    this._images = null;
    this._sounds = null;
};

/**
 * File object description.<br>
 * Used in {@link FORGE.Loader}
 *
 * @constructor FORGE.File
 */
FORGE.File = function()
{

};

/**
 * The key of the file.
 * @name FORGE.File#key
 * @type {string}
 */
FORGE.File.prototype.key = "";

/**
 * The url of the file.
 * @name FORGE.File#url
 * @type {string}
 */
FORGE.File.prototype.url = "";

/**
 * The type of the file.
 * @name FORGE.File#type
 * @type {string}
 */
FORGE.File.prototype.type = "";

/**
 * The file data.
 * @name FORGE.File#data
 * @type {Object|string}
 */
FORGE.File.prototype.data = null;

/**
 * The XMLHttpRequest response.
 * @name FORGE.File#xhr
 * @type {Object}
 */
FORGE.File.prototype.xhr = null;

/**
 * The loading satatus of the file.
 * @name FORGE.File#loading
 * @type {boolean}
 */
FORGE.File.prototype.loading = false;

/**
 * File is loaded?
 * @name FORGE.File#loaded
 * @type {boolean}
 */
FORGE.File.prototype.loaded = false;

/**
 * The error text of the file.
 * @name FORGE.File#error
 * @type {string}
 */
FORGE.File.prototype.error = "";

FORGE.File.prototype.constructor = FORGE.File;
/**
 * This class have several methods to load assets and put them in cache.
 * @constructor FORGE.Loader
 * @param {FORGE.Viewer} viewer - {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 *
 * @todo  Clean callback and context from file like in jsonLoadComplete, this cause JS keep reference to viewer when destroyed.
 */
FORGE.Loader = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.Loader#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    FORGE.BaseObject.call(this, "Loader");
};

FORGE.Loader.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Loader.prototype.constructor = FORGE.Loader;

/**
 * Load a json file.
 * @method FORGE.Loader#json
 * @param  {string} key - The key for the json file.
 * @param  {string} url - URL of the file.
 * @param  {Function} onCompleteCallback - The callback function called when file is completed.
 * @param  {Object} onCompleteContext - The callback context when file is completed.
 * @param  {Function=} onErrorCallback - The callback function called on file error.
 * @param  {Object=} onErrorContext - The callback context for file error.
 */
FORGE.Loader.prototype.json = function(key, url, onCompleteCallback, onCompleteContext, onErrorCallback, onErrorContext)
{
    var file = new FORGE.File();
    file.type = "json";
    file.key = key;
    file.url = url;
    file.onCompleteCallback = onCompleteCallback;
    file.onCompleteContext = onCompleteContext;
    file.onErrorCallback = onErrorCallback;
    file.onErrorContext = onErrorContext;

    this._xhr(file, "text", this._jsonLoadComplete, this._jsonLoadError);
};

/**
 * Internal method called when a json file is completed.
 * @method FORGE.Loader#_jsonLoadComplete
 * @private
 * @param {FORGE.File} file - The {@link FORGE.File} corresponding to the json file.
 * @param {XMLHttpRequest} xhr - The XMLHttpRequest response.
 */
FORGE.Loader.prototype._jsonLoadComplete = function(file, xhr)
{
    if (xhr.responseText)
    {
        file.data = Object(JSON.parse(xhr.responseText));

        if (this._viewer.cache.has(FORGE.Cache.types.JSON, file.key) === false)
        {
            this._viewer.cache.add(FORGE.Cache.types.JSON, file.key, file);
        }
        else
        {
            this.log("FORGE.Loader.json : JSON file already exists");
        }

        if (typeof file.onCompleteCallback === "function" && file.onCompleteContext !== null)
        {
            var callback = file.onCompleteCallback;
            var context = file.onCompleteContext;

            file.onCompleteCallback = null;
            file.onCompleteContext = null;
            file.onErrorCallback = null;
            file.onErrorContext = null;

            callback.call(context, file);
        }
    }
    else
    {
        throw "FORGE.Loader.json : JSON file empty ?";
    }
};

/**
 * Internal method called when the load of a json file return error.
 * @method FORGE.Loader#_jsonLoadError
 * @private
 * @param {FORGE.File} file - The {@link FORGE.File} corresponding to the json file.
 * @param {XMLHttpRequest} xhr - The XMLHttpRequest response.
 */
FORGE.Loader.prototype._jsonLoadError = function(file, xhr)
{
    if (xhr.responseText)
    {
        if (typeof file.onErrorCallback === "function" && file.onErrorContext !== null)
        {
            var callback = file.onErrorCallback;
            var context = file.onErrorContext;

            file.onCompleteCallback = null;
            file.onCompleteContext = null;
            file.onErrorCallback = null;
            file.onErrorContext = null;

            callback.call(context, file);
        }
    }
    else
    {
        throw "FORGE.Loader.json : JSON file empty ?";
    }
};

/**
 * Load a xml file.
 * @method FORGE.Loader#xml
 * @param  {string} key - The key for the xml file.
 * @param  {string} url - URL of the file.
 * @param  {Function} onCompleteCallback - The callback function called when file is completed.
 * @param  {Object} onCompleteContext - The callback context when file is completed.
 * @param  {Function} onErrorCallback - The callback function called on file error.
 * @param  {Object} onErrorContext - The callback context for file error.
 */
FORGE.Loader.prototype.xml = function(key, url, onCompleteCallback, onCompleteContext, onErrorCallback, onErrorContext)
{
    var file = new FORGE.File();
    file.type = "xml";
    file.key = key;
    file.url = url;
    file.onCompleteCallback = onCompleteCallback;
    file.onCompleteContext = onCompleteContext;
    file.onErrorCallback = onCompleteCallback;
    file.onErrorContext = onErrorContext;

    this._xhr(file, "document", this._xmlLoadComplete, this._xmlLoadError);
};

/**
 * Internal method called when a xml file is completed.
 * @method FORGE.Loader#_xmlLoadComplete
 * @private
 * @param {FORGE.File} file - The {@link FORGE.File} corresponding to the xml file.
 * @param {XMLHttpRequest} xhr - The XMLHttpRequest response.
 */
FORGE.Loader.prototype._xmlLoadComplete = function(file, xhr)
{
    if (xhr.responseXML)
    {
        file.data = xhr.responseXML;

        if (this._viewer.cache.has(FORGE.Cache.types.XML, file.key) === false)
        {
            this._viewer.cache.add(FORGE.Cache.types.XML, file.key, file);
        }
        else
        {
            this.log("FORGE.Loader.xml : XML file already exists");
        }

        if (typeof file.onCompleteCallback === "function" && file.onCompleteContext !== null)
        {
            var callback = file.onCompleteCallback;
            var context = file.onCompleteContext;

            file.onCompleteCallback = null;
            file.onCompleteContext = null;
            file.onErrorCallback = null;
            file.onErrorContext = null;

            callback.call(context, file);
        }
    }
    else
    {
        throw "FORGE.Loader.xml : XML file empty ?";
    }
};

/**
 * Internal method called when the load of a xml file return error.
 * @method FORGE.Loader#_xmlLoadError
 * @private
 * @param {FORGE.File} file - The {@link FORGE.File} corresponding to the xml file.
 * @param {XMLHttpRequest} xhr - The XMLHttpRequest response.
 */
FORGE.Loader.prototype._xmlLoadError = function(file, xhr)
{
    if (xhr.responseXML)
    {
        if (typeof file.onErrorCallback === "function" && file.onErrorContext !== null)
        {
            var callback = file.onErrorCallback;
            var context = file.onErrorContext;

            file.onCompleteCallback = null;
            file.onCompleteContext = null;
            file.onErrorCallback = null;
            file.onErrorContext = null;

            callback.call(context, file);
        }
    }
    else
    {
        throw "FORGE.Loader.xml : JSON file empty ?";
    }
};

/**
 * Load a sound file.
 * @method FORGE.Loader#sound
 * @param {string} key - The key for the sound file.
 * @param {string} url - The url of the sound file.
 * @param {Function} onCompleteCallback - The callback function called when file is completed.
 * @param {Object} onCompleteContext - The callback context when file is completed.
 * @param {boolean=} forceAudioTag - Is audio tag is forced ?
 */
FORGE.Loader.prototype.sound = function(key, url, onCompleteCallback, onCompleteContext, forceAudioTag)
{
    var file = new FORGE.File();
    file.type = "sound";
    file.key = key;
    file.url = url;
    file.onCompleteCallback = onCompleteCallback;
    file.onCompleteContext = onCompleteContext;

    if (this._viewer.audio.useWebAudio === true && forceAudioTag !== true)
    {
        this._xhr(file, "arraybuffer", this._soundLoadComplete);
    }
    else if (this._viewer.audio.useAudioTag === true || forceAudioTag === true)
    {
        this._loadAudioTag(file, this._soundLoadComplete, this);
    }
};

/**
 * Internal method called when a sound file is completed and use the WebAudio API.
 * @method FORGE.Loader#_soundLoadComplete
 * @private
 * @param {FORGE.File} file - The {@link FORGE.File} corresponding to the sound file.
 * @param {XMLHttpRequest=} xhr - The XMLHttpRequest response.
 */
FORGE.Loader.prototype._soundLoadComplete = function(file, xhr)
{
    if (this._viewer.audio.useWebAudio === true && typeof xhr !== "undefined")
    {
        file.data = xhr.response;
    }

    this._viewer.cache.add(FORGE.Cache.types.SOUND, file.key, file);

    if (typeof file.onCompleteCallback === "function" && file.onCompleteContext !== null)
    {
        file.onCompleteCallback.call(file.onCompleteContext, file);
    }
};

/**
 * Internal method called when a sound file is completed and use the AudioTag.
 * @method FORGE.Loader#_loadAudioTag
 * @private
 * @param {FORGE.File} file - The {@link FORGE.File} corresponding to the sound file.
 * @param {Function} callback - The callback function called when file is completed.
 * @param  {Object} context - The callback context when file is completed.
 */
FORGE.Loader.prototype._loadAudioTag = function(file, callback, context)
{
    // create an Audio element
    var audioElement = new Audio();

    var canPlayEvent = "canplay";
    var errorEvent = "error";
    var canPlayCallback = function()
    {
        this.removeEventListener(canPlayEvent, canPlayCallback);
        this.removeEventListener(errorEvent, errorCallback);

        if (typeof callback === "function")
        {
            file.data = this;
            callback.call(context, file);
        }
    };
    var errorCallback = function()
    {
        this.removeEventListener(canPlayEvent, canPlayCallback);
        this.removeEventListener(errorEvent, errorCallback);
        throw "FORGE.Loader : Could not load HTMLMediaElement " + file.url;
    };

    audioElement.addEventListener(canPlayEvent, canPlayCallback);
    audioElement.addEventListener(errorEvent, errorCallback);

    audioElement.preload = "auto";
    audioElement.crossOrigin = "anonymous";
    audioElement.src = file.url;
    audioElement.load();
};

/**
 * Internal method to load data from XMLHttpRequest.
 * @method FORGE.Loader#_xhr
 * @private
 * @param {FORGE.File} file - The {@link FORGE.File} corresponding to the file to load.
 * @param {string} type - The type of the object to load.
 * @param {Function} onComplete - The callback function called when file is completed.
 * @param {Function=} onError - The callback function for error during the load.
 * @param {Function=} onProgress - The callback function for the progress of the load.
 */
FORGE.Loader.prototype._xhr = function(file, type, onComplete, onError, onProgress)
{
    file.loading = true;

    var xhr = new XMLHttpRequest();
    xhr.open("GET", file.url, true);
    xhr.responseType = type;

    var length = 0;

    /** @this {XMLHttpRequest} */
    xhr.onreadystatechange = function()
    {
        if (xhr.readyState === XMLHttpRequest.DONE)
        {
            if (xhr.status === 200 || xhr.status === 0)
            {
                this.onreadystatechange = null;

                if (typeof onComplete === "function")
                {
                    file.loaded = true;
                    onComplete.call(this, file, xhr);
                }
            }
            else
            {
                throw "FORGE.Loader._xhr : Could not load " + file.url;
            }
        }
        else if (xhr.readyState === XMLHttpRequest.LOADING)
        {
            if (onProgress !== null && typeof onProgress !== "undefined")
            {
                if (length === 0)
                {
                    length = xhr.getResponseHeader("Content-Length");
                }

                if (typeof onProgress !== "undefined")
                {
                    onProgress(
                    {
                        "total": length,
                        "loaded": xhr.responseText.length
                    });
                }
            }
        }
        else if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED)
        {
            if (onProgress !== null && typeof onProgress !== "undefined")
            {
                length = xhr.getResponseHeader("Content-Length");
            }
        }

    }.bind(this);

    xhr.onerror = function()
    {
        if (typeof onError === "function")
        {
            onError.call(this, file, xhr);
        }
    }.bind(this);

    xhr.send();
};

/**
 * Load an image file.
 * @method FORGE.Loader#image
 * @param  {string} key - The key for the image file.
 * @param  {string} url - The url of the image file.
 * @param  {Function} success - The success callback function called when file is completed.
 * @param  {Function} error - The error callback function called when file won't load.
 * @param  {Object} context - The callbacks context when file is completed.
 */
FORGE.Loader.prototype.image = function(key, url, success, error, context)
{
    var file = new FORGE.File();
    file.type = "image";
    file.key = key;
    file.url = url;
    file.data = new Image();

    file.data.crossOrigin = "anonymous";

    file.data.onload = function()
    {
        file.data.onload = null;
        file.data.onerror = null;

        file.loading = false;
        file.loaded = true;

        this._viewer.cache.add(FORGE.Cache.types.IMAGE, file.key, file);

        if(typeof success === "function")
        {
            success.call(context, file);
        }

    }.bind(this);

    file.data.onerror = function()
    {
        file.data.onload = null;
        file.data.onerror = null;

        if(typeof error === "function")
        {
            error.call(context, file);
        }
        else
        {
            throw "ERROR : FORGE.Loader.image, failed to load image key : " + key + " at url " + url;
        }
    };

    file.data.src = file.url;
    file.loading = true;
};

/**
 * Load a script file.
 * @method FORGE.Loader#script
 * @param  {string} url - The url of the js file.
 * @param  {Function} callback - The callback function called when file is completed.
 * @param  {Object} context - The callback context when file is completed.
 */
FORGE.Loader.prototype.script = function(url, callback, context)
{
    var head = document.getElementsByTagName("head")[0];
    var scripts = head.getElementsByTagName("script");

    //Check if a script is not already in the head of the document
    for (var i = 0, ii = scripts.length; i < ii; i++)
    {
        if (scripts[i].src === url)
        {
            this.warn("Attempt to load an already loaded script!");
            callback.call(context);
            return;
        }
    }

    var script = document.createElement("script");
    script.type = "text/javascript";

    script.onload = function()
    {
        script.onload = null;
        callback.call(context);
    };

    script.src = url;
    head.appendChild(script);
};

/**
 * Load a CSS file.
 * @method FORGE.Loader#css
 * @param  {string} url - The url of the CSS file.
 * @param  {Function} callback - The callback function called when file is completed.
 * @param  {Object} context - The callback context when file is completed.
 */
FORGE.Loader.prototype.css = function(url, callback, context)
{
    var css = document.createElement("link");
    css.type = "text/css";
    css.rel = "stylesheet";

    if (typeof callback !== "undefined" && typeof context !== "undefined")
    {
        css.onload = function()
        {
            css.onload = null;
            callback.call(context);
        };
    }

    css.href = url;
    document.getElementsByTagName("head")[0].appendChild(css);
};

/**
 * Destroy sequence.
 * @method FORGE.Loader#destroy
 */
FORGE.Loader.prototype.destroy = function()
{
    this._viewer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Handle the time.
 * @constructor FORGE.Clock
 * @param {FORGE.Viewer} viewer - The {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.Clock = function(viewer)
{
    /**
     * The viewer reference.
     * @name FORGE.Clock#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The current time.
     * @name FORGE.Timer#_time
     * @type {number}
     * @private
     */
    this._time = 0;

    /**
     * Time from raf
     * @name FORGE.Clock#_rafTime
     * @type {number}
     * @private
     */
    this._rafTime = 0;

    /**
     * Started time.
     * @name FORGE.Timer#_started
     * @type {number}
     * @private
     */
    this._started = 0;

    /**
     * The {FORGE.Timer} list.
     * @name FORGE.Timer#_timers
     * @type {Array<FORGE.Timer>}
     * @private
     */
    this._timers = null;

    FORGE.BaseObject.call(this, "Clock");

    this._boot();
};

FORGE.Clock.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Clock.prototype.constructor = FORGE.Clock;

/**
 * Boot sequence.
 * @method FORGE.Clock#_boot
 * @private
 */
FORGE.Clock.prototype._boot = function()
{
    this._started = Date.now();
    this._time = Date.now();
    this._timers = [];
};

/**
 * Returns the timer identifier.
 * @method FORGE.Clock#_indexOfTimer
 * @param  {FORGE.Timer} timer - The timer to search for.
 * @return {number} Returns the {FORGE.Timer} identifier into the list of timers, if not, returns -1.
 * @private
 */
FORGE.Clock.prototype._indexOfTimer = function(timer)
{
    if(this._timers === null)
    {
        return -1;
    }

    var t;
    for ( var i = 0, ii = this._timers.length; i < ii; i++ )
    {
        t = this._timers[i];

        if(t === timer)
        {
            return i;
        }
    }

    return -1;
};

/**
 * Internal handler for timer destroy.
 * @method FORGE.Clock#_onTimerDestroy
 * @param  {FORGE.Event} event - The event.
 * @private
 */
FORGE.Clock.prototype._onTimerDestroy = function(event)
{
    var timer = /** @type {FORGE.Timer} */ (event.emitter);
    var index = this._indexOfTimer(timer);

    if(index !== -1)
    {
        this._timers.splice(index, 1);
    }
};

/**
 * Create a {FORGE.Timer} for the clock.
 * @method FORGE.Clock#create
 * @param  {boolean} autoDestroy - The timer must be destroyed once completed?
 * @return {FORGE.Timer} The created {@link FORGE.Timer}.
 */
FORGE.Clock.prototype.create = function(autoDestroy)
{
    var timer = new FORGE.Timer(this._viewer, autoDestroy);
    return this.add(timer);
};

/**
 * Add a {@link FORGE.Timer} to the clock.
 * @method FORGE.Clock#add
 * @param {FORGE.Timer} timer - The {FORGE.Timer} to add.
 * @return {FORGE.Timer} The added {@link FORGE.Timer}.
 */
FORGE.Clock.prototype.add = function(timer)
{
    this._timers.push(timer);
    timer.onDestroy.add(this._onTimerDestroy, this);
    return timer;
};

/**
 * Update clock on the main loop.
 * @method FORGE.Clock#update
 * @param  {number} time - Time in ms
 */
FORGE.Clock.prototype.update = function(time)
{
    this._rafTime = time;

    //Current TimeStamp
    this._time = Date.now();

    for(var i = 0, ii = this._timers.length; i < ii; i++)
    {
        this._timers[i].update(this._time);
    }
};

/**
 * Destroy method.
 * @method FORGE.Clock#destroy
 */
FORGE.Clock.prototype.destroy = function()
{
    this._viewer = null;

    var i = this._timers.length;
    while(i--)
    {
        this._timers[i].destroy();
    }

    this._timers = null;
};

/**
 * Get the time value.
 * @name FORGE.Clock#time
 * @readonly
 * @type {number}
 */
Object.defineProperty(FORGE.Clock.prototype, "time",
{
    /** @this {FORGE.Clock} */
    get: function()
    {
        return this._time;
    }
});


/**
 * Timer utility that work with {@link FORGE.Clock}.
 * @constructor FORGE.Timer
 * @param {FORGE.Viewer} viewer - The {@link FORGE.Viewer} reference.
 * @param {boolean} autoDestroy - Does the timer will autodestroy on time complete?
 * @extends {FORGE.BaseObject}
 */
FORGE.Timer = function(viewer, autoDestroy)
{
    /**
     * The viewer reference.
     * @name FORGE.Timer#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * Must be destoyed when time complete?
     * @name FORGE.Timer#_viewer
     * @type {boolean}
     * @private
     */
    this._autoDestroy = (typeof autoDestroy !== "undefined") ? autoDestroy : true;

    /**
     * The start time.
     * @name FORGE.Timer#_startTime
     * @type {number}
     * @private
     */
    this._startTime = 0;

    /**
     * Is timer running?
     * @name FORGE.Timer#_running
     * @type {boolean}
     * @private
     */
    this._running = false;

    /**
     * The time when paused.
     * @name FORGE.Timer#_pauseTime
     * @type {number}
     * @private
     */
    this._pauseTime = 0;

    /**
     * The number of pauses.
     * @name FORGE.Timer#_pauseTotal
     * @type {number}
     * @private
     */
    this._pauseTotal = 0;

    /**
     * Is timer paused?
     * @name FORGE.Timer#_paused
     * @type {boolean}
     * @private
     */
    this._paused = false;

    /**
     * The current time.
     * @name FORGE.Timer#_now
     * @type {number}
     * @private
     */
    this._now = 0;

    /**
     * The clock tick.
     * @name FORGE.Timer#_tick
     * @type {number}
     * @private
     */
    this._tick = 0;

    /**
     * Is timer expired?
     * @name FORGE.Timer#_expired
     * @type {boolean}
     * @private
     */
    this._expired = false;

    /**
     * The list of events.
     * @name FORGE.Timer#_events
     * @type {Array<FORGE.TimerEvent>}
     * @private
     */
    this._events = null;

     /**
     * Internal reference to the onStart {@link FORGE.EventDispatcher}.
     * @name FORGE.Timer#_onStart
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onStart = null;

     /**
     * Internal reference to the onPause {@link FORGE.EventDispatcher}.
     * @name FORGE.Timer#_onPause
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onPause = null;

    /**
     * Internal reference to the onResume {@link FORGE.EventDispatcher}.
     * @name FORGE.Timer#_onResume
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onResume = null;

     /**
     * Internal reference to the onStop {@link FORGE.EventDispatcher}.
     * @name FORGE.Timer#_onStop
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onStop = null;

    /**
     * Internal reference to the onComplete {@link FORGE.EventDispatcher}.
     * @name FORGE.Timer#_onComplete
     * @type {?FORGE.EventDispatcher}
     * @private
     */
    this._onComplete = null;

    FORGE.BaseObject.call(this, "Timer");

    this._boot();
};

FORGE.Timer.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Timer.prototype.constructor = FORGE.Timer;

/**
 * Boot sequence.
 * @method FORGE.Timer#_boot
 * @private
 */
FORGE.Timer.prototype._boot = function()
{
    this._events = [];
    this._now = Date.now();
};

/**
 * Update events.
 * @method FORGE.Timer#_updateEvents
 * @param  {number} baseTime - The reference time.
 * @private
 */
FORGE.Timer.prototype._updateEvents = function(baseTime)
{
    for(var i = 0; i < this._events.length; i++)
    {
        var event = this._events[i];

        if (event.pendingDelete === false)
        {
            // Work out how long there would have been from when the game paused until the events next tick
            var t = event.tick - baseTime;

            if (t < 0)
            {
                t = 0;
            }

            // Add the difference on to the time now
            event.tick = this._now + t;
        }
    }

    var d = this._nextTick - baseTime;

    if (d < 0)
    {
        this._nextTick = this._now;
    }
    else
    {
        this._nextTick = this._now + d;
    }
};

/**
 * Sort events list to get the next event.
 * @method FORGE.Timer#_sort
 * @private
 */
FORGE.Timer.prototype._sort = function()
{
    if (this._events.length > 0)
    {
        this._events.sort(this._sortCompare);
        this._nextTick = this._events[0].tick;
    }
};

/**
 * Sort comparison for events.
 * @param  {FORGE.TimerEvent} a - First event to compare.
 * @param  {FORGE.TimerEvent} b - Second event to compare.
 * @return {number} Returns 1 if bigger, -1 if lower, 0 if equal.
 * @private
 */
FORGE.Timer.prototype._sortCompare = function (a, b)
{
    if (a.tick < b.tick)
    {
        return -1;
    }
    else if (a.tick > b.tick)
    {
        return 1;
    }

    return 0;
};

/**
 * Clear pending events.
 * @method FORGE.Timer#_clearPendingEvents
 * @private
 */
FORGE.Timer.prototype._clearPendingEvents = function ()
{
    var count = this._events.length;

    while (count--)
    {
        if (this._events[count].pendingDelete === true)
        {
            this._events.splice(count, 1);
        }
    }
};

/**
 * Create an event in the timer.
 * @method FORGE.Timer#create
 * @param {number} delay - The delay to call the event.
 * @param {boolean} loop - Must be looped?
 * @param {number} repeatCount - Number of repetition.
 * @param {Function} callback - The callback function.
 * @param {Object} callbackContext - The context for the callback function.
 * @param {Array<*>} args - List of arguments.
 * @return {FORGE.TimerEvent} Returns the created event.
 */
FORGE.Timer.prototype.create = function(delay, loop, repeatCount, callback, callbackContext, args)
{

    delay = Math.round(delay);

    var tick = delay;

    if (this._now === 0)
    {
        tick += this._viewer.clock.time;
    }
    else
    {
        tick += this._now;
    }

    var event = new FORGE.TimerEvent(this, delay, tick, repeatCount, loop, callback, callbackContext, args);

    this._events.push(event);

    this._sort();

    this._expired = false;

    return event;
};

/**
 * Add an event in the timer
 * @method FORGE.Timer#add
 * @param {number} delay - The delay to call the event.
 * @param {Function} callback - The callback function.
 * @param {Object} callbackContext - The context for the callback function.
 * @param {...*} args - Arguments to pass to the timer event handler
 * @return {FORGE.TimerEvent} Returns the created event.
 */
//jscs:disable
FORGE.Timer.prototype.add = function(delay, callback, callbackContext, args)
{
    return this.create(delay, false, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));
};
//jscs:enable

/**
 * Repeat an event in the timer.
 * @method FORGE.Timer#repeat
 * @param {number} delay - The delay to call the event.
 * @param {number} repeatCount - The number of repetition.
 * @param {Function} callback - The callback function.
 * @param {Object}   callbackContext - The context for the callback function.
 * @return {FORGE.TimerEvent} Returns the created event.
 */
FORGE.Timer.prototype.repeat = function(delay, repeatCount, callback, callbackContext)
{
    return this.create(delay, false, repeatCount, callback, callbackContext, Array.prototype.splice.call(arguments, 4));
};

/**
 * Loop an event in the timer.
 * @method FORGE.Timer#loop
 * @param {number} delay - The delay to call the event.
 * @param {Function} callback - The callback function.
 * @param {Object} callbackContext - The context for the callback function.
 * @return {FORGE.TimerEvent} Returns the created event.
 */
FORGE.Timer.prototype.loop = function(delay, callback, callbackContext)
{
    return this.create(delay, true, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));
};

/**
 * Remove an event from the timer.
 * @method FORGE.Timer#remove
 * @param {FORGE.TimerEvent} event - The event to remove.
 * @return {boolean} Returns true if event has been removed, if not, returns false.
 */
FORGE.Timer.prototype.remove = function(event)
{
    for (var i = 0; i < this._events.length; i++)
    {
        if (this._events[i] === event)
        {
            this._events[i].pendingDelete = true;
            return true;
        }
    }

    return false;
};

/**
 * Start the timer.
 * @method FORGE.Timer#start
 */
FORGE.Timer.prototype.start = function()
{
    if(this._running === true)
    {
        return;
    }

    this._startTime = this._viewer.clock.time;
    this._running = true;

    var event;
    for (var i = 0; i < this._events.length; i++)
    {
        event = this._events[i];
        event.tick = event.delay + this._startTime;
    }

    if(this._onStart !== null)
    {
        this._onStart.dispatch();
    }
};

/**
 * Stop the timer.
 * @method FORGE.Timer#stop
 * @param {boolean} [clear=true] - Clear the events list.
 */
FORGE.Timer.prototype.stop = function(clear)
{
    this._running = false;

    if (clear !== false)
    {
        this._events.length = 0;
    }

    if(this._onStop !== null)
    {
        this._onStop.dispatch();
    }
};

/**
 * Pause the timer.
 * @method FORGE.Timer#pause
 */
FORGE.Timer.prototype.pause = function()
{
    if (this._running === false || this._paused === true)
    {
        return;
    }

    this._pauseTime = this._viewer.clock.time;
    this._paused = true;

    if(this._onPause !== null)
    {
        this._onPause.dispatch();
    }
};

/**
 * Resume the timer.
 * @method FORGE.Timer#resume
 */
FORGE.Timer.prototype.resume = function()
{
    if (this._paused === false)
    {
        return;
    }

    var now = this._viewer.clock.time;
    this._pauseTotal += now - this._now;

    this._now = now;
    this._updateEvents(this._pauseTime);
    this._paused = false;

    if(this._onResume !== null)
    {
        this._onResume.dispatch();
    }
};

/**
 * Update the timer from the main loop.
 * @method FORGE.Timer#update
 * @param {number} time - The current time.
 */
FORGE.Timer.prototype.update = function(time)
{
    if(this._paused === true)
    {
        return;
    }

    var elapsed = time - this._now;
    this._now = time;

    //If elapsed time is superior to 1000ms, we can consider that time has been paused by a brower tab change which makes the raf pause.
    if(elapsed > 1000)
    {
        this._updateEvents(time - elapsed);
    }

    this._clearPendingEvents();

    var count = this._events.length;
    var i = 0;
    var markedForDeletion = 0;

    if (this._running === true && this._now >= this._nextTick && count > 0)
    {
        var event;

        while (i < count && this._running === true)
        {
            event = this._events[i];

            if (this._now >= event.tick && event.pendingDelete === false)
            {
                //  (now + delay) - (time difference from last tick to now)
                var newTick = (this._now + event.delay) - (this._now - event.tick);

                if (newTick < 0)
                {
                    newTick = this._now + event.delay;
                }

                if (event.loop === true)
                {
                    event.tick = newTick;
                    event.execute();
                }
                else if (event.repeatCount > 0)
                {
                    event.repeatCount--;
                    event.tick = newTick;
                    event.execute();
                }
                else
                {
                    markedForDeletion++;
                    event.pendingDelete = true;
                    event.execute();
                }

                i++;
            }
            else
            {
                break;
            }
        }

        //  Are there any events left?
        if (this._events.length > markedForDeletion)
        {
            this._sort();
        }
        else
        {
            this._expired = true;
            this._running = false;

            if(this._onComplete !== null)
            {
                this._onComplete.dispatch();
            }
        }
    }

    if (this._expired && this._autoDestroy)
    {
        this.destroy();
    }

};

/**
 * Destroy method.
 * @method FORGE.Timer#destroy
 */
FORGE.Timer.prototype.destroy = function()
{
    this._running = false;
    this._events = [];

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get the auto destroy value.
 * @name FORGE.Timer#autoDestroy
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Timer.prototype, "autoDestroy",
{
    /** @this {FORGE.Timer} */
    get: function()
    {
        return this._autoDestroy;
    }
});

/**
 * Get the running value.
 * @name FORGE.Timer#running
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Timer.prototype, "running",
{
    /** @this {FORGE.Timer} */
    get: function()
    {
        return this._running;
    }
});

/**
 * Get the paused value.
 * @name FORGE.Timer#paused
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Timer.prototype, "paused",
{
    /** @this {FORGE.Timer} */
    get: function()
    {
        return this._paused;
    }
});

/**
 * Get the time tick at which the next event will occur.
 * @name FORGE.Timer#next
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Timer.prototype, "next",
{
    /** @this {FORGE.Timer} */
    get: function ()
    {
        return this._nextTick;
    }
});

/**
 * The duration in ms remaining until the next event will occur.
 * @name FORGE.Timer#duration
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Timer.prototype, "duration",
{
    /** @this {FORGE.Timer} */
    get: function ()
    {
        if (this._running && this._nextTick > this._now)
        {
            return this._nextTick - this._now;
        }
        else
        {
            return 0;
        }
    }
});

/**
 * The number of pending events in the queue.
 * @name FORGE.Timer#length
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Timer.prototype, "length",
{
    /** @this {FORGE.Timer} */
    get: function ()
    {
        return this._events.length;
    }
});

/**
 * The duration in milliseconds that this Timer has been running for.
 * @name FORGE.Timer#ms
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Timer.prototype, "ms",
{
    /** @this {FORGE.Timer} */
    get: function ()
    {
        if (this._running)
        {
            return this._now - this._startTime - this._pauseTotal;
        }
        else
        {
            return 0;
        }
    }
});

/**
 * The duration in seconds that this Timer has been running for.
 * @name FORGE.Timer#seconds
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Timer.prototype, "seconds",
{
    /** @this {FORGE.Timer} */
    get: function ()
    {
        if (this._running)
        {
            return this.ms * 0.001;
        }
        else
        {
            return 0;
        }
    }

});

/**
 * Get the "onStart" event {@link FORGE.EventDispatcher} of the timer.
 * @name FORGE.Timer#onStart
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Timer.prototype, "onStart",
{
    /** @this {FORGE.Timer} */
    get: function()
    {
        if(this._onStart === null)
        {
            this._onStart = new FORGE.EventDispatcher(this);
        }

        return this._onStart;
    }
});

/**
 * Get the "onPause" event {@link FORGE.EventDispatcher} of the timer.
 * @name FORGE.Timer#onPause
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Timer.prototype, "onPause",
{
    /** @this {FORGE.Timer} */
    get: function()
    {
        if(this._onPause === null)
        {
            this._onPause = new FORGE.EventDispatcher(this);
        }

        return this._onPause;
    }
});

/**
 * Get the "onResume" event {@link FORGE.EventDispatcher} of the timer.
 * @name FORGE.Timer#onResume
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Timer.prototype, "onResume",
{
    /** @this {FORGE.Timer} */
    get: function()
    {
        if(this._onResume === null)
        {
            this._onResume = new FORGE.EventDispatcher(this);
        }

        return this._onResume;
    }
});

/**
 * Get the "onStop" event {@link FORGE.EventDispatcher} of the timer.
 * @name FORGE.Timer#onStop
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Timer.prototype, "onStop",
{
    /** @this {FORGE.Timer} */
    get: function()
    {
        if(this._onStop === null)
        {
            this._onStop = new FORGE.EventDispatcher(this);
        }

        return this._onStop;
    }
});

/**
 * Get the "onComplete" event {@link FORGE.EventDispatcher} of the timer.
 * @name FORGE.Timer#onComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Timer.prototype, "onComplete",
{
    /** @this {FORGE.Timer} */
    get: function()
    {
        if(this._onComplete === null)
        {
            this._onComplete = new FORGE.EventDispatcher(this);
        }

        return this._onComplete;
    }
});

/**
 * Describe a timer event.
 *
 * @constructor FORGE.TimerEvent
 * @param {FORGE.Timer} timer - The {@link FORGE.Timer} that handle this event.
 * @param {number} delay - Delay in millisenconds.
 * @param {number} tick - The current clock tick.
 * @param {number} repeatCount - The number of time the timer should repeat itself.
 * @param {boolean} loop - Does the timer have to loop?
 * @param {Function} callback - The callback function for this timer timer event complete.
 * @param {Object} callbackContext - The context in which the callback have to be executed.
 * @param {Array<*>} args - The arguments to pass to the callback.
 */
FORGE.TimerEvent = function(timer, delay, tick, repeatCount, loop, callback, callbackContext, args)
{

    /**
     * The timer object.
     * @name FORGE.TimerEvent#timer
     * @type {FORGE.Timer}
     */
    this.timer = timer;

    /**
     * Delay in millisenconds.
     * @name FORGE.TimerEvent#delay
     * @type {number}
     */
    this.delay = delay;

    /**
     * The current clock tick.
     * @name FORGE.TimerEvent#tick
     * @type {number}
     */
    this.tick = tick;

    /**
     * The number of time the timer should repeat itself.
     * @name FORGE.TimerEvent#repeatCount
     * @type {number}
     */
    this.repeatCount = repeatCount - 1;

    /**
     * Does the timer have to loop?
     * @name FORGE.TimerEvent#loop
     * @type {boolean}
     */
    this.loop = loop;

    /**
     * The callback function for this timer event complete.
     * @name FORGE.TimerEvent#_callback
     * @type {Function}
     * @private
     */
    this._callback = callback;

    /**
     * The context in which the callback have to be executed.
     * @name FORGE.TimerEvent#_callbackContext
     * @type {Object}
     * @private
     */
    this._callbackContext = callbackContext;

    /**
     * List of arguments.
     * @name FORGE.TimerEvent#_args
     * @type {Array<*>}
     * @private
     */
    this._args = args;

    /**
     * Must be deleted?
     * @name FORGE.TimerEvent#pendingDelete
     * @type {boolean}
     */
    this.pendingDelete = false;
};

FORGE.TimerEvent.prototype.constructor = FORGE.TimerEvent;

/**
 * Execute the callback with arguments.
 * @method FORGE.TimerEvent#execute
 */
FORGE.TimerEvent.prototype.execute = function()
{
    this._callback.apply(this._callbackContext, this._args);
};


/**
 * Manages the {@link FORGE.Tween}.
 * @constructor FORGE.TweenManager
 * @param {FORGE.Viewer} viewer - The {@link FORGE.Viewer} reference.
 * @extends {FORGE.BaseObject}
 */
FORGE.TweenManager = function(viewer)
{
    /**
     * The viewer reference. 
     * @name FORGE.TweenManager#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The list of {FORGE.Tween}. 
     * @name FORGE.TweenManager#_tweens
     * @type {Array<FORGE.Tween>}
     * @private
     */
    this._tweens = [];

    FORGE.BaseObject.call(this, "TweenManager");
};

FORGE.TweenManager.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.TweenManager.prototype.constructor = FORGE.TweenManager;

/**
 * Internal handler to destroy a tween.
 * @method FORGE.TweenManager#_indexOfTween
 * @param {FORGE.Tween} tween - The {FORGE.Tween} to look for.
 * @return {number} Returns the tween identifier, if not, returns -1.
 * @private
 */
FORGE.TweenManager.prototype._indexOfTween = function(tween)
{
    for ( var i = 0, ii = this._tweens.length; i < ii; i++ )
    {
        if(tween === this._tweens[i])
        {
            return i;
        }
    }

    return -1;
};

/**
 * Internal handler to destroy a tween.
 * @method FORGE.TweenManager#_tweenDestroyHandler
 * @param {FORGE.Event} event - The event.
 * @private
 */
FORGE.TweenManager.prototype._tweenDestroyHandler = function(event)
{
    var tween = /** @type {FORGE.Tween} */ (event.emitter);
    this.remove(tween);
};

/**
 * Add a tween.
 * @method FORGE.TweenManager#add
 * @param {FORGE.Tween} tween - The {FORGE.Tween} to add.
 */
FORGE.TweenManager.prototype.add = function(tween)
{
    this._tweens.push(tween);
    tween.onDestroy.addOnce(this._tweenDestroyHandler, this);
};

/**
 * Remove a tween.
 * @method FORGE.TweenManager#remove
 * @param {FORGE.Tween} tween - The {FORGE.Tween} to remove.
 */
FORGE.TweenManager.prototype.remove = function(tween)
{
    var index = this._indexOfTween(tween);

    if(index !== -1)
    {
        this._tweens.splice(index, 1);
    }
};

/**
 * Update loop.
 * @method FORGE.TweenManager#update
 */
FORGE.TweenManager.prototype.update = function()
{
    for(var i = 0, ii = this._tweens.length; i < ii; i++)
    {
        this._tweens[i].update();
    }
};

/**
 * Destroy method.
 * @method FORGE.TweenManager#destroy
 */
FORGE.TweenManager.prototype.destroy = function()
{
    var count = this._tweens.length;
    while(count--)
    {
        this._tweens[count].destroy();
    }

    this._tweens = null;
    this._viewer = null;

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Utility class to interpolate objects values.
 * @constructor FORGE.Tween
 * @param {FORGE.Viewer} viewer - The {@link FORGE.Viewer} reference.
 * @param {Object} object - The object to interpolate its property.
 * @extends {FORGE.BaseObject}
 */
FORGE.Tween = function(viewer, object)
{
    /**
     * The viewer reference.
     * @name FORGE.Tween#_viewer
     * @type {FORGE.Viewer}
     * @private
     */
    this._viewer = viewer;

    /**
     * The targeted object.
     * @name FORGE.Tween#_object
     * @type {Object}
     * @private
     */
    this._object = object;

    /**
     * The tween properties.
     * @name FORGE.Tween#_properties
     * @type {Object<string,TweenProperties>}
     * @private
     */
    this._properties = null;

    /**
     * The easing method.
     * @name FORGE.Tween#_easing
     * @type {Function}
     * @private
     */
    this._easing = FORGE.Easing.LINEAR;

    /**
     * The start time.
     * @name FORGE.Tween#_startTime
     * @type {?number}
     * @private
     */
    this._startTime = null;

    /**
     * Is started?
     * @name FORGE.Tween#_started
     * @type {boolean}
     * @private
     */
    this._started = false;

    /**
     * Is stopped?
     * @name FORGE.Tween#_stopped
     * @type {boolean}
     * @private
     */
    this._stopped = false;

    /**
     * Is completed?
     * @name FORGE.Tween#_complete
     * @type {boolean}
     * @private
     */
    this._complete = false;

    /**
     * Tween start event dispatcher.
     * @name  FORGE.Tween#_onStart
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onStart = null;

    /**
     * Tween progress event dispatcher.
     * @name  FORGE.Tween#_onProgress
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onProgress = null;

    /**
     * Tween complete event dispatcher.
     * @name  FORGE.Tween#_onComplete
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onComplete = null;

    /**
     * Tween stop event dispatcher.
     * @name  FORGE.Tween#_onStop
     * @type {FORGE.EventDispatcher}
     * @private
     */
    this._onStop = null;

    FORGE.BaseObject.call(this, "Tween");
};

FORGE.Tween.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.Tween.prototype.constructor = FORGE.Tween;

/**
 * Set the tween properties.
 * @method  FORGE.Tween#to
 * @param  {Array|Object} values - Array of values.
 * @param  {number} duration - Duration of the tween.
 * @param  {Function=} easing - Easing value.
 * @return {FORGE.Tween} Returns the {FORGE.Tween} object.
 */
FORGE.Tween.prototype.to = function(values, duration, easing)
{
    if (this._properties === null)
    {
        this._properties = {};
    }

    for (var p in values)
    {
        this._properties[p] = {
            name: p,
            min: null,
            max: values[p],
            duration: typeof duration === "number" ? duration : 0,
            easing: typeof easing === "function" ? easing : null,
            started: false,
            complete: false,
            startTime: null
        };
    }

    return this;
};

/**
 * Start the tween.
 * @method  FORGE.Tween#start
 * @return {FORGE.Tween} Returns the {FORGE.Tween} object.
 */
FORGE.Tween.prototype.start = function()
{
    this._startTime = Date.now();
    this._started = true;
    this._stopped = false;
    this._complete = false;

    var prop;
    for (var p in this._properties)
    {
        prop = this._properties[p];
        prop.min = this._object[p];
        prop.max = typeof this._properties[p].max === "string" ? prop.min + parseInt(this._properties[p].max, 10) : prop.max;
        prop.started = true;
        prop.startTime = this._startTime;
    }

    if (this._onStart !== null)
    {
        this._onStart.dispatch();
    }

    return this;
};

/**
 * Stop the tween.
 * @method  FORGE.Tween#start
 * @return {FORGE.Tween} Returns the {FORGE.Tween} object.
 */
FORGE.Tween.prototype.stop = function()
{
    this._stopped = true;

    if (this._onStop !== null)
    {
        this._onStop.dispatch();
    }

    return this;
};

/**
 * Update loop.
 * @method  FORGE.Tween#update
 */
FORGE.Tween.prototype.update = function()
{
    if (this._started === false || this._complete === true || this._stopped === true)
    {
        return;
    }

    var prop;
    var notCompleteCount = 0;
    for (var p in this._properties)
    {
        prop = this._properties[p];

        if (prop.complete === false)
        {
            this._updateProperty(prop);
        }

        if (prop.complete === false)
        {
            notCompleteCount++;
        }
    }

    if (this._onProgress !== null)
    {
        this._onProgress.dispatch();
    }

    if (notCompleteCount === 0)
    {
        this._complete = true;

        if (this._onComplete !== null)
        {
            this._onComplete.dispatch();
        }
    }
};

/**
 * Update the tween properties.
 * @method  FORGE.Tween#_updateProperty
 * @param {Object} prop - The properties object.
 * @private
 */
FORGE.Tween.prototype._updateProperty = function(prop)
{
    var currentTime = Date.now();
    var deltaTime = currentTime - prop.startTime;

    prop.complete = deltaTime >= prop.duration;

    if (prop.complete === false)
    {
        var easing = prop.easing !== null ? prop.easing : this._easing;
        var y = easing(deltaTime / prop.duration);
        this._object[prop.name] = (y * (prop.max - prop.min) + prop.min);
    }
    else
    {
        this._object[prop.name] = prop.max;
    }
};

/**
 * Destroy method.
 * @method FORGE.Tween#destroy
 */
FORGE.Tween.prototype.destroy = function()
{
    this.stop();

    this._viewer = null;

    this._object = null;

    this._properties = null;

    this._easing = null;

    if (this._onStart !== null)
    {
        this._onStart.destroy();
        this._onStart = null;
    }

    if (this._onProgress !== null)
    {
        this._onProgress.destroy();
        this._onProgress = null;
    }

    if (this._onComplete !== null)
    {
        this._onComplete.destroy();
        this._onComplete = null;
    }

    if (this._onStop !== null)
    {
        this._onStop.destroy();
        this._onStop = null;
    }

    FORGE.BaseObject.prototype.destroy.call(this);
};

/**
 * Get and set the easing method.
 * @name  FORGE.Tween#easing
 * @type {Function}
 */
Object.defineProperty(FORGE.Tween.prototype, "easing",
{
    /** @this {FORGE.Tween} */
    get: function()
    {
        return this._easing;
    },

    /** @this {FORGE.Tween} */
    set: function(easing)
    {
        if (typeof easing === "string")
        {
            switch (easing)
            {
                case FORGE.EasingType.LINEAR:
                    this._easing = FORGE.Easing.LINEAR;
                    break;
                case FORGE.EasingType.SINE_IN:
                    this._easing = FORGE.Easing.SINE_IN;
                    break;
                case FORGE.EasingType.SINE_IN_OUT:
                    this._easing = FORGE.Easing.SINE_IN_OUT;
                    break;
                case FORGE.EasingType.SINE_OUT:
                    this._easing = FORGE.Easing.SINE_OUT;
                    break;
                case FORGE.EasingType.QUAD_IN:
                    this._easing = FORGE.Easing.QUAD_IN;
                    break;
                case FORGE.EasingType.QUAD_IN_OUT:
                    this._easing = FORGE.Easing.QUAD_IN_OUT;
                    break;
                case FORGE.EasingType.QUAD_OUT:
                    this._easing = FORGE.Easing.QUAD_OUT;
                    break;
                case FORGE.EasingType.CUBIC_IN:
                    this._easing = FORGE.Easing.CUBIC_IN;
                    break;
                case FORGE.EasingType.CUBIC_IN_OUT:
                    this._easing = FORGE.Easing.CUBIC_IN_OUT;
                    break;
                case FORGE.EasingType.CUBIC_OUT:
                    this._easing = FORGE.Easing.CUBIC_OUT;
                    break;
                case FORGE.EasingType.BOUNCE_OUT:
                    this._easing = FORGE.Easing.BOUNCE_OUT;
                    break;
                case FORGE.EasingType.BOUNCE_IN:
                    this._easing = FORGE.Easing.BOUNCE_IN;
                    break;
                default:
                    this._easing = FORGE.Easing.LINEAR;
                    break;
            }
        }
        else if (typeof easing === "function")
        {
            this._easing = easing;
        }
    }
});

/**
 * Get the complete flag value.
 * @name  FORGE.Tween#complete
 * @readonly
 * @type {boolean}
 */
Object.defineProperty(FORGE.Tween.prototype, "complete",
{
    /** @this {FORGE.Tween} */
    get: function()
    {
        return this._complete;
    }
});

/**
 * Get the onStart {@link FORGE.EventDispatcher}
 * @name  FORGE.Tween#onStart
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Tween.prototype, "onStart",
{
    /** @this {FORGE.Tween} */
    get: function()
    {
        if (this._onStart === null)
        {
            this._onStart = new FORGE.EventDispatcher(this);
        }

        return this._onStart;
    }
});

/**
 * Get the onProgress {@link FORGE.EventDispatcher}
 * @name  FORGE.Tween#onProgress
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Tween.prototype, "onProgress",
{
    /** @this {FORGE.Tween} */
    get: function()
    {
        if (this._onProgress === null)
        {
            this._onProgress = new FORGE.EventDispatcher(this);
        }

        return this._onProgress;
    }
});

/**
 * Get the onComplete {@link FORGE.EventDispatcher}
 * @name  FORGE.Tween#onComplete
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Tween.prototype, "onComplete",
{
    /** @this {FORGE.Tween} */
    get: function()
    {
        if (this._onComplete === null)
        {
            this._onComplete = new FORGE.EventDispatcher(this);
        }

        return this._onComplete;
    }
});

/**
 * Get the onStop {@link FORGE.EventDispatcher}
 * @name  FORGE.Tween#onStop
 * @readonly
 * @type {FORGE.EventDispatcher}
 */
Object.defineProperty(FORGE.Tween.prototype, "onStop",
{
    /** @this {FORGE.Tween} */
    get: function()
    {
        if (this._onStop === null)
        {
            this._onStop = new FORGE.EventDispatcher(this);
        }

        return this._onStop;
    }
});
/**
 * Namespace to store all easing methods.
 * @name FORGE.Easing
 * @type {Object}
 */
FORGE.Easing = {};

/**
 * @method FORGE.Easing.LINEAR
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
FORGE.Easing.LINEAR = function(t)
{
    var y = t;
    return FORGE.Math.clamp(y, 0, 1);
};

/**
 * @method FORGE.Easing.SINE_IN
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
FORGE.Easing.SINE_IN = function(t)
{
    var y = 1.0 + Math.sin(Math.PI / 2.0 * (t - 1.0));
    return FORGE.Math.clamp(y, 0, 1);
};

/**
 * @method FORGE.Easing.SINE_IN_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
FORGE.Easing.SINE_IN_OUT = function(t)
{
    var y = 0.5 * (1.0 + Math.sin(Math.PI / 2.0 * (2.0 * t - 1.0)));
    return FORGE.Math.clamp(y, 0, 1);
};

/**
 * @method FORGE.Easing.SINE_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
FORGE.Easing.SINE_OUT = function(t)
{
    var y = Math.sin(Math.PI / 2.0 * t);
    return FORGE.Math.clamp(y, 0, 1);
};

/**
 * @method FORGE.Easing.QUAD_IN
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
FORGE.Easing.QUAD_IN = function(t)
{
    var y = t * t;
    return FORGE.Math.clamp(y, 0, 1);
};

/**
 * @method FORGE.Easing.QUAD_IN_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
FORGE.Easing.QUAD_IN_OUT = function(t)
{
    var y;
    if (t < 0.5)
    {
        y = 2.0 * t * t;
    }
    else
    {
        y = 1.0 - 2.0 * (t - 1.0) * (t - 1.0);
    }

    return FORGE.Math.clamp(y, 0, 1);
};

/**
 * @method FORGE.Easing.QUAD_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
FORGE.Easing.QUAD_OUT = function(t)
{
    t = 1.0 - t;
    var y = 1.0 - (t * t);
    return FORGE.Math.clamp(y, 0, 1);
};

/**
 * @method FORGE.Easing.CUBIC_IN
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
FORGE.Easing.CUBIC_IN = function(t)
{
    var y = t * t * t;
    return FORGE.Math.clamp(y, 0, 1);
};

/**
 * @method FORGE.Easing.CUBIC_IN_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
FORGE.Easing.CUBIC_IN_OUT = function(t)
{
    var y;
    if (t < 0.5)
    {
        y = 4.0 * t * t * t;
    }
    else
    {
        y = 1.0 + 4.0 * (t - 1.0) * (t - 1.0) * (t - 1.0);
    }

    return FORGE.Math.clamp(y, 0, 1);
};

/**
 * @method FORGE.Easing.CUBIC_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
FORGE.Easing.CUBIC_OUT = function(t)
{
    t = 1.0 - t;
    var y = 1.0 - (t * t * t);
    return FORGE.Math.clamp(y, 0, 1);
};

/**
 * @method FORGE.Easing.BOUNCE_OUT
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
FORGE.Easing.BOUNCE_OUT = function (t)
{

    var y;
    if (t < 1 / 2.75)
    {
        y = 7.5625 * t * t;
    }
    else if (t < 2/2.75)
    {
        t = t - (1.5 / 2.75);
        y = 7.5625 * t * t + 0.75;
    }
    else if (t < 2.5 / 2.75)
    {
        t = t - 2.25 / 2.75;
        y = 7.5625 * t * t + 0.9375;
    }
    else
    {
        t = t - 2.625 / 2.75;
        y = 7.5625 * t * t + 0.984375;
    }
    return FORGE.Math.clamp(y, 0, 1);
};

/**
 * @method FORGE.Easing.BOUNCE_IN
 * @nocollapse
 * @param {number} t
 * @return {number}
 */
FORGE.Easing.BOUNCE_IN = function (t)
{
    return 1.0 - FORGE.Easing.BOUNCE_OUT(1-t);
};
/**
 * @namespace {Object} FORGE.EasingType
 */
FORGE.EasingType = {};

/**
 * @name FORGE.EasingType.LINEAR
 * @type {string}
 * @const
 */
FORGE.EasingType.LINEAR = "linear";

/**
 * @name FORGE.EasingType.SINE_IN
 * @type {string}
 * @const
 */
FORGE.EasingType.SINE_IN = "easeInSine";

/**
 * @name FORGE.EasingType.SINE_IN_OUT
 * @type {string}
 * @const
 */
FORGE.EasingType.SINE_IN_OUT = "easeInOutSine";

/**
 * @name FORGE.EasingType.SINE_OUT
 * @type {string}
 * @const
 */
FORGE.EasingType.SINE_OUT = "easeOutSine";

/**
 * @name FORGE.EasingType.QUAD_IN
 * @type {string}
 * @const
 */
FORGE.EasingType.QUAD_IN = "easeInQuad";

/**
 * @name FORGE.EasingType.QUAD_IN_OUT
 * @type {string}
 * @const
 */
FORGE.EasingType.QUAD_IN_OUT = "easeInOutQuad";

/**
 * @name FORGE.EasingType.QUAD_OUT
 * @type {string}
 * @const
 */
FORGE.EasingType.QUAD_OUT = "easeOutQuad";

/**
 * @name FORGE.EasingType.CUBIC_IN
 * @type {string}
 * @const
 */
FORGE.EasingType.CUBIC_IN = "easeInCubic";

/**
 * @name FORGE.EasingType.CUBIC_IN_OUT
 * @type {string}
 * @const
 */
FORGE.EasingType.CUBIC_IN_OUT = "easeInOutCubic";

/**
 * @name FORGE.EasingType.CUBIC_OUT
 * @type {string}
 * @const
 */
FORGE.EasingType.CUBIC_OUT = "easeOutCubic";

/**
 * @name FORGE.EasingType.BOUNCE_OUT
 * @type {string}
 * @const
 */
FORGE.EasingType.BOUNCE_OUT = "easeOutBounce";

/**
 * @name FORGE.EasingType.BOUNCE_IN
 * @type {string}
 * @const
 */
FORGE.EasingType.BOUNCE_IN = "easeInBounce";
/**
 * Global utilities.
 * @namespace  FORGE.Utils
 * @type {Object}
 */
FORGE.Utils = {};

/**
 * Convert a string value into a size object.
 * @method FORGE.Utils.parseSizeString
 * @param {string} value - The string value to convert.
 * @return {Object} A size object with value and unit.
 */
FORGE.Utils.parseSizeString = function(value)
{
    var result =
    {
        value: null,
        unit: null
    };

    if (typeof value === "string")
    {
        var size = parseInt(value, 10);
        if (isNaN(size) === false)
        {
            result.value = size;
        }

        if (value.indexOf("%") > -1)
        {
            result.unit = "%";
        }
        else if (value.indexOf("px") > -1)
        {
            result.unit = "px";
        }
    }

    return result;
};

/**
 * TODO. Use for config extend / override.
 * @method FORGE.Utils.extendSimpleObject
 * @param  {Object}   from
 * @param  {Object}   to
 * @param  {boolean=} recursive
 * @return {Object}
 */
FORGE.Utils.extendSimpleObject = function(from, to, recursive)
{
    var result = {};

    from = (typeof from !== "undefined") ? from : {};
    to = (typeof to !== "undefined") ? to : {};

    for (var f in from)
    {
        if (from.hasOwnProperty(f)) //to guarantee that keys are on the object instance itself
        {
            result[f] = from[f];
        }
    }

    for (var t in to)
    {
        if (to.hasOwnProperty(t)) //to guarantee that keys are on the object instance itself
        {
            if (recursive !== false && from !== null && to[t] !== null && typeof to[t] !== "undefined" && to[t].constructor === Object)
            {
                result[t] = FORGE.Utils.extendSimpleObject(from[t], to[t], true);
            }
            else
            {
                result[t] = to[t];
            }
        }
    }

    return result;
};

/**
 * Extend multiple object you pass in arguments, the last overrides the first and so on ...
 * @method  FORGE.Utils.extendMultipleObjects
 * @param  {...Object} obj - the objects to merge
 * @return {Object} return the merged objects.
 */
//jscs:disable
FORGE.Utils.extendMultipleObjects = function(obj)
{
    var objects = arguments;
    var res = {};

    for (var i = 0, ii = objects.length; i < ii; i++)
    {
        res = FORGE.Utils.extendSimpleObject(res, objects[i], true);
    }

    return res;
};
//jscs:enable

/**
 * Compare two objects
 * @method FORGE.Utils.compareObjects
 * @param  {*} objectA - The first object to compare
 * @param  {*} objectB - The second object to compare
 * @return {boolean} Returns true if the two objects are the same
 */
FORGE.Utils.compareObjects = function(objectA, objectB)
{
    if (typeof(objectA) !== typeof(objectB))
    {
        return false;
    }

    if (typeof(objectA) === "function")
    {
        return objectA.toString() === objectB.toString();
    }

    if (objectA instanceof Object && objectB instanceof Object)
    {
        if (FORGE.Utils.countProperties(objectA) !== FORGE.Utils.countProperties(objectB))
        {
            return false;
        }

        for (var prop in objectA)
        {
            if(FORGE.Utils.compareObjects(objectA[prop], objectB[prop]) === false)
            {
                return false;
            }
        }

        return true;
    }
    else
    {
        return objectA === objectB;
    }
};

/**
 * Count object properties
 * @method FORGE.Utils.countProperties
 * @param  {*} object
 * @return {number} Returns the count of the object's properties
 */
FORGE.Utils.countProperties = function(object)
{
    var count = 0;

    for (var i in object)
    {
        if (object.hasOwnProperty(i))
        {
            count++;
        }
    }

    return count;
};

/**
 * Clone an object deeply, without keeping a single reference.
 * @method FORGE.Utils.clone
 * @param  {*} obj - any object to clone
 * @return {*} the cloned object
 */
FORGE.Utils.clone = function(obj)
{
    if (!(obj instanceof Object))
    {
        return obj;
    }

    var clone = new obj.constructor();

    for (var prop in obj)
    {
        clone[prop] = FORGE.Utils.clone(obj[prop]);
    }

    return clone;
};

/**
 * Is the object a display object? Check the className.
 * @method FORGE.Utils.isDisplayObject
 * @param {Object} object - The object to verify.
 * @return {boolean} Returns true if the object is a display object.
 */
FORGE.Utils.isDisplayObject = function(object)
{
    if (object !== null && typeof object === "object")
    {
        if (typeof object.className === "string" && FORGE.DisplayList.types.indexOf(object.className) !== -1)
        {
            return true;
        }
    }

    return false;
};

/**
 * Is the className of the object can be verified?
 * @method FORGE.Utils.isTypeOf
 * @param {*} object - The object to verify.
 * @param {(string|Array<string>)} className - The className to search for, it can be a string or an array of string if you accept multiple types.
 * @return {boolean} Returns true if the className of the object can be verified.
 */
FORGE.Utils.isTypeOf = function(object, className)
{
    if (typeof className === "string" && ((object !== null && typeof object === "object" && typeof object.className === "string" && object.className.toLowerCase() === className.toLowerCase()) || typeof object === className.toLowerCase()))
    {
        return true;
    }
    else if (Array.isArray(className) === true && FORGE.Utils.isArrayOf(className, "string") === true)
    {
        for (var i = 0, ii = className.length; i < ii; i++)
        {
            if (FORGE.Utils.isTypeOf(object, className[i]) === true)
            {
                return true;
            }
        }
    }

    return false;
};

/**
 * Check the className of an object based on it's path (pointed syntax in string)<br>
 * Very usefull if you have to check a deep property without the knowing if all the parent chain is defined.
 * @method  FORGE.Utils.isTypeOfRecursive
 * @param  {Object}  object - The main object that handle the property you want to check.
 * @param  {string}  path - Path to the target you want to check (example : "image.url" on a button skin state)
 * @param  {string}  className - The className you want to check for
 * @return {boolean} Returns true if object is of the asked className, false if not or if it's not found.
 */
FORGE.Utils.isTypeOfRecursive = function(object, path, className)
{
    var pathArray = path.split(".");
    var currentObject = object;

    for (var i = 0, ii = pathArray.length; i < ii; i++)
    {
        currentObject = currentObject[pathArray[i]];

        if (i === ii - 1)
        {
            return FORGE.Utils.isTypeOf(currentObject, className);
        }
        else if (typeof currentObject === "undefined")
        {
            return false;
        }
    }

    return false;
};

/**
 * Know if array is an array full of object of a single ForgeJS className or classic JS types like string, number ...
 * @method FORGE.Utils.isArrayOf
 * @param  {*} array - The array to test.
 * @param  {string} className - The className to test if this array is exclusvie to this className.
 * @return {boolean} Returns true if the array is full of object with the className in params.
 */
FORGE.Utils.isArrayOf = function(array, className)
{
    if (typeof array === "object" && Array.isArray(array) === true)
    {
        for (var i = 0, ii = array.length; i < ii; i++)
        {
            if (FORGE.Utils.isTypeOf(array[i], className) === false)
            {
                return false;
            }
        }

        return true;
    }

    return false;
};


/**
 * Get an objet property by its string path in pointed syntax.
 * @method  FORGE.Utils.getObjectProperty
 * @param  {Object}  object - The main object that handle the property you want to check.
 * @param  {string}  property - Path to the property you want to get (example : "image.url" on a button skin state)
 * @param  {*=}  defaultReturnValue - The default return value if not found, if not specified the default is undefined
 * @return {*} Returns the property if found, if not found returns your defaultReturnValue or undefined.
 */
FORGE.Utils.getObjectProperty = function(object, property, defaultReturnValue)
{
    var pathArray = property.split(".");
    var currentObject = object;

    for (var i = 0, ii = pathArray.length; i < ii; i++)
    {
        currentObject = currentObject[pathArray[i]];

        //If current object is undefined, return default value or undefined
        if (typeof currentObject === "undefined")
        {
            return defaultReturnValue;
        }
        //If this is the target item (the last in property path)
        if (i === ii - 1)
        {
            return currentObject;
        }
    }

    return defaultReturnValue;
};

/**
 * Sort an array by property.
 * @method FORGE.Utils.sortArrayByProperty
 * @param  {Array} array - The array to test.
 * @param  {string} property - The property to sort.
 * @return {Array} Returns the sorted array.
 */
FORGE.Utils.sortArrayByProperty = function(array, property)
{
    var props = property.split(".");
    var len = props.length;

    array.sort(function(a, b)
    {
        var i = 0;

        while (i < len)
        {
            a = a[props[i]];
            b = b[props[i]];
            i++;
        }

        if (a < b)
        {
            return -1;
        }
        else if (a > b)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    });

    return array;
};

/**
 * Randomize the content of an array. Uses the Durstenfeld version of the
 * Fisher-Yates algorithm.
 * https://en.wikipedia.org/wiki/Fisher-Yates_shuffle#The_modern_algorithm
 * @method FORGE.Utils.randomize
 * @param  {Array<*>} array - The array to randomize
 * @return {Array<*>}         The randomized array
 */
FORGE.Utils.randomize = function(array)
{
    var res = array.slice();
    var temp, j;

    for (var i = res.length - 1; i > 0; i--)
    {
        j = ~~(Math.random() * (i + 1));

        temp = res[i];
        res[i] = res[j];
        res[j] = temp;
    }

    return res;
};

/**
 * Fill a string from the left
 * @method FORGE.Utils.leftFill
 * @param {string} string - String to fill.
 * @param {string|number} fillCharacter - Char or string to fill with.
 * @param {number} length - The length for the output string.
 * @return {string} The filled string.
 */
FORGE.Utils.leftFill = function(string, fillCharacter, length)
{
    var str = String(string);

    while (str.length < length)
    {
        str = fillCharacter + str;
    }

    return str;
};

/**
 * Parse seconds value in hours, minutes and seconds components.
 * @method FORGE.Utils.parseTime
 * @param {number} seconds - Seconds to parse.
 * @return {Object} Parsed values in an object.
 */
FORGE.Utils.parseTime = function(seconds)
{
    var time = {
        "input": seconds,
        "hours": 0,
        "minutes": 0,
        "seconds": 0
    };

    //If input is not a parsable value, return time with default values
    if (typeof time.input !== "number" || isNaN(time.input))
    {
        return time;
    }

    time.hours = parseInt(time.input / 3600, 10) % 24;
    time.minutes = parseInt(time.input / 60, 10) % 60;
    time.seconds = parseInt(time.input % 60, 10);

    return time;
};

/**
 * Format a timestamp according to a format (eg: H:M:S)<br>
 * H = hours two digits.<br>
 * h = hours no 0 fill.<br>
 * M = minutes two digits.<br>
 * m = minutes no 0 fill.<br>
 * S = seconds two digits.<br>
 * s = seconds no 0 fill.
 * @method FORGE.Utils.formatTime
 * @param  {number} time - Timestamp in seconds.
 * @param  {string} format - The out format for time (default "H:M:S").
 * @return {string} Returns the formated time string.
 */
FORGE.Utils.formatTime = function(time, format)
{
    var parsed = FORGE.Utils.parseTime(time);

    var f = (typeof format === "string") ? format : "H:M:S";

    var h = 0;
    if (f.indexOf("H") !== -1)
    {
        h = 2;
    }
    else if (f.indexOf("h") !== -1)
    {
        h = 1;
    }

    var m = 0;
    if (f.indexOf("M") !== -1)
    {
        m = 2;
    }
    else if (f.indexOf("m") !== -1)
    {
        m = 1;
    }

    var s = 0;
    if (f.indexOf("S") !== -1)
    {
        s = 2;
    }
    else if (f.indexOf("s") !== -1)
    {
        s = 1;
    }

    var result = f.toLowerCase();

    if (h > 0)
    {
        result = result.replace("h", FORGE.Utils.leftFill(parsed.hours, 0, h));
    }

    if (m > 0)
    {
        result = result.replace("m", FORGE.Utils.leftFill(parsed.minutes, 0, m));
    }

    if (s > 0)
    {
        result = result.replace("s", FORGE.Utils.leftFill(parsed.seconds, 0, s));
    }

    return result;
};

/**
 * Get an array by difference with another array
 * @method FORGE.Utils.arrayByDifference
 * @param  {Array} array input array to be filtered
 * @param  {Array} elements elements to be excluded in result array
 * @return {Array} difference array (array - elements)
 */
FORGE.Utils.arrayByDifference = function(array, elements)
{
    return array.filter(function(i)
    {
        return elements.indexOf(i) < 0;
    });
};


/**
 * Get an array of unique elements from a given array
 * @method FORGE.Utils.arrayUnique
 * @param  {Array} array input array to be filtered
 * @return {Array} array of unique elements
 */
FORGE.Utils.arrayUnique = function(array)
{
    return array.filter(function(item, index, items)
    {
        return items.indexOf(item) === index;
    });
};

/**
 * Remove and return item from an array at given index
 * @method FORGE.Utils.removeItemFromArrayAtIndex
 * @param {Array} array input array
 * @param {number} idx item index
 * @return {Object} removed array item or null if index was out of bounds
 */
FORGE.Utils.removeItemFromArrayAtIndex = function(array, idx)
{
    if (idx >= array.length)
    {
        return null;
    }

    return array.splice(idx, 1);
};

/**
 * endsWith ES6 implementation
 * @param  {string} str
 * @param  {string} suffix
 * @return {boolean} Ends with suffix?
 */
FORGE.Utils.endsWith = function(str, suffix)
{
    if (typeof String.prototype.endsWith !== "function")
    {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }

    return str.endsWith(suffix);
};

/**
 * Polyfill of Array.prototype.keys in ES5.
 *
 * @method FORGE.Utils.arrayKeys
 * @param {(Array|TypedArray)} array - Array to iterate.
 * @return {(IteratorIterable|Object)} Iterator
 * @see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys
 */
FORGE.Utils.arrayKeys = function(array)
{
    if (!Array.prototype.keys)
    {
        var len, result = {}, nextIndex = 0;
        len = array.length;
        result.array = [];
        result.length = array.length;
        while (len > 0) result.array[--len] = len;
        result.next = function()
        {
            return nextIndex < array.length ? {value: nextIndex++, done: false} : {done: true};
        };
        return result;
    }

    return array.keys();
};

/**
 * Make a new promise
 * Returned promise has accessors on resolve and reject to call them out of definition scope
 * @return {Promise} extended promise
 */
FORGE.Utils.makePromise = function()
{
    var resolveFn, rejectFn;

    var promise = new Promise(function(resolve, reject)
    {
        resolveFn = resolve;
        rejectFn = reject;
    });

    promise.resolve = resolveFn;
    promise.reject = rejectFn;

    return promise;
};



/**
 * Dom manager interface.
 * @type {Object}
 * @namespace FORGE.Dom
 */
FORGE.Dom = {};

/**
 * Get a CSS property.
 * @method FORGE.Dom.getCssProperty
 * @param  {Element} dom - DOM element to evaluate.
 * @param  {string} property - The CSS property you want to get.
 * @return {string} Returns the CSS property.
 */
FORGE.Dom.getCssProperty = function(dom, property)
{
    //If I want to get the real percent value, I have to temporarly hide the object to have it's true CSS value.
    var display = window.getComputedStyle(dom, null).getPropertyValue("display");
    dom.style.display = "none";

    var result = window.getComputedStyle(dom, null).getPropertyValue(property);
    dom.style.display = display;

    return result;
};

/**
 * Get the unit width of an element.
 * @method FORGE.Dom.getUnitWidth
 * @param  {Element} dom - DOM element to evaluate.
 * @return {string} Returns the unit. Can be px or %.
 */
FORGE.Dom.getUnitWidth = function(dom)
{
    var width = FORGE.Dom.getCssProperty(dom, "width");
    var unit = "px";

    if(width.indexOf("%") > -1)
    {
        unit = "%";
    }

    if(width.indexOf("px") > -1)
    {
        unit = "px";
    }

    return unit;
};

/**
 * Get the width value of an element.
 * @method FORGE.Dom.getValueWidth
 * @param  {Element} dom - DOM element to evaluate.
 * @return {number} Returns the width.
 */
FORGE.Dom.getValueWidth = function(dom)
{
    var width = parseInt(FORGE.Dom.getCssProperty(dom, "width"), 10);
    return isNaN(width) ? 0 : width;
};


/**
 * Get the unit height of an element.
 * @method FORGE.Dom.getUnitHeight
 * @param  {Element} dom - DOM element to evaluate.
 * @return {string} Returns the unit. Can be px or %.
 */
FORGE.Dom.getUnitHeight = function(dom)
{
    var height = FORGE.Dom.getCssProperty(dom, "height");
    var unit = "px";

    if(height.indexOf("%") > -1)
    {
        unit = "%";
    }

    if(height.indexOf("px") > -1)
    {
        unit = "px";
    }

    return unit;
};

/**
 * Get the height value of an element.
 * @method FORGE.Dom.getValueHeight
 * @param  {Element} dom - DOM element to evaluate.
 * @return {number} Returns the height.
 */
FORGE.Dom.getValueHeight = function(dom)
{
    var height = parseInt(FORGE.Dom.getCssProperty(dom, "height"), 10);
    return isNaN(height) ? 0 : height;
};

/**
 * Verify if a dom element is on document
 * @param  {Element|HTMLElement}  dom - dom element you want to check
 * @return {boolean}     Returns true if the dom element is in document, false if not
 */
FORGE.Dom.has = function(dom)
{
    return document.body.contains(dom);
};

/**
 * Is it an HTMLElement?
 * @method FORGE.Dom.isHtmlElement
 * @param  {*} dom - DOM element to evaluate.
 * @return {boolean} Returns true if element is an HTMLElement, if not, false.
 */
FORGE.Dom.isHtmlElement = function(dom)
{
    return dom instanceof HTMLElement;
};

/**
 * Get mouse/pointer/touch offset values for an element.
 * @method FORGE.Dom.getMouseEventOffset
 * @param  {(Event|MouseEvent|HammerEvent)} event - The event.
 * @return {Object} Object which describe the x and y offset values.
 */
FORGE.Dom.getMouseEventOffset = function(event)
{
    var rect, offsetX, offsetY;

    // If the event is coming from HammerJS, the native MouseEvent, PointerEvent or TouchEvent is in srcEvent property
    // Hammer.js event
    var nativeEvents = [ "MouseEvent", "PointerEvent", "TouchEvent" ];
    if(typeof event.srcEvent === "object" && nativeEvents.indexOf(event.srcEvent.constructor.toString()))
    {
        rect = event.target.getBoundingClientRect();
        offsetX = event.srcEvent.clientX - rect.left;
        offsetY = event.srcEvent.clientY - rect.top;
    }
    // Classic MouseEvent case
    else
    {
        var target = event.currentTarget || event.target || event.srcElement;
        rect = target.getBoundingClientRect();
        offsetX = event.clientX - rect.left;
        offsetY = event.clientY - rect.top;
    }

    return { x: offsetX, y: offsetY };
};


/**
 * Describe a Map.
 * @constructor FORGE.Map
 *
 * @todo be carreful with 'key' which can be a keyword as "length" !
 */
FORGE.Map = function()
{
    /**
     * The number of elements into the Map.
     * @name FORGE.Map#_count
     * @type {number}
     * @private
     */
    this._count = 0;

    /**
     * The map object.
     * @name FORGE.Map#_map
     * @type {Object}
     * @private
     */
    this._map = {};
};

FORGE.Map.prototype.constructor = FORGE.Map;

/**
 * Set an element into the Map.
 * @method FORGE.Map.set
 * @param {string} key - The key to assign.
 * @param {?} item - The item to add.
 * @return {number|undefined} The size of the Map.
 */
FORGE.Map.prototype.set = function(key, item)
{
    if (typeof key === "undefined")
    {
        return undefined;
    }

    if (this._map[key] === undefined)
    {
        this._count++;
    }

    this._map[key] = item;

    return this._count;
};

/**
 * Delete an element into the Map.
 * @method FORGE.Map.delete
 * @param {string} key - The key to search for.
 * @return {number|undefined} The size of the Map.
 */
FORGE.Map.prototype.delete = function(key)
{
    if (typeof key === "undefined" || this._map[key] === undefined)
    {
        return undefined;
    }

    delete this._map[key];
    return --this._count;
};

/**
 * Get an element of the Map.
 * @method FORGE.Map.get
 * @param {string} key - The key to search for.
 * @return {?} The item linked to the key.
 */
FORGE.Map.prototype.get = function(key)
{
    return this._map[key];
};

/**
 * The list of the keys.
 * @method FORGE.Map.keys
 * @return {Array<String>} The list of all the Map keys.
 */
FORGE.Map.prototype.keys = function()
{
    var keys = new FORGE.Collection();

    for (var key in this._map)
    {
        keys.add(key);
    }

    return keys.toArray();
};

/**
 * The list of the values.
 * @method FORGE.Map.values
 * @return {Array<?>} The list of all the Map values.
 */
FORGE.Map.prototype.values = function()
{
    var values = new FORGE.Collection();

    for (var key in this._map)
    {
        values.add(this._map[key]);
    }

    return values.toArray();
};

/**
 * The whole content of the Map.
 * @method FORGE.Map.entries
 * @return {Array} The complete key-value list of the Map.
 */
FORGE.Map.prototype.entries = function()
{
    var entries = new FORGE.Collection();

    for (var key in this._map)
    {
        var entry = [];
        entry.push(key);
        entry.push(this._map[key]);
        entries.add(entry);
    }

    return entries.toArray();
};

/**
 * Clear the Map object.
 * @method FORGE.Map.clear
 */
FORGE.Map.prototype.clear = function()
{
    for (var key in this._map)
    {
        this.delete(key);
    }
};

/**
 * Has an element into the Map?
 * @method FORGE.Map.has
 * @param {string} key - The key to search for.
 * @return {boolean} Returns true if an item corresponding to the key is found, if not, returns false.
 */
FORGE.Map.prototype.has = function(key)
{
    return (this._count > 0 && this._map[key] !== undefined);
};

/**
 * Get the size of the Map.
 * @name FORGE.Map.size
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Map.prototype, "size",
{
    /** @this {FORGE.Map} */
    get: function()
    {
        return this._count;
    }
});


/**
 * Describe a collection of elements.
 * @constructor FORGE.Collection
 */
FORGE.Collection = function() 
{
    /**
     * The elements list.
     * @name FORGE.Collection#_elements
     * @type {Array<*>}
     * @private
     */
    this._elements = [];
};

FORGE.Collection.prototype.constructor = FORGE.Collection;

/**
 * Add an element of the list.
 * @method FORGE.Collection.add
 * @param {*} item - The item to add.
 * @return {number} The size of the elements list.
 */
FORGE.Collection.prototype.add = function(item)
{
    this._elements.push(item);
    return this._elements.length;
};

/**
 * Remove an element of the list.
 * @method FORGE.Collection.remove
 * @param {*} item - The item to remove.
 */
FORGE.Collection.prototype.remove = function(item)
{
    for(var i = 0, ii = this._elements.length; i < ii; i++)
    {
        if(this._elements[i] === item)
        {
            this._elements.splice(i, 1);
        }
    }
};

/**
 * Get an element of the list.
 * @method FORGE.Collection.get
 * @param {number} index - The element index to search for.
 * @return {*} Returns an element.
 */
FORGE.Collection.prototype.get = function(index)
{
    return this._elements[index];
};

/**
 * Returns the elements list array.
 * @method FORGE.Collection.toArray
 * @return {Array} Returns the elements list.
 */
FORGE.Collection.prototype.toArray = function()
{
    return this._elements;
};

/**
 * Get the size of the elements list.
 * @name FORGE.Collection.size
 * @type {number}
 * @readonly
 */
Object.defineProperty(FORGE.Collection.prototype, "size",
{
    /** @this {FORGE.Collection} */
    get: function()
    {
        return this._elements.length;
    }
});


/**
 * Utility for URL.
 * @constructor FORGE.URL
 * @param {string=} url - The URL to use.
 * @extends {FORGE.BaseObject}
 *
 * @todo  exists method is a POC
 */
FORGE.URL = function(url)
{
    /**
     * The full URL.
     * @name FORGE.URL#_url
     * @type {string|undefined}
     * @private
     */
    this._url = url;

    /**
     * The protocol of the URL (http or https).
     * @name FORGE.URL#_protocol
     * @type {string}
     * @private
     */
    this._protocol = "";

    /**
     * The host for the URL.
     * @name FORGE.URL#_host
     * @type {string}
     * @private
     */
    this._host = "";

    /**
     * The port used in the URL.
     * @name FORGE.URL#_port
     * @type {string}
     * @private
     */
    this._port = "";

    /**
     * The path of the URL.
     * @name FORGE.URL#_path
     * @type {string}
     * @private
     */
    this._path = "";

    /**
     * The query string of the URL.
     * @name FORGE.URL#_query
     * @type {string}
     * @private
     */
    this._query = "";

    /**
     * The hash of the URL (slug name in there).
     * @name FORGE.URL#_hash
     * @type {string}
     * @private
     */
    this._hash = "";

    /**
     * This object contains hash parameters key / value.
     * @name  FORGE.URL#_hashParameters
     * @type {Object}
     * @private
     */
    this._hashParameters = null;

    /**
     * The extension of a file in URL.
     * @name FORGE.URL#_extension
     * @type {string}
     * @private
     */
    this._extension = "";

    FORGE.BaseObject.call(this, "URL");
};

FORGE.URL.prototype = Object.create(FORGE.BaseObject.prototype);
FORGE.URL.prototype.constructor = FORGE.URL;

/**
 * Parse the given URL.
 * @method  FORGE.URL.parse
 * @param  {string=} url - The URL to parse.
 * @return {FORGE.URL} Returns the a new FORGE.URL with parsed data.
 */
FORGE.URL.parse = function(url)
{
    var result = new FORGE.URL();

    if(typeof url !== "string")
    {
        //throw "FORGE.URL : Can't parse an undefined URL!";
        url = window.location.toString();
    }

    result._url = url;

    var a = document.createElement("a");
    a.href = result._url;

    result._protocol = a.protocol;
    result._host = a.hostname;
    result._port = a.port;
    result._path = a.pathname;
    result._query = a.search;
    result._hash = a.hash;
    result._extension = result._path.substr(result._path.lastIndexOf(".") + 1);

    if(result._hash !== "")
    {
        var hash = result._hash.replace("#", "");
        var hashComponents = hash.split("&");

        var parameters = {};
        parameters.slug = hashComponents[0];

        for(var i = 1, ii = hashComponents.length; i < ii; i++)
        {
            var item = hashComponents[i].split("=");
            parameters[item[0]] = decodeURIComponent(item[1]);
        }

        result._hashParameters = parameters;
    }

    return result;
};

/**
 * Check if a given url exists.
 * Beware of cross domain, work only on the same domain.
 * @method  FORGE.URL.exists
 * @param  {string} url - The URL to test.
 * @param  {Function} success - The callback to call when test is succeed.
 * @param  {Function} fail - The callback to call when test is failed.
 * @param  {Object} context - The context in which to call the callback.
 */
FORGE.URL.exists = function(url, success, fail, context)
{
    var xhr = new XMLHttpRequest();
    var exists = false;
    var timeout = null;

    /** @this {XMLHttpRequest} */
    xhr.onreadystatechange = function()
    {
        if(this.readyState === XMLHttpRequest.DONE)
        {
            if(this.status === 200)
            {
                exists = true;
                clearTimeout(timeout);

                if(typeof success === "function")
                {
                    success.call(context);
                }

            }
        }
    };

    xhr.onerror = function(event)
    {
        console.log(event);
    };

    xhr.open("HEAD", url);
    xhr.send();

    var timeoutCallback = function()
    {
        if(typeof fail === "function")
        {
            fail.call(context);
        }

    };

    timeout = window.setTimeout(timeoutCallback, 500);
};

/**
 * Check if a URL is valid.
 * Works only for absolute URLs.
 * @method  FORGE.URL.isValid
 * @param  {string} url - The URL to test.
 * @return {boolean} Returns true if URL is valid.
 */
FORGE.URL.isValid = function(url)
{
    var urlRegEx = /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[\-;:&=\+\$,\w]+@)?[A-Za-z0-9\.\-]+|(?:www\.|[\-;:&=\+\$,\w]+@)[A-Za-z0-9\.\-]+)((?:\/[\+~%\/\.\w\-]*)?\??(?:[\-\+=&;%@\.\w]*)#?(?:[\.\!\/\\\w]*))?)/;

    if(!urlRegEx.test(url))
    {
        return false;
    }

    return true;
};

/**
 * Get the full URL.
 * @name FORGE.URL#url
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.URL.prototype, "url",
{
    /** @this {FORGE.URL} */
    get: function()
    {
        return this._url;
    }
});

/**
 * Get the protocol of the URL.
 * @name FORGE.URL#protocol
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.URL.prototype, "protocol",
{
    /** @this {FORGE.URL} */
    get: function()
    {
        return this._protocol;
    }
});

/**
 * Get the host of the URL.
 * @name FORGE.URL#host
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.URL.prototype, "host",
{
    /** @this {FORGE.URL} */
    get: function()
    {
        return this._host;
    }
});

/**
 * Get the port of the URL.
 * @name FORGE.URL#port
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.URL.prototype, "port",
{
    /** @this {FORGE.URL} */
    get: function()
    {
        return this._port;
    }
});

/**
 * Get the path of the URL.
 * @name FORGE.URL#path
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.URL.prototype, "path",
{
    /** @this {FORGE.URL} */
    get: function()
    {
        return this._path;
    }
});

/**
 * Get the query of the URL.
 * @name FORGE.URL#query
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.URL.prototype, "query",
{
    /** @this {FORGE.URL} */
    get: function()
    {
        return this._query;
    }
});

/**
 * Get the hash of the URL.
 * @name FORGE.URL#hash
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.URL.prototype, "hash",
{
    /** @this {FORGE.URL} */
    get: function()
    {
        return this._hash;
    }
});

/**
 * Get the hash parameters of the URL.
 * @name FORGE.URL#hashParameters
 * @readonly
 * @type {Object}
 */
Object.defineProperty(FORGE.URL.prototype, "hashParameters",
{
    /** @this {FORGE.URL} */
    get: function()
    {
        return this._hashParameters;
    }
});

/**
 * Get the extension of the URL.
 * @name FORGE.URL#extension
 * @readonly
 * @type {string}
 */
Object.defineProperty(FORGE.URL.prototype, "extension",
{
    /** @this {FORGE.URL} */
    get: function()
    {
        return this._extension;
    }
});

/**
 * @namespace FORGE.Color
 */
FORGE.Color = {};

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.<br>
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 * @method FORGE.Color.rgbToHsl
 * @param {number} r - The red color value.
 * @param {number} g - The green color value.
 * @param {number} b - The blue color value.
 * @return {HSLColor} The HSL representation.
 */
FORGE.Color.rgbToHsl = function(r, g, b)
{
    r /= 255;
    g /= 255;
    b /= 255;

    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if (max === min)
    {
        h = s = 0; // achromatic
    }
    else
    {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h:h, s:s, l:l };
};

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.<br>
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 * @method FORGE.Color.hslToRgb
 * @param {number} h - The hue
 * @param {number} s - The saturation
 * @param {number} l - The lightness
 * @return {RGBaColor} The RGB representation
 */
FORGE.Color.hslToRgb = function(h, s, l)
{
    var r, g, b;

    if (s === 0)
    {
        r = g = b = l; // achromatic
    }
    else
    {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;

        r = FORGE.Color.hueToRgb(p, q, h + 1/3);
        g = FORGE.Color.hueToRgb(p, q, h);
        b = FORGE.Color.hueToRgb(p, q, h - 1/3);
    }

    return {r: r * 255, g: g * 255, b: b * 255};
};

/**
 * Convert hue to rgb.
 * @method FORGE.Color.hueToRgb
 * @param  {number} p
 * @param  {number} q
 * @param  {number} t
 * @return {number}
 */
FORGE.Color.hueToRgb = function(p, q, t)
{
    if (t < 0)
    {
        t += 1;
    }
    else if (t > 1)
    {
        t -= 1;
    }
    else if (t < 1 / 6)
    {
        return p + (q - p) * 6 * t;
    }
    else if (t < 1 / 2)
    {
        return q;
    }
    else if (t < 2 / 3)
    {
        return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
};

/**
 * Converts an RGB color value to HSV. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and v in the set [0, 1].
 * @method  FORGE.Color.rgbToHsv
 * @param {number} r - The red color value.
 * @param {number} g - The green color value.
 * @param {number} b - The blue color value.
 * @return {HSVColor} The HSV representation.
 */
FORGE.Color.rgbToHsv = function(r, g, b)
{
    r /= 255;
    g /= 255;
    b /= 255;

    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if (max === min)
    {
        h = 0; // achromatic
    }
    else
    {
        switch (max)
        {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return {h: h, s: s, v: v};
};

/**
 * Converts an HSV color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.<br>
 * Assumes h, s, and v are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 * @method  FORGE.Color.hsvToRgb
 * @param {number} h - The hue
 * @param {number} s - The saturation
 * @param {number} v - The value
 * @return {RGBaColor} The RGB representation
 */
FORGE.Color.hsvToRgb = function(h, s, v)
{
    var r, g, b;

    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);

    switch (i % 6)
    {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        case 5: r = v; g = p; b = q; break;
    }

    return {r: r * 255, g: g * 255, b: b * 255};
};

/**
 * Convert a color component into hexa value.
 * @method FORGE.Color.componentToHex
 * @param  {number} c - The color component to convert.
 * @return {string} The convert componenet into hex string.
 */
FORGE.Color.componentToHex = function(c)
{
    var hex = c.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
};

/**
 * Convert rgb values into a css compatible hexadecimal string.
 * @method FORGE.Color.regbToHex
 * @param {number} r - Red component.
 * @param {number} g - Green component.
 * @param {number} b - Blue component.
 * @return {string} Returns the hexadecimal string for the color.
 */
FORGE.Color.rgbToHex = function(r, g, b)
{
    return "#" + FORGE.Color.componentToHex(r) + FORGE.Color.componentToHex(g) + FORGE.Color.componentToHex(b);
};


/**
 * Convert rgba/rgb string into a four/three components object.
 * @method FORGE.Color.fromRgbaString
 * @param {string} rgbaString - rgba/rgb string with format rgba(r,g,b,a)/rgb(r,g,b)
 * @return {RGBaColor} The rgb color in four/three components.
 */
FORGE.Color.fromRgbaString = function(rgbaString)
{
    var rgba = rgbaString.split("(")[1].split(")")[0];
    var components = rgba.split(",");
    var color = {
        r: parseInt(components[0], 10),
        g: parseInt(components[1], 10),
        b: parseInt(components[2], 10)
    };

    if (components.length > 3)
    {
        color.a = parseInt(components[3], 10);
    }

    return color;
};


/**
 * Convert hexadecimal color string to rgb components.
 * @method  FORGE.Color.hexToRgb
 * @param  {string} hex - hexadecimal color string to convert.
 * @return {?RGBaColor} The rgb color in three components.
 */
FORGE.Color.hexToRgb = function(hex)
{
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function(m, r, g, b)
    {
        return r + r + g + g + b + b;
    });

    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
};

/**
 * Convert RGB into YCbCr color space
 * @method  FORGE.Color.rgbToYcbcr
 * @param  {RGBaColor} color color in RGB space ([0 .. 255])
 * @return {YCbCrColor} color in YCrCb space (Y,Cr,Cb [0 .. 255])
 */
FORGE.Color.rgbToYcbcr = function(color)
{
    var c = new THREE.Vector3(color.r, color.g, color.b);

    //jscs:disable
    var mat = new THREE.Matrix3().set(
         0.299,  0.587, 0.114,
        -0.169, -0.331, 0.500,
         0.500, -0.419, -0.081
    );
    //jscs:enable

    var offset = new THREE.Vector3(0, 128, 128);

    c.applyMatrix3(mat).add(offset);

    return {
        Y: c.x,
        Cr: c.y,
        Cb: c.z
    };
};

/**
 * Convert YCbCr into RGB color space
 * @method  FORGE.Color.ycbcrToRgb
 * @param {YCbCrColor} color color in YCrCb space (Y,Cr,Cb [0 .. 255])
 * @return  {RGBaColor} color in RGB space ([0 .. 255])
 */
FORGE.Color.ycbcrToRgb = function(color)
{
    var c = new THREE.Vector3(color.Y, color.Cr, color.Cb);

    var offset = new THREE.Vector3(0, -128, -128);

    //jscs:disable
    var mat = new THREE.Matrix3().set(
        1.000,  0.000,  1.400,
        1.000, -0.343, -0.711,
        1.000,  1.765,  0.000
    );
    //jscs:enable

    c.add(offset).applyMatrix3(mat);

    return {
        r: c.x,
        g: c.y,
        b: c.z
    };
};

/**
 * Rotate color in YCbCr color space
 * @method FORGE.Color.ycbcrRotate
 * @param {YCbCrColor} color YCbCr color
 * @param {number} angle rotation angle (degrees)
 * @return  {YCbCrColor} YCbCr rotated color
 */
FORGE.Color.ycbcrRotate = function(color, angle)
{
    var theta = FORGE.Math.degToRad(angle);
    var c = Math.cos(theta), s = Math.sin(theta);

    return {
        Y: color.Y,
        Cb: color.Cb * c - color.Cr * s,
        Cr: color.Cb * s + color.Cr * c
    };
};

/**
 * Evaluate euclidian distance between two colors
 * @param  {YCbCrColor} a 1st color in YCrCb colorspace
 * @param  {YCbCrColor} b 2nd color in YCrCb colorspace
 * @return {number} distance
 */
FORGE.Color.distance = function(a, b)
{
    return Math.sqrt((a.Cb - b.Cb) * (a.Cb - b.Cb) + (a.Cr - b.Cr) * (a.Cr - b.Cr));
};


/**
 * ColorRGBA Object
 * @constructor FORGE.ColorRGBA
 * @param {number} r - Red channel
 * @param {number} g - Green channel
 * @param {number} b - Blue channel
 * @param {number} a - Alpha channel
 */
FORGE.ColorRGBA = function(r, g, b, a)
{
    /**
     * Red channel
     * @name FORGE.ColorRGBA#red
     * @type {number}
     */
    this.red = r;

    /**
     * Green channel
     * @name FORGE.ColorRGBA#green
     * @type {number}
     */
    this.green = g;

    /**
     * Blue channel
     * @name FORGE.ColorRGBA#blue
     * @type {number}
     */
    this.blue = b;

    /**
     * Alpha channel
     * @name FORGE.ColorRGBA#alpha
     * @type {number}
     */
    this.alpha = a;
};